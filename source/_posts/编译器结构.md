什么是编译器

编译器是一个程序

核心功能:源程序代码翻译成目标代码

解释器:也是处理程序的一种程序

编译器输出可执行程序:离线

解释器输出结果:在线

第一个编译器:Fortran语言编译器1954~1957

影响:

理论上:形式语言,自动机,文法,语法执导的翻译

实践上:算法,数据结构

编译器架构



# 编译器结构

编译器具有非常模块化的高层结构

内部结构:

- 前端:输入相关部分,语言,语法规则,约束等
  - 词法
  - 语法
- 后端:目标机器指令集,前端约束到指令集的映射等
  - 指令生成
  - 指令优化

可以看成多个阶段构成的"流水线"结构(串行结构)

没有优化的编译器结构(所有阶段与符号表关联)

字符序列

​	词法分析

记号序列

​	语法分析

抽象语法树

​	语法分析

中间代码

​	目标代码

目标代码

编译器由多个阶段组成,每个阶段处理不同问题(使用不同理论,数据结构,算法)

如何划分

- 接口清晰
- 易于维护,实现

例子:

源语言:加法表达式语言Sum,两种语法形式:

- 整数数字n
- 加法e1+e2

目标机器:栈式计算机Stack

两条指令:

- push n
- add

编译1+2+3到栈式计算机上

前端:语法分析产生:抽象语法树(AST)

后端:树的后端遍历 n:push + :add

```
push 1
push 2
add 
push 3
add
```

增加一个代码优化阶段:



# 词法分析

阶段划分:

源程序->前端->中间表示->后端->目标程序

前端:

源程序->词法分析->`记号`->语法分析器->`抽象语法树`->语义分析器->中间表示

例子

```
if (x > 5)
  y = "hello";
else
  z = 1;
```

隐含的换行符,文件结束标示符

处理后:

```
IF LPAREN INDENT(x) GT INT(5) RPAREN
   IDENT(y) ASSIGN STRING("hello") SEMICOLON
ELSE
   IDENT(z) ASSIGN INT(1) SEMICOLON EOD
```

LPAREN->单词,记号

词法分析任务:字符流到单词流的切分

1. 记号的数据结构定义

   ```
   enum kind {IF, LPAREN, ID, INTLIT,...}  // 枚举类型
   struct token {
     enum kind k;
     char *lexeme;  // 所识别单词具体的值
   }
   ```

   if(x>5)转化:

   ```
   token{k=IF,LEXEM = 0};
   token{k=lp,LEXEM = 0};
   token{k=ID,LEXEM = "x"};
   ...
   ```

词法分析实现方法:

1. 手工编码实现法
   1. 复杂,容易出错
   2. 可控性比较好
   3. 流行的方式:GCC,LLVM
2. 词法分析器的生成器
   1. 可快速原型,代码量较少
   2. 但较难控制细节

