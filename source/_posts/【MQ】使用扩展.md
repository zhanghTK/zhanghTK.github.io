---
title: 【MQ】使用扩展
date: 2017-12-08 22:00:03
tags: MQ
categories: MQ
---

## TTL

### 带有 TTL 的消息

消息指定 TTL 有两种方式：

1. 通过队列属性设置，到达该队列的所有消息都具有相同的 TTL（x-message-ttl）
2. 对消息进行单独设置，每条消息的 TTL 可以不同（setExpiration）

两者差异：方式一设置的消息一旦过期就会从队列中丢弃，方式二设置的消息过期后需要在被消费时才丢弃

如果同时使用以上两种消息则以较小的为准。

### 带有 TTL 的队列

队列声明时可以（通过 x-expires）指定多久未使用后队列将被删除，使用场景：RPC 模式下用于回复而创建的 queue。

## 死信

死信：队列无法处理的消息，文档中定义了以下三种场景：

- 消费端发送 basic.reject or basic.nack 指令（并且需要设置 requeue=false ）
- TTL 过期的消息
- 队列达到最大长度

在消息投递前如果指定消息成为死信后的处理交换器和 routking，当消息成为死信后 Rabbit MQ 可以根据先前的配置重新投递。

## 延时消息

使用 TTL 消息和死信重新投递就可以容易的构造出延时消息的功能了。

创建两个交换器，两个 binding， 两个队列，延时的过程：

- exchange1 接收生产者的消息，根据 binding 转发给 queue1
- queue1 的消息设置统一的 TTL，并且不对 queue1 数据进行任何消费动作
- 等 queue1 的消息过期后 MQ 重新将消息投递到 exchange2
- exchange2 根据 bindling 信息转发给 queue2
- 消费者从 queue2 消费消息

## 优先级队列

消息在发送时如果指定优先级，则当队列中消息堆积时，高优先级的消息可以被优先消费掉。具体的做法：

1. 创建队列时，指定队列的最大优先级
2. 投递消息时指定消息的优先级

消息到达队列后，Rabbit MQ 会根据优先级进行处理，完全自动。


