{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"00d09eae4324f411e01562979a81eb9702aa0a16","modified":1483770026000},{"_id":"source/favicon.ico","hash":"bc4575713d5905501315801cc9d52d8fc2b43178","modified":1483770026000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1478882347000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1469886538000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1469886538000},{"_id":"themes/next/.javascript_ignore","hash":"de73037693881ad2626e2962e8c5ab243f7b24d0","modified":1478882434000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1469886538000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1469886538000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1469886538000},{"_id":"themes/next/bower.json","hash":"023b5b945bc45c205129a18e26d304fb9caa15c7","modified":1478882459000},{"_id":"themes/next/_config.yml","hash":"e74a9e7056933bb53fbfd5c1206ace064120a51f","modified":1478882203000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1469886538000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1469886538000},{"_id":"source/_posts/HTML与CSS小记.md","hash":"e2748c4330ecf4d48997079afa7c1d44df9b8fe5","modified":1483770026000},{"_id":"source/_posts/HTTPS小记.md","hash":"50bee3ed10eb6f2ffc8f3909206a046e99a5e392","modified":1483770026000},{"_id":"source/_posts/.HTTPS小记.md.swp","hash":"5c40aff0c85ddc2c776b6f330cbd1cd7783ab11e","modified":1489339283000},{"_id":"source/_posts/.从依赖实现到依赖行为.md.swp","hash":"4bd6cb34b72e9d0d4663ff5faaabf2f6d45de8af","modified":1483770026000},{"_id":"source/_posts/Java内存区域.md","hash":"238363279ad71ab1c5e915cff957a485dc62bc3a","modified":1483770026000},{"_id":"source/_posts/IoC容器的简单实现.md","hash":"d5bfad4dafbcb8fd754b49094d0c8e80247ef225","modified":1483770026000},{"_id":"source/_posts/Spring之BeanFactory.md","hash":"08e467387c8f9a9787a85cca6e2cc98f12949c4b","modified":1489339414000},{"_id":"source/_posts/Lambda表达式.md","hash":"dc93257f9a6d698fdb0acaee496a9bdb0bb62125","modified":1484505759000},{"_id":"source/_posts/《Java并发编程实战》读书笔记.md","hash":"033e79c32e98cf613523f359cc33e8fc129ed15d","modified":1483770026000},{"_id":"source/_posts/ThreadLocal小记.md","hash":"1ca1eaa05099e1f116f08e289ca3a2b1722ca85d","modified":1483770026000},{"_id":"source/_posts/《函数式编程思维》读书笔记.md","hash":"b3d9ce43d94f8650f1418d501b92a81ae7eb827e","modified":1483770026000},{"_id":"source/_posts/【翻译】《OSGI官方指南》首页.md","hash":"51ecc7fa86c8844dad4e67c413eb69bda13bffd0","modified":1485309962000},{"_id":"source/_posts/【翻译】SpringData官方文档第四章.md","hash":"7130cb79dca8b3541df56af570155a483854d0b2","modified":1483772285000},{"_id":"source/_posts/从依赖实现到依赖行为.md","hash":"444e860fc19361494cd70cd193cd283a6123cffb","modified":1483770026000},{"_id":"source/_posts/二零一六年度总结.md","hash":"95729fd27a2466cd96aab8f752c8e3175c0003a9","modified":1483777385000},{"_id":"source/_posts/使用Builder模式改进多参数方法.md","hash":"a138468db27bb32713add236e8ada17aeb10ffe4","modified":1483770026000},{"_id":"source/_posts/使用CI发布Hexo.md","hash":"7acbee16e173bd249b8e36e5985f5093d7029a04","modified":1483778295000},{"_id":"source/_posts/命令模式.md","hash":"95ef2e7e2beafa5f8f145ea0ae040772749808da","modified":1484505135000},{"_id":"source/_posts/责任链模式.md","hash":"1619ccd8af2f055b753cc0ff2fd1db73fa2ecf0f","modified":1484505464000},{"_id":"source/_posts/自下而上的开发实践.md","hash":"f1af2467bbccbb5202e9369a463deb2300434f70","modified":1483770026000},{"_id":"source/_posts/浅谈测试驱动开发.md","hash":"22558c4bfe8778c65617cda05545a99d62417930","modified":1486303990000},{"_id":"source/_posts/迪米特法则——合理的封装.md","hash":"dfcd4c4e9d9df2ea50690e849fc2519ed8b37ad5","modified":1483770026000},{"_id":"source/categories/index-2.md","hash":"01c6269ba8f66017829598c89ce35b0fcf041249","modified":1483770026000},{"_id":"source/categories/index-3.md","hash":"9c2ea31bdcb30eb37c89cf66f3e6a6c2648f72bc","modified":1483770026000},{"_id":"source/categories/index-1.md","hash":"32c65ffdc4b2b07d95bf52ca7331e2dfa8b84a60","modified":1483770026000},{"_id":"source/categories/index-4.md","hash":"720625e0db913d633e142a4fbccdf771f903d6b2","modified":1483770026000},{"_id":"source/categories/index-5.md","hash":"63608e6e32d05787de75c02ebb9ea793206cd7a1","modified":1483771847000},{"_id":"source/categories/index-7.md","hash":"18a1a3ef2bccd90d386992230e7c4f0579ba8992","modified":1489339142000},{"_id":"source/categories/index-6.md","hash":"7e2fa2be8c7b32d85525e20edaab980d6e96dd7a","modified":1483771970000},{"_id":"source/categories/index.md","hash":"265279f98f069e929ce7a682d3d80f30df999a43","modified":1483770026000},{"_id":"source/tags/index-2.md","hash":"cf3e574ba065f16e24d019b51eade2060d3c1c62","modified":1483770026000},{"_id":"source/tags/index-3.md","hash":"2bcb7dc8521f2e013f0cd2f49d3b0f52917fa96c","modified":1483770026000},{"_id":"source/tags/index-4.md","hash":"751f69598690223422467db912b81e623d805a88","modified":1483770026000},{"_id":"source/tags/index-1.md","hash":"15f2af37c1cdc21f3dcc572d8017099646cdd617","modified":1483770026000},{"_id":"source/tags/index-5.md","hash":"da17106467a5adc108e9fad7e0f04160a557a185","modified":1483770026000},{"_id":"source/tags/index-6.md","hash":"e9ed82135629d97b29dc691c27b58330b1474966","modified":1483770026000},{"_id":"source/tags/index-7.md","hash":"3ce31588fb1b0fdb924984004402858d10aaa005","modified":1483772174000},{"_id":"source/tags/index-8.md","hash":"05dc9b8155df1ff9d8ce4eed213c97d765de5f17","modified":1489339058000},{"_id":"source/tags/index.md","hash":"7b78e54ef8023d86641b636f341196330582d695","modified":1483770026000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1469886538000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1469886538000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1469886538000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1469886538000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1469886538000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1469886538000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1469886538000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1469886538000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1469886538000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1469886538000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1469886538000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1469886538000},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1469886538000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1469886538000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1469886538000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1469886538000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1469886538000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1469886538000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1469886538000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1469886538000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1469886538000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1469886538000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1469886538000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1469886538000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1469886538000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1469886538000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1469886538000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1469886538000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1469886538000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1469886538000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1469886538000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1469886538000},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1469886538000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1469886538000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1469886538000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1469886538000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1469886538000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1469886538000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1469886538000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1469886538000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1469886538000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1469886538000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1469886538000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1469886538000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1469886538000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1469886538000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1469886538000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1469886538000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1469886538000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1469886538000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1469886538000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1469886538000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1469886538000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1469886538000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1469886538000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1469886538000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1469886538000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1469886538000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1469886538000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1469886538000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1469886538000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1469886538000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1469886538000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1469886538000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1469886538000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1469886538000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1469886538000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1469886538000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1469886538000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1469886538000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1469886538000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1469886538000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1469886538000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1469886538000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1469886538000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1469886538000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1469886538000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1469886538000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1469886538000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1469886538000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1469886538000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1469886538000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1469886538000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1469886538000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1469886538000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1469886538000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1469886538000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1469886538000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1469886538000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1469886538000},{"_id":"themes/next/source/images/avatar.png","hash":"9b1c328be2868cd82320037820b2a1b89be37a37","modified":1469888010000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1469886538000}],"Category":[{"name":"前端","_id":"cj06y6ga70005yi2e5sndwti1"},{"name":"其它","_id":"cj06y6gah000cyi2e7ddw76d4"},{"name":"Java","_id":"cj06y6gao000kyi2e7e5zf5at"},{"name":"Spring","_id":"cj06y6gay000yyi2eck9uztl8"},{"name":"读书笔记","_id":"cj06y6gb30018yi2ei7t5tcua"},{"name":"翻译","_id":"cj06y6gbi001oyi2ero1o88qt"},{"name":"设计模式","_id":"cj06y6gbj001ryi2ep633y6d1"},{"name":"随笔","_id":"cj06y6gbl001zyi2egnv9qbe3"}],"Data":[],"Page":[{"title":"读书笔记","date":"2016-08-27T14:15:37.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-2.md","raw":"---\ntitle: 读书笔记\ndate: 2016-08-27 22:15:37\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"categories/index-2.html","layout":"page","_id":"cj06y6g9t0001yi2eiygqe3w1","content":"","excerpt":"","more":""},{"title":"设计模式","date":"2016-10-22T11:06:15.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-3.md","raw":"---\ntitle: 设计模式\ndate: 2016-10-22 19:06:15\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"categories/index-3.html","layout":"page","_id":"cj06y6g9z0003yi2emou7o79r","content":"","excerpt":"","more":""},{"title":"前端","date":"2016-07-31T10:50:48.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-1.md","raw":"---\ntitle: 前端\ndate: 2016-07-31 18:50:48\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"categories/index-1.html","layout":"page","_id":"cj06y6gaa0007yi2eiwdfhemy","content":"","excerpt":"","more":""},{"title":"其它","date":"2016-10-24T16:01:14.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-4.md","raw":"---\ntitle: 其它\ndate: 2016-10-25 00:01:14\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"categories/index-4.html","layout":"page","_id":"cj06y6gaf0009yi2ejwk4b2d0","content":"","excerpt":"","more":""},{"title":"翻译","date":"2017-01-07T06:49:10.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-5.md","raw":"---\ntitle: 翻译\ndate: 2017-01-07 14:49:10\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:50:47.000Z","path":"categories/index-5.html","layout":"page","_id":"cj06y6gai000dyi2e2uyuvqbw","content":"","excerpt":"","more":""},{"title":"Spring","date":"2017-03-12T17:17:54.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-7.md","raw":"---\ntitle: Spring\ndate: 2017-03-13 01:17:54\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-03-12T17:19:02.000Z","path":"categories/index-7.html","layout":"page","_id":"cj06y6gaj000fyi2em8jktm4z","content":"","excerpt":"","more":""},{"title":"随笔","date":"2017-01-07T06:51:27.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-6.md","raw":"---\ntitle: 随笔\ndate: 2017-01-07 14:51:27\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:52:50.000Z","path":"categories/index-6.html","layout":"page","_id":"cj06y6gan000jyi2e9n4bm79s","content":"","excerpt":"","more":""},{"title":"Java","date":"2016-07-30T14:47:23.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: Java\ndate: 2016-07-30 22:47:23\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"categories/index.html","layout":"page","_id":"cj06y6gaq000nyi2e0fecs6kb","content":"","excerpt":"","more":""},{"title":"CSS","date":"2016-07-31T11:18:55.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-2.md","raw":"---\ntitle: CSS\ndate: 2016-07-31 19:18:55\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-2.html","layout":"page","_id":"cj06y6gh7003hyi2ed1ci86sg","content":"","excerpt":"","more":""},{"title":"JVM","date":"2016-08-14T15:09:22.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-3.md","raw":"---\ntitle: JVM\ndate: 2016-08-14 23:09:22\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-3.html","layout":"page","_id":"cj06y6gh9003iyi2eeoghjpr6","content":"","excerpt":"","more":""},{"title":"Java","date":"2016-08-14T15:14:08.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-4.md","raw":"---\ntitle: Java\ndate: 2016-08-14 23:14:08\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-4.html","layout":"page","_id":"cj06y6ghc003jyi2e1wxhlm0h","content":"","excerpt":"","more":""},{"title":"HTML","date":"2016-07-31T11:10:04.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-1.md","raw":"---\ntitle: HTML\ndate: 2016-07-31 19:10:04\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-1.html","layout":"page","_id":"cj06y6ghe003kyi2e0nfkwlua","content":"","excerpt":"","more":""},{"title":"Functional","date":"2016-08-27T14:01:31.000Z","_content":"","source":"tags/index-5.md","raw":"---\ntitle: Functional\ndate: 2016-08-27 22:01:31\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-5.html","comments":1,"layout":"page","_id":"cj06y6ghj003lyi2e1ulb3vci","content":"","excerpt":"","more":""},{"title":"设计模式","date":"2016-10-22T11:12:06.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-6.md","raw":"---\ntitle: 设计模式\ndate: 2016-10-22 19:12:06\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-6.html","layout":"page","_id":"cj06y6ghk003myi2es65do617","content":"","excerpt":"","more":""},{"title":"翻译","date":"2017-01-07T06:55:01.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-7.md","raw":"---\ntitle: 翻译\ndate: 2017-01-07 14:55:01\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:56:14.000Z","path":"tags/index-7.html","layout":"page","_id":"cj06y6ghl003nyi2eoflcnr4l","content":"","excerpt":"","more":""},{"title":"Spring","date":"2017-03-12T17:16:16.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-8.md","raw":"---\ntitle: Spring\ndate: 2017-03-13 01:16:16\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-03-12T17:17:38.000Z","path":"tags/index-8.html","layout":"page","_id":"cj06y6gho003oyi2efvcq3zxj","content":"","excerpt":"","more":""},{"title":"daily","date":"2016-07-30T14:27:10.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: daily\ndate: 2016-07-30 22:27:10\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index.html","layout":"page","_id":"cj06y6ghp003pyi2ezdpqbbed","content":"","excerpt":"","more":""}],"Post":[{"title":"HTML与CSS小记","date":"2016-07-31T10:54:52.000Z","_content":"\n![jjj](https://ooo.0o0.ooo/2016/07/31/579dd779d1389.png)","source":"_posts/HTML与CSS小记.md","raw":"---\ntitle: HTML与CSS小记\ndate: 2016-07-31 18:54:52\ntags: \n  - HTML\n  - CSS\ncategories: 前端\n\n---\n\n![jjj](https://ooo.0o0.ooo/2016/07/31/579dd779d1389.png)","slug":"HTML与CSS小记","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6g9m0000yi2e6c2uobh6","content":"<p><img src=\"https://ooo.0o0.ooo/2016/07/31/579dd779d1389.png\" alt=\"jjj\"></p>\n","excerpt":"","more":"<p><img src=\"https://ooo.0o0.ooo/2016/07/31/579dd779d1389.png\" alt=\"jjj\"></p>\n"},{"title":"HTTPS小记","date":"2016-10-24T15:58:06.000Z","_content":"\n## 背景\n\n最近好像跟HTTPS较上劲了，前几天的职级答辩问到了相关问题，最近维护的系统升级也碰到相关问题。\n\n自己对HTTPS了解的并不多，今天简单了解了一下，在此做个记录。\n\n首先有几个基本概念，TCP/IP协议，HTTP一些，对称/非对称加密，证书，公钥/私钥。\n\nTCP/TP：\n\n- 传输层协议，主要解决数据如何在网络中传输\n\nHTTP：\n\n- 应用层协议，主要解决如何包装数据，依赖TCP/IP协议\n\n对称加密：\n\n- 加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来\n\n非对称加密：\n\n- 加密和解密过程使用了不同的密钥。分为公钥和私钥，它们可以互相解密。\n- 公钥加密，私钥解密\n- 私钥数字签名，公钥验证\n\n证书：\n\n- 我理解主要是两个作用：验证证书持有者身份、提供证书持有者公钥\n\n## 为什么用HTTPS\n\n因为HTTP不安全。\n\n1. HTTP使用的是明文传输，容易被窃取\n2. 无法验证报文完整性，可能被篡改\n3. 无法验证通信双方的身份\n\n为了对HTTP提供安全保障，就依赖：\n\n### SSL与TLS\n\nSSL（Secure Socket Layer，安全套接字层）\n\nTLS（Transport Layer Security，传输层安全协议）\n\nTLS可以理解为SSL的增强版。\n\nHTTP直接与TCP通信，而在HTTPS中首先与SSL通信，SSL再与TCP通信。我觉得可以理解成HTTPS = HTTP + SSL。\n\n不论HTTP还是HTTPS，所有的通信、加解密都是最终都是建立在TCP/IP之上的。\n\n## 加密思路\n\n1. 客户端向服务器端索要并验证公钥；\n2. 双方协商生成\"对话密钥\"；\n3. 双方采用\"对话密钥\"进行加密通信；\n\n在通信过程中其实双方使用的还是对称的加密算法，但是为了让这个对称的加密算法足够安全。首先使用非对称的算法来获取对话密钥，之后再用对话密钥来对通信的内容加密解密。\n\n所以关键问题就变成了：\n\n## 对话密钥的创建\n\n我没有仔细阅读相关协议，在网上查了一些资料，下面的内容是根据自己的理解写的。\n\n简单描述一次对话密钥的获取过程：\n\n> C：我想跟服务器A说悄悄话，我支持1,2,3版本的协议。我先跟你说个秘密X。\n>\n> S：我是服务器A。我们用3版本的协议说话吧，我也给你说个秘密Y。我再给你个公钥，使用它加密后的信息就只有我能听懂了。\n>\n> C：让我先看看你是不是服务器A。（确认是服务器A）那我再给你说个秘密Z，这次用你给我的公钥对Z加密，确保其他人都不知道。以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要跟你确认的就这些。\n>\n> S：好的，以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要确认的也就这些内容。网上把上面四个步骤描述\n\n网上把上述的四个步骤描述为：\n\n- 客户端发出请求\n  - 支持的协议版本，比如TLS 1.0版\n  - 一个随机数\n  - 支持的加密方法，比如RSA公钥加密\n  - 支持的压缩方法\n- 服务器回应\n  - 协议的版本\n  - 加密的算法\n  - 生成随机数\n  - 服务器证书\n- 客户端回应\n  - 对服务器下发的证书进行验证\n  - 再次产生一个随机数（第三个随机数）\n  - 使用服务器证书中的公钥进行加密\n  - 发送编码改变的消息\n  - 发送整个前面所有消息的hash值\n  - 根据三个随机数生成对话密钥\n- 服务器最终回应\n  - 使用私钥解密接收到第三个随机数\n  - 验证数据完整性\n  - 使用跟客户端同样的方式生成对话密钥\n  - 告知客户端已经切换到协商过的加密套件状态\n  - 服务端发送消息验证加解密是否成功\n\n如果服务器需要对客户端的身份进行认证，那么在第一次服务器回应中可以向客户端索取证书。客户端提供证书后，服务器通过验证客户端证书，从而验证客户端的身份。\n","source":"_posts/HTTPS小记.md","raw":"---\ntitle: HTTPS小记\ndate: 2016-10-24 23:58:06\ntags: daily\ncategories: 其它\n---\n\n## 背景\n\n最近好像跟HTTPS较上劲了，前几天的职级答辩问到了相关问题，最近维护的系统升级也碰到相关问题。\n\n自己对HTTPS了解的并不多，今天简单了解了一下，在此做个记录。\n\n首先有几个基本概念，TCP/IP协议，HTTP一些，对称/非对称加密，证书，公钥/私钥。\n\nTCP/TP：\n\n- 传输层协议，主要解决数据如何在网络中传输\n\nHTTP：\n\n- 应用层协议，主要解决如何包装数据，依赖TCP/IP协议\n\n对称加密：\n\n- 加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来\n\n非对称加密：\n\n- 加密和解密过程使用了不同的密钥。分为公钥和私钥，它们可以互相解密。\n- 公钥加密，私钥解密\n- 私钥数字签名，公钥验证\n\n证书：\n\n- 我理解主要是两个作用：验证证书持有者身份、提供证书持有者公钥\n\n## 为什么用HTTPS\n\n因为HTTP不安全。\n\n1. HTTP使用的是明文传输，容易被窃取\n2. 无法验证报文完整性，可能被篡改\n3. 无法验证通信双方的身份\n\n为了对HTTP提供安全保障，就依赖：\n\n### SSL与TLS\n\nSSL（Secure Socket Layer，安全套接字层）\n\nTLS（Transport Layer Security，传输层安全协议）\n\nTLS可以理解为SSL的增强版。\n\nHTTP直接与TCP通信，而在HTTPS中首先与SSL通信，SSL再与TCP通信。我觉得可以理解成HTTPS = HTTP + SSL。\n\n不论HTTP还是HTTPS，所有的通信、加解密都是最终都是建立在TCP/IP之上的。\n\n## 加密思路\n\n1. 客户端向服务器端索要并验证公钥；\n2. 双方协商生成\"对话密钥\"；\n3. 双方采用\"对话密钥\"进行加密通信；\n\n在通信过程中其实双方使用的还是对称的加密算法，但是为了让这个对称的加密算法足够安全。首先使用非对称的算法来获取对话密钥，之后再用对话密钥来对通信的内容加密解密。\n\n所以关键问题就变成了：\n\n## 对话密钥的创建\n\n我没有仔细阅读相关协议，在网上查了一些资料，下面的内容是根据自己的理解写的。\n\n简单描述一次对话密钥的获取过程：\n\n> C：我想跟服务器A说悄悄话，我支持1,2,3版本的协议。我先跟你说个秘密X。\n>\n> S：我是服务器A。我们用3版本的协议说话吧，我也给你说个秘密Y。我再给你个公钥，使用它加密后的信息就只有我能听懂了。\n>\n> C：让我先看看你是不是服务器A。（确认是服务器A）那我再给你说个秘密Z，这次用你给我的公钥对Z加密，确保其他人都不知道。以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要跟你确认的就这些。\n>\n> S：好的，以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要确认的也就这些内容。网上把上面四个步骤描述\n\n网上把上述的四个步骤描述为：\n\n- 客户端发出请求\n  - 支持的协议版本，比如TLS 1.0版\n  - 一个随机数\n  - 支持的加密方法，比如RSA公钥加密\n  - 支持的压缩方法\n- 服务器回应\n  - 协议的版本\n  - 加密的算法\n  - 生成随机数\n  - 服务器证书\n- 客户端回应\n  - 对服务器下发的证书进行验证\n  - 再次产生一个随机数（第三个随机数）\n  - 使用服务器证书中的公钥进行加密\n  - 发送编码改变的消息\n  - 发送整个前面所有消息的hash值\n  - 根据三个随机数生成对话密钥\n- 服务器最终回应\n  - 使用私钥解密接收到第三个随机数\n  - 验证数据完整性\n  - 使用跟客户端同样的方式生成对话密钥\n  - 告知客户端已经切换到协商过的加密套件状态\n  - 服务端发送消息验证加解密是否成功\n\n如果服务器需要对客户端的身份进行认证，那么在第一次服务器回应中可以向客户端索取证书。客户端提供证书后，服务器通过验证客户端证书，从而验证客户端的身份。\n","slug":"HTTPS小记","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6g9v0002yi2ex87qqnaz","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近好像跟HTTPS较上劲了，前几天的职级答辩问到了相关问题，最近维护的系统升级也碰到相关问题。</p>\n<p>自己对HTTPS了解的并不多，今天简单了解了一下，在此做个记录。</p>\n<p>首先有几个基本概念，TCP/IP协议，HTTP一些，对称/非对称加密，证书，公钥/私钥。</p>\n<p>TCP/TP：</p>\n<ul>\n<li>传输层协议，主要解决数据如何在网络中传输</li>\n</ul>\n<p>HTTP：</p>\n<ul>\n<li>应用层协议，主要解决如何包装数据，依赖TCP/IP协议</li>\n</ul>\n<p>对称加密：</p>\n<ul>\n<li>加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来</li>\n</ul>\n<p>非对称加密：</p>\n<ul>\n<li>加密和解密过程使用了不同的密钥。分为公钥和私钥，它们可以互相解密。</li>\n<li>公钥加密，私钥解密</li>\n<li>私钥数字签名，公钥验证</li>\n</ul>\n<p>证书：</p>\n<ul>\n<li>我理解主要是两个作用：验证证书持有者身份、提供证书持有者公钥</li>\n</ul>\n<h2 id=\"为什么用HTTPS\"><a href=\"#为什么用HTTPS\" class=\"headerlink\" title=\"为什么用HTTPS\"></a>为什么用HTTPS</h2><p>因为HTTP不安全。</p>\n<ol>\n<li>HTTP使用的是明文传输，容易被窃取</li>\n<li>无法验证报文完整性，可能被篡改</li>\n<li>无法验证通信双方的身份</li>\n</ol>\n<p>为了对HTTP提供安全保障，就依赖：</p>\n<h3 id=\"SSL与TLS\"><a href=\"#SSL与TLS\" class=\"headerlink\" title=\"SSL与TLS\"></a>SSL与TLS</h3><p>SSL（Secure Socket Layer，安全套接字层）</p>\n<p>TLS（Transport Layer Security，传输层安全协议）</p>\n<p>TLS可以理解为SSL的增强版。</p>\n<p>HTTP直接与TCP通信，而在HTTPS中首先与SSL通信，SSL再与TCP通信。我觉得可以理解成HTTPS = HTTP + SSL。</p>\n<p>不论HTTP还是HTTPS，所有的通信、加解密都是最终都是建立在TCP/IP之上的。</p>\n<h2 id=\"加密思路\"><a href=\"#加密思路\" class=\"headerlink\" title=\"加密思路\"></a>加密思路</h2><ol>\n<li>客户端向服务器端索要并验证公钥；</li>\n<li>双方协商生成”对话密钥”；</li>\n<li>双方采用”对话密钥”进行加密通信；</li>\n</ol>\n<p>在通信过程中其实双方使用的还是对称的加密算法，但是为了让这个对称的加密算法足够安全。首先使用非对称的算法来获取对话密钥，之后再用对话密钥来对通信的内容加密解密。</p>\n<p>所以关键问题就变成了：</p>\n<h2 id=\"对话密钥的创建\"><a href=\"#对话密钥的创建\" class=\"headerlink\" title=\"对话密钥的创建\"></a>对话密钥的创建</h2><p>我没有仔细阅读相关协议，在网上查了一些资料，下面的内容是根据自己的理解写的。</p>\n<p>简单描述一次对话密钥的获取过程：</p>\n<blockquote>\n<p>C：我想跟服务器A说悄悄话，我支持1,2,3版本的协议。我先跟你说个秘密X。</p>\n<p>S：我是服务器A。我们用3版本的协议说话吧，我也给你说个秘密Y。我再给你个公钥，使用它加密后的信息就只有我能听懂了。</p>\n<p>C：让我先看看你是不是服务器A。（确认是服务器A）那我再给你说个秘密Z，这次用你给我的公钥对Z加密，确保其他人都不知道。以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要跟你确认的就这些。</p>\n<p>S：好的，以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要确认的也就这些内容。网上把上面四个步骤描述</p>\n</blockquote>\n<p>网上把上述的四个步骤描述为：</p>\n<ul>\n<li>客户端发出请求<ul>\n<li>支持的协议版本，比如TLS 1.0版</li>\n<li>一个随机数</li>\n<li>支持的加密方法，比如RSA公钥加密</li>\n<li>支持的压缩方法</li>\n</ul>\n</li>\n<li>服务器回应<ul>\n<li>协议的版本</li>\n<li>加密的算法</li>\n<li>生成随机数</li>\n<li>服务器证书</li>\n</ul>\n</li>\n<li>客户端回应<ul>\n<li>对服务器下发的证书进行验证</li>\n<li>再次产生一个随机数（第三个随机数）</li>\n<li>使用服务器证书中的公钥进行加密</li>\n<li>发送编码改变的消息</li>\n<li>发送整个前面所有消息的hash值</li>\n<li>根据三个随机数生成对话密钥</li>\n</ul>\n</li>\n<li>服务器最终回应<ul>\n<li>使用私钥解密接收到第三个随机数</li>\n<li>验证数据完整性</li>\n<li>使用跟客户端同样的方式生成对话密钥</li>\n<li>告知客户端已经切换到协商过的加密套件状态</li>\n<li>服务端发送消息验证加解密是否成功</li>\n</ul>\n</li>\n</ul>\n<p>如果服务器需要对客户端的身份进行认证，那么在第一次服务器回应中可以向客户端索取证书。客户端提供证书后，服务器通过验证客户端证书，从而验证客户端的身份。</p>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近好像跟HTTPS较上劲了，前几天的职级答辩问到了相关问题，最近维护的系统升级也碰到相关问题。</p>\n<p>自己对HTTPS了解的并不多，今天简单了解了一下，在此做个记录。</p>\n<p>首先有几个基本概念，TCP/IP协议，HTTP一些，对称/非对称加密，证书，公钥/私钥。</p>\n<p>TCP/TP：</p>\n<ul>\n<li>传输层协议，主要解决数据如何在网络中传输</li>\n</ul>\n<p>HTTP：</p>\n<ul>\n<li>应用层协议，主要解决如何包装数据，依赖TCP/IP协议</li>\n</ul>\n<p>对称加密：</p>\n<ul>\n<li>加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来</li>\n</ul>\n<p>非对称加密：</p>\n<ul>\n<li>加密和解密过程使用了不同的密钥。分为公钥和私钥，它们可以互相解密。</li>\n<li>公钥加密，私钥解密</li>\n<li>私钥数字签名，公钥验证</li>\n</ul>\n<p>证书：</p>\n<ul>\n<li>我理解主要是两个作用：验证证书持有者身份、提供证书持有者公钥</li>\n</ul>\n<h2 id=\"为什么用HTTPS\"><a href=\"#为什么用HTTPS\" class=\"headerlink\" title=\"为什么用HTTPS\"></a>为什么用HTTPS</h2><p>因为HTTP不安全。</p>\n<ol>\n<li>HTTP使用的是明文传输，容易被窃取</li>\n<li>无法验证报文完整性，可能被篡改</li>\n<li>无法验证通信双方的身份</li>\n</ol>\n<p>为了对HTTP提供安全保障，就依赖：</p>\n<h3 id=\"SSL与TLS\"><a href=\"#SSL与TLS\" class=\"headerlink\" title=\"SSL与TLS\"></a>SSL与TLS</h3><p>SSL（Secure Socket Layer，安全套接字层）</p>\n<p>TLS（Transport Layer Security，传输层安全协议）</p>\n<p>TLS可以理解为SSL的增强版。</p>\n<p>HTTP直接与TCP通信，而在HTTPS中首先与SSL通信，SSL再与TCP通信。我觉得可以理解成HTTPS = HTTP + SSL。</p>\n<p>不论HTTP还是HTTPS，所有的通信、加解密都是最终都是建立在TCP/IP之上的。</p>\n<h2 id=\"加密思路\"><a href=\"#加密思路\" class=\"headerlink\" title=\"加密思路\"></a>加密思路</h2><ol>\n<li>客户端向服务器端索要并验证公钥；</li>\n<li>双方协商生成”对话密钥”；</li>\n<li>双方采用”对话密钥”进行加密通信；</li>\n</ol>\n<p>在通信过程中其实双方使用的还是对称的加密算法，但是为了让这个对称的加密算法足够安全。首先使用非对称的算法来获取对话密钥，之后再用对话密钥来对通信的内容加密解密。</p>\n<p>所以关键问题就变成了：</p>\n<h2 id=\"对话密钥的创建\"><a href=\"#对话密钥的创建\" class=\"headerlink\" title=\"对话密钥的创建\"></a>对话密钥的创建</h2><p>我没有仔细阅读相关协议，在网上查了一些资料，下面的内容是根据自己的理解写的。</p>\n<p>简单描述一次对话密钥的获取过程：</p>\n<blockquote>\n<p>C：我想跟服务器A说悄悄话，我支持1,2,3版本的协议。我先跟你说个秘密X。</p>\n<p>S：我是服务器A。我们用3版本的协议说话吧，我也给你说个秘密Y。我再给你个公钥，使用它加密后的信息就只有我能听懂了。</p>\n<p>C：让我先看看你是不是服务器A。（确认是服务器A）那我再给你说个秘密Z，这次用你给我的公钥对Z加密，确保其他人都不知道。以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要跟你确认的就这些。</p>\n<p>S：好的，以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要确认的也就这些内容。网上把上面四个步骤描述</p>\n</blockquote>\n<p>网上把上述的四个步骤描述为：</p>\n<ul>\n<li>客户端发出请求<ul>\n<li>支持的协议版本，比如TLS 1.0版</li>\n<li>一个随机数</li>\n<li>支持的加密方法，比如RSA公钥加密</li>\n<li>支持的压缩方法</li>\n</ul>\n</li>\n<li>服务器回应<ul>\n<li>协议的版本</li>\n<li>加密的算法</li>\n<li>生成随机数</li>\n<li>服务器证书</li>\n</ul>\n</li>\n<li>客户端回应<ul>\n<li>对服务器下发的证书进行验证</li>\n<li>再次产生一个随机数（第三个随机数）</li>\n<li>使用服务器证书中的公钥进行加密</li>\n<li>发送编码改变的消息</li>\n<li>发送整个前面所有消息的hash值</li>\n<li>根据三个随机数生成对话密钥</li>\n</ul>\n</li>\n<li>服务器最终回应<ul>\n<li>使用私钥解密接收到第三个随机数</li>\n<li>验证数据完整性</li>\n<li>使用跟客户端同样的方式生成对话密钥</li>\n<li>告知客户端已经切换到协商过的加密套件状态</li>\n<li>服务端发送消息验证加解密是否成功</li>\n</ul>\n</li>\n</ul>\n<p>如果服务器需要对客户端的身份进行认证，那么在第一次服务器回应中可以向客户端索取证书。客户端提供证书后，服务器通过验证客户端证书，从而验证客户端的身份。</p>\n"},{"title":"Java内存区域","date":"2016-08-14T15:02:39.000Z","_content":"\n![Java内存区域.png](https://ooo.0o0.ooo/2016/08/14/57b08be587b3a.png)\n","source":"_posts/Java内存区域.md","raw":"---\ntitle: Java内存区域\ndate: 2016-08-14 23:02:39\ntags:\n  - daily\n  - JVM\n  - Java\ncategories: Java\n\n---\n\n![Java内存区域.png](https://ooo.0o0.ooo/2016/08/14/57b08be587b3a.png)\n","slug":"Java内存区域","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6ga80006yi2e0w5fypne","content":"<p><img src=\"https://ooo.0o0.ooo/2016/08/14/57b08be587b3a.png\" alt=\"Java内存区域.png\"></p>\n","excerpt":"","more":"<p><img src=\"https://ooo.0o0.ooo/2016/08/14/57b08be587b3a.png\" alt=\"Java内存区域.png\"></p>\n"},{"title":"IoC容器的简单实现","date":"2016-11-10T15:44:15.000Z","_content":"\n记录临摹一个IoC容器的过程，使用对象容器进行控制反转，将对象间依赖关系的管理交给容器。\n\n代码在[这里](https://github.com/zhanghTK/HelloIoC)，API参照了Spring IoC部分，实现的具体过程参照了[tiny-spring](https://github.com/code4craft/tiny-spring)和[ioc-sample](https://github.com/kevinlynx/ioc-sample)。先看看如何使用：\n\n# 像Spring一样用\n\n```xml\n<beans>\n    <bean name=\"helloWorldOutputService\"\n          class=\"tk.zhangh.ioc.beans.HelloWorldOutputServiceImpl\">\n        <property name=\"name\" value=\"helloWorld\"/>\n        <property name=\"outputService\" ref=\"outputService\"/>\n    </bean>\n</beans>\n```\n\n```java\n@Test\npublic void register_get_bean_by_ClassPathXmlApplicationContextTest() throws Exception {\n    ApplicationContext applicationContext = new\n      ClassPathXmlApplicationContext(\"ioc.xml\");\n    HelloWorldService helloWorldService = (HelloWorldService)\n      applicationContext.getBean(\"helloWorldOutputService\");\n    helloWorldService.sayHello();\n}\n```\n\n---\n\n整个开发过程是这样的：\n\n# 自下而上\n\n大体的开发步骤以及思路参照了[tiny-spring](https://github.com/code4craft/tiny-spring)，实现步骤可以简述为：\n\n## 1.全手动式的Bean容器\n\n做容器的最重要的就是存取，针对bean容器就是bean信息的保存（注册）和bean实例的获取。\n\n- bean信息注册\n\n  bean的基本信息包括：bean的名称、bean实例、bean的Class信息，bean的属性信息，把这些基本信息封装成了`BeanDefinition`。\n\n  以`key(beanName)=>value(BeanDefinition)`的键值对就可以完成注册的功能\n\n- bean实例获取\n\n  从bean信息到bean实例中间还有一条鸿沟：怎么实例化bean。\n\n  为了方便实现，在初始化`BeanDefinition`实例的时候也对bean进行了初始化。\n\n\n站在客户端角度，怎么注册bean并不重要，因此bean容器接口只声明获取bena的方法。\n\n在`BeanDefinition`中实例化bean带来一个严重问题：bean实例的创建不受容器控制的。\n\n## 2. 定制Bean的实例化过程\n\n针对上面的问题，`AbstractBeanFactory`抽象出实例化bean方法，并在`AutowireCapableBeanFactory`提供基板实现。在`BeanDefinition`中并不需要再实例化了（代码实现到这一步时没有修改,bug）。\n\n新的`AutowireCapableBeanFactory`已经可以做到：\n\n1. 注册保存`BeanDefinition`\n2. 在注册时实例化bean\n3. 提供bean实例的获取\n\n现在，bean的实例化是受控于容器的。\n\n但是初始化的时机不够灵活，整个生命周期只有在注册时刻有唯一一次初始化。\n\n这样会影响bean实例属性的初始化，先看基本属性：\n\n## 3. 支持基本属性依赖\n\n对基本属性支持比较简单，整个过程完全由容器控制：\n\n1. 根据`BeanDefinition`获取bean相关的属性信息\n2. 创建对应的属性对象\n3. 使用反射注入属性\n\n在bean实例构造完成后就对属性注入，但是现有的方案并不能支持bean属性的注入：\n\n1. 属性bean从哪里来\n2. bean属性本身依赖其他bean呢？如果存在循环依赖呢？\n\n## 4. 使用资源文件配置\n\n解决bean属性问题前，先完成支持资源文件的管理。\n\n1. 创建资源文件表示类，以及资源加载类\n2. 创建信息读取接口，抽象类，以及具体的XML配置读取策略类\n\n添加对资源文件配置支持后，整个bean容器的过程为：\n\n1. 读取加载配置文件信息\n2. 创建beanfactory\n3. 注册保存bean信息\n   1. 创建bean实例\n   2. 设置bean实例的属性\n\n支持资源文件配置后原来需要硬编码的bean信息可以以配置文件的形式展示。\n\n但是，bean的实例构造时机、属性注入的时机没有改变，所以依赖存在对bean属性的支持问题。\n\n## 5. 支持bean属性依赖\n\n前面碰到的两个问题：\n\n1. 属性bean从哪里来\n2. bean属性本身依赖其他bean呢？如果存在循环依赖呢？\n\n属性bean也是bean，所以应该从工厂获取，循环依赖问题在Spring里是通过延迟实例化解决。\n\n所以问题变成了怎么调整bean实例构造时机，让这个过程延迟，发生在所有bean注册完成后。\n\n调整：在注册时只保存`BeanDefinition`，不对bena进行实例化。\n\n所有bean的实例化延迟到第一次获取bean实例时再进行：\n\n1. 先创建bean实例\n2. 遍历所有属性，基本属性直接注入，如果是其他bean引用重复以上过程。\n\n## 6. 进一步简化\n\n回头看现在的客户端使用：\n\n1. 加载资源\n2. 解析资源\n3. 创建beanFactory\n4. 注册bean\n5. 获取bean\n\n前四步实际是beanFactory的生命周期内容，客户端不关心这些细节，只要提供配置文件就可以。\n\n所以使用`ApplicationContext`接口对外暴露获取bean的方法。\n\nbean加载，解析，存取功能分别委托给：`BeanDefinitionReader`， `AbstractBeanFactory`。\n\n整个Bean容器生命周期细节都可以封装起来，对外提供简单调用。\n\n\n\n至此，一个简单的IoC容器就完成了\n\n---\n\n# 自上而下\n\n俯视这个IoC容器，基本的生命周期活动包括了：\n\n1. 资源加载\n2. 资源解析\n3. bean factory创建\n4. bean注册\n5. 创建bean实例\n6. bean获取\n\n所有的步骤都是以接口或抽象方法的形式提供或者是多态留白，具体的实现都交由子类实现。\n\n|       步骤       |                   抽象方法                   |\n| :------------: | :--------------------------------------: |\n|      资源加载      |        Resources.getInputStream()        |\n|      资源解析      | BeanDefinitionReader.loadBeanDefinitions(String) |\n| bean factory创建 |      this.beanFactory = beanFactory      |\n|     bean注册     | AbstractBeanFactory.registerBeanDefinition(String, BeanDefinition) |\n|    bean实例化     | AbstractBeanFactory.doCreateBean(BeanDefinition) |\n|     bean获取     |       BeanFactory.getBean(String)        |\n\n各个模块的耦合以接口留白的形式而非具体实现类为扩展带来了极大的灵活。\n\n在实现的时候并没有考虑这些，但实现完成后发现接口带来的灵活极大的方便了修改和扩展。\n","source":"_posts/IoC容器的简单实现.md","raw":"---\ntitle: IoC容器的简单实现\ndate: 2016-11-10 23:44:15\ntags:\n  - Java\ncategories: Java\n\n---\n\n记录临摹一个IoC容器的过程，使用对象容器进行控制反转，将对象间依赖关系的管理交给容器。\n\n代码在[这里](https://github.com/zhanghTK/HelloIoC)，API参照了Spring IoC部分，实现的具体过程参照了[tiny-spring](https://github.com/code4craft/tiny-spring)和[ioc-sample](https://github.com/kevinlynx/ioc-sample)。先看看如何使用：\n\n# 像Spring一样用\n\n```xml\n<beans>\n    <bean name=\"helloWorldOutputService\"\n          class=\"tk.zhangh.ioc.beans.HelloWorldOutputServiceImpl\">\n        <property name=\"name\" value=\"helloWorld\"/>\n        <property name=\"outputService\" ref=\"outputService\"/>\n    </bean>\n</beans>\n```\n\n```java\n@Test\npublic void register_get_bean_by_ClassPathXmlApplicationContextTest() throws Exception {\n    ApplicationContext applicationContext = new\n      ClassPathXmlApplicationContext(\"ioc.xml\");\n    HelloWorldService helloWorldService = (HelloWorldService)\n      applicationContext.getBean(\"helloWorldOutputService\");\n    helloWorldService.sayHello();\n}\n```\n\n---\n\n整个开发过程是这样的：\n\n# 自下而上\n\n大体的开发步骤以及思路参照了[tiny-spring](https://github.com/code4craft/tiny-spring)，实现步骤可以简述为：\n\n## 1.全手动式的Bean容器\n\n做容器的最重要的就是存取，针对bean容器就是bean信息的保存（注册）和bean实例的获取。\n\n- bean信息注册\n\n  bean的基本信息包括：bean的名称、bean实例、bean的Class信息，bean的属性信息，把这些基本信息封装成了`BeanDefinition`。\n\n  以`key(beanName)=>value(BeanDefinition)`的键值对就可以完成注册的功能\n\n- bean实例获取\n\n  从bean信息到bean实例中间还有一条鸿沟：怎么实例化bean。\n\n  为了方便实现，在初始化`BeanDefinition`实例的时候也对bean进行了初始化。\n\n\n站在客户端角度，怎么注册bean并不重要，因此bean容器接口只声明获取bena的方法。\n\n在`BeanDefinition`中实例化bean带来一个严重问题：bean实例的创建不受容器控制的。\n\n## 2. 定制Bean的实例化过程\n\n针对上面的问题，`AbstractBeanFactory`抽象出实例化bean方法，并在`AutowireCapableBeanFactory`提供基板实现。在`BeanDefinition`中并不需要再实例化了（代码实现到这一步时没有修改,bug）。\n\n新的`AutowireCapableBeanFactory`已经可以做到：\n\n1. 注册保存`BeanDefinition`\n2. 在注册时实例化bean\n3. 提供bean实例的获取\n\n现在，bean的实例化是受控于容器的。\n\n但是初始化的时机不够灵活，整个生命周期只有在注册时刻有唯一一次初始化。\n\n这样会影响bean实例属性的初始化，先看基本属性：\n\n## 3. 支持基本属性依赖\n\n对基本属性支持比较简单，整个过程完全由容器控制：\n\n1. 根据`BeanDefinition`获取bean相关的属性信息\n2. 创建对应的属性对象\n3. 使用反射注入属性\n\n在bean实例构造完成后就对属性注入，但是现有的方案并不能支持bean属性的注入：\n\n1. 属性bean从哪里来\n2. bean属性本身依赖其他bean呢？如果存在循环依赖呢？\n\n## 4. 使用资源文件配置\n\n解决bean属性问题前，先完成支持资源文件的管理。\n\n1. 创建资源文件表示类，以及资源加载类\n2. 创建信息读取接口，抽象类，以及具体的XML配置读取策略类\n\n添加对资源文件配置支持后，整个bean容器的过程为：\n\n1. 读取加载配置文件信息\n2. 创建beanfactory\n3. 注册保存bean信息\n   1. 创建bean实例\n   2. 设置bean实例的属性\n\n支持资源文件配置后原来需要硬编码的bean信息可以以配置文件的形式展示。\n\n但是，bean的实例构造时机、属性注入的时机没有改变，所以依赖存在对bean属性的支持问题。\n\n## 5. 支持bean属性依赖\n\n前面碰到的两个问题：\n\n1. 属性bean从哪里来\n2. bean属性本身依赖其他bean呢？如果存在循环依赖呢？\n\n属性bean也是bean，所以应该从工厂获取，循环依赖问题在Spring里是通过延迟实例化解决。\n\n所以问题变成了怎么调整bean实例构造时机，让这个过程延迟，发生在所有bean注册完成后。\n\n调整：在注册时只保存`BeanDefinition`，不对bena进行实例化。\n\n所有bean的实例化延迟到第一次获取bean实例时再进行：\n\n1. 先创建bean实例\n2. 遍历所有属性，基本属性直接注入，如果是其他bean引用重复以上过程。\n\n## 6. 进一步简化\n\n回头看现在的客户端使用：\n\n1. 加载资源\n2. 解析资源\n3. 创建beanFactory\n4. 注册bean\n5. 获取bean\n\n前四步实际是beanFactory的生命周期内容，客户端不关心这些细节，只要提供配置文件就可以。\n\n所以使用`ApplicationContext`接口对外暴露获取bean的方法。\n\nbean加载，解析，存取功能分别委托给：`BeanDefinitionReader`， `AbstractBeanFactory`。\n\n整个Bean容器生命周期细节都可以封装起来，对外提供简单调用。\n\n\n\n至此，一个简单的IoC容器就完成了\n\n---\n\n# 自上而下\n\n俯视这个IoC容器，基本的生命周期活动包括了：\n\n1. 资源加载\n2. 资源解析\n3. bean factory创建\n4. bean注册\n5. 创建bean实例\n6. bean获取\n\n所有的步骤都是以接口或抽象方法的形式提供或者是多态留白，具体的实现都交由子类实现。\n\n|       步骤       |                   抽象方法                   |\n| :------------: | :--------------------------------------: |\n|      资源加载      |        Resources.getInputStream()        |\n|      资源解析      | BeanDefinitionReader.loadBeanDefinitions(String) |\n| bean factory创建 |      this.beanFactory = beanFactory      |\n|     bean注册     | AbstractBeanFactory.registerBeanDefinition(String, BeanDefinition) |\n|    bean实例化     | AbstractBeanFactory.doCreateBean(BeanDefinition) |\n|     bean获取     |       BeanFactory.getBean(String)        |\n\n各个模块的耦合以接口留白的形式而非具体实现类为扩展带来了极大的灵活。\n\n在实现的时候并没有考虑这些，但实现完成后发现接口带来的灵活极大的方便了修改和扩展。\n","slug":"IoC容器的简单实现","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gad0008yi2eturkgjbm","content":"<p>记录临摹一个IoC容器的过程，使用对象容器进行控制反转，将对象间依赖关系的管理交给容器。</p>\n<p>代码在<a href=\"https://github.com/zhanghTK/HelloIoC\" target=\"_blank\" rel=\"external\">这里</a>，API参照了Spring IoC部分，实现的具体过程参照了<a href=\"https://github.com/code4craft/tiny-spring\" target=\"_blank\" rel=\"external\">tiny-spring</a>和<a href=\"https://github.com/kevinlynx/ioc-sample\" target=\"_blank\" rel=\"external\">ioc-sample</a>。先看看如何使用：</p>\n<h1 id=\"像Spring一样用\"><a href=\"#像Spring一样用\" class=\"headerlink\" title=\"像Spring一样用\"></a>像Spring一样用</h1><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"helloWorldOutputService\"</span></span></div><div class=\"line\">          <span class=\"attr\">class</span>=<span class=\"string\">\"tk.zhangh.ioc.beans.HelloWorldOutputServiceImpl\"</span>&gt;</div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"helloWorld\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"outputService\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"outputService\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register_get_bean_by_ClassPathXmlApplicationContextTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    ApplicationContext applicationContext = <span class=\"keyword\">new</span></div><div class=\"line\">      ClassPathXmlApplicationContext(<span class=\"string\">\"ioc.xml\"</span>);</div><div class=\"line\">    HelloWorldService helloWorldService = (HelloWorldService)</div><div class=\"line\">      applicationContext.getBean(<span class=\"string\">\"helloWorldOutputService\"</span>);</div><div class=\"line\">    helloWorldService.sayHello();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>整个开发过程是这样的：</p>\n<h1 id=\"自下而上\"><a href=\"#自下而上\" class=\"headerlink\" title=\"自下而上\"></a>自下而上</h1><p>大体的开发步骤以及思路参照了<a href=\"https://github.com/code4craft/tiny-spring\" target=\"_blank\" rel=\"external\">tiny-spring</a>，实现步骤可以简述为：</p>\n<h2 id=\"1-全手动式的Bean容器\"><a href=\"#1-全手动式的Bean容器\" class=\"headerlink\" title=\"1.全手动式的Bean容器\"></a>1.全手动式的Bean容器</h2><p>做容器的最重要的就是存取，针对bean容器就是bean信息的保存（注册）和bean实例的获取。</p>\n<ul>\n<li><p>bean信息注册</p>\n<p>bean的基本信息包括：bean的名称、bean实例、bean的Class信息，bean的属性信息，把这些基本信息封装成了<code>BeanDefinition</code>。</p>\n<p>以<code>key(beanName)=&gt;value(BeanDefinition)</code>的键值对就可以完成注册的功能</p>\n</li>\n<li><p>bean实例获取</p>\n<p>从bean信息到bean实例中间还有一条鸿沟：怎么实例化bean。</p>\n<p>为了方便实现，在初始化<code>BeanDefinition</code>实例的时候也对bean进行了初始化。</p>\n</li>\n</ul>\n<p>站在客户端角度，怎么注册bean并不重要，因此bean容器接口只声明获取bena的方法。</p>\n<p>在<code>BeanDefinition</code>中实例化bean带来一个严重问题：bean实例的创建不受容器控制的。</p>\n<h2 id=\"2-定制Bean的实例化过程\"><a href=\"#2-定制Bean的实例化过程\" class=\"headerlink\" title=\"2. 定制Bean的实例化过程\"></a>2. 定制Bean的实例化过程</h2><p>针对上面的问题，<code>AbstractBeanFactory</code>抽象出实例化bean方法，并在<code>AutowireCapableBeanFactory</code>提供基板实现。在<code>BeanDefinition</code>中并不需要再实例化了（代码实现到这一步时没有修改,bug）。</p>\n<p>新的<code>AutowireCapableBeanFactory</code>已经可以做到：</p>\n<ol>\n<li>注册保存<code>BeanDefinition</code></li>\n<li>在注册时实例化bean</li>\n<li>提供bean实例的获取</li>\n</ol>\n<p>现在，bean的实例化是受控于容器的。</p>\n<p>但是初始化的时机不够灵活，整个生命周期只有在注册时刻有唯一一次初始化。</p>\n<p>这样会影响bean实例属性的初始化，先看基本属性：</p>\n<h2 id=\"3-支持基本属性依赖\"><a href=\"#3-支持基本属性依赖\" class=\"headerlink\" title=\"3. 支持基本属性依赖\"></a>3. 支持基本属性依赖</h2><p>对基本属性支持比较简单，整个过程完全由容器控制：</p>\n<ol>\n<li>根据<code>BeanDefinition</code>获取bean相关的属性信息</li>\n<li>创建对应的属性对象</li>\n<li>使用反射注入属性</li>\n</ol>\n<p>在bean实例构造完成后就对属性注入，但是现有的方案并不能支持bean属性的注入：</p>\n<ol>\n<li>属性bean从哪里来</li>\n<li>bean属性本身依赖其他bean呢？如果存在循环依赖呢？</li>\n</ol>\n<h2 id=\"4-使用资源文件配置\"><a href=\"#4-使用资源文件配置\" class=\"headerlink\" title=\"4. 使用资源文件配置\"></a>4. 使用资源文件配置</h2><p>解决bean属性问题前，先完成支持资源文件的管理。</p>\n<ol>\n<li>创建资源文件表示类，以及资源加载类</li>\n<li>创建信息读取接口，抽象类，以及具体的XML配置读取策略类</li>\n</ol>\n<p>添加对资源文件配置支持后，整个bean容器的过程为：</p>\n<ol>\n<li>读取加载配置文件信息</li>\n<li>创建beanfactory</li>\n<li>注册保存bean信息<ol>\n<li>创建bean实例</li>\n<li>设置bean实例的属性</li>\n</ol>\n</li>\n</ol>\n<p>支持资源文件配置后原来需要硬编码的bean信息可以以配置文件的形式展示。</p>\n<p>但是，bean的实例构造时机、属性注入的时机没有改变，所以依赖存在对bean属性的支持问题。</p>\n<h2 id=\"5-支持bean属性依赖\"><a href=\"#5-支持bean属性依赖\" class=\"headerlink\" title=\"5. 支持bean属性依赖\"></a>5. 支持bean属性依赖</h2><p>前面碰到的两个问题：</p>\n<ol>\n<li>属性bean从哪里来</li>\n<li>bean属性本身依赖其他bean呢？如果存在循环依赖呢？</li>\n</ol>\n<p>属性bean也是bean，所以应该从工厂获取，循环依赖问题在Spring里是通过延迟实例化解决。</p>\n<p>所以问题变成了怎么调整bean实例构造时机，让这个过程延迟，发生在所有bean注册完成后。</p>\n<p>调整：在注册时只保存<code>BeanDefinition</code>，不对bena进行实例化。</p>\n<p>所有bean的实例化延迟到第一次获取bean实例时再进行：</p>\n<ol>\n<li>先创建bean实例</li>\n<li>遍历所有属性，基本属性直接注入，如果是其他bean引用重复以上过程。</li>\n</ol>\n<h2 id=\"6-进一步简化\"><a href=\"#6-进一步简化\" class=\"headerlink\" title=\"6. 进一步简化\"></a>6. 进一步简化</h2><p>回头看现在的客户端使用：</p>\n<ol>\n<li>加载资源</li>\n<li>解析资源</li>\n<li>创建beanFactory</li>\n<li>注册bean</li>\n<li>获取bean</li>\n</ol>\n<p>前四步实际是beanFactory的生命周期内容，客户端不关心这些细节，只要提供配置文件就可以。</p>\n<p>所以使用<code>ApplicationContext</code>接口对外暴露获取bean的方法。</p>\n<p>bean加载，解析，存取功能分别委托给：<code>BeanDefinitionReader</code>， <code>AbstractBeanFactory</code>。</p>\n<p>整个Bean容器生命周期细节都可以封装起来，对外提供简单调用。</p>\n<p>至此，一个简单的IoC容器就完成了</p>\n<hr>\n<h1 id=\"自上而下\"><a href=\"#自上而下\" class=\"headerlink\" title=\"自上而下\"></a>自上而下</h1><p>俯视这个IoC容器，基本的生命周期活动包括了：</p>\n<ol>\n<li>资源加载</li>\n<li>资源解析</li>\n<li>bean factory创建</li>\n<li>bean注册</li>\n<li>创建bean实例</li>\n<li>bean获取</li>\n</ol>\n<p>所有的步骤都是以接口或抽象方法的形式提供或者是多态留白，具体的实现都交由子类实现。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">步骤</th>\n<th style=\"text-align:center\">抽象方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">资源加载</td>\n<td style=\"text-align:center\">Resources.getInputStream()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">资源解析</td>\n<td style=\"text-align:center\">BeanDefinitionReader.loadBeanDefinitions(String)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean factory创建</td>\n<td style=\"text-align:center\">this.beanFactory = beanFactory</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean注册</td>\n<td style=\"text-align:center\">AbstractBeanFactory.registerBeanDefinition(String, BeanDefinition)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean实例化</td>\n<td style=\"text-align:center\">AbstractBeanFactory.doCreateBean(BeanDefinition)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean获取</td>\n<td style=\"text-align:center\">BeanFactory.getBean(String)</td>\n</tr>\n</tbody>\n</table>\n<p>各个模块的耦合以接口留白的形式而非具体实现类为扩展带来了极大的灵活。</p>\n<p>在实现的时候并没有考虑这些，但实现完成后发现接口带来的灵活极大的方便了修改和扩展。</p>\n","excerpt":"","more":"<p>记录临摹一个IoC容器的过程，使用对象容器进行控制反转，将对象间依赖关系的管理交给容器。</p>\n<p>代码在<a href=\"https://github.com/zhanghTK/HelloIoC\">这里</a>，API参照了Spring IoC部分，实现的具体过程参照了<a href=\"https://github.com/code4craft/tiny-spring\">tiny-spring</a>和<a href=\"https://github.com/kevinlynx/ioc-sample\">ioc-sample</a>。先看看如何使用：</p>\n<h1 id=\"像Spring一样用\"><a href=\"#像Spring一样用\" class=\"headerlink\" title=\"像Spring一样用\"></a>像Spring一样用</h1><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"helloWorldOutputService\"</span></div><div class=\"line\">          <span class=\"attr\">class</span>=<span class=\"string\">\"tk.zhangh.ioc.beans.HelloWorldOutputServiceImpl\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"helloWorld\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"outputService\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"outputService\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register_get_bean_by_ClassPathXmlApplicationContextTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    ApplicationContext applicationContext = <span class=\"keyword\">new</span></div><div class=\"line\">      ClassPathXmlApplicationContext(<span class=\"string\">\"ioc.xml\"</span>);</div><div class=\"line\">    HelloWorldService helloWorldService = (HelloWorldService)</div><div class=\"line\">      applicationContext.getBean(<span class=\"string\">\"helloWorldOutputService\"</span>);</div><div class=\"line\">    helloWorldService.sayHello();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>整个开发过程是这样的：</p>\n<h1 id=\"自下而上\"><a href=\"#自下而上\" class=\"headerlink\" title=\"自下而上\"></a>自下而上</h1><p>大体的开发步骤以及思路参照了<a href=\"https://github.com/code4craft/tiny-spring\">tiny-spring</a>，实现步骤可以简述为：</p>\n<h2 id=\"1-全手动式的Bean容器\"><a href=\"#1-全手动式的Bean容器\" class=\"headerlink\" title=\"1.全手动式的Bean容器\"></a>1.全手动式的Bean容器</h2><p>做容器的最重要的就是存取，针对bean容器就是bean信息的保存（注册）和bean实例的获取。</p>\n<ul>\n<li><p>bean信息注册</p>\n<p>bean的基本信息包括：bean的名称、bean实例、bean的Class信息，bean的属性信息，把这些基本信息封装成了<code>BeanDefinition</code>。</p>\n<p>以<code>key(beanName)=&gt;value(BeanDefinition)</code>的键值对就可以完成注册的功能</p>\n</li>\n<li><p>bean实例获取</p>\n<p>从bean信息到bean实例中间还有一条鸿沟：怎么实例化bean。</p>\n<p>为了方便实现，在初始化<code>BeanDefinition</code>实例的时候也对bean进行了初始化。</p>\n</li>\n</ul>\n<p>站在客户端角度，怎么注册bean并不重要，因此bean容器接口只声明获取bena的方法。</p>\n<p>在<code>BeanDefinition</code>中实例化bean带来一个严重问题：bean实例的创建不受容器控制的。</p>\n<h2 id=\"2-定制Bean的实例化过程\"><a href=\"#2-定制Bean的实例化过程\" class=\"headerlink\" title=\"2. 定制Bean的实例化过程\"></a>2. 定制Bean的实例化过程</h2><p>针对上面的问题，<code>AbstractBeanFactory</code>抽象出实例化bean方法，并在<code>AutowireCapableBeanFactory</code>提供基板实现。在<code>BeanDefinition</code>中并不需要再实例化了（代码实现到这一步时没有修改,bug）。</p>\n<p>新的<code>AutowireCapableBeanFactory</code>已经可以做到：</p>\n<ol>\n<li>注册保存<code>BeanDefinition</code></li>\n<li>在注册时实例化bean</li>\n<li>提供bean实例的获取</li>\n</ol>\n<p>现在，bean的实例化是受控于容器的。</p>\n<p>但是初始化的时机不够灵活，整个生命周期只有在注册时刻有唯一一次初始化。</p>\n<p>这样会影响bean实例属性的初始化，先看基本属性：</p>\n<h2 id=\"3-支持基本属性依赖\"><a href=\"#3-支持基本属性依赖\" class=\"headerlink\" title=\"3. 支持基本属性依赖\"></a>3. 支持基本属性依赖</h2><p>对基本属性支持比较简单，整个过程完全由容器控制：</p>\n<ol>\n<li>根据<code>BeanDefinition</code>获取bean相关的属性信息</li>\n<li>创建对应的属性对象</li>\n<li>使用反射注入属性</li>\n</ol>\n<p>在bean实例构造完成后就对属性注入，但是现有的方案并不能支持bean属性的注入：</p>\n<ol>\n<li>属性bean从哪里来</li>\n<li>bean属性本身依赖其他bean呢？如果存在循环依赖呢？</li>\n</ol>\n<h2 id=\"4-使用资源文件配置\"><a href=\"#4-使用资源文件配置\" class=\"headerlink\" title=\"4. 使用资源文件配置\"></a>4. 使用资源文件配置</h2><p>解决bean属性问题前，先完成支持资源文件的管理。</p>\n<ol>\n<li>创建资源文件表示类，以及资源加载类</li>\n<li>创建信息读取接口，抽象类，以及具体的XML配置读取策略类</li>\n</ol>\n<p>添加对资源文件配置支持后，整个bean容器的过程为：</p>\n<ol>\n<li>读取加载配置文件信息</li>\n<li>创建beanfactory</li>\n<li>注册保存bean信息<ol>\n<li>创建bean实例</li>\n<li>设置bean实例的属性</li>\n</ol>\n</li>\n</ol>\n<p>支持资源文件配置后原来需要硬编码的bean信息可以以配置文件的形式展示。</p>\n<p>但是，bean的实例构造时机、属性注入的时机没有改变，所以依赖存在对bean属性的支持问题。</p>\n<h2 id=\"5-支持bean属性依赖\"><a href=\"#5-支持bean属性依赖\" class=\"headerlink\" title=\"5. 支持bean属性依赖\"></a>5. 支持bean属性依赖</h2><p>前面碰到的两个问题：</p>\n<ol>\n<li>属性bean从哪里来</li>\n<li>bean属性本身依赖其他bean呢？如果存在循环依赖呢？</li>\n</ol>\n<p>属性bean也是bean，所以应该从工厂获取，循环依赖问题在Spring里是通过延迟实例化解决。</p>\n<p>所以问题变成了怎么调整bean实例构造时机，让这个过程延迟，发生在所有bean注册完成后。</p>\n<p>调整：在注册时只保存<code>BeanDefinition</code>，不对bena进行实例化。</p>\n<p>所有bean的实例化延迟到第一次获取bean实例时再进行：</p>\n<ol>\n<li>先创建bean实例</li>\n<li>遍历所有属性，基本属性直接注入，如果是其他bean引用重复以上过程。</li>\n</ol>\n<h2 id=\"6-进一步简化\"><a href=\"#6-进一步简化\" class=\"headerlink\" title=\"6. 进一步简化\"></a>6. 进一步简化</h2><p>回头看现在的客户端使用：</p>\n<ol>\n<li>加载资源</li>\n<li>解析资源</li>\n<li>创建beanFactory</li>\n<li>注册bean</li>\n<li>获取bean</li>\n</ol>\n<p>前四步实际是beanFactory的生命周期内容，客户端不关心这些细节，只要提供配置文件就可以。</p>\n<p>所以使用<code>ApplicationContext</code>接口对外暴露获取bean的方法。</p>\n<p>bean加载，解析，存取功能分别委托给：<code>BeanDefinitionReader</code>， <code>AbstractBeanFactory</code>。</p>\n<p>整个Bean容器生命周期细节都可以封装起来，对外提供简单调用。</p>\n<p>至此，一个简单的IoC容器就完成了</p>\n<hr>\n<h1 id=\"自上而下\"><a href=\"#自上而下\" class=\"headerlink\" title=\"自上而下\"></a>自上而下</h1><p>俯视这个IoC容器，基本的生命周期活动包括了：</p>\n<ol>\n<li>资源加载</li>\n<li>资源解析</li>\n<li>bean factory创建</li>\n<li>bean注册</li>\n<li>创建bean实例</li>\n<li>bean获取</li>\n</ol>\n<p>所有的步骤都是以接口或抽象方法的形式提供或者是多态留白，具体的实现都交由子类实现。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">步骤</th>\n<th style=\"text-align:center\">抽象方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">资源加载</td>\n<td style=\"text-align:center\">Resources.getInputStream()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">资源解析</td>\n<td style=\"text-align:center\">BeanDefinitionReader.loadBeanDefinitions(String)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean factory创建</td>\n<td style=\"text-align:center\">this.beanFactory = beanFactory</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean注册</td>\n<td style=\"text-align:center\">AbstractBeanFactory.registerBeanDefinition(String, BeanDefinition)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean实例化</td>\n<td style=\"text-align:center\">AbstractBeanFactory.doCreateBean(BeanDefinition)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean获取</td>\n<td style=\"text-align:center\">BeanFactory.getBean(String)</td>\n</tr>\n</tbody>\n</table>\n<p>各个模块的耦合以接口留白的形式而非具体实现类为扩展带来了极大的灵活。</p>\n<p>在实现的时候并没有考虑这些，但实现完成后发现接口带来的灵活极大的方便了修改和扩展。</p>\n"},{"title":"Spring之BeanFactory","date":"2017-03-12T17:19:54.000Z","_content":"Spring核心的功能是IoC和AOP，IoC又是AOP的基础。对于IoC，Spring提供了两种容器类型：\n\n- BeanFactory\n- ApplicationContext\n\nApplicationContext可以简单理解为是BeanFactory的升级版。\n\n本文试图讨论与BeanFactory相关的大致过程。\n\n### 调用实现\n\n#### 直接编码\n\nBeanFactory是基础的IoC容器，提供了完成的IoC服务。先看看BeanFactory和Bean之间的关系：\n\n![BeanFactory.png](https://ooo.0o0.ooo/2017/03/12/58c4fc455dda9.png)\n\nBeanFactory，BeanDefinitionRegistry，BeanDefinition都是基本接口。其中：\n\n- BeanFactory定义了基本的查询相关方法；\n- BeanDefinitionRegistry定义了Bean注册管理的相关方法；\n- BeanDefinition定义容器中的一个Bean实例；\n\nDefaultListableBeanFactory实现了Bean注册，查询相关方法，Bean之间的关系则通过Bean实例维护，以上构成了一个最基本的IoC结构。\n\n使用Spring IoC最直接的方式就是依赖上述几个类来加载、维护、查询Bean实例，只是当更先进的方式到来后，直接编码的方式已经离我们很远了。\n\n#### 外部配置\n\n程序员总是希望以更便捷的方式维护配置信息，配置文件是其中一个手段，也是Spring配置最常使用的一种方式。\n\nSpring配置文件最常见的方式是XML形式，其实还有Properties，得益于良好可扩展性，我们甚至可以自定义配置文件及加载方式。\n\nBeanDefinitionReader通过处理外部配置文件，根据不同的配置文件格式，BeanDefinitionReader不同子类将相应的配置文件内容加载并解析映射到BeanDefinition，然后将映射后的BeanDefinition测试到BeanDefinitionRegistry。\n\n加入BeanDefinitionRegistry后的类图：\n\n![BeanFactory.png](https://ooo.0o0.ooo/2017/03/12/58c5115a0c0fa.png)\n\n### 背后的细节\n\nIoC容器功能实现简单可以分类两个阶段：\n\n- 容器启动\n- Bean实例化\n\n#### 容器启动\n\n容器启动主要的过程包括了：\n\n1. 加载配置\n2. 分析配置信息\n3. 装配到BeanDefinition\n4. 其他后续\n\n在整个启动阶段可以通过BeanFactoryPostProcessor，在实例化阶段开始之前，对注册到容器的BeanDefinition保存的原始数据做出修改。\n\nSpring自带了几个BeanFactoryPostProcessor的实现：\n\n- PropertyPlaceholderConfigurer：占位符替换\n- PropertyOverrideConfigurer：替换bean字段\n- CustomEidtorConfigurer：配置解析\n\n#### Bean实例化\n\n对于BeanFactory，当容器启动后只有当客户端调用`getBean()`方法时才会触发实例化阶段活动。\n\n完整的Bean实例化过程如下：\n\n![Bean实例化.png](https://ooo.0o0.ooo/2017/03/12/58c51014ca1e0.png)\n\n几个说明的点：\n\n1. Bean的实例化\n\n   实例化有两种方式实现：\n\n   - 反射\n   - CGLIB（默认）\n\n   实例化完成后，不直接返回生成的实例化对象，使用BeanWrapper对对象进行包裹\n\n2. 设置对象属性\n\n   BeanWrapper使用PropertyEditor对获取的属性值做出相应转换，设置对象属性值\n\n3. 设置Aware依赖\n\n   容器根据Aware接口，对Bean实例设置相应属性\n\n4. BeanPostProcessor\n\n   一般用于筛选bean，对bean实例化过程扩展，AOP更多在此生成代理对象\n\n   ApplicationContext在此阶段设置Aware依赖\n","source":"_posts/Spring之BeanFactory.md","raw":"---\ntitle: Spring之BeanFactory\ndate: 2017-03-13 01:19:54\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\nSpring核心的功能是IoC和AOP，IoC又是AOP的基础。对于IoC，Spring提供了两种容器类型：\n\n- BeanFactory\n- ApplicationContext\n\nApplicationContext可以简单理解为是BeanFactory的升级版。\n\n本文试图讨论与BeanFactory相关的大致过程。\n\n### 调用实现\n\n#### 直接编码\n\nBeanFactory是基础的IoC容器，提供了完成的IoC服务。先看看BeanFactory和Bean之间的关系：\n\n![BeanFactory.png](https://ooo.0o0.ooo/2017/03/12/58c4fc455dda9.png)\n\nBeanFactory，BeanDefinitionRegistry，BeanDefinition都是基本接口。其中：\n\n- BeanFactory定义了基本的查询相关方法；\n- BeanDefinitionRegistry定义了Bean注册管理的相关方法；\n- BeanDefinition定义容器中的一个Bean实例；\n\nDefaultListableBeanFactory实现了Bean注册，查询相关方法，Bean之间的关系则通过Bean实例维护，以上构成了一个最基本的IoC结构。\n\n使用Spring IoC最直接的方式就是依赖上述几个类来加载、维护、查询Bean实例，只是当更先进的方式到来后，直接编码的方式已经离我们很远了。\n\n#### 外部配置\n\n程序员总是希望以更便捷的方式维护配置信息，配置文件是其中一个手段，也是Spring配置最常使用的一种方式。\n\nSpring配置文件最常见的方式是XML形式，其实还有Properties，得益于良好可扩展性，我们甚至可以自定义配置文件及加载方式。\n\nBeanDefinitionReader通过处理外部配置文件，根据不同的配置文件格式，BeanDefinitionReader不同子类将相应的配置文件内容加载并解析映射到BeanDefinition，然后将映射后的BeanDefinition测试到BeanDefinitionRegistry。\n\n加入BeanDefinitionRegistry后的类图：\n\n![BeanFactory.png](https://ooo.0o0.ooo/2017/03/12/58c5115a0c0fa.png)\n\n### 背后的细节\n\nIoC容器功能实现简单可以分类两个阶段：\n\n- 容器启动\n- Bean实例化\n\n#### 容器启动\n\n容器启动主要的过程包括了：\n\n1. 加载配置\n2. 分析配置信息\n3. 装配到BeanDefinition\n4. 其他后续\n\n在整个启动阶段可以通过BeanFactoryPostProcessor，在实例化阶段开始之前，对注册到容器的BeanDefinition保存的原始数据做出修改。\n\nSpring自带了几个BeanFactoryPostProcessor的实现：\n\n- PropertyPlaceholderConfigurer：占位符替换\n- PropertyOverrideConfigurer：替换bean字段\n- CustomEidtorConfigurer：配置解析\n\n#### Bean实例化\n\n对于BeanFactory，当容器启动后只有当客户端调用`getBean()`方法时才会触发实例化阶段活动。\n\n完整的Bean实例化过程如下：\n\n![Bean实例化.png](https://ooo.0o0.ooo/2017/03/12/58c51014ca1e0.png)\n\n几个说明的点：\n\n1. Bean的实例化\n\n   实例化有两种方式实现：\n\n   - 反射\n   - CGLIB（默认）\n\n   实例化完成后，不直接返回生成的实例化对象，使用BeanWrapper对对象进行包裹\n\n2. 设置对象属性\n\n   BeanWrapper使用PropertyEditor对获取的属性值做出相应转换，设置对象属性值\n\n3. 设置Aware依赖\n\n   容器根据Aware接口，对Bean实例设置相应属性\n\n4. BeanPostProcessor\n\n   一般用于筛选bean，对bean实例化过程扩展，AOP更多在此生成代理对象\n\n   ApplicationContext在此阶段设置Aware依赖\n","slug":"Spring之BeanFactory","published":1,"updated":"2017-03-12T17:23:34.000Z","_id":"cj06y6gag000byi2e2yo5laad","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Spring核心的功能是IoC和AOP，IoC又是AOP的基础。对于IoC，Spring提供了两种容器类型：</p>\n<ul>\n<li>BeanFactory</li>\n<li>ApplicationContext</li>\n</ul>\n<p>ApplicationContext可以简单理解为是BeanFactory的升级版。</p>\n<p>本文试图讨论与BeanFactory相关的大致过程。</p>\n<h3 id=\"调用实现\"><a href=\"#调用实现\" class=\"headerlink\" title=\"调用实现\"></a>调用实现</h3><h4 id=\"直接编码\"><a href=\"#直接编码\" class=\"headerlink\" title=\"直接编码\"></a>直接编码</h4><p>BeanFactory是基础的IoC容器，提供了完成的IoC服务。先看看BeanFactory和Bean之间的关系：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c4fc455dda9.png\" alt=\"BeanFactory.png\"></p>\n<p>BeanFactory，BeanDefinitionRegistry，BeanDefinition都是基本接口。其中：</p>\n<ul>\n<li>BeanFactory定义了基本的查询相关方法；</li>\n<li>BeanDefinitionRegistry定义了Bean注册管理的相关方法；</li>\n<li>BeanDefinition定义容器中的一个Bean实例；</li>\n</ul>\n<p>DefaultListableBeanFactory实现了Bean注册，查询相关方法，Bean之间的关系则通过Bean实例维护，以上构成了一个最基本的IoC结构。</p>\n<p>使用Spring IoC最直接的方式就是依赖上述几个类来加载、维护、查询Bean实例，只是当更先进的方式到来后，直接编码的方式已经离我们很远了。</p>\n<h4 id=\"外部配置\"><a href=\"#外部配置\" class=\"headerlink\" title=\"外部配置\"></a>外部配置</h4><p>程序员总是希望以更便捷的方式维护配置信息，配置文件是其中一个手段，也是Spring配置最常使用的一种方式。</p>\n<p>Spring配置文件最常见的方式是XML形式，其实还有Properties，得益于良好可扩展性，我们甚至可以自定义配置文件及加载方式。</p>\n<p>BeanDefinitionReader通过处理外部配置文件，根据不同的配置文件格式，BeanDefinitionReader不同子类将相应的配置文件内容加载并解析映射到BeanDefinition，然后将映射后的BeanDefinition测试到BeanDefinitionRegistry。</p>\n<p>加入BeanDefinitionRegistry后的类图：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c5115a0c0fa.png\" alt=\"BeanFactory.png\"></p>\n<h3 id=\"背后的细节\"><a href=\"#背后的细节\" class=\"headerlink\" title=\"背后的细节\"></a>背后的细节</h3><p>IoC容器功能实现简单可以分类两个阶段：</p>\n<ul>\n<li>容器启动</li>\n<li>Bean实例化</li>\n</ul>\n<h4 id=\"容器启动\"><a href=\"#容器启动\" class=\"headerlink\" title=\"容器启动\"></a>容器启动</h4><p>容器启动主要的过程包括了：</p>\n<ol>\n<li>加载配置</li>\n<li>分析配置信息</li>\n<li>装配到BeanDefinition</li>\n<li>其他后续</li>\n</ol>\n<p>在整个启动阶段可以通过BeanFactoryPostProcessor，在实例化阶段开始之前，对注册到容器的BeanDefinition保存的原始数据做出修改。</p>\n<p>Spring自带了几个BeanFactoryPostProcessor的实现：</p>\n<ul>\n<li>PropertyPlaceholderConfigurer：占位符替换</li>\n<li>PropertyOverrideConfigurer：替换bean字段</li>\n<li>CustomEidtorConfigurer：配置解析</li>\n</ul>\n<h4 id=\"Bean实例化\"><a href=\"#Bean实例化\" class=\"headerlink\" title=\"Bean实例化\"></a>Bean实例化</h4><p>对于BeanFactory，当容器启动后只有当客户端调用<code>getBean()</code>方法时才会触发实例化阶段活动。</p>\n<p>完整的Bean实例化过程如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c51014ca1e0.png\" alt=\"Bean实例化.png\"></p>\n<p>几个说明的点：</p>\n<ol>\n<li><p>Bean的实例化</p>\n<p>实例化有两种方式实现：</p>\n<ul>\n<li>反射</li>\n<li>CGLIB（默认）</li>\n</ul>\n<p>实例化完成后，不直接返回生成的实例化对象，使用BeanWrapper对对象进行包裹</p>\n</li>\n<li><p>设置对象属性</p>\n<p>BeanWrapper使用PropertyEditor对获取的属性值做出相应转换，设置对象属性值</p>\n</li>\n<li><p>设置Aware依赖</p>\n<p>容器根据Aware接口，对Bean实例设置相应属性</p>\n</li>\n<li><p>BeanPostProcessor</p>\n<p>一般用于筛选bean，对bean实例化过程扩展，AOP更多在此生成代理对象</p>\n<p>ApplicationContext在此阶段设置Aware依赖</p>\n</li>\n</ol>\n","excerpt":"","more":"<p>Spring核心的功能是IoC和AOP，IoC又是AOP的基础。对于IoC，Spring提供了两种容器类型：</p>\n<ul>\n<li>BeanFactory</li>\n<li>ApplicationContext</li>\n</ul>\n<p>ApplicationContext可以简单理解为是BeanFactory的升级版。</p>\n<p>本文试图讨论与BeanFactory相关的大致过程。</p>\n<h3 id=\"调用实现\"><a href=\"#调用实现\" class=\"headerlink\" title=\"调用实现\"></a>调用实现</h3><h4 id=\"直接编码\"><a href=\"#直接编码\" class=\"headerlink\" title=\"直接编码\"></a>直接编码</h4><p>BeanFactory是基础的IoC容器，提供了完成的IoC服务。先看看BeanFactory和Bean之间的关系：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c4fc455dda9.png\" alt=\"BeanFactory.png\"></p>\n<p>BeanFactory，BeanDefinitionRegistry，BeanDefinition都是基本接口。其中：</p>\n<ul>\n<li>BeanFactory定义了基本的查询相关方法；</li>\n<li>BeanDefinitionRegistry定义了Bean注册管理的相关方法；</li>\n<li>BeanDefinition定义容器中的一个Bean实例；</li>\n</ul>\n<p>DefaultListableBeanFactory实现了Bean注册，查询相关方法，Bean之间的关系则通过Bean实例维护，以上构成了一个最基本的IoC结构。</p>\n<p>使用Spring IoC最直接的方式就是依赖上述几个类来加载、维护、查询Bean实例，只是当更先进的方式到来后，直接编码的方式已经离我们很远了。</p>\n<h4 id=\"外部配置\"><a href=\"#外部配置\" class=\"headerlink\" title=\"外部配置\"></a>外部配置</h4><p>程序员总是希望以更便捷的方式维护配置信息，配置文件是其中一个手段，也是Spring配置最常使用的一种方式。</p>\n<p>Spring配置文件最常见的方式是XML形式，其实还有Properties，得益于良好可扩展性，我们甚至可以自定义配置文件及加载方式。</p>\n<p>BeanDefinitionReader通过处理外部配置文件，根据不同的配置文件格式，BeanDefinitionReader不同子类将相应的配置文件内容加载并解析映射到BeanDefinition，然后将映射后的BeanDefinition测试到BeanDefinitionRegistry。</p>\n<p>加入BeanDefinitionRegistry后的类图：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c5115a0c0fa.png\" alt=\"BeanFactory.png\"></p>\n<h3 id=\"背后的细节\"><a href=\"#背后的细节\" class=\"headerlink\" title=\"背后的细节\"></a>背后的细节</h3><p>IoC容器功能实现简单可以分类两个阶段：</p>\n<ul>\n<li>容器启动</li>\n<li>Bean实例化</li>\n</ul>\n<h4 id=\"容器启动\"><a href=\"#容器启动\" class=\"headerlink\" title=\"容器启动\"></a>容器启动</h4><p>容器启动主要的过程包括了：</p>\n<ol>\n<li>加载配置</li>\n<li>分析配置信息</li>\n<li>装配到BeanDefinition</li>\n<li>其他后续</li>\n</ol>\n<p>在整个启动阶段可以通过BeanFactoryPostProcessor，在实例化阶段开始之前，对注册到容器的BeanDefinition保存的原始数据做出修改。</p>\n<p>Spring自带了几个BeanFactoryPostProcessor的实现：</p>\n<ul>\n<li>PropertyPlaceholderConfigurer：占位符替换</li>\n<li>PropertyOverrideConfigurer：替换bean字段</li>\n<li>CustomEidtorConfigurer：配置解析</li>\n</ul>\n<h4 id=\"Bean实例化\"><a href=\"#Bean实例化\" class=\"headerlink\" title=\"Bean实例化\"></a>Bean实例化</h4><p>对于BeanFactory，当容器启动后只有当客户端调用<code>getBean()</code>方法时才会触发实例化阶段活动。</p>\n<p>完整的Bean实例化过程如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c51014ca1e0.png\" alt=\"Bean实例化.png\"></p>\n<p>几个说明的点：</p>\n<ol>\n<li><p>Bean的实例化</p>\n<p>实例化有两种方式实现：</p>\n<ul>\n<li>反射</li>\n<li>CGLIB（默认）</li>\n</ul>\n<p>实例化完成后，不直接返回生成的实例化对象，使用BeanWrapper对对象进行包裹</p>\n</li>\n<li><p>设置对象属性</p>\n<p>BeanWrapper使用PropertyEditor对获取的属性值做出相应转换，设置对象属性值</p>\n</li>\n<li><p>设置Aware依赖</p>\n<p>容器根据Aware接口，对Bean实例设置相应属性</p>\n</li>\n<li><p>BeanPostProcessor</p>\n<p>一般用于筛选bean，对bean实例化过程扩展，AOP更多在此生成代理对象</p>\n<p>ApplicationContext在此阶段设置Aware依赖</p>\n</li>\n</ol>\n"},{"title":"Lambda表达式","date":"2017-01-15T18:39:56.000Z","_content":"\n# Lambda表达式\n\n**Lambda表达式**:一段可以传递的代码\n\nJava8之前不能单纯的传递代码,必须先创建对象,以对象为载体,通过传递对象达到传递代码的目的.\n\n为了简化传递代码，在Java8中引入了对lambda表达式的支持。\n\nLambda表达式中代码的传递是以函数为载体的，一个函数最基本的构成为：\n\n- 函数声明：\n  - 返回值\n  - 函数名\n  - 参数列表\n- 函数体\n\n返回值可以根据函数体的执行结果确定，如果函数只调用一次，那么函数名也可以省略（匿名）。\n\n一个函数就可以概括成参数和函数体（即就是表达式）。\n\n所以Lambda表达式的语法为：`(参数列表声明)->{表达式}`\n\n# 函数式接口\n\n**函数式接口**：只包含一个抽象方法的接口\n\nJava8中lambda表达式能做的唯一一件事：转换函数式接口\n\n如果一个方法的参数为函数式接口的对象，可以使用Lamdba表达式来替代创建函数式接口的对象。\n\n例如：\n\n`Comparator`接口只有`int compare(T o1, T o2);`这一个抽象方法，所以是一个函数式接口。\n\n`Arrays.sort(T[] a, Comparator<? super T> c)`接收`Comparator`的对象，而`c.compare()`函数体内包含实际执行的代码.\n\nJava8之前：\n\n调用`Arrays.sort(T[] a, Comparator<? super T> c)`之前必须先创建`Comparator`接口实例对象。\n\nJava8中lambda表达式对开发人员可以简单理解为：\n\n传入一个lambda表达式，系统会自动创建`Comparator`对象，调用该对象的`compare()`方法时会执行lambda表达式中的代码。\n\n实际的编译，运行过程并不是上面描述的这样，但我们可以简单的这么理解。\n\n实际上lambda表达式依赖了JDK7引入的`invokedynamic`指令，在多数情况下，lambda都拥有比内部类更好的性能。\n\n# 方法引用\n\nLambda表达式的本质是传递函数，如果现有的函数完全能达到我们的需求，我们就可以直接传递函数，这就是方法引用。\n\n方法引用的基本语法：`类/对象::方法`，可能存在的对应关系有：\n\n- 对象：：实例方法\n- 类：：静态方法\n- 类：：实例方法\n\n第三种情况最为特殊，表达的意思是第一个参数作为方法调用的对象。\n\n关于重载方法的问题，根据参数类型自动匹配。\n\n可以作为对象的不仅有普通对象，还有`this`和`super`两个隐含对象。\n\n对构造器则使用`类::new`的形式调用，根据上下文类型信息会比配构造器。\n\n# 变量作用域\n\nlambda表达式不同于函数的地方：\n\n函数是独立的，而lambda包含上下文，lambda可以引用定义它的上下文变量（闭包）。\n\nJava8之前为了实现对上下文的引用，使用的是内部类访问外部的final局部变量，Java8中放宽了这条规则，不要求变量必须使用final声明了，但是仍然要求不改变变量，编译器会对做部分此检查。\n\n如果变量是一个实例变量，编译器无法检查不变性，但是不建议这么使用。\n\nlambda表达式的作用域与嵌套它的上下文环境一样。\n\n在lambda表达式中使用`this`指向的是创建该lambda表达式的方法的对象，这也间接可以说明lambda表达式不是由内部类实现的。\n\n# 默认方法\n\nJava8中允许接口中定义并实现方法，这样的方法称为默认方法。\n\n- 优点：方便的扩展接口方法\n\n  例如为`Collectoin`接口添加一个`forEach`方法，如果没有默认方法的支持，我们需要为每个子类增加对应的实现，这是灾难式的，但默认方法只需要在一个接口中添加就可以了。\n\n- 缺点：方法冲突\n\n  在继承体系中，继承的接口与接口，或接口与类可能实现了相同的方法，造成冲突。\n\n  Java8的规则：\n\n  - 接口与接口的方法冲突：不管有没有接口实现了方法，子类中一律必须重新实现\n  - 接口与类的方法冲突：子类默认继承类的实现方法（类优先）\n\nJava8允许在接口中定义方法可以将原本工具类中的静态方法定义到接口中，避免了接口和工具类的分离。\n\n同时将原本高层的工具类中的方法分散到各个子接口中，可以更清楚的使用类型。\n\n例如：原本定在`Collections`中的`nCopies`方法现在定义在`List`中，写法更加清晰：\n\n之前：`Collections.nCopies(10, \"Hello\");`\n\n现在：`List.nCopies(10, \"Hello\");`\n\n\n","source":"_posts/Lambda表达式.md","raw":"---\ntitle: Lambda表达式\ndate: 2017-01-16 02:39:56\ntags:\n - Java\n - 读书笔记\n - Functional\ncategory: Java\n---\n\n# Lambda表达式\n\n**Lambda表达式**:一段可以传递的代码\n\nJava8之前不能单纯的传递代码,必须先创建对象,以对象为载体,通过传递对象达到传递代码的目的.\n\n为了简化传递代码，在Java8中引入了对lambda表达式的支持。\n\nLambda表达式中代码的传递是以函数为载体的，一个函数最基本的构成为：\n\n- 函数声明：\n  - 返回值\n  - 函数名\n  - 参数列表\n- 函数体\n\n返回值可以根据函数体的执行结果确定，如果函数只调用一次，那么函数名也可以省略（匿名）。\n\n一个函数就可以概括成参数和函数体（即就是表达式）。\n\n所以Lambda表达式的语法为：`(参数列表声明)->{表达式}`\n\n# 函数式接口\n\n**函数式接口**：只包含一个抽象方法的接口\n\nJava8中lambda表达式能做的唯一一件事：转换函数式接口\n\n如果一个方法的参数为函数式接口的对象，可以使用Lamdba表达式来替代创建函数式接口的对象。\n\n例如：\n\n`Comparator`接口只有`int compare(T o1, T o2);`这一个抽象方法，所以是一个函数式接口。\n\n`Arrays.sort(T[] a, Comparator<? super T> c)`接收`Comparator`的对象，而`c.compare()`函数体内包含实际执行的代码.\n\nJava8之前：\n\n调用`Arrays.sort(T[] a, Comparator<? super T> c)`之前必须先创建`Comparator`接口实例对象。\n\nJava8中lambda表达式对开发人员可以简单理解为：\n\n传入一个lambda表达式，系统会自动创建`Comparator`对象，调用该对象的`compare()`方法时会执行lambda表达式中的代码。\n\n实际的编译，运行过程并不是上面描述的这样，但我们可以简单的这么理解。\n\n实际上lambda表达式依赖了JDK7引入的`invokedynamic`指令，在多数情况下，lambda都拥有比内部类更好的性能。\n\n# 方法引用\n\nLambda表达式的本质是传递函数，如果现有的函数完全能达到我们的需求，我们就可以直接传递函数，这就是方法引用。\n\n方法引用的基本语法：`类/对象::方法`，可能存在的对应关系有：\n\n- 对象：：实例方法\n- 类：：静态方法\n- 类：：实例方法\n\n第三种情况最为特殊，表达的意思是第一个参数作为方法调用的对象。\n\n关于重载方法的问题，根据参数类型自动匹配。\n\n可以作为对象的不仅有普通对象，还有`this`和`super`两个隐含对象。\n\n对构造器则使用`类::new`的形式调用，根据上下文类型信息会比配构造器。\n\n# 变量作用域\n\nlambda表达式不同于函数的地方：\n\n函数是独立的，而lambda包含上下文，lambda可以引用定义它的上下文变量（闭包）。\n\nJava8之前为了实现对上下文的引用，使用的是内部类访问外部的final局部变量，Java8中放宽了这条规则，不要求变量必须使用final声明了，但是仍然要求不改变变量，编译器会对做部分此检查。\n\n如果变量是一个实例变量，编译器无法检查不变性，但是不建议这么使用。\n\nlambda表达式的作用域与嵌套它的上下文环境一样。\n\n在lambda表达式中使用`this`指向的是创建该lambda表达式的方法的对象，这也间接可以说明lambda表达式不是由内部类实现的。\n\n# 默认方法\n\nJava8中允许接口中定义并实现方法，这样的方法称为默认方法。\n\n- 优点：方便的扩展接口方法\n\n  例如为`Collectoin`接口添加一个`forEach`方法，如果没有默认方法的支持，我们需要为每个子类增加对应的实现，这是灾难式的，但默认方法只需要在一个接口中添加就可以了。\n\n- 缺点：方法冲突\n\n  在继承体系中，继承的接口与接口，或接口与类可能实现了相同的方法，造成冲突。\n\n  Java8的规则：\n\n  - 接口与接口的方法冲突：不管有没有接口实现了方法，子类中一律必须重新实现\n  - 接口与类的方法冲突：子类默认继承类的实现方法（类优先）\n\nJava8允许在接口中定义方法可以将原本工具类中的静态方法定义到接口中，避免了接口和工具类的分离。\n\n同时将原本高层的工具类中的方法分散到各个子接口中，可以更清楚的使用类型。\n\n例如：原本定在`Collections`中的`nCopies`方法现在定义在`List`中，写法更加清晰：\n\n之前：`Collections.nCopies(10, \"Hello\");`\n\n现在：`List.nCopies(10, \"Hello\");`\n\n\n","slug":"Lambda表达式","published":1,"updated":"2017-01-15T18:42:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gai000eyi2ehp61jf13","content":"<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><p><strong>Lambda表达式</strong>:一段可以传递的代码</p>\n<p>Java8之前不能单纯的传递代码,必须先创建对象,以对象为载体,通过传递对象达到传递代码的目的.</p>\n<p>为了简化传递代码，在Java8中引入了对lambda表达式的支持。</p>\n<p>Lambda表达式中代码的传递是以函数为载体的，一个函数最基本的构成为：</p>\n<ul>\n<li>函数声明：<ul>\n<li>返回值</li>\n<li>函数名</li>\n<li>参数列表</li>\n</ul>\n</li>\n<li>函数体</li>\n</ul>\n<p>返回值可以根据函数体的执行结果确定，如果函数只调用一次，那么函数名也可以省略（匿名）。</p>\n<p>一个函数就可以概括成参数和函数体（即就是表达式）。</p>\n<p>所以Lambda表达式的语法为：<code>(参数列表声明)-&gt;{表达式}</code></p>\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><p><strong>函数式接口</strong>：只包含一个抽象方法的接口</p>\n<p>Java8中lambda表达式能做的唯一一件事：转换函数式接口</p>\n<p>如果一个方法的参数为函数式接口的对象，可以使用Lamdba表达式来替代创建函数式接口的对象。</p>\n<p>例如：</p>\n<p><code>Comparator</code>接口只有<code>int compare(T o1, T o2);</code>这一个抽象方法，所以是一个函数式接口。</p>\n<p><code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>接收<code>Comparator</code>的对象，而<code>c.compare()</code>函数体内包含实际执行的代码.</p>\n<p>Java8之前：</p>\n<p>调用<code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>之前必须先创建<code>Comparator</code>接口实例对象。</p>\n<p>Java8中lambda表达式对开发人员可以简单理解为：</p>\n<p>传入一个lambda表达式，系统会自动创建<code>Comparator</code>对象，调用该对象的<code>compare()</code>方法时会执行lambda表达式中的代码。</p>\n<p>实际的编译，运行过程并不是上面描述的这样，但我们可以简单的这么理解。</p>\n<p>实际上lambda表达式依赖了JDK7引入的<code>invokedynamic</code>指令，在多数情况下，lambda都拥有比内部类更好的性能。</p>\n<h1 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h1><p>Lambda表达式的本质是传递函数，如果现有的函数完全能达到我们的需求，我们就可以直接传递函数，这就是方法引用。</p>\n<p>方法引用的基本语法：<code>类/对象::方法</code>，可能存在的对应关系有：</p>\n<ul>\n<li>对象：：实例方法</li>\n<li>类：：静态方法</li>\n<li>类：：实例方法</li>\n</ul>\n<p>第三种情况最为特殊，表达的意思是第一个参数作为方法调用的对象。</p>\n<p>关于重载方法的问题，根据参数类型自动匹配。</p>\n<p>可以作为对象的不仅有普通对象，还有<code>this</code>和<code>super</code>两个隐含对象。</p>\n<p>对构造器则使用<code>类::new</code>的形式调用，根据上下文类型信息会比配构造器。</p>\n<h1 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h1><p>lambda表达式不同于函数的地方：</p>\n<p>函数是独立的，而lambda包含上下文，lambda可以引用定义它的上下文变量（闭包）。</p>\n<p>Java8之前为了实现对上下文的引用，使用的是内部类访问外部的final局部变量，Java8中放宽了这条规则，不要求变量必须使用final声明了，但是仍然要求不改变变量，编译器会对做部分此检查。</p>\n<p>如果变量是一个实例变量，编译器无法检查不变性，但是不建议这么使用。</p>\n<p>lambda表达式的作用域与嵌套它的上下文环境一样。</p>\n<p>在lambda表达式中使用<code>this</code>指向的是创建该lambda表达式的方法的对象，这也间接可以说明lambda表达式不是由内部类实现的。</p>\n<h1 id=\"默认方法\"><a href=\"#默认方法\" class=\"headerlink\" title=\"默认方法\"></a>默认方法</h1><p>Java8中允许接口中定义并实现方法，这样的方法称为默认方法。</p>\n<ul>\n<li><p>优点：方便的扩展接口方法</p>\n<p>例如为<code>Collectoin</code>接口添加一个<code>forEach</code>方法，如果没有默认方法的支持，我们需要为每个子类增加对应的实现，这是灾难式的，但默认方法只需要在一个接口中添加就可以了。</p>\n</li>\n<li><p>缺点：方法冲突</p>\n<p>在继承体系中，继承的接口与接口，或接口与类可能实现了相同的方法，造成冲突。</p>\n<p>Java8的规则：</p>\n<ul>\n<li>接口与接口的方法冲突：不管有没有接口实现了方法，子类中一律必须重新实现</li>\n<li>接口与类的方法冲突：子类默认继承类的实现方法（类优先）</li>\n</ul>\n</li>\n</ul>\n<p>Java8允许在接口中定义方法可以将原本工具类中的静态方法定义到接口中，避免了接口和工具类的分离。</p>\n<p>同时将原本高层的工具类中的方法分散到各个子接口中，可以更清楚的使用类型。</p>\n<p>例如：原本定在<code>Collections</code>中的<code>nCopies</code>方法现在定义在<code>List</code>中，写法更加清晰：</p>\n<p>之前：<code>Collections.nCopies(10, &quot;Hello&quot;);</code></p>\n<p>现在：<code>List.nCopies(10, &quot;Hello&quot;);</code></p>\n","excerpt":"","more":"<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><p><strong>Lambda表达式</strong>:一段可以传递的代码</p>\n<p>Java8之前不能单纯的传递代码,必须先创建对象,以对象为载体,通过传递对象达到传递代码的目的.</p>\n<p>为了简化传递代码，在Java8中引入了对lambda表达式的支持。</p>\n<p>Lambda表达式中代码的传递是以函数为载体的，一个函数最基本的构成为：</p>\n<ul>\n<li>函数声明：<ul>\n<li>返回值</li>\n<li>函数名</li>\n<li>参数列表</li>\n</ul>\n</li>\n<li>函数体</li>\n</ul>\n<p>返回值可以根据函数体的执行结果确定，如果函数只调用一次，那么函数名也可以省略（匿名）。</p>\n<p>一个函数就可以概括成参数和函数体（即就是表达式）。</p>\n<p>所以Lambda表达式的语法为：<code>(参数列表声明)-&gt;{表达式}</code></p>\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><p><strong>函数式接口</strong>：只包含一个抽象方法的接口</p>\n<p>Java8中lambda表达式能做的唯一一件事：转换函数式接口</p>\n<p>如果一个方法的参数为函数式接口的对象，可以使用Lamdba表达式来替代创建函数式接口的对象。</p>\n<p>例如：</p>\n<p><code>Comparator</code>接口只有<code>int compare(T o1, T o2);</code>这一个抽象方法，所以是一个函数式接口。</p>\n<p><code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>接收<code>Comparator</code>的对象，而<code>c.compare()</code>函数体内包含实际执行的代码.</p>\n<p>Java8之前：</p>\n<p>调用<code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>之前必须先创建<code>Comparator</code>接口实例对象。</p>\n<p>Java8中lambda表达式对开发人员可以简单理解为：</p>\n<p>传入一个lambda表达式，系统会自动创建<code>Comparator</code>对象，调用该对象的<code>compare()</code>方法时会执行lambda表达式中的代码。</p>\n<p>实际的编译，运行过程并不是上面描述的这样，但我们可以简单的这么理解。</p>\n<p>实际上lambda表达式依赖了JDK7引入的<code>invokedynamic</code>指令，在多数情况下，lambda都拥有比内部类更好的性能。</p>\n<h1 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h1><p>Lambda表达式的本质是传递函数，如果现有的函数完全能达到我们的需求，我们就可以直接传递函数，这就是方法引用。</p>\n<p>方法引用的基本语法：<code>类/对象::方法</code>，可能存在的对应关系有：</p>\n<ul>\n<li>对象：：实例方法</li>\n<li>类：：静态方法</li>\n<li>类：：实例方法</li>\n</ul>\n<p>第三种情况最为特殊，表达的意思是第一个参数作为方法调用的对象。</p>\n<p>关于重载方法的问题，根据参数类型自动匹配。</p>\n<p>可以作为对象的不仅有普通对象，还有<code>this</code>和<code>super</code>两个隐含对象。</p>\n<p>对构造器则使用<code>类::new</code>的形式调用，根据上下文类型信息会比配构造器。</p>\n<h1 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h1><p>lambda表达式不同于函数的地方：</p>\n<p>函数是独立的，而lambda包含上下文，lambda可以引用定义它的上下文变量（闭包）。</p>\n<p>Java8之前为了实现对上下文的引用，使用的是内部类访问外部的final局部变量，Java8中放宽了这条规则，不要求变量必须使用final声明了，但是仍然要求不改变变量，编译器会对做部分此检查。</p>\n<p>如果变量是一个实例变量，编译器无法检查不变性，但是不建议这么使用。</p>\n<p>lambda表达式的作用域与嵌套它的上下文环境一样。</p>\n<p>在lambda表达式中使用<code>this</code>指向的是创建该lambda表达式的方法的对象，这也间接可以说明lambda表达式不是由内部类实现的。</p>\n<h1 id=\"默认方法\"><a href=\"#默认方法\" class=\"headerlink\" title=\"默认方法\"></a>默认方法</h1><p>Java8中允许接口中定义并实现方法，这样的方法称为默认方法。</p>\n<ul>\n<li><p>优点：方便的扩展接口方法</p>\n<p>例如为<code>Collectoin</code>接口添加一个<code>forEach</code>方法，如果没有默认方法的支持，我们需要为每个子类增加对应的实现，这是灾难式的，但默认方法只需要在一个接口中添加就可以了。</p>\n</li>\n<li><p>缺点：方法冲突</p>\n<p>在继承体系中，继承的接口与接口，或接口与类可能实现了相同的方法，造成冲突。</p>\n<p>Java8的规则：</p>\n<ul>\n<li>接口与接口的方法冲突：不管有没有接口实现了方法，子类中一律必须重新实现</li>\n<li>接口与类的方法冲突：子类默认继承类的实现方法（类优先）</li>\n</ul>\n</li>\n</ul>\n<p>Java8允许在接口中定义方法可以将原本工具类中的静态方法定义到接口中，避免了接口和工具类的分离。</p>\n<p>同时将原本高层的工具类中的方法分散到各个子接口中，可以更清楚的使用类型。</p>\n<p>例如：原本定在<code>Collections</code>中的<code>nCopies</code>方法现在定义在<code>List</code>中，写法更加清晰：</p>\n<p>之前：<code>Collections.nCopies(10, &quot;Hello&quot;);</code></p>\n<p>现在：<code>List.nCopies(10, &quot;Hello&quot;);</code></p>\n"},{"title":"《Java并发编程实战》读书笔记","date":"2016-09-29T05:14:27.000Z","_content":"右键->新标签页中打开图片->放大预览\n![Java并发编程实战.png](https://ooo.0o0.ooo/2016/09/29/57eca40868441.png)\n","source":"_posts/《Java并发编程实战》读书笔记.md","raw":"---\ntitle: 《Java并发编程实战》读书笔记\ndate: 2016-09-29 13:14:27\ntags:\n  - Java\ncategories: 读书笔记\n---\n右键->新标签页中打开图片->放大预览\n![Java并发编程实战.png](https://ooo.0o0.ooo/2016/09/29/57eca40868441.png)\n","slug":"《Java并发编程实战》读书笔记","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gal000hyi2e1ol42g31","content":"<p>右键-&gt;新标签页中打开图片-&gt;放大预览<br><img src=\"https://ooo.0o0.ooo/2016/09/29/57eca40868441.png\" alt=\"Java并发编程实战.png\"></p>\n","excerpt":"","more":"<p>右键-&gt;新标签页中打开图片-&gt;放大预览<br><img src=\"https://ooo.0o0.ooo/2016/09/29/57eca40868441.png\" alt=\"Java并发编程实战.png\"></p>\n"},{"title":"《函数式编程思维》读书笔记","date":"2016-08-27T14:20:48.000Z","_content":"\n![函数式编程思维.png](http://i2.buimg.com/4851/efe49260863d5566.png)","source":"_posts/《函数式编程思维》读书笔记.md","raw":"---\ntitle: 《函数式编程思维》读书笔记\ndate: 2016-08-27 22:20:48\ntags:\n  - Functional\ncategories: 读书笔记\n---\n\n![函数式编程思维.png](http://i2.buimg.com/4851/efe49260863d5566.png)","slug":"《函数式编程思维》读书笔记","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gap000myi2e0v8x6u7f","content":"<p><img src=\"http://i2.buimg.com/4851/efe49260863d5566.png\" alt=\"函数式编程思维.png\"></p>\n","excerpt":"","more":"<p><img src=\"http://i2.buimg.com/4851/efe49260863d5566.png\" alt=\"函数式编程思维.png\"></p>\n"},{"title":"【翻译】《OSGI官方指南》首页","date":"2017-01-25T01:58:59.000Z","_content":"\n说明：本翻译原计划发布于并发编程网，但因个人原因拖延，导致其他网友先于发布，在此仅作记录。督促自己改善拖延问题。\n\n---\n\n# 开发者\n\n开始OSGI之旅，你将得到：复用组件构建管理高度复杂的系统，让编写代码更容易，管理动态部署，更早的发现错误，远程部署，发现并解决你现在可以不知道的问题。\n\n如果你正在使用Java开发软件，OSGi应该在你的工具箱。\n\n## 为什么选择OSGi\n\nOSGI提供一个模块化构建用方式用于现代大规模分布式系统以及小型系统，嵌入式应用和设备网络。从内部和现成模块构建的系统明显增加了软件产品和解决方案的复用，并延长了其生命周期，减小了开发和维护的费用。OSGi编程模型确保实现基于组件的系统。\n\nOSGi技术是成功的，因为它提供了一个非常成熟的组件系统，并在大量的环境中使用。OSGi组件系统被用于构建高度复杂的应用程序，例如IDE，应用服务器，应用程序框架，电信和服务解决方案，工业自动化，住宅网关，车载远程信息处理系统等。\n\n## 为OSGi工作\n\n垂直和跨行业需要“专家组”提供定制，以不影响OSGi服务平台架构的完整性。当前专家组包括企业专家组，住宅专家组和核心平台专家组。成员在OSGi董事会批准的情况下提议并建立新EG的章程。\n\n你希望OSGi使用你的协议吗？作为会员的好处，OSGi成员有资格为新协议创建[规范](https://www.osgi.org/developer/specifications/)。专家组正在开发OSGi设备抽象层，以扩展OSGi的覆盖范围，与其他行业联盟合作。成员正在致力于物联网和云计算。 那么你对OSGi的议程是什么？\n\n## 开始\n\n联盟提供了许多资源来探索OSGi，并开始在您的开发项目中使用OSGi。[enRoute](https://www.osgi.org/enroute/)是一个实用和高效的资源用于构建和实现模块化应用程序。\n\n## 认证\n证明您的OSGi专业知识。获得认证。 OSGi成员提供培训课程，联盟提供[OSGi认证](https://www.osgi.org/osgi-certification/developer-certification/)测试。\n","source":"_posts/【翻译】《OSGI官方指南》首页.md","raw":"---\ntitle: 【翻译】《OSGI官方指南》首页\ndate: 2017-01-25 09:58:59\ntags:\n  - 翻译\ncategories: 翻译\n---\n\n说明：本翻译原计划发布于并发编程网，但因个人原因拖延，导致其他网友先于发布，在此仅作记录。督促自己改善拖延问题。\n\n---\n\n# 开发者\n\n开始OSGI之旅，你将得到：复用组件构建管理高度复杂的系统，让编写代码更容易，管理动态部署，更早的发现错误，远程部署，发现并解决你现在可以不知道的问题。\n\n如果你正在使用Java开发软件，OSGi应该在你的工具箱。\n\n## 为什么选择OSGi\n\nOSGI提供一个模块化构建用方式用于现代大规模分布式系统以及小型系统，嵌入式应用和设备网络。从内部和现成模块构建的系统明显增加了软件产品和解决方案的复用，并延长了其生命周期，减小了开发和维护的费用。OSGi编程模型确保实现基于组件的系统。\n\nOSGi技术是成功的，因为它提供了一个非常成熟的组件系统，并在大量的环境中使用。OSGi组件系统被用于构建高度复杂的应用程序，例如IDE，应用服务器，应用程序框架，电信和服务解决方案，工业自动化，住宅网关，车载远程信息处理系统等。\n\n## 为OSGi工作\n\n垂直和跨行业需要“专家组”提供定制，以不影响OSGi服务平台架构的完整性。当前专家组包括企业专家组，住宅专家组和核心平台专家组。成员在OSGi董事会批准的情况下提议并建立新EG的章程。\n\n你希望OSGi使用你的协议吗？作为会员的好处，OSGi成员有资格为新协议创建[规范](https://www.osgi.org/developer/specifications/)。专家组正在开发OSGi设备抽象层，以扩展OSGi的覆盖范围，与其他行业联盟合作。成员正在致力于物联网和云计算。 那么你对OSGi的议程是什么？\n\n## 开始\n\n联盟提供了许多资源来探索OSGi，并开始在您的开发项目中使用OSGi。[enRoute](https://www.osgi.org/enroute/)是一个实用和高效的资源用于构建和实现模块化应用程序。\n\n## 认证\n证明您的OSGi专业知识。获得认证。 OSGi成员提供培训课程，联盟提供[OSGi认证](https://www.osgi.org/osgi-certification/developer-certification/)测试。\n","slug":"【翻译】《OSGI官方指南》首页","published":1,"updated":"2017-01-25T02:06:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gar000pyi2errvix1fn","content":"<p>说明：本翻译原计划发布于并发编程网，但因个人原因拖延，导致其他网友先于发布，在此仅作记录。督促自己改善拖延问题。</p>\n<hr>\n<h1 id=\"开发者\"><a href=\"#开发者\" class=\"headerlink\" title=\"开发者\"></a>开发者</h1><p>开始OSGI之旅，你将得到：复用组件构建管理高度复杂的系统，让编写代码更容易，管理动态部署，更早的发现错误，远程部署，发现并解决你现在可以不知道的问题。</p>\n<p>如果你正在使用Java开发软件，OSGi应该在你的工具箱。</p>\n<h2 id=\"为什么选择OSGi\"><a href=\"#为什么选择OSGi\" class=\"headerlink\" title=\"为什么选择OSGi\"></a>为什么选择OSGi</h2><p>OSGI提供一个模块化构建用方式用于现代大规模分布式系统以及小型系统，嵌入式应用和设备网络。从内部和现成模块构建的系统明显增加了软件产品和解决方案的复用，并延长了其生命周期，减小了开发和维护的费用。OSGi编程模型确保实现基于组件的系统。</p>\n<p>OSGi技术是成功的，因为它提供了一个非常成熟的组件系统，并在大量的环境中使用。OSGi组件系统被用于构建高度复杂的应用程序，例如IDE，应用服务器，应用程序框架，电信和服务解决方案，工业自动化，住宅网关，车载远程信息处理系统等。</p>\n<h2 id=\"为OSGi工作\"><a href=\"#为OSGi工作\" class=\"headerlink\" title=\"为OSGi工作\"></a>为OSGi工作</h2><p>垂直和跨行业需要“专家组”提供定制，以不影响OSGi服务平台架构的完整性。当前专家组包括企业专家组，住宅专家组和核心平台专家组。成员在OSGi董事会批准的情况下提议并建立新EG的章程。</p>\n<p>你希望OSGi使用你的协议吗？作为会员的好处，OSGi成员有资格为新协议创建<a href=\"https://www.osgi.org/developer/specifications/\" target=\"_blank\" rel=\"external\">规范</a>。专家组正在开发OSGi设备抽象层，以扩展OSGi的覆盖范围，与其他行业联盟合作。成员正在致力于物联网和云计算。 那么你对OSGi的议程是什么？</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>联盟提供了许多资源来探索OSGi，并开始在您的开发项目中使用OSGi。<a href=\"https://www.osgi.org/enroute/\" target=\"_blank\" rel=\"external\">enRoute</a>是一个实用和高效的资源用于构建和实现模块化应用程序。</p>\n<h2 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h2><p>证明您的OSGi专业知识。获得认证。 OSGi成员提供培训课程，联盟提供<a href=\"https://www.osgi.org/osgi-certification/developer-certification/\" target=\"_blank\" rel=\"external\">OSGi认证</a>测试。</p>\n","excerpt":"","more":"<p>说明：本翻译原计划发布于并发编程网，但因个人原因拖延，导致其他网友先于发布，在此仅作记录。督促自己改善拖延问题。</p>\n<hr>\n<h1 id=\"开发者\"><a href=\"#开发者\" class=\"headerlink\" title=\"开发者\"></a>开发者</h1><p>开始OSGI之旅，你将得到：复用组件构建管理高度复杂的系统，让编写代码更容易，管理动态部署，更早的发现错误，远程部署，发现并解决你现在可以不知道的问题。</p>\n<p>如果你正在使用Java开发软件，OSGi应该在你的工具箱。</p>\n<h2 id=\"为什么选择OSGi\"><a href=\"#为什么选择OSGi\" class=\"headerlink\" title=\"为什么选择OSGi\"></a>为什么选择OSGi</h2><p>OSGI提供一个模块化构建用方式用于现代大规模分布式系统以及小型系统，嵌入式应用和设备网络。从内部和现成模块构建的系统明显增加了软件产品和解决方案的复用，并延长了其生命周期，减小了开发和维护的费用。OSGi编程模型确保实现基于组件的系统。</p>\n<p>OSGi技术是成功的，因为它提供了一个非常成熟的组件系统，并在大量的环境中使用。OSGi组件系统被用于构建高度复杂的应用程序，例如IDE，应用服务器，应用程序框架，电信和服务解决方案，工业自动化，住宅网关，车载远程信息处理系统等。</p>\n<h2 id=\"为OSGi工作\"><a href=\"#为OSGi工作\" class=\"headerlink\" title=\"为OSGi工作\"></a>为OSGi工作</h2><p>垂直和跨行业需要“专家组”提供定制，以不影响OSGi服务平台架构的完整性。当前专家组包括企业专家组，住宅专家组和核心平台专家组。成员在OSGi董事会批准的情况下提议并建立新EG的章程。</p>\n<p>你希望OSGi使用你的协议吗？作为会员的好处，OSGi成员有资格为新协议创建<a href=\"https://www.osgi.org/developer/specifications/\">规范</a>。专家组正在开发OSGi设备抽象层，以扩展OSGi的覆盖范围，与其他行业联盟合作。成员正在致力于物联网和云计算。 那么你对OSGi的议程是什么？</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>联盟提供了许多资源来探索OSGi，并开始在您的开发项目中使用OSGi。<a href=\"https://www.osgi.org/enroute/\">enRoute</a>是一个实用和高效的资源用于构建和实现模块化应用程序。</p>\n<h2 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h2><p>证明您的OSGi专业知识。获得认证。 OSGi成员提供培训课程，联盟提供<a href=\"https://www.osgi.org/osgi-certification/developer-certification/\">OSGi认证</a>测试。</p>\n"},{"title":"ThreadLocal小记","date":"2016-09-11T11:33:39.000Z","_content":"\n# ThreadLocal\n\n最近《Java并发编程实战》第三章谈及了对象共享的问题。对共享的可变数据最简单粗暴的做法当然是同步，但是同步的缺点也很明显，代码复杂可维护性降低。针对这个问题，书上谈及到了通过线程封闭避免同步，其中的ThreadLocal类就是帮助维持线程封闭性的。\n\n之前对ThreadLocal的认识非常简单，就是把一个变量绑定到线程上。参照网上的例子自己也实现了类似功能的例子ThreadLocalVariable(https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。\n\n看JDK之前想当然的以为ThreadLocal应该就是简单对`Map<Thread, Object>`做一个封装，然而实际并没有这么简单。参照了网上一些文章的说法，早期的ThreadLocal确实是这样实现的。但是这样实现存在一些问题：\n\n1. 线程安全问题，如果使用线程安全的Map实现那么就会带来性能问题，当有大量的线程使用ThreadLocal，伴随着线程生命周期ThreadLocal也需要频繁向底层的Map添加删除数据。\n2. 内存回收问题，用Thread当key，除非手动调用remove，否则即使线程退出了会导致：1)该Thread对象无法回收；2)该线程在所有ThreadLocal中对应的value也无法回收。\n\nThreadLocal实际给出了不同的实现方式。首先绑定到线程的变量没有维护在ThreadLocal内，而是维护在各个Thread类实例内——在Thread类内使用了ThreadLocal的静态内部类`ThreadLocalMap`实例去维护需要绑定到线程的变量。这样原本需要维护在ThreadLocal内的数据现在就分散到了各个线程内去维护。\n\n\n\n在Thread中ThreadLocalMap的声明长这样：\n\n```java\n// 真的就只是声明了一下，什么都没干    \nThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n\n\nThreadLocal一共只有五个非私有的方法，首先是两个并没有什么卵用的方法：\n\n```java\n// 构造，什么都没干\npublic ThreadLocal() {}\n\n// 设置ThreadLocal的初始值，protected很明显是希望子类重写\nprotected T initialValue() {return null}\n```\n\n看看其余三个方法的实现（JDK8）\n\n```java\n    public T get() {\n        Thread t = Thread.currentThread();\n        // 从线程里获取ThreadLocalMap\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            // 根据ThreadLocal实例获取Entity\n            // 一会看ThreadLocal的实现\n            // 暂时可以看做类似Map<ThreadLocal,Object>\n            // 注意key类型是ThreadLocal，不是Thread\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        // 如果获得的map为null或者从map通过key获取的value为空时获取一个初始值\n        // setInitialValue方法里调用了initialValue方法\n        // 宝宝不管，反正宝宝想要有值，宝宝不想为null\n        return setInitialValue();\n    }\n\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            // 没什么说的set进去\n            map.set(this, value);\n        else\n            // 当map不存在时，使用初始值创建一个\n            createMap(t, value);\n    }\n\n     public void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             // 没什么说的，remove掉\n             m.remove(this);\n     }\n    \n    ThreadLocalMap getMap(Thread t) {\n        // 你给我一个线程，我换你一个map\n        return t.threadLocals;\n    }\n```\nThreadLocal所有的操作都是围绕着内部类ThreadLocalMap的，ThreadLocal只是让ThreadLocalMap更加容易访问。咦，有点耳熟，没错外观模式。\n\n下面看一下ThreadLocal的静态内部类ThreadLocalMap，JDK文档对它的描述主要集中在一下几点：\n\n1. 是什么：定制的hash map用于维护本地线程变量\n2. 可见性：ThreadLocal之外没有任何方法可访问，Thread类使用它定义了私有属性\n3. 特殊性：为了管理大对象、长生命周期对象，使用WeakReference包装ThreadLocal对象作为key\n\n前面两点没什么好说的，主要是第三点：key使用了弱引用类型管理（关于弱引用可以先参考https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。\n\n![image](http://img.blog.csdn.net/20160121000731607)\n\n图片来自互联网，实线表示强引用，虚线表示弱引用。\n\n简而言之，一个对象在没有强引用引用，只有弱引用引用时，当GC发生这个对象就会被标记回收。将ThreadLocal对象设置成弱引用作为key的好处是显而易见：当ThreadLocal没有任何强引用引用时，只有ThreadLocalMap的Entry对它存在弱引用，这样GC的时候这个ThreadLocal对象就可以被回收了。但是这又带来了一个问题：Entry的key可能被回收了，但留下了一个并没有什么卵用的value。只要线程生命周期不结束，那么这个value对象始终保持了一个强引用链条：\n\nThread Ref -> Thread -> ThreadLocalMap -> Entry -> value\n\n当内存有大量驻留的线程时，因为强引用存在，GC始终无法回收，就导致了内存泄漏。\n\n真对这个问题ThreadLocalMap在实现的时候也采取了一些防护措施，比如ThreadLocalMap的get（set，remove方法也类似，限于篇幅不展开了）：\n\n```java\n    private Entry getEntry(ThreadLocal<?> key) {\n        // hash函数获取索引位置\n        int i = key.threadLocalHashCode & (table.length - 1);\n        Entry e = table[i];\n        if (e != null && e.get() == key)\n            // 命中了\n            return e;\n        else\n            // miss了\n            return getEntryAfterMiss(key, i, e);\n    }\n\n    private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n        Entry[] tab = table;\n        int len = tab.length;\n\t\t\n        // 遍历table\n        while (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == key)\n                // 找到了\n                return e;\n            if (k == null)\n                // 发现key为空（也就是上面描述的内存泄漏的情况），做删除\n                expungeStaleEntry(i);\n            else\n                // 找下一个Entty位置\n                i = nextIndex(i, len);\n            e = tab[i];\n        }\n        return null;\n    }\n```\n\n在get的过程中凡是碰到了key为null的Entry，这个Entry就会被擦除，从而避免内存泄漏。类似的思路在set，remove方法中都有实现。针对内存泄漏问题ThreadLocal实际是需要手动触发函数删除key为null的Entry，所以当不要再需要一个变量当定到线程时手动的remove还是很有必要的。\n\n\n\n最后，在网上看到对ThreadLocal有多种说法：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。\n\n关于第一种说法我觉得是部分正确的，ThreadLocal将需要共享的对象封闭在了线程内确实解决了并发的一部分问题，但并不是万能的。比如重写initialValue方法时返回的是一个全局共享的对象，那实际上ThreadLocal只是把这个全局共享的对象又封装到了Thread对象里，ThreadLocal本身并没有做类似深拷贝的操作，因此这个变量依然是线程不安全的（逸出）。\n\n关于第二种说法，我觉得问题就比较大了。ThreadLocal根本不是为了线程间共享，实际是为了将状态封闭在线程内以确保线程安全。这样做确实带来了访问共享状态的便利，但这个状态的共享是在单个线程内的，而不是线程之间的。比如在action中将session对象绑定在线程内，在service、dao里都可以方便的共享，但所有的共享都是在单个的线程内部，而不是在多个的线程之间共享。\n\n\n\n参考资料：\n\n《Java并发编程实战》\n\nJDK8帮助手册\n\nhttp://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/\n\nhttp://my.oschina.net/xianggao/blog/392440#navbar-header\n","source":"_posts/ThreadLocal小记.md","raw":"---\ntitle: ThreadLocal小记\ndate: 2016-09-11 19:33:39\ntags: Java\ncategories: Java\n---\n\n# ThreadLocal\n\n最近《Java并发编程实战》第三章谈及了对象共享的问题。对共享的可变数据最简单粗暴的做法当然是同步，但是同步的缺点也很明显，代码复杂可维护性降低。针对这个问题，书上谈及到了通过线程封闭避免同步，其中的ThreadLocal类就是帮助维持线程封闭性的。\n\n之前对ThreadLocal的认识非常简单，就是把一个变量绑定到线程上。参照网上的例子自己也实现了类似功能的例子ThreadLocalVariable(https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。\n\n看JDK之前想当然的以为ThreadLocal应该就是简单对`Map<Thread, Object>`做一个封装，然而实际并没有这么简单。参照了网上一些文章的说法，早期的ThreadLocal确实是这样实现的。但是这样实现存在一些问题：\n\n1. 线程安全问题，如果使用线程安全的Map实现那么就会带来性能问题，当有大量的线程使用ThreadLocal，伴随着线程生命周期ThreadLocal也需要频繁向底层的Map添加删除数据。\n2. 内存回收问题，用Thread当key，除非手动调用remove，否则即使线程退出了会导致：1)该Thread对象无法回收；2)该线程在所有ThreadLocal中对应的value也无法回收。\n\nThreadLocal实际给出了不同的实现方式。首先绑定到线程的变量没有维护在ThreadLocal内，而是维护在各个Thread类实例内——在Thread类内使用了ThreadLocal的静态内部类`ThreadLocalMap`实例去维护需要绑定到线程的变量。这样原本需要维护在ThreadLocal内的数据现在就分散到了各个线程内去维护。\n\n\n\n在Thread中ThreadLocalMap的声明长这样：\n\n```java\n// 真的就只是声明了一下，什么都没干    \nThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n\n\nThreadLocal一共只有五个非私有的方法，首先是两个并没有什么卵用的方法：\n\n```java\n// 构造，什么都没干\npublic ThreadLocal() {}\n\n// 设置ThreadLocal的初始值，protected很明显是希望子类重写\nprotected T initialValue() {return null}\n```\n\n看看其余三个方法的实现（JDK8）\n\n```java\n    public T get() {\n        Thread t = Thread.currentThread();\n        // 从线程里获取ThreadLocalMap\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            // 根据ThreadLocal实例获取Entity\n            // 一会看ThreadLocal的实现\n            // 暂时可以看做类似Map<ThreadLocal,Object>\n            // 注意key类型是ThreadLocal，不是Thread\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        // 如果获得的map为null或者从map通过key获取的value为空时获取一个初始值\n        // setInitialValue方法里调用了initialValue方法\n        // 宝宝不管，反正宝宝想要有值，宝宝不想为null\n        return setInitialValue();\n    }\n\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            // 没什么说的set进去\n            map.set(this, value);\n        else\n            // 当map不存在时，使用初始值创建一个\n            createMap(t, value);\n    }\n\n     public void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             // 没什么说的，remove掉\n             m.remove(this);\n     }\n    \n    ThreadLocalMap getMap(Thread t) {\n        // 你给我一个线程，我换你一个map\n        return t.threadLocals;\n    }\n```\nThreadLocal所有的操作都是围绕着内部类ThreadLocalMap的，ThreadLocal只是让ThreadLocalMap更加容易访问。咦，有点耳熟，没错外观模式。\n\n下面看一下ThreadLocal的静态内部类ThreadLocalMap，JDK文档对它的描述主要集中在一下几点：\n\n1. 是什么：定制的hash map用于维护本地线程变量\n2. 可见性：ThreadLocal之外没有任何方法可访问，Thread类使用它定义了私有属性\n3. 特殊性：为了管理大对象、长生命周期对象，使用WeakReference包装ThreadLocal对象作为key\n\n前面两点没什么好说的，主要是第三点：key使用了弱引用类型管理（关于弱引用可以先参考https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。\n\n![image](http://img.blog.csdn.net/20160121000731607)\n\n图片来自互联网，实线表示强引用，虚线表示弱引用。\n\n简而言之，一个对象在没有强引用引用，只有弱引用引用时，当GC发生这个对象就会被标记回收。将ThreadLocal对象设置成弱引用作为key的好处是显而易见：当ThreadLocal没有任何强引用引用时，只有ThreadLocalMap的Entry对它存在弱引用，这样GC的时候这个ThreadLocal对象就可以被回收了。但是这又带来了一个问题：Entry的key可能被回收了，但留下了一个并没有什么卵用的value。只要线程生命周期不结束，那么这个value对象始终保持了一个强引用链条：\n\nThread Ref -> Thread -> ThreadLocalMap -> Entry -> value\n\n当内存有大量驻留的线程时，因为强引用存在，GC始终无法回收，就导致了内存泄漏。\n\n真对这个问题ThreadLocalMap在实现的时候也采取了一些防护措施，比如ThreadLocalMap的get（set，remove方法也类似，限于篇幅不展开了）：\n\n```java\n    private Entry getEntry(ThreadLocal<?> key) {\n        // hash函数获取索引位置\n        int i = key.threadLocalHashCode & (table.length - 1);\n        Entry e = table[i];\n        if (e != null && e.get() == key)\n            // 命中了\n            return e;\n        else\n            // miss了\n            return getEntryAfterMiss(key, i, e);\n    }\n\n    private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n        Entry[] tab = table;\n        int len = tab.length;\n\t\t\n        // 遍历table\n        while (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == key)\n                // 找到了\n                return e;\n            if (k == null)\n                // 发现key为空（也就是上面描述的内存泄漏的情况），做删除\n                expungeStaleEntry(i);\n            else\n                // 找下一个Entty位置\n                i = nextIndex(i, len);\n            e = tab[i];\n        }\n        return null;\n    }\n```\n\n在get的过程中凡是碰到了key为null的Entry，这个Entry就会被擦除，从而避免内存泄漏。类似的思路在set，remove方法中都有实现。针对内存泄漏问题ThreadLocal实际是需要手动触发函数删除key为null的Entry，所以当不要再需要一个变量当定到线程时手动的remove还是很有必要的。\n\n\n\n最后，在网上看到对ThreadLocal有多种说法：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。\n\n关于第一种说法我觉得是部分正确的，ThreadLocal将需要共享的对象封闭在了线程内确实解决了并发的一部分问题，但并不是万能的。比如重写initialValue方法时返回的是一个全局共享的对象，那实际上ThreadLocal只是把这个全局共享的对象又封装到了Thread对象里，ThreadLocal本身并没有做类似深拷贝的操作，因此这个变量依然是线程不安全的（逸出）。\n\n关于第二种说法，我觉得问题就比较大了。ThreadLocal根本不是为了线程间共享，实际是为了将状态封闭在线程内以确保线程安全。这样做确实带来了访问共享状态的便利，但这个状态的共享是在单个线程内的，而不是线程之间的。比如在action中将session对象绑定在线程内，在service、dao里都可以方便的共享，但所有的共享都是在单个的线程内部，而不是在多个的线程之间共享。\n\n\n\n参考资料：\n\n《Java并发编程实战》\n\nJDK8帮助手册\n\nhttp://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/\n\nhttp://my.oschina.net/xianggao/blog/392440#navbar-header\n","slug":"ThreadLocal小记","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gav000tyi2e5jkvruge","content":"<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><p>最近《Java并发编程实战》第三章谈及了对象共享的问题。对共享的可变数据最简单粗暴的做法当然是同步，但是同步的缺点也很明显，代码复杂可维护性降低。针对这个问题，书上谈及到了通过线程封闭避免同步，其中的ThreadLocal类就是帮助维持线程封闭性的。</p>\n<p>之前对ThreadLocal的认识非常简单，就是把一个变量绑定到线程上。参照网上的例子自己也实现了类似功能的例子ThreadLocalVariable(<a href=\"https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。\" target=\"_blank\" rel=\"external\">https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。</a></p>\n<p>看JDK之前想当然的以为ThreadLocal应该就是简单对<code>Map&lt;Thread, Object&gt;</code>做一个封装，然而实际并没有这么简单。参照了网上一些文章的说法，早期的ThreadLocal确实是这样实现的。但是这样实现存在一些问题：</p>\n<ol>\n<li>线程安全问题，如果使用线程安全的Map实现那么就会带来性能问题，当有大量的线程使用ThreadLocal，伴随着线程生命周期ThreadLocal也需要频繁向底层的Map添加删除数据。</li>\n<li>内存回收问题，用Thread当key，除非手动调用remove，否则即使线程退出了会导致：1)该Thread对象无法回收；2)该线程在所有ThreadLocal中对应的value也无法回收。</li>\n</ol>\n<p>ThreadLocal实际给出了不同的实现方式。首先绑定到线程的变量没有维护在ThreadLocal内，而是维护在各个Thread类实例内——在Thread类内使用了ThreadLocal的静态内部类<code>ThreadLocalMap</code>实例去维护需要绑定到线程的变量。这样原本需要维护在ThreadLocal内的数据现在就分散到了各个线程内去维护。</p>\n<p>在Thread中ThreadLocalMap的声明长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 真的就只是声明了一下，什么都没干    </span></div><div class=\"line\">ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</div></pre></td></tr></table></figure>\n<p>ThreadLocal一共只有五个非私有的方法，首先是两个并没有什么卵用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 构造，什么都没干</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadLocal</span><span class=\"params\">()</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置ThreadLocal的初始值，protected很明显是希望子类重写</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>&#125;</div></pre></td></tr></table></figure>\n<p>看看其余三个方法的实现（JDK8）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Thread t = Thread.currentThread();</div><div class=\"line\">    <span class=\"comment\">// 从线程里获取ThreadLocalMap</span></div><div class=\"line\">    ThreadLocalMap map = getMap(t);</div><div class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 根据ThreadLocal实例获取Entity</span></div><div class=\"line\">        <span class=\"comment\">// 一会看ThreadLocal的实现</span></div><div class=\"line\">        <span class=\"comment\">// 暂时可以看做类似Map&lt;ThreadLocal,Object&gt;</span></div><div class=\"line\">        <span class=\"comment\">// 注意key类型是ThreadLocal，不是Thread</span></div><div class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</div><div class=\"line\">            T result = (T)e.value;</div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 如果获得的map为null或者从map通过key获取的value为空时获取一个初始值</span></div><div class=\"line\">    <span class=\"comment\">// setInitialValue方法里调用了initialValue方法</span></div><div class=\"line\">    <span class=\"comment\">// 宝宝不管，反正宝宝想要有值，宝宝不想为null</span></div><div class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">    Thread t = Thread.currentThread();</div><div class=\"line\">    ThreadLocalMap map = getMap(t);</div><div class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"comment\">// 没什么说的set进去</span></div><div class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"comment\">// 当map不存在时，使用初始值创建一个</span></div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     ThreadLocalMap m = getMap(Thread.currentThread());</div><div class=\"line\">     <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</div><div class=\"line\">         <span class=\"comment\">// 没什么说的，remove掉</span></div><div class=\"line\">         m.remove(<span class=\"keyword\">this</span>);</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 你给我一个线程，我换你一个map</span></div><div class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ThreadLocal所有的操作都是围绕着内部类ThreadLocalMap的，ThreadLocal只是让ThreadLocalMap更加容易访问。咦，有点耳熟，没错外观模式。</p>\n<p>下面看一下ThreadLocal的静态内部类ThreadLocalMap，JDK文档对它的描述主要集中在一下几点：</p>\n<ol>\n<li>是什么：定制的hash map用于维护本地线程变量</li>\n<li>可见性：ThreadLocal之外没有任何方法可访问，Thread类使用它定义了私有属性</li>\n<li>特殊性：为了管理大对象、长生命周期对象，使用WeakReference包装ThreadLocal对象作为key</li>\n</ol>\n<p>前面两点没什么好说的，主要是第三点：key使用了弱引用类型管理（关于弱引用可以先参考<a href=\"https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。\" target=\"_blank\" rel=\"external\">https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。</a></p>\n<p><img src=\"http://img.blog.csdn.net/20160121000731607\" alt=\"image\"></p>\n<p>图片来自互联网，实线表示强引用，虚线表示弱引用。</p>\n<p>简而言之，一个对象在没有强引用引用，只有弱引用引用时，当GC发生这个对象就会被标记回收。将ThreadLocal对象设置成弱引用作为key的好处是显而易见：当ThreadLocal没有任何强引用引用时，只有ThreadLocalMap的Entry对它存在弱引用，这样GC的时候这个ThreadLocal对象就可以被回收了。但是这又带来了一个问题：Entry的key可能被回收了，但留下了一个并没有什么卵用的value。只要线程生命周期不结束，那么这个value对象始终保持了一个强引用链条：</p>\n<p>Thread Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</p>\n<p>当内存有大量驻留的线程时，因为强引用存在，GC始终无法回收，就导致了内存泄漏。</p>\n<p>真对这个问题ThreadLocalMap在实现的时候也采取了一些防护措施，比如ThreadLocalMap的get（set，remove方法也类似，限于篇幅不展开了）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// hash函数获取索引位置</span></div><div class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</div><div class=\"line\">    Entry e = table[i];</div><div class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</div><div class=\"line\">        <span class=\"comment\">// 命中了</span></div><div class=\"line\">        <span class=\"keyword\">return</span> e;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"comment\">// miss了</span></div><div class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</div><div class=\"line\">    Entry[] tab = table;</div><div class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</div><div class=\"line\">\t\t</div><div class=\"line\">    <span class=\"comment\">// 遍历table</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</div><div class=\"line\">        <span class=\"keyword\">if</span> (k == key)</div><div class=\"line\">            <span class=\"comment\">// 找到了</span></div><div class=\"line\">            <span class=\"keyword\">return</span> e;</div><div class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"comment\">// 发现key为空（也就是上面描述的内存泄漏的情况），做删除</span></div><div class=\"line\">            expungeStaleEntry(i);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"comment\">// 找下一个Entty位置</span></div><div class=\"line\">            i = nextIndex(i, len);</div><div class=\"line\">        e = tab[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在get的过程中凡是碰到了key为null的Entry，这个Entry就会被擦除，从而避免内存泄漏。类似的思路在set，remove方法中都有实现。针对内存泄漏问题ThreadLocal实际是需要手动触发函数删除key为null的Entry，所以当不要再需要一个变量当定到线程时手动的remove还是很有必要的。</p>\n<p>最后，在网上看到对ThreadLocal有多种说法：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。</p>\n<p>关于第一种说法我觉得是部分正确的，ThreadLocal将需要共享的对象封闭在了线程内确实解决了并发的一部分问题，但并不是万能的。比如重写initialValue方法时返回的是一个全局共享的对象，那实际上ThreadLocal只是把这个全局共享的对象又封装到了Thread对象里，ThreadLocal本身并没有做类似深拷贝的操作，因此这个变量依然是线程不安全的（逸出）。</p>\n<p>关于第二种说法，我觉得问题就比较大了。ThreadLocal根本不是为了线程间共享，实际是为了将状态封闭在线程内以确保线程安全。这样做确实带来了访问共享状态的便利，但这个状态的共享是在单个线程内的，而不是线程之间的。比如在action中将session对象绑定在线程内，在service、dao里都可以方便的共享，但所有的共享都是在单个的线程内部，而不是在多个的线程之间共享。</p>\n<p>参考资料：</p>\n<p>《Java并发编程实战》</p>\n<p>JDK8帮助手册</p>\n<p><a href=\"http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/\" target=\"_blank\" rel=\"external\">http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/</a></p>\n<p><a href=\"http://my.oschina.net/xianggao/blog/392440#navbar-header\" target=\"_blank\" rel=\"external\">http://my.oschina.net/xianggao/blog/392440#navbar-header</a></p>\n","excerpt":"","more":"<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><p>最近《Java并发编程实战》第三章谈及了对象共享的问题。对共享的可变数据最简单粗暴的做法当然是同步，但是同步的缺点也很明显，代码复杂可维护性降低。针对这个问题，书上谈及到了通过线程封闭避免同步，其中的ThreadLocal类就是帮助维持线程封闭性的。</p>\n<p>之前对ThreadLocal的认识非常简单，就是把一个变量绑定到线程上。参照网上的例子自己也实现了类似功能的例子ThreadLocalVariable(<a href=\"https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。\">https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。</a></p>\n<p>看JDK之前想当然的以为ThreadLocal应该就是简单对<code>Map&lt;Thread, Object&gt;</code>做一个封装，然而实际并没有这么简单。参照了网上一些文章的说法，早期的ThreadLocal确实是这样实现的。但是这样实现存在一些问题：</p>\n<ol>\n<li>线程安全问题，如果使用线程安全的Map实现那么就会带来性能问题，当有大量的线程使用ThreadLocal，伴随着线程生命周期ThreadLocal也需要频繁向底层的Map添加删除数据。</li>\n<li>内存回收问题，用Thread当key，除非手动调用remove，否则即使线程退出了会导致：1)该Thread对象无法回收；2)该线程在所有ThreadLocal中对应的value也无法回收。</li>\n</ol>\n<p>ThreadLocal实际给出了不同的实现方式。首先绑定到线程的变量没有维护在ThreadLocal内，而是维护在各个Thread类实例内——在Thread类内使用了ThreadLocal的静态内部类<code>ThreadLocalMap</code>实例去维护需要绑定到线程的变量。这样原本需要维护在ThreadLocal内的数据现在就分散到了各个线程内去维护。</p>\n<p>在Thread中ThreadLocalMap的声明长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 真的就只是声明了一下，什么都没干    </span></div><div class=\"line\">ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</div></pre></td></tr></table></figure>\n<p>ThreadLocal一共只有五个非私有的方法，首先是两个并没有什么卵用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 构造，什么都没干</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadLocal</span><span class=\"params\">()</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置ThreadLocal的初始值，protected很明显是希望子类重写</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>&#125;</div></pre></td></tr></table></figure>\n<p>看看其余三个方法的实现（JDK8）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Thread t = Thread.currentThread();</div><div class=\"line\">    <span class=\"comment\">// 从线程里获取ThreadLocalMap</span></div><div class=\"line\">    ThreadLocalMap map = getMap(t);</div><div class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 根据ThreadLocal实例获取Entity</span></div><div class=\"line\">        <span class=\"comment\">// 一会看ThreadLocal的实现</span></div><div class=\"line\">        <span class=\"comment\">// 暂时可以看做类似Map&lt;ThreadLocal,Object&gt;</span></div><div class=\"line\">        <span class=\"comment\">// 注意key类型是ThreadLocal，不是Thread</span></div><div class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</div><div class=\"line\">            T result = (T)e.value;</div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 如果获得的map为null或者从map通过key获取的value为空时获取一个初始值</span></div><div class=\"line\">    <span class=\"comment\">// setInitialValue方法里调用了initialValue方法</span></div><div class=\"line\">    <span class=\"comment\">// 宝宝不管，反正宝宝想要有值，宝宝不想为null</span></div><div class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">    Thread t = Thread.currentThread();</div><div class=\"line\">    ThreadLocalMap map = getMap(t);</div><div class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"comment\">// 没什么说的set进去</span></div><div class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"comment\">// 当map不存在时，使用初始值创建一个</span></div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     ThreadLocalMap m = getMap(Thread.currentThread());</div><div class=\"line\">     <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</div><div class=\"line\">         <span class=\"comment\">// 没什么说的，remove掉</span></div><div class=\"line\">         m.remove(<span class=\"keyword\">this</span>);</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 你给我一个线程，我换你一个map</span></div><div class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ThreadLocal所有的操作都是围绕着内部类ThreadLocalMap的，ThreadLocal只是让ThreadLocalMap更加容易访问。咦，有点耳熟，没错外观模式。</p>\n<p>下面看一下ThreadLocal的静态内部类ThreadLocalMap，JDK文档对它的描述主要集中在一下几点：</p>\n<ol>\n<li>是什么：定制的hash map用于维护本地线程变量</li>\n<li>可见性：ThreadLocal之外没有任何方法可访问，Thread类使用它定义了私有属性</li>\n<li>特殊性：为了管理大对象、长生命周期对象，使用WeakReference包装ThreadLocal对象作为key</li>\n</ol>\n<p>前面两点没什么好说的，主要是第三点：key使用了弱引用类型管理（关于弱引用可以先参考<a href=\"https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。\">https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。</a></p>\n<p><img src=\"http://img.blog.csdn.net/20160121000731607\" alt=\"image\"></p>\n<p>图片来自互联网，实线表示强引用，虚线表示弱引用。</p>\n<p>简而言之，一个对象在没有强引用引用，只有弱引用引用时，当GC发生这个对象就会被标记回收。将ThreadLocal对象设置成弱引用作为key的好处是显而易见：当ThreadLocal没有任何强引用引用时，只有ThreadLocalMap的Entry对它存在弱引用，这样GC的时候这个ThreadLocal对象就可以被回收了。但是这又带来了一个问题：Entry的key可能被回收了，但留下了一个并没有什么卵用的value。只要线程生命周期不结束，那么这个value对象始终保持了一个强引用链条：</p>\n<p>Thread Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</p>\n<p>当内存有大量驻留的线程时，因为强引用存在，GC始终无法回收，就导致了内存泄漏。</p>\n<p>真对这个问题ThreadLocalMap在实现的时候也采取了一些防护措施，比如ThreadLocalMap的get（set，remove方法也类似，限于篇幅不展开了）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// hash函数获取索引位置</span></div><div class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</div><div class=\"line\">    Entry e = table[i];</div><div class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</div><div class=\"line\">        <span class=\"comment\">// 命中了</span></div><div class=\"line\">        <span class=\"keyword\">return</span> e;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"comment\">// miss了</span></div><div class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</div><div class=\"line\">    Entry[] tab = table;</div><div class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</div><div class=\"line\">\t\t</div><div class=\"line\">    <span class=\"comment\">// 遍历table</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</div><div class=\"line\">        <span class=\"keyword\">if</span> (k == key)</div><div class=\"line\">            <span class=\"comment\">// 找到了</span></div><div class=\"line\">            <span class=\"keyword\">return</span> e;</div><div class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"comment\">// 发现key为空（也就是上面描述的内存泄漏的情况），做删除</span></div><div class=\"line\">            expungeStaleEntry(i);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"comment\">// 找下一个Entty位置</span></div><div class=\"line\">            i = nextIndex(i, len);</div><div class=\"line\">        e = tab[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在get的过程中凡是碰到了key为null的Entry，这个Entry就会被擦除，从而避免内存泄漏。类似的思路在set，remove方法中都有实现。针对内存泄漏问题ThreadLocal实际是需要手动触发函数删除key为null的Entry，所以当不要再需要一个变量当定到线程时手动的remove还是很有必要的。</p>\n<p>最后，在网上看到对ThreadLocal有多种说法：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。</p>\n<p>关于第一种说法我觉得是部分正确的，ThreadLocal将需要共享的对象封闭在了线程内确实解决了并发的一部分问题，但并不是万能的。比如重写initialValue方法时返回的是一个全局共享的对象，那实际上ThreadLocal只是把这个全局共享的对象又封装到了Thread对象里，ThreadLocal本身并没有做类似深拷贝的操作，因此这个变量依然是线程不安全的（逸出）。</p>\n<p>关于第二种说法，我觉得问题就比较大了。ThreadLocal根本不是为了线程间共享，实际是为了将状态封闭在线程内以确保线程安全。这样做确实带来了访问共享状态的便利，但这个状态的共享是在单个线程内的，而不是线程之间的。比如在action中将session对象绑定在线程内，在service、dao里都可以方便的共享，但所有的共享都是在单个的线程内部，而不是在多个的线程之间共享。</p>\n<p>参考资料：</p>\n<p>《Java并发编程实战》</p>\n<p>JDK8帮助手册</p>\n<p><a href=\"http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/\">http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/</a></p>\n<p><a href=\"http://my.oschina.net/xianggao/blog/392440#navbar-header\">http://my.oschina.net/xianggao/blog/392440#navbar-header</a></p>\n"},{"title":"从依赖实现到依赖行为","date":"2016-10-22T10:59:11.000Z","_content":"\n## 背景\n\n一个报表程序需要初始化报表参数。具体的参数分为三种类型，都实现了`Parameter`类型，具体的初始化过程由子类实现。\n\n对报表参数初始化的过程，从对具体实现过程的依赖，依次经历对接口、对数据结构，最终对行为依赖，不断抽象依赖，实现更大程度的复用。\n\n## 对实现的依赖\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        for (Parameter para : parameterGraph.getParmaeters()) {\n            if (para instanceof SimpleParameter) {\n                SimpleParameter simplePara = (SimpleParameter) para;\n                String[] values = request.getParameterValues(para.getName());\n                simplePara.setValue(values);\n            } else {\n                if (para instanceof ItemParameter) {\n                    ItemParameter itemPara = (ItemParameter) para;\n                    for (Item item : itemPara.getItems()) {\n                        String[] values = request.getParameterValues(item.getName());\n                        item.setValues(values);\n                    }\n                } else {\n                    TableParameter tablePara = (TableParameter) para;\n                    String[] rows =\n                            request.getParameterValues(tablePara.getRowName());\n                    String[] columns =\n                            request.getParameterValues(tablePara.getColumnName());\n                    String[] dataCells =\n                            request.getParameterValues(tablePara.getDataCellName());\n\n                    int columnSize = columns.length;\n                    for (int i = 0; i < rows.length; i++) {\n                        for (int j = 0; j < columns.length; j++) {\n                            TableParameterElement element = new TableParameterElement();\n                            element.setRow(rows[i]);\n                            element.setColumn(columns[j]);\n                            element.setDataCell(dataCells[columnSize * i + j]);\n                            tablePara.addElement(element);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n坏代码的味道：\n\n1. 多层次的循环、IF嵌套，如果要在这个层次上加一个期限，那就是大于2。\n2. `IF/SWITCH instanceof Class`式的样板代码\n\n##  对接口的依赖\n\n多态替换分支语句，重构：\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        for (Parameter para : parameterGraph.getParmaeters()) {\n            para.fillParamter(request);\n        }\n    }\n}\n```\n## 对数据结构的依赖\n\n上面的重构使用多态极大简化了`ParameterCollector`，同时也让不同实现的`Parameter`更加容易维护。但是在Parameter的方法中传递了request，这使得Parameter类所在的包也必须依赖ServletHttpRequest。这种包之间不必要的耦合可以使用Map保存需要的键值映射关系，弱化这种依赖关系。\n\n进一步重构：\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        Map parmaeters = getParameterMap();           \n        for (Parameter para : parameterGraph.getParmaeters()) {\n            para.fillParamter(parmaeters);\n        }\n    }\n}\n```\n\n进一步重构后的代码虽然避免了对ServletHttpRequest的依赖，但是无法避免的对Map进行了依赖。\n\n对类似Map这样具体的数据结构依赖，让人无法清晰知道方法参数含义并不是好的编码风格。\n\n## 对行为的依赖\n\n在回头看最初的代码，与Servlet API强耦合的是这样一句`request.getParameterValues(para.getName())`\n\n依赖的到底是什么？站在函数式编程的角度，依赖的其实是一种行为：\n\n```java\nstring ->  request.getParameterValues(string)\n```\n\n在Java语法中为了传递一个方法，必须让方法附属在一个接口上，像这样：\n\n```java\npublic interface ParamterRequest {\n    String[] getParameterValues(String string);\n}\n```\n\n为了让ServletHttpRequest与ParamterRequest相关联，必须适配器模式，对象的适配器实现像下面这样：\n\n```java\nprivate class ParameterRequestAdapter implements ParamterRequest {\n    ServletHttpRequest servletHttpRequest;\n\n    public ParameterRequestAdapter(ServletHttpRequest servletHttpRequest) {\n        this.servletHttpRequest = servletHttpRequest;\n    }\n\n    @Override\n    public String[] getParameterValues(String string) {\n        return servletHttpRequest.getParameterValues(string);\n    }\n}\n```\n\n使用上面的适配器再进一步重构：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n\tfor (Parameter para : parameterGraph.getParmaeters()) {\n\t\tpara.fillParamter(new ParameterRequestAdapter(request));\n\t}\n}\n```\n\n我们还可以使用匿名内部类：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(new ParamterRequest() {\n      @Override\n      public String[] getParameterValues(String string) {\n        return request.getParameterValues(string);\n      }\n    });\n  }\n}\n```\n\n在Java8我们还可以这样写：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(string ->  request.getParameterValues(string));\n  }\n}\n```\n\n甚至还可以这样：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(request::getParameterValues);\n  }\n}\n```\n回头看一眼原有大篇幅的方法，再看看多次重构过的代码。\n\n最明显的感受`fillParameters`方法比以前薄了：\n\n不相关的职责从方法中抽取出来放到单独的类维护了（职责单一）\n\n当有更多参数类型需要添加时`fillParameters`不需要做任何的修改，只要添加对应类型就好（开闭原则）\n\n之前对实现类的依赖现在变成了对接口的依赖（依赖倒置）\n\n重构过程中`Parameter`从对`request`的依赖变为对数据结构（Map）的依赖，避免了Parameter所在模块与`Servlet API`之间的耦合。\n\n从对数据结构的依赖最后变成了对接口（行为）的依赖，抽象程度进一步提高，可维护性也更好。\n\n\n\n## 面向对象与函数式编程\n\n面向对象强调对事物的抽象，强调名词\n\n函数式编程强调对行为的抽象，强调动词\n\n例如：\n\n```java\npublic class People {\n    private List<Person> persons = new ArrayList<Person>();\n\n    public List<Person> findByName(String name) {\n        List<Person> result = new ArrayList<Person>();\n        for (Person person : persons) {\n            if (person.getName().equals(name)) {\n                result.add(person);\n            }\n        }\n        return result;\n    }\n}\n```\n例如我们有一个方法findByName，以后可能还需要更多方法例如findByAge，findByGender，findChildren等等方法，所有的方法其实都只有查找的过滤条件不同，可以抽象出函数式的写法：\n\n```java\npublic List<Person> findPersons(Predicate<Person> predicate, Person people) {\n  List<Person> result = new ArrayList<>();\n  for (Person person : persons) {\n    if (predicate.test(people)) {\n      result.add(person);\n    }\n  }\n  return result;\n}\n```\n\nJava8可以简写成：\n\n\n```java\npublic List<Person> findPersons(Predicate<Person> predicate, Person people) {\n  return persons.stream().filter(predicate).collect(Collectors.toList());\n}\n```\n\n","source":"_posts/从依赖实现到依赖行为.md","raw":"---\ntitle: 从依赖实现到依赖行为\ndate: 2016-10-22 18:59:11\ntags:\n  - Java\n  - 设计模式\n  - Functional\ncategories: 设计模式\n---\n\n## 背景\n\n一个报表程序需要初始化报表参数。具体的参数分为三种类型，都实现了`Parameter`类型，具体的初始化过程由子类实现。\n\n对报表参数初始化的过程，从对具体实现过程的依赖，依次经历对接口、对数据结构，最终对行为依赖，不断抽象依赖，实现更大程度的复用。\n\n## 对实现的依赖\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        for (Parameter para : parameterGraph.getParmaeters()) {\n            if (para instanceof SimpleParameter) {\n                SimpleParameter simplePara = (SimpleParameter) para;\n                String[] values = request.getParameterValues(para.getName());\n                simplePara.setValue(values);\n            } else {\n                if (para instanceof ItemParameter) {\n                    ItemParameter itemPara = (ItemParameter) para;\n                    for (Item item : itemPara.getItems()) {\n                        String[] values = request.getParameterValues(item.getName());\n                        item.setValues(values);\n                    }\n                } else {\n                    TableParameter tablePara = (TableParameter) para;\n                    String[] rows =\n                            request.getParameterValues(tablePara.getRowName());\n                    String[] columns =\n                            request.getParameterValues(tablePara.getColumnName());\n                    String[] dataCells =\n                            request.getParameterValues(tablePara.getDataCellName());\n\n                    int columnSize = columns.length;\n                    for (int i = 0; i < rows.length; i++) {\n                        for (int j = 0; j < columns.length; j++) {\n                            TableParameterElement element = new TableParameterElement();\n                            element.setRow(rows[i]);\n                            element.setColumn(columns[j]);\n                            element.setDataCell(dataCells[columnSize * i + j]);\n                            tablePara.addElement(element);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n坏代码的味道：\n\n1. 多层次的循环、IF嵌套，如果要在这个层次上加一个期限，那就是大于2。\n2. `IF/SWITCH instanceof Class`式的样板代码\n\n##  对接口的依赖\n\n多态替换分支语句，重构：\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        for (Parameter para : parameterGraph.getParmaeters()) {\n            para.fillParamter(request);\n        }\n    }\n}\n```\n## 对数据结构的依赖\n\n上面的重构使用多态极大简化了`ParameterCollector`，同时也让不同实现的`Parameter`更加容易维护。但是在Parameter的方法中传递了request，这使得Parameter类所在的包也必须依赖ServletHttpRequest。这种包之间不必要的耦合可以使用Map保存需要的键值映射关系，弱化这种依赖关系。\n\n进一步重构：\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        Map parmaeters = getParameterMap();           \n        for (Parameter para : parameterGraph.getParmaeters()) {\n            para.fillParamter(parmaeters);\n        }\n    }\n}\n```\n\n进一步重构后的代码虽然避免了对ServletHttpRequest的依赖，但是无法避免的对Map进行了依赖。\n\n对类似Map这样具体的数据结构依赖，让人无法清晰知道方法参数含义并不是好的编码风格。\n\n## 对行为的依赖\n\n在回头看最初的代码，与Servlet API强耦合的是这样一句`request.getParameterValues(para.getName())`\n\n依赖的到底是什么？站在函数式编程的角度，依赖的其实是一种行为：\n\n```java\nstring ->  request.getParameterValues(string)\n```\n\n在Java语法中为了传递一个方法，必须让方法附属在一个接口上，像这样：\n\n```java\npublic interface ParamterRequest {\n    String[] getParameterValues(String string);\n}\n```\n\n为了让ServletHttpRequest与ParamterRequest相关联，必须适配器模式，对象的适配器实现像下面这样：\n\n```java\nprivate class ParameterRequestAdapter implements ParamterRequest {\n    ServletHttpRequest servletHttpRequest;\n\n    public ParameterRequestAdapter(ServletHttpRequest servletHttpRequest) {\n        this.servletHttpRequest = servletHttpRequest;\n    }\n\n    @Override\n    public String[] getParameterValues(String string) {\n        return servletHttpRequest.getParameterValues(string);\n    }\n}\n```\n\n使用上面的适配器再进一步重构：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n\tfor (Parameter para : parameterGraph.getParmaeters()) {\n\t\tpara.fillParamter(new ParameterRequestAdapter(request));\n\t}\n}\n```\n\n我们还可以使用匿名内部类：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(new ParamterRequest() {\n      @Override\n      public String[] getParameterValues(String string) {\n        return request.getParameterValues(string);\n      }\n    });\n  }\n}\n```\n\n在Java8我们还可以这样写：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(string ->  request.getParameterValues(string));\n  }\n}\n```\n\n甚至还可以这样：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(request::getParameterValues);\n  }\n}\n```\n回头看一眼原有大篇幅的方法，再看看多次重构过的代码。\n\n最明显的感受`fillParameters`方法比以前薄了：\n\n不相关的职责从方法中抽取出来放到单独的类维护了（职责单一）\n\n当有更多参数类型需要添加时`fillParameters`不需要做任何的修改，只要添加对应类型就好（开闭原则）\n\n之前对实现类的依赖现在变成了对接口的依赖（依赖倒置）\n\n重构过程中`Parameter`从对`request`的依赖变为对数据结构（Map）的依赖，避免了Parameter所在模块与`Servlet API`之间的耦合。\n\n从对数据结构的依赖最后变成了对接口（行为）的依赖，抽象程度进一步提高，可维护性也更好。\n\n\n\n## 面向对象与函数式编程\n\n面向对象强调对事物的抽象，强调名词\n\n函数式编程强调对行为的抽象，强调动词\n\n例如：\n\n```java\npublic class People {\n    private List<Person> persons = new ArrayList<Person>();\n\n    public List<Person> findByName(String name) {\n        List<Person> result = new ArrayList<Person>();\n        for (Person person : persons) {\n            if (person.getName().equals(name)) {\n                result.add(person);\n            }\n        }\n        return result;\n    }\n}\n```\n例如我们有一个方法findByName，以后可能还需要更多方法例如findByAge，findByGender，findChildren等等方法，所有的方法其实都只有查找的过滤条件不同，可以抽象出函数式的写法：\n\n```java\npublic List<Person> findPersons(Predicate<Person> predicate, Person people) {\n  List<Person> result = new ArrayList<>();\n  for (Person person : persons) {\n    if (predicate.test(people)) {\n      result.add(person);\n    }\n  }\n  return result;\n}\n```\n\nJava8可以简写成：\n\n\n```java\npublic List<Person> findPersons(Predicate<Person> predicate, Person people) {\n  return persons.stream().filter(predicate).collect(Collectors.toList());\n}\n```\n\n","slug":"从依赖实现到依赖行为","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gaw000vyi2e10usfl2h","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>一个报表程序需要初始化报表参数。具体的参数分为三种类型，都实现了<code>Parameter</code>类型，具体的初始化过程由子类实现。</p>\n<p>对报表参数初始化的过程，从对具体实现过程的依赖，依次经历对接口、对数据结构，最终对行为依赖，不断抽象依赖，实现更大程度的复用。</p>\n<h2 id=\"对实现的依赖\"><a href=\"#对实现的依赖\" class=\"headerlink\" title=\"对实现的依赖\"></a>对实现的依赖</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </span></span></div><div class=\"line\">                                ParameterGraph parameterGraph) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (para <span class=\"keyword\">instanceof</span> SimpleParameter) &#123;</div><div class=\"line\">                SimpleParameter simplePara = (SimpleParameter) para;</div><div class=\"line\">                String[] values = request.getParameterValues(para.getName());</div><div class=\"line\">                simplePara.setValue(values);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (para <span class=\"keyword\">instanceof</span> ItemParameter) &#123;</div><div class=\"line\">                    ItemParameter itemPara = (ItemParameter) para;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (Item item : itemPara.getItems()) &#123;</div><div class=\"line\">                        String[] values = request.getParameterValues(item.getName());</div><div class=\"line\">                        item.setValues(values);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    TableParameter tablePara = (TableParameter) para;</div><div class=\"line\">                    String[] rows =</div><div class=\"line\">                            request.getParameterValues(tablePara.getRowName());</div><div class=\"line\">                    String[] columns =</div><div class=\"line\">                            request.getParameterValues(tablePara.getColumnName());</div><div class=\"line\">                    String[] dataCells =</div><div class=\"line\">                            request.getParameterValues(tablePara.getDataCellName());</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">int</span> columnSize = columns.length;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows.length; i++) &#123;</div><div class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; columns.length; j++) &#123;</div><div class=\"line\">                            TableParameterElement element = <span class=\"keyword\">new</span> TableParameterElement();</div><div class=\"line\">                            element.setRow(rows[i]);</div><div class=\"line\">                            element.setColumn(columns[j]);</div><div class=\"line\">                            element.setDataCell(dataCells[columnSize * i + j]);</div><div class=\"line\">                            tablePara.addElement(element);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>坏代码的味道：</p>\n<ol>\n<li>多层次的循环、IF嵌套，如果要在这个层次上加一个期限，那就是大于2。</li>\n<li><code>IF/SWITCH instanceof Class</code>式的样板代码</li>\n</ol>\n<h2 id=\"对接口的依赖\"><a href=\"#对接口的依赖\" class=\"headerlink\" title=\"对接口的依赖\"></a>对接口的依赖</h2><p>多态替换分支语句，重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </span></span></div><div class=\"line\">                                ParameterGraph parameterGraph) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            para.fillParamter(request);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"对数据结构的依赖\"><a href=\"#对数据结构的依赖\" class=\"headerlink\" title=\"对数据结构的依赖\"></a>对数据结构的依赖</h2><p>上面的重构使用多态极大简化了<code>ParameterCollector</code>，同时也让不同实现的<code>Parameter</code>更加容易维护。但是在Parameter的方法中传递了request，这使得Parameter类所在的包也必须依赖ServletHttpRequest。这种包之间不必要的耦合可以使用Map保存需要的键值映射关系，弱化这种依赖关系。</p>\n<p>进一步重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </span></span></div><div class=\"line\">                                ParameterGraph parameterGraph) &#123;</div><div class=\"line\">        Map parmaeters = getParameterMap();           </div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            para.fillParamter(parmaeters);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进一步重构后的代码虽然避免了对ServletHttpRequest的依赖，但是无法避免的对Map进行了依赖。</p>\n<p>对类似Map这样具体的数据结构依赖，让人无法清晰知道方法参数含义并不是好的编码风格。</p>\n<h2 id=\"对行为的依赖\"><a href=\"#对行为的依赖\" class=\"headerlink\" title=\"对行为的依赖\"></a>对行为的依赖</h2><p>在回头看最初的代码，与Servlet API强耦合的是这样一句<code>request.getParameterValues(para.getName())</code></p>\n<p>依赖的到底是什么？站在函数式编程的角度，依赖的其实是一种行为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">string -&gt;  request.getParameterValues(string)</div></pre></td></tr></table></figure>\n<p>在Java语法中为了传递一个方法，必须让方法附属在一个接口上，像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ParamterRequest</span> </span>&#123;</div><div class=\"line\">    String[] getParameterValues(String string);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了让ServletHttpRequest与ParamterRequest相关联，必须适配器模式，对象的适配器实现像下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterRequestAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">ParamterRequest</span> </span>&#123;</div><div class=\"line\">    ServletHttpRequest servletHttpRequest;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ParameterRequestAdapter</span><span class=\"params\">(ServletHttpRequest servletHttpRequest)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.servletHttpRequest = servletHttpRequest;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> String[] getParameterValues(String string) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> servletHttpRequest.getParameterValues(string);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用上面的适配器再进一步重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">\t\tpara.fillParamter(<span class=\"keyword\">new</span> ParameterRequestAdapter(request));</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们还可以使用匿名内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(<span class=\"keyword\">new</span> ParamterRequest() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"keyword\">public</span> String[] getParameterValues(String string) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> request.getParameterValues(string);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Java8我们还可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(string -&gt;  request.getParameterValues(string));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>甚至还可以这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(request::getParameterValues);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>回头看一眼原有大篇幅的方法，再看看多次重构过的代码。</p>\n<p>最明显的感受<code>fillParameters</code>方法比以前薄了：</p>\n<p>不相关的职责从方法中抽取出来放到单独的类维护了（职责单一）</p>\n<p>当有更多参数类型需要添加时<code>fillParameters</code>不需要做任何的修改，只要添加对应类型就好（开闭原则）</p>\n<p>之前对实现类的依赖现在变成了对接口的依赖（依赖倒置）</p>\n<p>重构过程中<code>Parameter</code>从对<code>request</code>的依赖变为对数据结构（Map）的依赖，避免了Parameter所在模块与<code>Servlet API</code>之间的耦合。</p>\n<p>从对数据结构的依赖最后变成了对接口（行为）的依赖，抽象程度进一步提高，可维护性也更好。</p>\n<h2 id=\"面向对象与函数式编程\"><a href=\"#面向对象与函数式编程\" class=\"headerlink\" title=\"面向对象与函数式编程\"></a>面向对象与函数式编程</h2><p>面向对象强调对事物的抽象，强调名词</p>\n<p>函数式编程强调对行为的抽象，强调动词</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList&lt;Person&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findByName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        List&lt;Person&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;Person&gt;();</div><div class=\"line\">        <span class=\"keyword\">for</span> (Person person : persons) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (person.getName().equals(name)) &#123;</div><div class=\"line\">                result.add(person);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例如我们有一个方法findByName，以后可能还需要更多方法例如findByAge，findByGender，findChildren等等方法，所有的方法其实都只有查找的过滤条件不同，可以抽象出函数式的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findPersons</span><span class=\"params\">(Predicate&lt;Person&gt; predicate, Person people)</span> </span>&#123;</div><div class=\"line\">  List&lt;Person&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">  <span class=\"keyword\">for</span> (Person person : persons) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (predicate.test(people)) &#123;</div><div class=\"line\">      result.add(person);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Java8可以简写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findPersons</span><span class=\"params\">(Predicate&lt;Person&gt; predicate, Person people)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> persons.stream().filter(predicate).collect(Collectors.toList());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>一个报表程序需要初始化报表参数。具体的参数分为三种类型，都实现了<code>Parameter</code>类型，具体的初始化过程由子类实现。</p>\n<p>对报表参数初始化的过程，从对具体实现过程的依赖，依次经历对接口、对数据结构，最终对行为依赖，不断抽象依赖，实现更大程度的复用。</p>\n<h2 id=\"对实现的依赖\"><a href=\"#对实现的依赖\" class=\"headerlink\" title=\"对实现的依赖\"></a>对实现的依赖</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </div><div class=\"line\">                                ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (para <span class=\"keyword\">instanceof</span> SimpleParameter) &#123;</div><div class=\"line\">                SimpleParameter simplePara = (SimpleParameter) para;</div><div class=\"line\">                String[] values = request.getParameterValues(para.getName());</div><div class=\"line\">                simplePara.setValue(values);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (para <span class=\"keyword\">instanceof</span> ItemParameter) &#123;</div><div class=\"line\">                    ItemParameter itemPara = (ItemParameter) para;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (Item item : itemPara.getItems()) &#123;</div><div class=\"line\">                        String[] values = request.getParameterValues(item.getName());</div><div class=\"line\">                        item.setValues(values);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    TableParameter tablePara = (TableParameter) para;</div><div class=\"line\">                    String[] rows =</div><div class=\"line\">                            request.getParameterValues(tablePara.getRowName());</div><div class=\"line\">                    String[] columns =</div><div class=\"line\">                            request.getParameterValues(tablePara.getColumnName());</div><div class=\"line\">                    String[] dataCells =</div><div class=\"line\">                            request.getParameterValues(tablePara.getDataCellName());</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">int</span> columnSize = columns.length;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows.length; i++) &#123;</div><div class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; columns.length; j++) &#123;</div><div class=\"line\">                            TableParameterElement element = <span class=\"keyword\">new</span> TableParameterElement();</div><div class=\"line\">                            element.setRow(rows[i]);</div><div class=\"line\">                            element.setColumn(columns[j]);</div><div class=\"line\">                            element.setDataCell(dataCells[columnSize * i + j]);</div><div class=\"line\">                            tablePara.addElement(element);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>坏代码的味道：</p>\n<ol>\n<li>多层次的循环、IF嵌套，如果要在这个层次上加一个期限，那就是大于2。</li>\n<li><code>IF/SWITCH instanceof Class</code>式的样板代码</li>\n</ol>\n<h2 id=\"对接口的依赖\"><a href=\"#对接口的依赖\" class=\"headerlink\" title=\"对接口的依赖\"></a>对接口的依赖</h2><p>多态替换分支语句，重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </div><div class=\"line\">                                ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            para.fillParamter(request);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"对数据结构的依赖\"><a href=\"#对数据结构的依赖\" class=\"headerlink\" title=\"对数据结构的依赖\"></a>对数据结构的依赖</h2><p>上面的重构使用多态极大简化了<code>ParameterCollector</code>，同时也让不同实现的<code>Parameter</code>更加容易维护。但是在Parameter的方法中传递了request，这使得Parameter类所在的包也必须依赖ServletHttpRequest。这种包之间不必要的耦合可以使用Map保存需要的键值映射关系，弱化这种依赖关系。</p>\n<p>进一步重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </div><div class=\"line\">                                ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">        Map parmaeters = getParameterMap();           </div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            para.fillParamter(parmaeters);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进一步重构后的代码虽然避免了对ServletHttpRequest的依赖，但是无法避免的对Map进行了依赖。</p>\n<p>对类似Map这样具体的数据结构依赖，让人无法清晰知道方法参数含义并不是好的编码风格。</p>\n<h2 id=\"对行为的依赖\"><a href=\"#对行为的依赖\" class=\"headerlink\" title=\"对行为的依赖\"></a>对行为的依赖</h2><p>在回头看最初的代码，与Servlet API强耦合的是这样一句<code>request.getParameterValues(para.getName())</code></p>\n<p>依赖的到底是什么？站在函数式编程的角度，依赖的其实是一种行为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">string -&gt;  request.getParameterValues(string)</div></pre></td></tr></table></figure>\n<p>在Java语法中为了传递一个方法，必须让方法附属在一个接口上，像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ParamterRequest</span> </span>&#123;</div><div class=\"line\">    String[] getParameterValues(String string);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了让ServletHttpRequest与ParamterRequest相关联，必须适配器模式，对象的适配器实现像下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterRequestAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">ParamterRequest</span> </span>&#123;</div><div class=\"line\">    ServletHttpRequest servletHttpRequest;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ParameterRequestAdapter</span><span class=\"params\">(ServletHttpRequest servletHttpRequest)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.servletHttpRequest = servletHttpRequest;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> String[] getParameterValues(String string) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> servletHttpRequest.getParameterValues(string);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用上面的适配器再进一步重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">\t\tpara.fillParamter(<span class=\"keyword\">new</span> ParameterRequestAdapter(request));</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们还可以使用匿名内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(<span class=\"keyword\">new</span> ParamterRequest() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"keyword\">public</span> String[] getParameterValues(String string) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> request.getParameterValues(string);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Java8我们还可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(string -&gt;  request.getParameterValues(string));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>甚至还可以这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(request::getParameterValues);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>回头看一眼原有大篇幅的方法，再看看多次重构过的代码。</p>\n<p>最明显的感受<code>fillParameters</code>方法比以前薄了：</p>\n<p>不相关的职责从方法中抽取出来放到单独的类维护了（职责单一）</p>\n<p>当有更多参数类型需要添加时<code>fillParameters</code>不需要做任何的修改，只要添加对应类型就好（开闭原则）</p>\n<p>之前对实现类的依赖现在变成了对接口的依赖（依赖倒置）</p>\n<p>重构过程中<code>Parameter</code>从对<code>request</code>的依赖变为对数据结构（Map）的依赖，避免了Parameter所在模块与<code>Servlet API</code>之间的耦合。</p>\n<p>从对数据结构的依赖最后变成了对接口（行为）的依赖，抽象程度进一步提高，可维护性也更好。</p>\n<h2 id=\"面向对象与函数式编程\"><a href=\"#面向对象与函数式编程\" class=\"headerlink\" title=\"面向对象与函数式编程\"></a>面向对象与函数式编程</h2><p>面向对象强调对事物的抽象，强调名词</p>\n<p>函数式编程强调对行为的抽象，强调动词</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList&lt;Person&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findByName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        List&lt;Person&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;Person&gt;();</div><div class=\"line\">        <span class=\"keyword\">for</span> (Person person : persons) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (person.getName().equals(name)) &#123;</div><div class=\"line\">                result.add(person);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例如我们有一个方法findByName，以后可能还需要更多方法例如findByAge，findByGender，findChildren等等方法，所有的方法其实都只有查找的过滤条件不同，可以抽象出函数式的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findPersons</span><span class=\"params\">(Predicate&lt;Person&gt; predicate, Person people)</span> </span>&#123;</div><div class=\"line\">  List&lt;Person&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">  <span class=\"keyword\">for</span> (Person person : persons) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (predicate.test(people)) &#123;</div><div class=\"line\">      result.add(person);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Java8可以简写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findPersons</span><span class=\"params\">(Predicate&lt;Person&gt; predicate, Person people)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> persons.stream().filter(predicate).collect(Collectors.toList());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"【翻译】SpringData官方文档第四章","date":"2016-11-26T16:00:00.000Z","_content":"说明：本翻译[4.6](http://ifeve.com/repositories-custom-implementations/)和[4.7](http://ifeve.com/spring-data-4-7/)段发布在[并发编程网](http://ifeve.com/),其他段落为了熟悉上下文而翻译，没有精校。首次参与翻译任务，翻译的不好请指正。\n\n---\n\n# 第四章 使用Spring Data Repositories\n\nSpring Data repository abstraction目的是为了显著的简化必要的样板式代码来为多种持久化数据存储实现数据层。\n\n> 重要\n>\n> 本章解释Spring Data repositories核心的概念和接口。Spring Data repository documentation 与 你的模块。本章这些信息是从Spring Data Commons模块获取的。它使用了JPA模块的配置和代码示范,命名引用覆盖XML配置，它支持所有的Spring Data模块支持的repository API，Repository查询关键字覆盖被repository 接口一般的关键字查询方法。你的模块特性的细节信息，查询文档对应模块。\n>\n\n## 4.1 核心概念\n\nSpring Data repository抽象接口的核心是`Repository`（可能没有那么惊喜）。它需要管理实体类以及实体类的id作为参数。此接口主要用作是获取要使用的类型接口并帮助扩展这个接口。\n\n`CrudRepository`为被管理的实体类提供复杂CRUD功能。\n\n## 4.2 查询方法\n\n标准的CRUD功能repositories通常有查询底层数据库。\n\n在Spring Data中，分词声明这些查询变成了四个步骤的过程：\n\n1. 声明一个接口继承`Repository`或者它的一个子类，并且指定要被处理的实体类和Id类型。\n\n   ```java\n   interface PersonRepository extends Repository<Person, Long> { … }\n   ```\n\n\n1. 在接口中声明查询方法。\n\n   ```java\n   interface PersonRepository extends Repository<Person, Long> {\n     List<Person> findByLastname(String lastname);\n   }\n   ```\n\n\n1. 创建Spring生成代理实现上面接口，通过JavaConfig：\n\n   ```java\n   import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n   @EnableJpaRepositories\n   class Config {}\n   ```\n\n   或者通过XML配置：\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xmlns:jpa=\"http://www.springframework.org/schema/data/jpa\"\n   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n   http://www.springframework.org/schema/beans/spring-beans.xsd\n   http://www.springframework.org/schema/data/jpa\n   http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\">\n   <jpa:repositories base-package=\"com.acme.repositories\"/>\n   </beans>\n   ```\n\n   这个实例中使用了JPA命名空间。\n\n   如果你为其他存储使用repository接口，你需要修改来适应你的存储模块命名空间的声明，大概就是替换jpa为期望的，例如mongodb。\n\n   当然，注意JavaConfig并没有明确配置一个包默认使用注解的包。\n\n   为了定制包被扫描可以使用数据存储注解`@Enable`的一个属性`basePackage`。\n\n\n1. 获得repository实例注入并使用。\n\n   ```java\n   public class SomeClient {\n     @Autowired\n     private PersonRepository repository;\n     public void doSomething() {\n       List<Person> persons = repository.findByLastname(\"Matthews\");\n     }\n   }\n   ```\n\n\n以下部分详细说明每个步骤。\n\n## 4.3 定义repository接口\n\n第一步定义一个实体类依赖repository接口。\n\n这个接口必须继承`Repository`接口并且指定实体类型和Id类型。\n\n如果你希望实体类型拥有CRUD方法，将`Repository`接口替换成继承`CrudRepository`。\n\n### 4.3.1 小巧repository定义 \n\n一般情况下，你的repository接口应该继承`Repository`，`CrudRepository`或者`PagingAndSortingRepository`\n\n除此之外,如果你不想继承Spring Data接口,你也可以使用`@Repository`注解定义你的接口\n\n继承`CrudRepository`提供了一系列完整的方法来操纵你的实体.\n\n如果你希望选择方法,简单的从`CurdRepository`复制你希望获得的方法到你的`Repository`\n\n> 注意\n>\n> 注意这允许你定义你自己的抽闲建立在Spring Data Repositories功能.\n\n例5.有选择的展现`CRUD`方法\n\n```java\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends Repository<T, ID> {\n  T findOne(ID id);\n  T save(T entity);\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  User findByEmailAddress(EmailAddress emailAddress);\n}\n```\n\n这是第一步你定义一个通用的基本接口,接口供你所有的实体repositories使用并提供`findOne()`和`save()`方法\n\n这些方法会被转发到你选择的Spring Data提供的基本repository实现,例如JPA`SimpleJpaRepository`,因为他们匹配`CrudRepository`的方法签名.\n\n因此`UserPepository`现在可以保存用户,查找唯一用户根据id,并且触发一个查询去查找`Users`根据他们的邮箱地址\n\n> 注意\n>\n> 注意,中间的repository接口使用了注解`NoRepositoryBean`.\n>\n> 对所有Spring Data在运行时不需要生成实例的repository接口,确保你为他们添加了注解.\n\n### 4.3.2 在多个Spring Data模块使用Repositories\n\n在你的应用中使用唯一的Spring Data模块,所有repository接口定义范围限制在Spring Data模块.\n\n有时候应用需要使用不止一个Spring Data模块.\n\n这种情况下,需要repository定义在持久化技术之间有所区别.\n\n在class path发现多个repository工厂时,Spring Data严格检测repository配置模块.\n\n在repository或者实体类严格配置需要得细节以决定Spring Data模块绑定一个repository的定义:\n\n1. 如果repository定义继承模块特殊的repository,那么对Spring Data模块这是一个有效的备选.\n\n\n1. 如果实体类被模块特有的注解类型注解,那么对Spring Data模块这是一个有效的备选.\n\n   Spring Data模块接收第三方注解(例如 JPA的`@Entity`)或者提供自己的注解例如`@Document`为Spring Data MongoDB/Spring Data Elasticsearch.\n\n\n例6.使用模块特有的接口定义Repository\n\n```java\ninterface MyRepository extends JpaRepository<User, Long> { }\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends JpaRepository<T,ID{\n  …\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  …\n}\n```\n\n`MyRepository`和`UserRepository`继承`JpaRepository`在他们类型层级.他们有效的表示了Spring Data JPA模块.\n\n例7.使用通用的接口定义`Repository`.\n\n```java\ninterface AmbiguousRepository extends Repository<User, Long> {\n  …\n}\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends\n  CrudRepository<T,ID> {\n  …\n}\n\ninterface AmbiguousUserRepository extends MyBaseRepository<User, Long> {\n  …\n}\n```\n\n`AmbiguousRepository`和`AmbiguousUserRepository`在它们继承体系里只继承了`Repository`和`CrudRepository`.使用唯一的Spring Data模块是这是完成正确的,多个模块不能识别`Repository`到底绑定哪个Spring Data.\n\n例8.使用注解配合实体类定义`Repositor`\n\n```java\ninterface PersonRepository extends Repository<Person, Long> {\n  …\n}\n\n@Entity\npublic class Person {\n  …\n}\n\ninterface UserRepository extends Repository<User, Long> {\n  …\n}\n\n@Document\npublic class User {\n  …\n}\n```\n\n`PersonRepository`引用使用了JPA的注解`@Entity`进行注解的`Person`,所以这个repository明确的属于Spring Data JPA.`UserRepository`使用了Spring Data MongoDB的注解`@Document`进行注解.\n\n例9.使用混合注解配合实体类定义`Repositor`\n\n```java\ninterface JpaPersonRepository extends Repository<Person, Long> {\n  …\n}\n\ninterface MongoDBPersonRepository extends Repository<Person, Long> {\n  …\n}\n\n@Entity\n@Document\npublic class Person {\n  …\n}\n```\n\n这个示例展示实体类同时使用JPA和Spring Data MongoDB注解.\n\n这里定义了两个repository,`JpaPersonRepository`和`MongoDBPersonRepository`.\n\n一个被JPA使用,另一个被MongoDB使用.\n\nSpring Data不再能告诉repository区分,这将导致不清晰的行为\n\n\"使用模块特有的接口定义Repository\"和\"使用注解配合实体类定义`Repositor`\"都使用了严格的repository配置为一个特定的Spring Data模块识别可选的repository\n\n\n使用多种持久化技术特定的注解在同一个实体类上可能在锅中持久化技术上重用了实体类,但是这样做Spring Data将不能确定为repository绑定唯一的模块\n\n最后一种方式区分repository是划分repository的基本包.\n\n\n基本包定义起始点是扫描repository接口定义,这意味着在合适的包定义repository.\n\n默认的,注解配置使用类配置的包\n\n基于XML基本配置在这里.\n\n例10.注解配置基本包\n\n```java\n@EnableJpaRepositories(basePackages = \"com.acme.repositories.jpa\")\n@EnableMongoRepositories(basePackages = \"com.acme.repositories.mongo\")\ninterface Configuration { }\n```\n\n\n\n## 4.4 Defining query methods\n\n## 4.4 定义查询方法\n\nrepository代理有两种方式获得通过方法名获得指定查询.可以通过方法名直接获得查询,或者手动定义查询.有可用的选项定义在实际的存储.这有一些策略决定实际查询如何被创建.让我们一些看看可用的选项.\n\n### 4.4.1 Query lookup strategies\n\n下面这些repository基本组件的决定查询可用的策略.你可以配置策略,在XML配置中通过命名空间`query-look-strategy`属性或者在Java配置中通过启用${store} Repository的属性注解`queryLookupStrategy`.一些策略可能不能支持特定的数据库.\n\n- CREATE 试图通过方法名构建一个指定查询.一般处理是从方法名移除一系列给定的前缀并解析方法其他部分.更多查询构建信息阅读Query creation.\n- USE_DECLARED_QUERY试图查找一个准确的查询,并在找不到时抛出一个异常.查询可以被通过注解定义或者其它方式定义.查询特殊存储的文档了解存储的可用选择.如果repository基本组件在启动时不能为方法找到一个准确的查询,将会失败\n- CREATE_IF_NOT_FOUND(默认)联合了CREATE和USE_DECLARED_QUERY.首先查找一个准确查询,如果没有找到,创建一个定制方法基于名字的查询.这是默认的查询策略,因此如果你没有做任何明确配置.它允许根据方法名快速查询定义,而且定制查询根据需要引入声明的查询.\n\n\n### 4.4.2 查询创建\n\n建成Spring Data repository基本组件的查询构建机制有用的构建了repository所有实体类的约束查询.\n\n这个机制分隔方法前缀`find...By`,`read...By`,`query...By`,`count...By`以及`get...By`,并解析其他部分.这个引入条款可以表达包含的特性例如`Distinct`,来设置明确的标志在要生成的查询上.然而,第一个by扮演了分解符来指明真实条件的起始.分词在一个非常基本的水平,你可以在实体属性上定义条件并且连接使用and或or连接他们.\n\n例11.来自方法名的查询创建\n\n```java\npublic interface PersonRepository extends Repository<User, Long> {\n  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String\n                                             lastname);\n  // Enables the distinct flag for the query\n  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String\n                                                       firstname);\n  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String\n                                                       firstname);\n\n  // Enabling ignoring case for an individual property\n  List<Person> findByLastnameIgnoreCase(String lastname);\n  // Enabling ignoring case for all suitable properties\n  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String\n                                                       firstname);\n  // Enabling static ORDER BY for a query\n  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);\n \n  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);\n}\n```\n\n解析方法的实际结果取决于你创建查询的持久化存储.然而,这有些问题需要注意:\n\n- 表达式通常串行的连接属性的遍历与操作符.你可以使用and和or连接属性表达式.你也可以给属性表达式使用操作符,例如between,lessThan,granterThan,like.你可以使用的表达式操作符有between,LessThan,GreaterThan,Loke.被支持的操作符根据多样的数据库决定,因此查询你引用文档的恰当部分.\n- 方法解析支持为单独属性设置一个IgnoreCase标志(例如,findByLastnameIgnoreCase(...))或者为所有属性都支持忽略情况(通常是String情形,例如,findByLastnameAndFirstnameAllIgnoreCase(…)).忽略情况是否被支持由多样的数据库决定，所以具体存储查询方法在引用文档查询相关章节.\n- 你可以为查询方法引用的属性提供静态排序连接OrderBy子句并且提供排序方向(Asc或Desc).为创建一个查询方法支持动态排序,查看特殊参数处理.\n\n\n\n### 4.4.3 属性表达式\n\n属性表达式可以只为管理的实体类的直接属性使用，就像前面所展示的那样。查询常见时你已经确认解析的字段是管理的实体类的一个字段.然而,你也可以通过最近的字段定义一个约束.假设`Person`的`Address`有一个`ZipCode`字段.这种情况一个方法如果这样命名:\n\n```java\nList<Person> findByAddressZipCode(ZipCode zipCode);\n```\n\n创建属性遍历`x.address.zipCode`.决策算法从把全部(`AddressZipCode`)作为属性开始并且检查实体类依此命名的属性(小写开头).如果算法成功了,就是用这个属性.否则,算法将源码部分驼峰式大小写从右侧头部到尾巴分隔,并试图找到相应的属性,在我们的例子中,`AddressZip`和`Code`.如果从头部找到一个属性,算法将在这里生成树处理后面的部分,使用描述的方式分隔.如果第一个分隔没有匹配到,算法移动分割点到左侧继续(`Address`,`ZipCode`).\n\n这在大多数情况都可以使用,但也可能选择错误的属性.假设`Person`类也有一个`addressZip`属性.算法将匹配第一个匹配的,本质上选择了错误属性,最终失败(伴随的`addressZip`类型没有属性`code`).\n\n没了解决这种起义,你可以在方法名称内使用`_`手动的定义遍历点.所以我们的方法名称最终像这样:\n\n```java\nList<Person> findByAddress_ZipCode(ZipCode zipCode);\n```\n\nAs we treat underscore as a reserved character we strongly advise to follow standard Java naming\nconventions (i.e. not using underscores in property names but camel case instead) \n\n我们对待下划线当做一个保留关键字,我们强力建议遵循标准Java命名规范(例如,使用驼峰命名而不是下划线命名属性名称)\n\n### 4.4.4 特殊参数处理\n\n处理你查询中的参数,你可以定义简单的方法参数像上面的示例中.处理之外基本组件可以识别出某些特殊类型例如`Pageable`和`Sort`用来动态的编码和排序你的查询.\n\n例12.在查询方法使用`Pageable`,`Slice`和`Sort`\n\n```java\nPage<User> findByLastname(String lastname, Pageable pageable);\nSlice<User> findByLastname(String lastname, Pageable pageable);\nList<User> findByLastname(String lastname, Sort sort);\nList<User> findByLastname(String lastname, Pageable pageable);\n```\n\n第一个方法允许你在通过一个`org.springframework.data.domain.Pageable`实例在查询方法中动态添加分页信息在你的静态定义查询中.一个`Page`清楚数据的全部数量和页面总数.它是通过触发计数的基础设施查询计算总数。这个代价可能是昂贵的具体取决于所使用的存储,可以用`Slice`代替.一个`Slict`只知道下一个`Slice`可到到哪里,当运行在一个大的结果集上时这可能已经足够了.排序选项也通过`Pageable`实例处理.如果你只需要排序,简单起见添加`org.springframework.data.domain.Sort`参数在你的方法.如你所见,简单返回一个列表.在这种情况下,额外元数据构建实际的`Page`实例将不会被创建(反过来这意味着,没有发出额外的统计查询所必须的)简单约束只在给定的范围内查询.\n\n> 注意\n>\n> 为了尽早得到你查询了多少页,你必须出发一个格外统计查询.默认的,这个查询你实际触发的查询调用.\n\n### 4.4.5 限制查询结果\n\n查询方法的结果可以通过关键`first`或者`top`限制,可以交换使用.一个可选的数值可以追加在top/first来指定返回的最大结果集.如果数字缺失,假定结果集大小是1.\n\n例13.查询中使用Top和First限制结果大小\n\n```java\nUser findFirstByOrderByLastnameAsc();\nUser findTopByOrderByAgeDesc();\nPage<User> queryFirst10ByLastname(String lastname, Pageable pageable);\nSlice<User> findTop3ByLastname(String lastname, Pageable pageable);\nList<User> findFirst10ByLastname(String lastname, Sort sort);\nList<User> findTop10ByLastname(String lastname, Pageable pageable);\n```\n\n限制表达式也支持Distinct关键字.此外，对于将结果集设置为一个实例的查询，支持将结果包装到一个`Optional`.如果应用分页或分片限制查询分页(并且计算可用的页数)那么这可以应用limited结果.\n\n> 注意\n>\n> 请注意，限制结果结合使用`Sort`的动态排序的结果允许参数可以表示“k”最小的查询方法以及“K”的查询方法最大的元素。\n\n### 4.4.6 流式处理结果\n\n方法查询结果可以通过使用java 8`Stream<T>`逐步处理。\n\n特定的方法用来表示流而不是简单的包装查询结果在一个`Stream`数据存储\n\n例14 一个用java流8`Stream<T>`查询结果\n\n```java\n@Query(\"select u from User u\")\nStream<User> findAllByCustomQueryAndStream();\n\nStream<User> readAllByFirstnameNotNull();\n\n@Query(\"select u from User u\")\nStream<User> streamAllPaged(Pageable pageable);\n```\n\n> 注意\n>\n> 一个`Stream`潜在的包装底层数据存储在页数的资源中,因此使用完毕必须关闭.你可以使用`close()`方法手动关闭`Stream`或者使用一个Java7的try_with-resources块.\n\n```java\ntry(Stream<User> stream = repository.findAllByCustomQueryAndStream()) {\n  stream.forEach(...);\n}\n```\n\n### 4.4.7 异步查询结果\n\nRepository查询可以使用`Spring's asynchronous method execution capacity`执行异步.这意味着方法可以一执行立即返回,真实的查询执行发生在任务提交到一个Spring TaskExecutor.\n\n```java\n@Async\nFuture<User> findByFirstname(String firstname);\n\n@Async\nCompletableFuture<User> findOneByFirstname(String firstname);\n\n@Async\nListenableFuture<User> findOneByLastname(String lastname);\n```\n\n1. 使用`java.util.concurrent.Future`作为返回类型\n2. 使用一个Java8`java.util.current.CompletableFuture`作为返回类型\n3. 使用一个`org.springframework.util.concurrent.ListenableFuture`作为返回类型\n\n## 创建repository实例\n\n这个章节你创建实例和bean定义为repository接口定义.方法之一是手动的支持repository使用包含各个Spring Data模块的Spring命名空间装载,然而我们一般推荐使用Java配置的方法配置.\n\n### 4.5.1 XML配置\n\n每个Spring Data module包含一个repository 元素,这可以让你简单的定义一个基本包,Spring为你扫描它.\n\n例16 通过XML启用Spring Data repositories\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans:beans xmlns:beans=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns=\"http://www.springframework.org/schema/data/jpa\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/jpa\n        http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\">\n      <repositories base-package=\"com.acme.repositories\" />\n    </beans:beans>\n```\n\n在前面的实例中,让Spring扫描`com.acme.repositories`包和它的子包里继承`Repository`的接口或者它的子接口.找到的每个接口,继承组件注册持久化技术的`FactoryBean`来创建合适的代理处理执行查询方法.每个bean被注册在一个接口名称确定的bean name下,所以一个叫`UserRepository`将注册`userRepository`.基本包属性允许通配符,所以你可以定义一个规则扫描包.\n\n**使用过滤**\n\n默认的基本组件选取所有在配置的基本包下继承了持久化技术`Repositpry`接口以及子接口\n\n并且为他们创建一个bean实例.然而,你可能希望更细粒度的控制哪个接口bean实例被创建.为了实现这个你可以在`<repository/>`中使用`<include-filter/>`和`<exclude-filter/>`元素.语义完全等同于Spring的上下文命名空间中的元素.更多细节,查看他们的元素`Spring reference documentation`\n\n例如，要将某些确定的接口排除实例化为repository，可以使用以下配置:\n\n例17. 使用exclude-filter元素\n\n```java\n<repository base-package=\"com.acme.repositories\">\n  <context:exclude-filter type=\"regex\" expression=\".*SomeRepository\" />\n</repositories>\n```\n\n这个示例从待实例化对象中排除所有以SomeRepository结尾的接口.\n\n### 4.5.2 JavaConfig\n\nrepository基础组件也可以使用一个存储的特殊的`@Enable${store}Repositories`注解在一个JavaConfig类上.入门介绍Spring容器Java基本Spring容器查看文档:`JavaConfig in the Spring reference documentaional`\n\n一个简单配置启用Spring Data repositories像这样:\n\n例18. repository配置基于简单注解\n\n```java\n@Configuration\n@EnableJpaRepositories(\"com.acme.repositories\")\nclass ApplicationConfiguration {\n  @Bean\n  public EntityManagerFactory entityManagerFactory() {\n    // …\n  }\n}\n```\n\n> 注意\n>\n> 示例使用了JPA特有的注解,根据你使用的存储模块决定实际如何替换.示例定义`EntityManagerFactory`bean.查阅具体存储的配置\n\n### 4.5.3 单独使用\n\n你也可以在Spring容器之外使用repository基础组件,例如在CDI环境.你仍然需要一些Spring库在你的classpath中,但是你可以以编程的方式启动.repository包装持久化技术支持的Spring Data模块提供RepositoryFactory,你可以向下面这样使用:\n\n例19. repository工厂单独使用\n\n```java\nRepositoryFactorySupport factory = … // Instantiate factory here\nUserRepository repository = factory.getRepository(UserRepository.class);\n```\n\n## 4.6 定制Spring Data仓库实现\n\n时常有必要为一少部分仓库方法提供一个定制的实现.Spring数据存储库很容易允许您提供自定义存储库代码并将其与通用CRUD集成抽象和查询方法功能整合.\n\n### 4.6.1 为单独仓库添加定制行为\n\n为了定制功能丰富一个仓库,你首先为定制功能定义一个接口和实现.使用你提供的仓库接口来继承自定义接口.\n\n例20. 定制仓库功能的接口\n\n```java\ninterface UserRepositoryCustom {\n  public void someCustomMethod(User user);\n}\n```\n\n例21.定制功能的实现\n\n```java\nclass UserRepositoryImpl implements UserRepositoryCustom {\n  public void someCustomMethod(User user) {\n    // Your custom implementation\n  }\n}\n```\n\n> 注意\n>\n> 类可以被找到最重要的点是名字以Impl为后缀区别于仓库的核心接口(见下文)\n\n实现的本身没有依赖Spring Data,可以是一个标准的Spring bean.所以你可以使用标准的依赖注入行为给其他bean注入引用,像`JdbcTemplate`,切面的一部分等等.\n\n例22 修改你基本的仓库接口\n\n```java\ninterface UserRepository extends CrudRepository<User, Long>, UserRepositoryCustom {\n  // Declare query methods here\n}\n```\n\n让你的标准仓库接口继承定制的.这样做结合了CRUD和定制功能并使其可用于客户端.\n\n**配置**\n\n如果你使用命名空间配置,仓库基本组件扫描类所在包,根据扫描结果尝试自动定制实现.\n\n这些类需要遵循命名规范:给仓库接口名添加命名空间元素属性`repositoryimpl-postfix`.默认的后缀是`Impl`\n\n例23. 配置示例\n\n```xml\n<repositories base-package=\"com.acme.repository\" />\n<repositories base-package=\"com.acme.repository\" repository-impl-postfix=\"FooBar\"/>\n```\n\n第一个配置示例将查实查找一个类`com.acme.repository.UserRepositoryImpl`来作为定制藏局实现.然而第二个示例将尝试查找`com.acme.repository.UserRepositoryFooBar `.\n\n\n**手动指定**\n\n上面的方法可以正常工作,只有当你定制实现使用注解配置和自动注入,这将与其他Spring bean一样被对待.如果你定制的实现需要特殊处理,你可以像描述的简单定义一个bean并且命名它.基本组件将通过名称引用手动定义的bean定义而不是它自己创建一个.\n\n例24.手动指定定制实现\n\n```xml\n<repositories base-package=\"com.acme.repository\" />\n<beans:bean id=\"userRepositoryImpl\" class=\"…\">\n  <!-- further configuration -->\n</beans:bean>\n```\n\n### 4.6.2为所有仓库添加定制行为\n\n当你希望把一个单独的方法添加到你所有的仓库接口中时,上面的方法就不可行了.为了添加定制到所有的仓库,你首先添加一个中间接口来定义共享的行为.\n\n例25 定义共享定制行为接口\n\n```java\n@NoRepositoryBean\npublic interface MyRepository<T, ID extends Serializable>\n  extends PagingAndSortingRepository<T, ID> {\n  void sharedCustomMethod(ID id);\n}\n```\n\n现在你独立的仓库接口将继承这个中间接口而不是`Repository`接口来包含功能的定义.接下来创建一个中间接口的实现继承持久化具体仓库的基本类.这个类后面将作为仓库代理的基本类.\n\n例26 定制仓库基本类\n\n```java\npublic class MyRepositoryImpl<T, ID extends Serializable>\n  extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {\n  \n  private final EntityManager entityManager;\n  \n  public MyRepositoryImpl(JpaEntityInformation entityInformation,\n                          EntityManager entityManager) {\n    super(entityInformation, entityManager);\n    // Keep the EntityManager around to used from the newly introduced methods.\n    this.entityManager = entityManager;\n  }\n  \n  public void sharedCustomMethod(ID id) {\n    // implementation goes here\n  }\n}\n```\n\n> 警告\n>\n> 这个类需要有一个构造方法调用父类具体存储仓库工厂实现.万一仓库基础类有多个构造,覆盖包括一个`EntityInformation `加上存储具体基本组件对象(例如一个`EntityManager `或者模板类)\n\nSpring`<repository/>`命名空间下的默认行为为所有接口提供一个实现.这意味着如果处于其当前状态，`MyRepository`的实现实例将由Spring创建.这当然不是被期望的,它只是作为一个用来定义实体的 `Repository`和真实仓库接口的中间接口.为了排除一个继承`Repository`的接口被当做一个仓库接口实例化,你可以给它使用`@NoRepositoryBean`(像上面)或者把它从配置中`base-package`移除.\n\n最后一步是让Spring Data基本组件识别到定制的仓库基本类.在JavaConf使用注解`@Enable...Repository`的属性`repositoryBaseClass`完成:\n\n例27 使用JavaConfig配置一个定制仓库基本类\n\n```java\n@Configuration\n@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)\nclass ApplicationConfiguration { … }\n```\n\n类似的属性在XML命名空间中也可以找到.\n\n例28 使用XML配置一个定制仓库基本类\n\n```xml\n<repositories base-package=\"com.acme.repository\"\n              base-class=\"….MyRepositoryImpl\" />\n```\n\n## 4.7 Spring Data扩展\n\n这部分说明Spring Data一系列的扩展功能,可以使Spring Dta使用多样的上下文.目前大部分集成是针对Spring MVC.\n\n### 4.7.1 Querydsl扩展\n\nQuerydsl是一个框架,通过它的流式API构建静态类型的SQL类查询.\n\n多个Spring Data模块通过`QueryDslPredicateExecutor `与Querydsl集成.\n\n例29 QueryDslPredicateExecutor接口\n\n```java\npublic interface QueryDslPredicateExecutor<T> {\n  T findOne(Predicate predicate); ①\n    Iterable<T> findAll(Predicate predicate); ②\n    long count(Predicate predicate); ③\n    boolean exists(Predicate predicate); ④\n    // … more functionality omitted.\n}\n```\n\n① 查询并返回一个匹配`Predicate `的单例实体\n\n②查询并返回所有匹配`Predicate`的实体\n\n③ 返回匹配`Predicate`的实体数量\n\n④  返回是否存在一个匹配`Predicate`的实体\n\n为了简单的使用Querydsl功能,在你的仓库接口继承`QueryDslPredicateExecutor`.\n\n例30 在仓库集成QueryDsl\n\n```java\ninterface UserRepository extends CrudRepository<User, Long>,\n  QueryDslPredicateExecutor<User> {\n}\n```\n\n像上面这样就可以使用Querydsl的`Predicate`书写类型安全的查询\n\n```java\nPredicate predicate = user.firstname.equalsIgnoreCase(\"dave\")\n  .and(user.lastname.startsWithIgnoreCase(\"mathews\"));\nuserRepository.findAll(predicate);\n```\n\n### 4.7.2 Web支持\n\n> 注意\n>\n> 本节包含Spring Data Web支持的文档是在1.6范围内的Spring Data Commons实现的.因为支持新引入的内容改变了很多东西，我们保留了旧行为的文档在\"遗留Web支持\"部分.\n>\n\n如果模块支持仓库编程模型，那么Spring Data模块附带了各种Web模块支持.Web关联的东西需要Spring MVC的JAR包位于classpath路径下,它们中有些甚至提供了Spring HATEOAS集成.一般情况,集成方式支持使用`@EnableSpringDataWebSupport`注解在你的JavaConfig配置类.\n\n例31 启用Spring Data web支持\n\n```java\n@Configuration\n@EnableWebMvc\n@EnableSpringDataWebSupport\nclass WebConfiguration {}\n```\n\n`@EnableSpringDataWebSupport`注解注册了一些组件，我们将在稍后讨论.注解还将在类路径上检测Spring HATEOAS，如果才在将为其注册集成组件.\n\n作为可选项,如果你使用XML配置,注册`SpringDataWebSupport`或者`HateoasWareSpringDataWebSupport`作为Spring bean:\n\n例32 用XML启用Spring Data web支持\n\n```xml\n<bean class=\"org.springframework.data.web.config.SpringDataWebConfiguration\" />\n<!-- If you're using Spring HATEOAS as well register this one *instead* of the\nformer -->\n<bean class= \"org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration\" />\n```\n\n**基本Web支持**\n\n上面展示的的配置设置将注册几个基本组件：\n\n- 一个`DomainClassConverter`启用Spring MVC来根据请求参数或路径变量管理仓例实体类的实例\n- `HandlerMethodArgumentResolver`实现让Spring MVC从请求参数解析Pageable和Sort实例.\n\n**实体类转换**\n\n`DomainClassConverter`允许你在Spring MVC控制器方法签名中直接使用实体类型,因此你不必手动的通过仓库查询实例:\n\n例33 一个Spring MVC控制器在方法签名中使用实体类型\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") User user, Model model) {\n    model.addAttribute(\"user\", user);\n    return \"userForm\";\n  }\n}\n```\n\n如你所见,方法直接接收一个User实例并没有更进一步的查询是否必要.实例可以通过Spring MVC将路径变量转换为实体类的id类型并最终通过在实体类型注册的仓库实例上调用`findOne(...)`访问实例转换得到.\n\n> 注意\n>\n> 当前的仓库必须实现`CrudRepository`做好准备被发现来进行转换.\n\n**为了分页和排序分解方法参数**\n\n上面的配置片段还注册了一个`PageableHandlerMethodArgumentResolver`和一个`SortHandlerMethodArgumentResolver`实例.注册使得Pageable和Sort成为有效的控制器方法参数.\n\n例34 使用Pageable作为控制器方法参数\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @Autowired UserRepository repository;\n  @RequestMapping\n  public String showUsers(Model model, Pageable pageable) {\n    model.addAttribute(\"users\", repository.findAll(pageable));\n    return \"users\";\n  }\n}\n```\n\n这个方法签名将使Spring MVC尝试使用下面的默认配置从请求参数中转换一个Pageable实例:\n\n表1 请求参数转换Pageable实例\n\n| 参数   | 说明                                       |\n| ---- | ---------------------------------------- |\n| page | 要检索的页面,索引为0,默认为0                         |\n| size | 要检索的页面大小,默认20                            |\n| sort | 被排序的属性应以格式`property,property(, ASC\\|DESC)`表示.默认生序排序,如果你希望改变排序顺序,则使用多个排序参数,例如?sort=firstname&sort=lastname,asc |\n\n为了定制行为,可以继承`SpringDataWebConfiguration`或者启用等效的HATEOAS并覆盖`pageableResolver()`或`sortResolver()`方法并导入你的自定义配置文件替代@Enable-注解.\n\n有一种情况你需要多个`Pageable`或`Sort`实例从请求转换(例如处理多个表单),你可以使用Spring的`@Qualifier`注解来互相区别.请求参数必须以`${qualifier}为`前缀.这样一个方法的签名像这样:\n\n```java\npublic String showUsers(Model model, \n                        @Qualifier(\"foo\")Pagebale first, \n                        @Qualifier(\"bar\") Pageable second) {\n  ...\n}\n```\n\n你必须填充foo_page和bar_page等.\n\n默认的`Pageable`在方法中处理等价于一个`new PageRequest(0, 20)`,但是可以使用`@PageableDefaults`注解在`Pageable`参数上定制.\n\n**Hypermedia支持分页**\n\nSpring HATEOAS包装了一个代表模型的类`PageResources` ,\n\n它可以使用Page实例包装必要的Page元数据内容作为连接让客户端导航页面.一个页面到一个`PageResources`的转换被Spring HATEOAS的`ResourceAssembler`接口实现`PagedResourcesAssembler `来完成.\n\n例35 使用一个PagedResourcesAssembler作为控制器方法参数\n\n```java\n@Controller\nclass PersonController {\n  @Autowired PersonRepository repository;\n  @RequestMapping(value = \"/persons\", method = RequestMethod.GET)\n  HttpEntity<PagedResources<Person>> persons(Pageable pageable,\n                                             PagedResourcesAssembler assembler) {\n    Page<Person> persons = repository.findAll(pageable);\n    return new ResponseEntity<>(assembler.toResources(persons), HttpStatus.OK);\n  }\n}\n```\n\n像上面这样配置将允许`PageResourcesAssembler`作为控制器方法的一个参数.在这调用toResources(...)方法有以下作用:\n\n- `Page`的内容将`PageResources`实例的内容\n- `PageResources`将获得`PageMetadata`实例,该实例由Page和基础的PageRequest中的信息填充\n- `PageResources`获得`prev`和`next`连接,添加这些依赖在页面.这些链接将指向uri方法的调用映射.页码参数根据`PageableHandlerMethodArgumentResolver`添加到参数以在后面被转换.\n\n假设我们有30个Person实例在数据库.你现在可以触发一个GET请求 http://localhost:8080/persons, 你将可以看到类似下面的内容:\n\n```json\n{ \"links\" : [ { \"rel\" : \"next\",\n\"href\" : \"http://localhost:8080/persons?page=1&size=20 }\n],\n\"content\" : [\n… // 20 Person instances rendered here\n],\n\"pageMetadata\" : {\n\"size\" : 20,\n\"totalElements\" : 30,\n\"totalPages\" : 2,\n\"number\" : 0\n}\n}\n```\n\n你可以看到编译生成了正确的URI，并且还会提取默认配置转换参数到即将到来的请求中的`Pageable`.这意味着,如果你改变配置,链接也将自动跟随改变.默认情况下，编译指向控制器执行的方法，但是这可以被一个自定义链接作为基本构建来构成分页的`Link`重载`PagedResourcesAssembler.toResource（...）`方法定制.\n\n**Querydsl web 支持**\n\n那些整合了`QueryDSL`的存储可能从`Request`查询字符串中的属性驱动查询.\n\n这意味着前面例子的查询字符串可以给出`User`的对象\n\n```\n?firstname=Dave&lastname=Matthews\n```\n\n可以被转换为\n\n```java\nQUser.user.firstname.eq(\"Dave\").and(QUser.user.lastname.eq(\"Matthews\"))\n```\n\n使用了`QuerydslPredicateArgumentResolver`.\n\n> 注意\n>\n> 当在类路径上找到Querydsl时，该功能将在@EnableSpringDataWebSupport注解中自动启用\n\n添加一个`@QuerydslPredicate`到一个方法签名将提供一个就绪的`Predicate`,可以通过`QueryDslPredicateExecutor`执行.\n\n> 提示\n>\n> 类型信息通常从返回方法上解析.由于这些信息不一定匹配实体类型,使用`QuerydslPredicate`的`root`属性可能是个好主意.\n\n```java\n@Controller\nclass UserController {\n  @Autowired UserRepository repository;\n  @RequestMapping(value = \"/\", method = RequestMethod.GET)\n  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,\n              Pageable pageable, @RequestParam MultiValueMap<String, String>\n    parameters) {\n        model.addAttribute(\"users\", repository.findAll(predicate, pageable));\n        return \"index\";\n  } \n}\n```\n\n为User转换匹配查询字符串参数的`Predicate`\n\n默认的绑定规则如下:\n\n1. `Object`在简单属性上如同`eq`\n\n2. `Object`在集合作为属性如同`contains`\n\n3. `Collection`在简单属性上如同`in`\n\n\n这些绑定可以通过`@QuerydslPredicate`的`bindings`属性定制或者使用Java8`default methods`给仓库接口添加`QuerydslBinderCustomizer`\n\n```java\ninterface UserReposotory extends CurdRepository<User, String>, \n  QueryDslPredicateExecutor<User>,\n  QuerydslBinderCustomizer<QUser> {\n    @Override\n  \tdefault public void customize(QuerydslBindings bindings, QUser user) {\n      bindings.bind(user.username).first((path, value) -> path.contains(value));\n      bindings.bind(String.class).first((StringPath path, String value) ->\n                                        path.containsIgnoreCase(value));\n      bindings.excluding(user.password);\n  \t}\n  }\n```\n\n1. `QueryDslPredicateExecutor`为`Predicate`提供特殊的查询方法提供入口\n2. 在仓库接口定义`QuerydslBinderCustomizer`将自动注解`@QuerydslPredicate(bindings=...)`\n3. 为`username`属性定义绑定,绑定到一个简单集合\n4. 为`String`属性定义默认绑定到一个不区分大小写的集合\n5. 从`Predicate`移除密码属性\n\n### 4.7.3 仓库填充\n\n如果你使用Spring JDBC模块,你可能熟悉在`DataSource`使用SQL脚本来填充.一个类似的抽象在仓库级别可以使用,尽管它不是使用SQL作为数据定义语言,因为它必须由存储决定.填充根据仓库支持XML(通过Spring的OXM抽象)和JSON(通过Jackson)定义数据.\n\n假设你有一个文件`data.json`内容如下:\n\n例36 JSON定义的数据\n\n```json\n[ { \"_class\" : \"com.acme.Person\",\n     \"firstname\" : \"Dave\",\n      \"lastname\" : \"Matthews\" },\n      { \"_class\" : \"com.acme.Person\",\n     \"firstname\" : \"Carter\",\n      \"lastname\" : \"Beauford\" } ]\n```\n\n你可以容易的根据Spring Data Commons提供仓库的命名空间填充元素填充你的仓库.为了填充前面的数据到你的PersonRepository,像下面这样配置:\n\n例37 声明一个Jackson仓库填充\n\n```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:repository=\"http://www.springframework.org/schema/data/repository\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/repository\n        http://www.springframework.org/schema/data/repository/spring-repository.xsd\">\n      <repository:jackson2-populator locations=\"classpath:data.json\" />\n    </beans>\n```\n\n这样的声明可以让`data.json`文件可以被一个Jackson的`ObjectMpper`读取和反序列化.\n\nJSON将要解析的对象类型由检查JSON文档的`_class`属性决定.基本组件将最终选择合适的仓库去处理反序列化的对象.\n\n要使用XML定义数据填充仓库,你可以使用`unmarshaller-populator`元素.你配置它使用Spring OXM提供给你的XML装配选项.在Spring reference documentation查看更多细节.\n\n例38 声明一个装配仓库填充器(使用JAXB)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:repository=\"http://www.springframework.org/schema/data/repository\"\n      xmlns:oxm=\"http://www.springframework.org/schema/oxm\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/repository\n        http://www.springframework.org/schema/data/repository/spring-repository.xsd\n        http://www.springframework.org/schema/oxm\n        http://www.springframework.org/schema/oxm/spring-oxm.xsd\">\n      <repository:unmarshaller-populator locations=\"classpath:data.json\"\n        unmarshaller-ref=\"unmarshaller\" />\n      <oxm:jaxb2-marshaller contextPath=\"com.acme\" />\n    </beans>\n```\n\n### 4.7.4 遗留web支持\n\n**Spring MVC的实体类绑定**\n\n如果正在开发Spring MVC web应用,你通常必须从URL中解析实体类的id.默认的,你的任务是转化请求参数或URL参数到实体类并将它移交给下面或直接在实体上操作业务逻辑.这看起来像下面这样:\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  private final UserRepository userRepository;\n  \n  @Autowired\n  public UserController(UserRepository userRepository) {\n    Assert.notNull(repository, \"Repository must not be null!\");\n    this.userRepository = userRepository;\n  }\n\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") Long id, Model model) {\n    // Do null check for id\n    User user = userRepository.findOne(id);\n    // Do null check for user\n    model.addAttribute(\"user\", user);\n    return \"user\";\n  }\n}\n```\n\n首先你为每个控制器定义一个依赖的仓库来查找它们分别管理的实体.查询实体也是样板,因为它总是一个`findOne(...)`调用.幸运的Spring提供了方法来注册自定义组件,允许一个String值转换到一个属性类型.\n\n**属性编辑**\n\nSpring3.0之前Java`PropertyEditors`被使用.为了集成这些,Spring Data提出一个`DomainClassPropertyEditorRegistrar`来查询所有注册到`ApplicatonContext`的Spring Data仓库和一个定制的`PropertyEditor`来管理实体类.\n\n```xml\n<bean class=\"….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\">\n  <property name=\"webBindingInitializer\">\n    <bean class=\"….web.bind.support.ConfigurableWebBindingInitializer\">\n      <property name=\"propertyEditorRegistrars\">\n        <bean class=\n          \"org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar\" />\n      </property>\n    </bean>\n  </property>\n</bean>\n```\n\n如果你已经像上面这样配置Spring MVC,你可以向下面这样配置你的控制器,从而减少不清晰和样板式的代码\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") User user, Model model) {\n    model.addAttribute(\"user\", user);\n    return \"userForm\";\n  }\n}\n```\n\n","source":"_posts/【翻译】SpringData官方文档第四章.md","raw":"---\ntitle: 【翻译】SpringData官方文档第四章\ndate: 2016-11-27\ntags:\n  - 翻译\ncategories: 翻译\n---\n说明：本翻译[4.6](http://ifeve.com/repositories-custom-implementations/)和[4.7](http://ifeve.com/spring-data-4-7/)段发布在[并发编程网](http://ifeve.com/),其他段落为了熟悉上下文而翻译，没有精校。首次参与翻译任务，翻译的不好请指正。\n\n---\n\n# 第四章 使用Spring Data Repositories\n\nSpring Data repository abstraction目的是为了显著的简化必要的样板式代码来为多种持久化数据存储实现数据层。\n\n> 重要\n>\n> 本章解释Spring Data repositories核心的概念和接口。Spring Data repository documentation 与 你的模块。本章这些信息是从Spring Data Commons模块获取的。它使用了JPA模块的配置和代码示范,命名引用覆盖XML配置，它支持所有的Spring Data模块支持的repository API，Repository查询关键字覆盖被repository 接口一般的关键字查询方法。你的模块特性的细节信息，查询文档对应模块。\n>\n\n## 4.1 核心概念\n\nSpring Data repository抽象接口的核心是`Repository`（可能没有那么惊喜）。它需要管理实体类以及实体类的id作为参数。此接口主要用作是获取要使用的类型接口并帮助扩展这个接口。\n\n`CrudRepository`为被管理的实体类提供复杂CRUD功能。\n\n## 4.2 查询方法\n\n标准的CRUD功能repositories通常有查询底层数据库。\n\n在Spring Data中，分词声明这些查询变成了四个步骤的过程：\n\n1. 声明一个接口继承`Repository`或者它的一个子类，并且指定要被处理的实体类和Id类型。\n\n   ```java\n   interface PersonRepository extends Repository<Person, Long> { … }\n   ```\n\n\n1. 在接口中声明查询方法。\n\n   ```java\n   interface PersonRepository extends Repository<Person, Long> {\n     List<Person> findByLastname(String lastname);\n   }\n   ```\n\n\n1. 创建Spring生成代理实现上面接口，通过JavaConfig：\n\n   ```java\n   import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n   @EnableJpaRepositories\n   class Config {}\n   ```\n\n   或者通过XML配置：\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xmlns:jpa=\"http://www.springframework.org/schema/data/jpa\"\n   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n   http://www.springframework.org/schema/beans/spring-beans.xsd\n   http://www.springframework.org/schema/data/jpa\n   http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\">\n   <jpa:repositories base-package=\"com.acme.repositories\"/>\n   </beans>\n   ```\n\n   这个实例中使用了JPA命名空间。\n\n   如果你为其他存储使用repository接口，你需要修改来适应你的存储模块命名空间的声明，大概就是替换jpa为期望的，例如mongodb。\n\n   当然，注意JavaConfig并没有明确配置一个包默认使用注解的包。\n\n   为了定制包被扫描可以使用数据存储注解`@Enable`的一个属性`basePackage`。\n\n\n1. 获得repository实例注入并使用。\n\n   ```java\n   public class SomeClient {\n     @Autowired\n     private PersonRepository repository;\n     public void doSomething() {\n       List<Person> persons = repository.findByLastname(\"Matthews\");\n     }\n   }\n   ```\n\n\n以下部分详细说明每个步骤。\n\n## 4.3 定义repository接口\n\n第一步定义一个实体类依赖repository接口。\n\n这个接口必须继承`Repository`接口并且指定实体类型和Id类型。\n\n如果你希望实体类型拥有CRUD方法，将`Repository`接口替换成继承`CrudRepository`。\n\n### 4.3.1 小巧repository定义 \n\n一般情况下，你的repository接口应该继承`Repository`，`CrudRepository`或者`PagingAndSortingRepository`\n\n除此之外,如果你不想继承Spring Data接口,你也可以使用`@Repository`注解定义你的接口\n\n继承`CrudRepository`提供了一系列完整的方法来操纵你的实体.\n\n如果你希望选择方法,简单的从`CurdRepository`复制你希望获得的方法到你的`Repository`\n\n> 注意\n>\n> 注意这允许你定义你自己的抽闲建立在Spring Data Repositories功能.\n\n例5.有选择的展现`CRUD`方法\n\n```java\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends Repository<T, ID> {\n  T findOne(ID id);\n  T save(T entity);\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  User findByEmailAddress(EmailAddress emailAddress);\n}\n```\n\n这是第一步你定义一个通用的基本接口,接口供你所有的实体repositories使用并提供`findOne()`和`save()`方法\n\n这些方法会被转发到你选择的Spring Data提供的基本repository实现,例如JPA`SimpleJpaRepository`,因为他们匹配`CrudRepository`的方法签名.\n\n因此`UserPepository`现在可以保存用户,查找唯一用户根据id,并且触发一个查询去查找`Users`根据他们的邮箱地址\n\n> 注意\n>\n> 注意,中间的repository接口使用了注解`NoRepositoryBean`.\n>\n> 对所有Spring Data在运行时不需要生成实例的repository接口,确保你为他们添加了注解.\n\n### 4.3.2 在多个Spring Data模块使用Repositories\n\n在你的应用中使用唯一的Spring Data模块,所有repository接口定义范围限制在Spring Data模块.\n\n有时候应用需要使用不止一个Spring Data模块.\n\n这种情况下,需要repository定义在持久化技术之间有所区别.\n\n在class path发现多个repository工厂时,Spring Data严格检测repository配置模块.\n\n在repository或者实体类严格配置需要得细节以决定Spring Data模块绑定一个repository的定义:\n\n1. 如果repository定义继承模块特殊的repository,那么对Spring Data模块这是一个有效的备选.\n\n\n1. 如果实体类被模块特有的注解类型注解,那么对Spring Data模块这是一个有效的备选.\n\n   Spring Data模块接收第三方注解(例如 JPA的`@Entity`)或者提供自己的注解例如`@Document`为Spring Data MongoDB/Spring Data Elasticsearch.\n\n\n例6.使用模块特有的接口定义Repository\n\n```java\ninterface MyRepository extends JpaRepository<User, Long> { }\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends JpaRepository<T,ID{\n  …\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  …\n}\n```\n\n`MyRepository`和`UserRepository`继承`JpaRepository`在他们类型层级.他们有效的表示了Spring Data JPA模块.\n\n例7.使用通用的接口定义`Repository`.\n\n```java\ninterface AmbiguousRepository extends Repository<User, Long> {\n  …\n}\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends\n  CrudRepository<T,ID> {\n  …\n}\n\ninterface AmbiguousUserRepository extends MyBaseRepository<User, Long> {\n  …\n}\n```\n\n`AmbiguousRepository`和`AmbiguousUserRepository`在它们继承体系里只继承了`Repository`和`CrudRepository`.使用唯一的Spring Data模块是这是完成正确的,多个模块不能识别`Repository`到底绑定哪个Spring Data.\n\n例8.使用注解配合实体类定义`Repositor`\n\n```java\ninterface PersonRepository extends Repository<Person, Long> {\n  …\n}\n\n@Entity\npublic class Person {\n  …\n}\n\ninterface UserRepository extends Repository<User, Long> {\n  …\n}\n\n@Document\npublic class User {\n  …\n}\n```\n\n`PersonRepository`引用使用了JPA的注解`@Entity`进行注解的`Person`,所以这个repository明确的属于Spring Data JPA.`UserRepository`使用了Spring Data MongoDB的注解`@Document`进行注解.\n\n例9.使用混合注解配合实体类定义`Repositor`\n\n```java\ninterface JpaPersonRepository extends Repository<Person, Long> {\n  …\n}\n\ninterface MongoDBPersonRepository extends Repository<Person, Long> {\n  …\n}\n\n@Entity\n@Document\npublic class Person {\n  …\n}\n```\n\n这个示例展示实体类同时使用JPA和Spring Data MongoDB注解.\n\n这里定义了两个repository,`JpaPersonRepository`和`MongoDBPersonRepository`.\n\n一个被JPA使用,另一个被MongoDB使用.\n\nSpring Data不再能告诉repository区分,这将导致不清晰的行为\n\n\"使用模块特有的接口定义Repository\"和\"使用注解配合实体类定义`Repositor`\"都使用了严格的repository配置为一个特定的Spring Data模块识别可选的repository\n\n\n使用多种持久化技术特定的注解在同一个实体类上可能在锅中持久化技术上重用了实体类,但是这样做Spring Data将不能确定为repository绑定唯一的模块\n\n最后一种方式区分repository是划分repository的基本包.\n\n\n基本包定义起始点是扫描repository接口定义,这意味着在合适的包定义repository.\n\n默认的,注解配置使用类配置的包\n\n基于XML基本配置在这里.\n\n例10.注解配置基本包\n\n```java\n@EnableJpaRepositories(basePackages = \"com.acme.repositories.jpa\")\n@EnableMongoRepositories(basePackages = \"com.acme.repositories.mongo\")\ninterface Configuration { }\n```\n\n\n\n## 4.4 Defining query methods\n\n## 4.4 定义查询方法\n\nrepository代理有两种方式获得通过方法名获得指定查询.可以通过方法名直接获得查询,或者手动定义查询.有可用的选项定义在实际的存储.这有一些策略决定实际查询如何被创建.让我们一些看看可用的选项.\n\n### 4.4.1 Query lookup strategies\n\n下面这些repository基本组件的决定查询可用的策略.你可以配置策略,在XML配置中通过命名空间`query-look-strategy`属性或者在Java配置中通过启用${store} Repository的属性注解`queryLookupStrategy`.一些策略可能不能支持特定的数据库.\n\n- CREATE 试图通过方法名构建一个指定查询.一般处理是从方法名移除一系列给定的前缀并解析方法其他部分.更多查询构建信息阅读Query creation.\n- USE_DECLARED_QUERY试图查找一个准确的查询,并在找不到时抛出一个异常.查询可以被通过注解定义或者其它方式定义.查询特殊存储的文档了解存储的可用选择.如果repository基本组件在启动时不能为方法找到一个准确的查询,将会失败\n- CREATE_IF_NOT_FOUND(默认)联合了CREATE和USE_DECLARED_QUERY.首先查找一个准确查询,如果没有找到,创建一个定制方法基于名字的查询.这是默认的查询策略,因此如果你没有做任何明确配置.它允许根据方法名快速查询定义,而且定制查询根据需要引入声明的查询.\n\n\n### 4.4.2 查询创建\n\n建成Spring Data repository基本组件的查询构建机制有用的构建了repository所有实体类的约束查询.\n\n这个机制分隔方法前缀`find...By`,`read...By`,`query...By`,`count...By`以及`get...By`,并解析其他部分.这个引入条款可以表达包含的特性例如`Distinct`,来设置明确的标志在要生成的查询上.然而,第一个by扮演了分解符来指明真实条件的起始.分词在一个非常基本的水平,你可以在实体属性上定义条件并且连接使用and或or连接他们.\n\n例11.来自方法名的查询创建\n\n```java\npublic interface PersonRepository extends Repository<User, Long> {\n  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String\n                                             lastname);\n  // Enables the distinct flag for the query\n  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String\n                                                       firstname);\n  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String\n                                                       firstname);\n\n  // Enabling ignoring case for an individual property\n  List<Person> findByLastnameIgnoreCase(String lastname);\n  // Enabling ignoring case for all suitable properties\n  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String\n                                                       firstname);\n  // Enabling static ORDER BY for a query\n  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);\n \n  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);\n}\n```\n\n解析方法的实际结果取决于你创建查询的持久化存储.然而,这有些问题需要注意:\n\n- 表达式通常串行的连接属性的遍历与操作符.你可以使用and和or连接属性表达式.你也可以给属性表达式使用操作符,例如between,lessThan,granterThan,like.你可以使用的表达式操作符有between,LessThan,GreaterThan,Loke.被支持的操作符根据多样的数据库决定,因此查询你引用文档的恰当部分.\n- 方法解析支持为单独属性设置一个IgnoreCase标志(例如,findByLastnameIgnoreCase(...))或者为所有属性都支持忽略情况(通常是String情形,例如,findByLastnameAndFirstnameAllIgnoreCase(…)).忽略情况是否被支持由多样的数据库决定，所以具体存储查询方法在引用文档查询相关章节.\n- 你可以为查询方法引用的属性提供静态排序连接OrderBy子句并且提供排序方向(Asc或Desc).为创建一个查询方法支持动态排序,查看特殊参数处理.\n\n\n\n### 4.4.3 属性表达式\n\n属性表达式可以只为管理的实体类的直接属性使用，就像前面所展示的那样。查询常见时你已经确认解析的字段是管理的实体类的一个字段.然而,你也可以通过最近的字段定义一个约束.假设`Person`的`Address`有一个`ZipCode`字段.这种情况一个方法如果这样命名:\n\n```java\nList<Person> findByAddressZipCode(ZipCode zipCode);\n```\n\n创建属性遍历`x.address.zipCode`.决策算法从把全部(`AddressZipCode`)作为属性开始并且检查实体类依此命名的属性(小写开头).如果算法成功了,就是用这个属性.否则,算法将源码部分驼峰式大小写从右侧头部到尾巴分隔,并试图找到相应的属性,在我们的例子中,`AddressZip`和`Code`.如果从头部找到一个属性,算法将在这里生成树处理后面的部分,使用描述的方式分隔.如果第一个分隔没有匹配到,算法移动分割点到左侧继续(`Address`,`ZipCode`).\n\n这在大多数情况都可以使用,但也可能选择错误的属性.假设`Person`类也有一个`addressZip`属性.算法将匹配第一个匹配的,本质上选择了错误属性,最终失败(伴随的`addressZip`类型没有属性`code`).\n\n没了解决这种起义,你可以在方法名称内使用`_`手动的定义遍历点.所以我们的方法名称最终像这样:\n\n```java\nList<Person> findByAddress_ZipCode(ZipCode zipCode);\n```\n\nAs we treat underscore as a reserved character we strongly advise to follow standard Java naming\nconventions (i.e. not using underscores in property names but camel case instead) \n\n我们对待下划线当做一个保留关键字,我们强力建议遵循标准Java命名规范(例如,使用驼峰命名而不是下划线命名属性名称)\n\n### 4.4.4 特殊参数处理\n\n处理你查询中的参数,你可以定义简单的方法参数像上面的示例中.处理之外基本组件可以识别出某些特殊类型例如`Pageable`和`Sort`用来动态的编码和排序你的查询.\n\n例12.在查询方法使用`Pageable`,`Slice`和`Sort`\n\n```java\nPage<User> findByLastname(String lastname, Pageable pageable);\nSlice<User> findByLastname(String lastname, Pageable pageable);\nList<User> findByLastname(String lastname, Sort sort);\nList<User> findByLastname(String lastname, Pageable pageable);\n```\n\n第一个方法允许你在通过一个`org.springframework.data.domain.Pageable`实例在查询方法中动态添加分页信息在你的静态定义查询中.一个`Page`清楚数据的全部数量和页面总数.它是通过触发计数的基础设施查询计算总数。这个代价可能是昂贵的具体取决于所使用的存储,可以用`Slice`代替.一个`Slict`只知道下一个`Slice`可到到哪里,当运行在一个大的结果集上时这可能已经足够了.排序选项也通过`Pageable`实例处理.如果你只需要排序,简单起见添加`org.springframework.data.domain.Sort`参数在你的方法.如你所见,简单返回一个列表.在这种情况下,额外元数据构建实际的`Page`实例将不会被创建(反过来这意味着,没有发出额外的统计查询所必须的)简单约束只在给定的范围内查询.\n\n> 注意\n>\n> 为了尽早得到你查询了多少页,你必须出发一个格外统计查询.默认的,这个查询你实际触发的查询调用.\n\n### 4.4.5 限制查询结果\n\n查询方法的结果可以通过关键`first`或者`top`限制,可以交换使用.一个可选的数值可以追加在top/first来指定返回的最大结果集.如果数字缺失,假定结果集大小是1.\n\n例13.查询中使用Top和First限制结果大小\n\n```java\nUser findFirstByOrderByLastnameAsc();\nUser findTopByOrderByAgeDesc();\nPage<User> queryFirst10ByLastname(String lastname, Pageable pageable);\nSlice<User> findTop3ByLastname(String lastname, Pageable pageable);\nList<User> findFirst10ByLastname(String lastname, Sort sort);\nList<User> findTop10ByLastname(String lastname, Pageable pageable);\n```\n\n限制表达式也支持Distinct关键字.此外，对于将结果集设置为一个实例的查询，支持将结果包装到一个`Optional`.如果应用分页或分片限制查询分页(并且计算可用的页数)那么这可以应用limited结果.\n\n> 注意\n>\n> 请注意，限制结果结合使用`Sort`的动态排序的结果允许参数可以表示“k”最小的查询方法以及“K”的查询方法最大的元素。\n\n### 4.4.6 流式处理结果\n\n方法查询结果可以通过使用java 8`Stream<T>`逐步处理。\n\n特定的方法用来表示流而不是简单的包装查询结果在一个`Stream`数据存储\n\n例14 一个用java流8`Stream<T>`查询结果\n\n```java\n@Query(\"select u from User u\")\nStream<User> findAllByCustomQueryAndStream();\n\nStream<User> readAllByFirstnameNotNull();\n\n@Query(\"select u from User u\")\nStream<User> streamAllPaged(Pageable pageable);\n```\n\n> 注意\n>\n> 一个`Stream`潜在的包装底层数据存储在页数的资源中,因此使用完毕必须关闭.你可以使用`close()`方法手动关闭`Stream`或者使用一个Java7的try_with-resources块.\n\n```java\ntry(Stream<User> stream = repository.findAllByCustomQueryAndStream()) {\n  stream.forEach(...);\n}\n```\n\n### 4.4.7 异步查询结果\n\nRepository查询可以使用`Spring's asynchronous method execution capacity`执行异步.这意味着方法可以一执行立即返回,真实的查询执行发生在任务提交到一个Spring TaskExecutor.\n\n```java\n@Async\nFuture<User> findByFirstname(String firstname);\n\n@Async\nCompletableFuture<User> findOneByFirstname(String firstname);\n\n@Async\nListenableFuture<User> findOneByLastname(String lastname);\n```\n\n1. 使用`java.util.concurrent.Future`作为返回类型\n2. 使用一个Java8`java.util.current.CompletableFuture`作为返回类型\n3. 使用一个`org.springframework.util.concurrent.ListenableFuture`作为返回类型\n\n## 创建repository实例\n\n这个章节你创建实例和bean定义为repository接口定义.方法之一是手动的支持repository使用包含各个Spring Data模块的Spring命名空间装载,然而我们一般推荐使用Java配置的方法配置.\n\n### 4.5.1 XML配置\n\n每个Spring Data module包含一个repository 元素,这可以让你简单的定义一个基本包,Spring为你扫描它.\n\n例16 通过XML启用Spring Data repositories\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans:beans xmlns:beans=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns=\"http://www.springframework.org/schema/data/jpa\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/jpa\n        http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\">\n      <repositories base-package=\"com.acme.repositories\" />\n    </beans:beans>\n```\n\n在前面的实例中,让Spring扫描`com.acme.repositories`包和它的子包里继承`Repository`的接口或者它的子接口.找到的每个接口,继承组件注册持久化技术的`FactoryBean`来创建合适的代理处理执行查询方法.每个bean被注册在一个接口名称确定的bean name下,所以一个叫`UserRepository`将注册`userRepository`.基本包属性允许通配符,所以你可以定义一个规则扫描包.\n\n**使用过滤**\n\n默认的基本组件选取所有在配置的基本包下继承了持久化技术`Repositpry`接口以及子接口\n\n并且为他们创建一个bean实例.然而,你可能希望更细粒度的控制哪个接口bean实例被创建.为了实现这个你可以在`<repository/>`中使用`<include-filter/>`和`<exclude-filter/>`元素.语义完全等同于Spring的上下文命名空间中的元素.更多细节,查看他们的元素`Spring reference documentation`\n\n例如，要将某些确定的接口排除实例化为repository，可以使用以下配置:\n\n例17. 使用exclude-filter元素\n\n```java\n<repository base-package=\"com.acme.repositories\">\n  <context:exclude-filter type=\"regex\" expression=\".*SomeRepository\" />\n</repositories>\n```\n\n这个示例从待实例化对象中排除所有以SomeRepository结尾的接口.\n\n### 4.5.2 JavaConfig\n\nrepository基础组件也可以使用一个存储的特殊的`@Enable${store}Repositories`注解在一个JavaConfig类上.入门介绍Spring容器Java基本Spring容器查看文档:`JavaConfig in the Spring reference documentaional`\n\n一个简单配置启用Spring Data repositories像这样:\n\n例18. repository配置基于简单注解\n\n```java\n@Configuration\n@EnableJpaRepositories(\"com.acme.repositories\")\nclass ApplicationConfiguration {\n  @Bean\n  public EntityManagerFactory entityManagerFactory() {\n    // …\n  }\n}\n```\n\n> 注意\n>\n> 示例使用了JPA特有的注解,根据你使用的存储模块决定实际如何替换.示例定义`EntityManagerFactory`bean.查阅具体存储的配置\n\n### 4.5.3 单独使用\n\n你也可以在Spring容器之外使用repository基础组件,例如在CDI环境.你仍然需要一些Spring库在你的classpath中,但是你可以以编程的方式启动.repository包装持久化技术支持的Spring Data模块提供RepositoryFactory,你可以向下面这样使用:\n\n例19. repository工厂单独使用\n\n```java\nRepositoryFactorySupport factory = … // Instantiate factory here\nUserRepository repository = factory.getRepository(UserRepository.class);\n```\n\n## 4.6 定制Spring Data仓库实现\n\n时常有必要为一少部分仓库方法提供一个定制的实现.Spring数据存储库很容易允许您提供自定义存储库代码并将其与通用CRUD集成抽象和查询方法功能整合.\n\n### 4.6.1 为单独仓库添加定制行为\n\n为了定制功能丰富一个仓库,你首先为定制功能定义一个接口和实现.使用你提供的仓库接口来继承自定义接口.\n\n例20. 定制仓库功能的接口\n\n```java\ninterface UserRepositoryCustom {\n  public void someCustomMethod(User user);\n}\n```\n\n例21.定制功能的实现\n\n```java\nclass UserRepositoryImpl implements UserRepositoryCustom {\n  public void someCustomMethod(User user) {\n    // Your custom implementation\n  }\n}\n```\n\n> 注意\n>\n> 类可以被找到最重要的点是名字以Impl为后缀区别于仓库的核心接口(见下文)\n\n实现的本身没有依赖Spring Data,可以是一个标准的Spring bean.所以你可以使用标准的依赖注入行为给其他bean注入引用,像`JdbcTemplate`,切面的一部分等等.\n\n例22 修改你基本的仓库接口\n\n```java\ninterface UserRepository extends CrudRepository<User, Long>, UserRepositoryCustom {\n  // Declare query methods here\n}\n```\n\n让你的标准仓库接口继承定制的.这样做结合了CRUD和定制功能并使其可用于客户端.\n\n**配置**\n\n如果你使用命名空间配置,仓库基本组件扫描类所在包,根据扫描结果尝试自动定制实现.\n\n这些类需要遵循命名规范:给仓库接口名添加命名空间元素属性`repositoryimpl-postfix`.默认的后缀是`Impl`\n\n例23. 配置示例\n\n```xml\n<repositories base-package=\"com.acme.repository\" />\n<repositories base-package=\"com.acme.repository\" repository-impl-postfix=\"FooBar\"/>\n```\n\n第一个配置示例将查实查找一个类`com.acme.repository.UserRepositoryImpl`来作为定制藏局实现.然而第二个示例将尝试查找`com.acme.repository.UserRepositoryFooBar `.\n\n\n**手动指定**\n\n上面的方法可以正常工作,只有当你定制实现使用注解配置和自动注入,这将与其他Spring bean一样被对待.如果你定制的实现需要特殊处理,你可以像描述的简单定义一个bean并且命名它.基本组件将通过名称引用手动定义的bean定义而不是它自己创建一个.\n\n例24.手动指定定制实现\n\n```xml\n<repositories base-package=\"com.acme.repository\" />\n<beans:bean id=\"userRepositoryImpl\" class=\"…\">\n  <!-- further configuration -->\n</beans:bean>\n```\n\n### 4.6.2为所有仓库添加定制行为\n\n当你希望把一个单独的方法添加到你所有的仓库接口中时,上面的方法就不可行了.为了添加定制到所有的仓库,你首先添加一个中间接口来定义共享的行为.\n\n例25 定义共享定制行为接口\n\n```java\n@NoRepositoryBean\npublic interface MyRepository<T, ID extends Serializable>\n  extends PagingAndSortingRepository<T, ID> {\n  void sharedCustomMethod(ID id);\n}\n```\n\n现在你独立的仓库接口将继承这个中间接口而不是`Repository`接口来包含功能的定义.接下来创建一个中间接口的实现继承持久化具体仓库的基本类.这个类后面将作为仓库代理的基本类.\n\n例26 定制仓库基本类\n\n```java\npublic class MyRepositoryImpl<T, ID extends Serializable>\n  extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {\n  \n  private final EntityManager entityManager;\n  \n  public MyRepositoryImpl(JpaEntityInformation entityInformation,\n                          EntityManager entityManager) {\n    super(entityInformation, entityManager);\n    // Keep the EntityManager around to used from the newly introduced methods.\n    this.entityManager = entityManager;\n  }\n  \n  public void sharedCustomMethod(ID id) {\n    // implementation goes here\n  }\n}\n```\n\n> 警告\n>\n> 这个类需要有一个构造方法调用父类具体存储仓库工厂实现.万一仓库基础类有多个构造,覆盖包括一个`EntityInformation `加上存储具体基本组件对象(例如一个`EntityManager `或者模板类)\n\nSpring`<repository/>`命名空间下的默认行为为所有接口提供一个实现.这意味着如果处于其当前状态，`MyRepository`的实现实例将由Spring创建.这当然不是被期望的,它只是作为一个用来定义实体的 `Repository`和真实仓库接口的中间接口.为了排除一个继承`Repository`的接口被当做一个仓库接口实例化,你可以给它使用`@NoRepositoryBean`(像上面)或者把它从配置中`base-package`移除.\n\n最后一步是让Spring Data基本组件识别到定制的仓库基本类.在JavaConf使用注解`@Enable...Repository`的属性`repositoryBaseClass`完成:\n\n例27 使用JavaConfig配置一个定制仓库基本类\n\n```java\n@Configuration\n@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)\nclass ApplicationConfiguration { … }\n```\n\n类似的属性在XML命名空间中也可以找到.\n\n例28 使用XML配置一个定制仓库基本类\n\n```xml\n<repositories base-package=\"com.acme.repository\"\n              base-class=\"….MyRepositoryImpl\" />\n```\n\n## 4.7 Spring Data扩展\n\n这部分说明Spring Data一系列的扩展功能,可以使Spring Dta使用多样的上下文.目前大部分集成是针对Spring MVC.\n\n### 4.7.1 Querydsl扩展\n\nQuerydsl是一个框架,通过它的流式API构建静态类型的SQL类查询.\n\n多个Spring Data模块通过`QueryDslPredicateExecutor `与Querydsl集成.\n\n例29 QueryDslPredicateExecutor接口\n\n```java\npublic interface QueryDslPredicateExecutor<T> {\n  T findOne(Predicate predicate); ①\n    Iterable<T> findAll(Predicate predicate); ②\n    long count(Predicate predicate); ③\n    boolean exists(Predicate predicate); ④\n    // … more functionality omitted.\n}\n```\n\n① 查询并返回一个匹配`Predicate `的单例实体\n\n②查询并返回所有匹配`Predicate`的实体\n\n③ 返回匹配`Predicate`的实体数量\n\n④  返回是否存在一个匹配`Predicate`的实体\n\n为了简单的使用Querydsl功能,在你的仓库接口继承`QueryDslPredicateExecutor`.\n\n例30 在仓库集成QueryDsl\n\n```java\ninterface UserRepository extends CrudRepository<User, Long>,\n  QueryDslPredicateExecutor<User> {\n}\n```\n\n像上面这样就可以使用Querydsl的`Predicate`书写类型安全的查询\n\n```java\nPredicate predicate = user.firstname.equalsIgnoreCase(\"dave\")\n  .and(user.lastname.startsWithIgnoreCase(\"mathews\"));\nuserRepository.findAll(predicate);\n```\n\n### 4.7.2 Web支持\n\n> 注意\n>\n> 本节包含Spring Data Web支持的文档是在1.6范围内的Spring Data Commons实现的.因为支持新引入的内容改变了很多东西，我们保留了旧行为的文档在\"遗留Web支持\"部分.\n>\n\n如果模块支持仓库编程模型，那么Spring Data模块附带了各种Web模块支持.Web关联的东西需要Spring MVC的JAR包位于classpath路径下,它们中有些甚至提供了Spring HATEOAS集成.一般情况,集成方式支持使用`@EnableSpringDataWebSupport`注解在你的JavaConfig配置类.\n\n例31 启用Spring Data web支持\n\n```java\n@Configuration\n@EnableWebMvc\n@EnableSpringDataWebSupport\nclass WebConfiguration {}\n```\n\n`@EnableSpringDataWebSupport`注解注册了一些组件，我们将在稍后讨论.注解还将在类路径上检测Spring HATEOAS，如果才在将为其注册集成组件.\n\n作为可选项,如果你使用XML配置,注册`SpringDataWebSupport`或者`HateoasWareSpringDataWebSupport`作为Spring bean:\n\n例32 用XML启用Spring Data web支持\n\n```xml\n<bean class=\"org.springframework.data.web.config.SpringDataWebConfiguration\" />\n<!-- If you're using Spring HATEOAS as well register this one *instead* of the\nformer -->\n<bean class= \"org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration\" />\n```\n\n**基本Web支持**\n\n上面展示的的配置设置将注册几个基本组件：\n\n- 一个`DomainClassConverter`启用Spring MVC来根据请求参数或路径变量管理仓例实体类的实例\n- `HandlerMethodArgumentResolver`实现让Spring MVC从请求参数解析Pageable和Sort实例.\n\n**实体类转换**\n\n`DomainClassConverter`允许你在Spring MVC控制器方法签名中直接使用实体类型,因此你不必手动的通过仓库查询实例:\n\n例33 一个Spring MVC控制器在方法签名中使用实体类型\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") User user, Model model) {\n    model.addAttribute(\"user\", user);\n    return \"userForm\";\n  }\n}\n```\n\n如你所见,方法直接接收一个User实例并没有更进一步的查询是否必要.实例可以通过Spring MVC将路径变量转换为实体类的id类型并最终通过在实体类型注册的仓库实例上调用`findOne(...)`访问实例转换得到.\n\n> 注意\n>\n> 当前的仓库必须实现`CrudRepository`做好准备被发现来进行转换.\n\n**为了分页和排序分解方法参数**\n\n上面的配置片段还注册了一个`PageableHandlerMethodArgumentResolver`和一个`SortHandlerMethodArgumentResolver`实例.注册使得Pageable和Sort成为有效的控制器方法参数.\n\n例34 使用Pageable作为控制器方法参数\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @Autowired UserRepository repository;\n  @RequestMapping\n  public String showUsers(Model model, Pageable pageable) {\n    model.addAttribute(\"users\", repository.findAll(pageable));\n    return \"users\";\n  }\n}\n```\n\n这个方法签名将使Spring MVC尝试使用下面的默认配置从请求参数中转换一个Pageable实例:\n\n表1 请求参数转换Pageable实例\n\n| 参数   | 说明                                       |\n| ---- | ---------------------------------------- |\n| page | 要检索的页面,索引为0,默认为0                         |\n| size | 要检索的页面大小,默认20                            |\n| sort | 被排序的属性应以格式`property,property(, ASC\\|DESC)`表示.默认生序排序,如果你希望改变排序顺序,则使用多个排序参数,例如?sort=firstname&sort=lastname,asc |\n\n为了定制行为,可以继承`SpringDataWebConfiguration`或者启用等效的HATEOAS并覆盖`pageableResolver()`或`sortResolver()`方法并导入你的自定义配置文件替代@Enable-注解.\n\n有一种情况你需要多个`Pageable`或`Sort`实例从请求转换(例如处理多个表单),你可以使用Spring的`@Qualifier`注解来互相区别.请求参数必须以`${qualifier}为`前缀.这样一个方法的签名像这样:\n\n```java\npublic String showUsers(Model model, \n                        @Qualifier(\"foo\")Pagebale first, \n                        @Qualifier(\"bar\") Pageable second) {\n  ...\n}\n```\n\n你必须填充foo_page和bar_page等.\n\n默认的`Pageable`在方法中处理等价于一个`new PageRequest(0, 20)`,但是可以使用`@PageableDefaults`注解在`Pageable`参数上定制.\n\n**Hypermedia支持分页**\n\nSpring HATEOAS包装了一个代表模型的类`PageResources` ,\n\n它可以使用Page实例包装必要的Page元数据内容作为连接让客户端导航页面.一个页面到一个`PageResources`的转换被Spring HATEOAS的`ResourceAssembler`接口实现`PagedResourcesAssembler `来完成.\n\n例35 使用一个PagedResourcesAssembler作为控制器方法参数\n\n```java\n@Controller\nclass PersonController {\n  @Autowired PersonRepository repository;\n  @RequestMapping(value = \"/persons\", method = RequestMethod.GET)\n  HttpEntity<PagedResources<Person>> persons(Pageable pageable,\n                                             PagedResourcesAssembler assembler) {\n    Page<Person> persons = repository.findAll(pageable);\n    return new ResponseEntity<>(assembler.toResources(persons), HttpStatus.OK);\n  }\n}\n```\n\n像上面这样配置将允许`PageResourcesAssembler`作为控制器方法的一个参数.在这调用toResources(...)方法有以下作用:\n\n- `Page`的内容将`PageResources`实例的内容\n- `PageResources`将获得`PageMetadata`实例,该实例由Page和基础的PageRequest中的信息填充\n- `PageResources`获得`prev`和`next`连接,添加这些依赖在页面.这些链接将指向uri方法的调用映射.页码参数根据`PageableHandlerMethodArgumentResolver`添加到参数以在后面被转换.\n\n假设我们有30个Person实例在数据库.你现在可以触发一个GET请求 http://localhost:8080/persons, 你将可以看到类似下面的内容:\n\n```json\n{ \"links\" : [ { \"rel\" : \"next\",\n\"href\" : \"http://localhost:8080/persons?page=1&size=20 }\n],\n\"content\" : [\n… // 20 Person instances rendered here\n],\n\"pageMetadata\" : {\n\"size\" : 20,\n\"totalElements\" : 30,\n\"totalPages\" : 2,\n\"number\" : 0\n}\n}\n```\n\n你可以看到编译生成了正确的URI，并且还会提取默认配置转换参数到即将到来的请求中的`Pageable`.这意味着,如果你改变配置,链接也将自动跟随改变.默认情况下，编译指向控制器执行的方法，但是这可以被一个自定义链接作为基本构建来构成分页的`Link`重载`PagedResourcesAssembler.toResource（...）`方法定制.\n\n**Querydsl web 支持**\n\n那些整合了`QueryDSL`的存储可能从`Request`查询字符串中的属性驱动查询.\n\n这意味着前面例子的查询字符串可以给出`User`的对象\n\n```\n?firstname=Dave&lastname=Matthews\n```\n\n可以被转换为\n\n```java\nQUser.user.firstname.eq(\"Dave\").and(QUser.user.lastname.eq(\"Matthews\"))\n```\n\n使用了`QuerydslPredicateArgumentResolver`.\n\n> 注意\n>\n> 当在类路径上找到Querydsl时，该功能将在@EnableSpringDataWebSupport注解中自动启用\n\n添加一个`@QuerydslPredicate`到一个方法签名将提供一个就绪的`Predicate`,可以通过`QueryDslPredicateExecutor`执行.\n\n> 提示\n>\n> 类型信息通常从返回方法上解析.由于这些信息不一定匹配实体类型,使用`QuerydslPredicate`的`root`属性可能是个好主意.\n\n```java\n@Controller\nclass UserController {\n  @Autowired UserRepository repository;\n  @RequestMapping(value = \"/\", method = RequestMethod.GET)\n  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,\n              Pageable pageable, @RequestParam MultiValueMap<String, String>\n    parameters) {\n        model.addAttribute(\"users\", repository.findAll(predicate, pageable));\n        return \"index\";\n  } \n}\n```\n\n为User转换匹配查询字符串参数的`Predicate`\n\n默认的绑定规则如下:\n\n1. `Object`在简单属性上如同`eq`\n\n2. `Object`在集合作为属性如同`contains`\n\n3. `Collection`在简单属性上如同`in`\n\n\n这些绑定可以通过`@QuerydslPredicate`的`bindings`属性定制或者使用Java8`default methods`给仓库接口添加`QuerydslBinderCustomizer`\n\n```java\ninterface UserReposotory extends CurdRepository<User, String>, \n  QueryDslPredicateExecutor<User>,\n  QuerydslBinderCustomizer<QUser> {\n    @Override\n  \tdefault public void customize(QuerydslBindings bindings, QUser user) {\n      bindings.bind(user.username).first((path, value) -> path.contains(value));\n      bindings.bind(String.class).first((StringPath path, String value) ->\n                                        path.containsIgnoreCase(value));\n      bindings.excluding(user.password);\n  \t}\n  }\n```\n\n1. `QueryDslPredicateExecutor`为`Predicate`提供特殊的查询方法提供入口\n2. 在仓库接口定义`QuerydslBinderCustomizer`将自动注解`@QuerydslPredicate(bindings=...)`\n3. 为`username`属性定义绑定,绑定到一个简单集合\n4. 为`String`属性定义默认绑定到一个不区分大小写的集合\n5. 从`Predicate`移除密码属性\n\n### 4.7.3 仓库填充\n\n如果你使用Spring JDBC模块,你可能熟悉在`DataSource`使用SQL脚本来填充.一个类似的抽象在仓库级别可以使用,尽管它不是使用SQL作为数据定义语言,因为它必须由存储决定.填充根据仓库支持XML(通过Spring的OXM抽象)和JSON(通过Jackson)定义数据.\n\n假设你有一个文件`data.json`内容如下:\n\n例36 JSON定义的数据\n\n```json\n[ { \"_class\" : \"com.acme.Person\",\n     \"firstname\" : \"Dave\",\n      \"lastname\" : \"Matthews\" },\n      { \"_class\" : \"com.acme.Person\",\n     \"firstname\" : \"Carter\",\n      \"lastname\" : \"Beauford\" } ]\n```\n\n你可以容易的根据Spring Data Commons提供仓库的命名空间填充元素填充你的仓库.为了填充前面的数据到你的PersonRepository,像下面这样配置:\n\n例37 声明一个Jackson仓库填充\n\n```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:repository=\"http://www.springframework.org/schema/data/repository\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/repository\n        http://www.springframework.org/schema/data/repository/spring-repository.xsd\">\n      <repository:jackson2-populator locations=\"classpath:data.json\" />\n    </beans>\n```\n\n这样的声明可以让`data.json`文件可以被一个Jackson的`ObjectMpper`读取和反序列化.\n\nJSON将要解析的对象类型由检查JSON文档的`_class`属性决定.基本组件将最终选择合适的仓库去处理反序列化的对象.\n\n要使用XML定义数据填充仓库,你可以使用`unmarshaller-populator`元素.你配置它使用Spring OXM提供给你的XML装配选项.在Spring reference documentation查看更多细节.\n\n例38 声明一个装配仓库填充器(使用JAXB)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:repository=\"http://www.springframework.org/schema/data/repository\"\n      xmlns:oxm=\"http://www.springframework.org/schema/oxm\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/repository\n        http://www.springframework.org/schema/data/repository/spring-repository.xsd\n        http://www.springframework.org/schema/oxm\n        http://www.springframework.org/schema/oxm/spring-oxm.xsd\">\n      <repository:unmarshaller-populator locations=\"classpath:data.json\"\n        unmarshaller-ref=\"unmarshaller\" />\n      <oxm:jaxb2-marshaller contextPath=\"com.acme\" />\n    </beans>\n```\n\n### 4.7.4 遗留web支持\n\n**Spring MVC的实体类绑定**\n\n如果正在开发Spring MVC web应用,你通常必须从URL中解析实体类的id.默认的,你的任务是转化请求参数或URL参数到实体类并将它移交给下面或直接在实体上操作业务逻辑.这看起来像下面这样:\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  private final UserRepository userRepository;\n  \n  @Autowired\n  public UserController(UserRepository userRepository) {\n    Assert.notNull(repository, \"Repository must not be null!\");\n    this.userRepository = userRepository;\n  }\n\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") Long id, Model model) {\n    // Do null check for id\n    User user = userRepository.findOne(id);\n    // Do null check for user\n    model.addAttribute(\"user\", user);\n    return \"user\";\n  }\n}\n```\n\n首先你为每个控制器定义一个依赖的仓库来查找它们分别管理的实体.查询实体也是样板,因为它总是一个`findOne(...)`调用.幸运的Spring提供了方法来注册自定义组件,允许一个String值转换到一个属性类型.\n\n**属性编辑**\n\nSpring3.0之前Java`PropertyEditors`被使用.为了集成这些,Spring Data提出一个`DomainClassPropertyEditorRegistrar`来查询所有注册到`ApplicatonContext`的Spring Data仓库和一个定制的`PropertyEditor`来管理实体类.\n\n```xml\n<bean class=\"….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\">\n  <property name=\"webBindingInitializer\">\n    <bean class=\"….web.bind.support.ConfigurableWebBindingInitializer\">\n      <property name=\"propertyEditorRegistrars\">\n        <bean class=\n          \"org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar\" />\n      </property>\n    </bean>\n  </property>\n</bean>\n```\n\n如果你已经像上面这样配置Spring MVC,你可以向下面这样配置你的控制器,从而减少不清晰和样板式的代码\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") User user, Model model) {\n    model.addAttribute(\"user\", user);\n    return \"userForm\";\n  }\n}\n```\n\n","slug":"【翻译】SpringData官方文档第四章","published":1,"updated":"2017-01-07T06:58:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gay000zyi2erf9jwcun","content":"<p>说明：本翻译<a href=\"http://ifeve.com/repositories-custom-implementations/\" target=\"_blank\" rel=\"external\">4.6</a>和<a href=\"http://ifeve.com/spring-data-4-7/\" target=\"_blank\" rel=\"external\">4.7</a>段发布在<a href=\"http://ifeve.com/\" target=\"_blank\" rel=\"external\">并发编程网</a>,其他段落为了熟悉上下文而翻译，没有精校。首次参与翻译任务，翻译的不好请指正。</p>\n<hr>\n<h1 id=\"第四章-使用Spring-Data-Repositories\"><a href=\"#第四章-使用Spring-Data-Repositories\" class=\"headerlink\" title=\"第四章 使用Spring Data Repositories\"></a>第四章 使用Spring Data Repositories</h1><p>Spring Data repository abstraction目的是为了显著的简化必要的样板式代码来为多种持久化数据存储实现数据层。</p>\n<blockquote>\n<p>重要</p>\n<p>本章解释Spring Data repositories核心的概念和接口。Spring Data repository documentation 与 你的模块。本章这些信息是从Spring Data Commons模块获取的。它使用了JPA模块的配置和代码示范,命名引用覆盖XML配置，它支持所有的Spring Data模块支持的repository API，Repository查询关键字覆盖被repository 接口一般的关键字查询方法。你的模块特性的细节信息，查询文档对应模块。</p>\n</blockquote>\n<h2 id=\"4-1-核心概念\"><a href=\"#4-1-核心概念\" class=\"headerlink\" title=\"4.1 核心概念\"></a>4.1 核心概念</h2><p>Spring Data repository抽象接口的核心是<code>Repository</code>（可能没有那么惊喜）。它需要管理实体类以及实体类的id作为参数。此接口主要用作是获取要使用的类型接口并帮助扩展这个接口。</p>\n<p><code>CrudRepository</code>为被管理的实体类提供复杂CRUD功能。</p>\n<h2 id=\"4-2-查询方法\"><a href=\"#4-2-查询方法\" class=\"headerlink\" title=\"4.2 查询方法\"></a>4.2 查询方法</h2><p>标准的CRUD功能repositories通常有查询底层数据库。</p>\n<p>在Spring Data中，分词声明这些查询变成了四个步骤的过程：</p>\n<ol>\n<li><p>声明一个接口继承<code>Repository</code>或者它的一个子类，并且指定要被处理的实体类和Id类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123; … &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在接口中声明查询方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建Spring生成代理实现上面接口，通过JavaConfig：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>或者通过XML配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xmlns:jpa</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/jpa\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></div><div class=\"line\">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">http://www.springframework.org/schema/data/jpa</div><div class=\"line\">http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\"&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jpa:repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repositories\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个实例中使用了JPA命名空间。</p>\n<p>如果你为其他存储使用repository接口，你需要修改来适应你的存储模块命名空间的声明，大概就是替换jpa为期望的，例如mongodb。</p>\n<p>当然，注意JavaConfig并没有明确配置一个包默认使用注解的包。</p>\n<p>为了定制包被扫描可以使用数据存储注解<code>@Enable</code>的一个属性<code>basePackage</code>。</p>\n</li>\n</ol>\n<ol>\n<li><p>获得repository实例注入并使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClient</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"keyword\">private</span> PersonRepository repository;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    List&lt;Person&gt; persons = repository.findByLastname(<span class=\"string\">\"Matthews\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>以下部分详细说明每个步骤。</p>\n<h2 id=\"4-3-定义repository接口\"><a href=\"#4-3-定义repository接口\" class=\"headerlink\" title=\"4.3 定义repository接口\"></a>4.3 定义repository接口</h2><p>第一步定义一个实体类依赖repository接口。</p>\n<p>这个接口必须继承<code>Repository</code>接口并且指定实体类型和Id类型。</p>\n<p>如果你希望实体类型拥有CRUD方法，将<code>Repository</code>接口替换成继承<code>CrudRepository</code>。</p>\n<h3 id=\"4-3-1-小巧repository定义\"><a href=\"#4-3-1-小巧repository定义\" class=\"headerlink\" title=\"4.3.1 小巧repository定义\"></a>4.3.1 小巧repository定义</h3><p>一般情况下，你的repository接口应该继承<code>Repository</code>，<code>CrudRepository</code>或者<code>PagingAndSortingRepository</code></p>\n<p>除此之外,如果你不想继承Spring Data接口,你也可以使用<code>@Repository</code>注解定义你的接口</p>\n<p>继承<code>CrudRepository</code>提供了一系列完整的方法来操纵你的实体.</p>\n<p>如果你希望选择方法,简单的从<code>CurdRepository</code>复制你希望获得的方法到你的<code>Repository</code></p>\n<blockquote>\n<p>注意</p>\n<p>注意这允许你定义你自己的抽闲建立在Spring Data Repositories功能.</p>\n</blockquote>\n<p>例5.有选择的展现<code>CRUD</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">findOne</span><span class=\"params\">(ID id)</span></span>;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">save</span><span class=\"params\">(T entity)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">User <span class=\"title\">findByEmailAddress</span><span class=\"params\">(EmailAddress emailAddress)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是第一步你定义一个通用的基本接口,接口供你所有的实体repositories使用并提供<code>findOne()</code>和<code>save()</code>方法</p>\n<p>这些方法会被转发到你选择的Spring Data提供的基本repository实现,例如JPA<code>SimpleJpaRepository</code>,因为他们匹配<code>CrudRepository</code>的方法签名.</p>\n<p>因此<code>UserPepository</code>现在可以保存用户,查找唯一用户根据id,并且触发一个查询去查找<code>Users</code>根据他们的邮箱地址</p>\n<blockquote>\n<p>注意</p>\n<p>注意,中间的repository接口使用了注解<code>NoRepositoryBean</code>.</p>\n<p>对所有Spring Data在运行时不需要生成实例的repository接口,确保你为他们添加了注解.</p>\n</blockquote>\n<h3 id=\"4-3-2-在多个Spring-Data模块使用Repositories\"><a href=\"#4-3-2-在多个Spring-Data模块使用Repositories\" class=\"headerlink\" title=\"4.3.2 在多个Spring Data模块使用Repositories\"></a>4.3.2 在多个Spring Data模块使用Repositories</h3><p>在你的应用中使用唯一的Spring Data模块,所有repository接口定义范围限制在Spring Data模块.</p>\n<p>有时候应用需要使用不止一个Spring Data模块.</p>\n<p>这种情况下,需要repository定义在持久化技术之间有所区别.</p>\n<p>在class path发现多个repository工厂时,Spring Data严格检测repository配置模块.</p>\n<p>在repository或者实体类严格配置需要得细节以决定Spring Data模块绑定一个repository的定义:</p>\n<ol>\n<li>如果repository定义继承模块特殊的repository,那么对Spring Data模块这是一个有效的备选.</li>\n</ol>\n<ol>\n<li><p>如果实体类被模块特有的注解类型注解,那么对Spring Data模块这是一个有效的备选.</p>\n<p>Spring Data模块接收第三方注解(例如 JPA的<code>@Entity</code>)或者提供自己的注解例如<code>@Document</code>为Spring Data MongoDB/Spring Data Elasticsearch.</p>\n</li>\n</ol>\n<p>例6.使用模块特有的接口定义Repository</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123; &#125;</div><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">T</span>,<span class=\"title\">ID</span></span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>MyRepository</code>和<code>UserRepository</code>继承<code>JpaRepository</code>在他们类型层级.他们有效的表示了Spring Data JPA模块.</p>\n<p>例7.使用通用的接口定义<code>Repository</code>.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AmbiguousRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span></span></div><div class=\"line\">  <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">T</span>,<span class=\"title\">ID</span>&gt; &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AmbiguousUserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>AmbiguousRepository</code>和<code>AmbiguousUserRepository</code>在它们继承体系里只继承了<code>Repository</code>和<code>CrudRepository</code>.使用唯一的Spring Data模块是这是完成正确的,多个模块不能识别<code>Repository</code>到底绑定哪个Spring Data.</p>\n<p>例8.使用注解配合实体类定义<code>Repositor</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Entity</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Document</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>PersonRepository</code>引用使用了JPA的注解<code>@Entity</code>进行注解的<code>Person</code>,所以这个repository明确的属于Spring Data JPA.<code>UserRepository</code>使用了Spring Data MongoDB的注解<code>@Document</code>进行注解.</p>\n<p>例9.使用混合注解配合实体类定义<code>Repositor</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">JpaPersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MongoDBPersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Entity</span></div><div class=\"line\"><span class=\"meta\">@Document</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个示例展示实体类同时使用JPA和Spring Data MongoDB注解.</p>\n<p>这里定义了两个repository,<code>JpaPersonRepository</code>和<code>MongoDBPersonRepository</code>.</p>\n<p>一个被JPA使用,另一个被MongoDB使用.</p>\n<p>Spring Data不再能告诉repository区分,这将导致不清晰的行为</p>\n<p>“使用模块特有的接口定义Repository”和”使用注解配合实体类定义<code>Repositor</code>“都使用了严格的repository配置为一个特定的Spring Data模块识别可选的repository</p>\n<p>使用多种持久化技术特定的注解在同一个实体类上可能在锅中持久化技术上重用了实体类,但是这样做Spring Data将不能确定为repository绑定唯一的模块</p>\n<p>最后一种方式区分repository是划分repository的基本包.</p>\n<p>基本包定义起始点是扫描repository接口定义,这意味着在合适的包定义repository.</p>\n<p>默认的,注解配置使用类配置的包</p>\n<p>基于XML基本配置在这里.</p>\n<p>例10.注解配置基本包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(basePackages = <span class=\"string\">\"com.acme.repositories.jpa\"</span>)</div><div class=\"line\"><span class=\"meta\">@EnableMongoRepositories</span>(basePackages = <span class=\"string\">\"com.acme.repositories.mongo\"</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Configuration</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4-4-Defining-query-methods\"><a href=\"#4-4-Defining-query-methods\" class=\"headerlink\" title=\"4.4 Defining query methods\"></a>4.4 Defining query methods</h2><h2 id=\"4-4-定义查询方法\"><a href=\"#4-4-定义查询方法\" class=\"headerlink\" title=\"4.4 定义查询方法\"></a>4.4 定义查询方法</h2><p>repository代理有两种方式获得通过方法名获得指定查询.可以通过方法名直接获得查询,或者手动定义查询.有可用的选项定义在实际的存储.这有一些策略决定实际查询如何被创建.让我们一些看看可用的选项.</p>\n<h3 id=\"4-4-1-Query-lookup-strategies\"><a href=\"#4-4-1-Query-lookup-strategies\" class=\"headerlink\" title=\"4.4.1 Query lookup strategies\"></a>4.4.1 Query lookup strategies</h3><p>下面这些repository基本组件的决定查询可用的策略.你可以配置策略,在XML配置中通过命名空间<code>query-look-strategy</code>属性或者在Java配置中通过启用${store} Repository的属性注解<code>queryLookupStrategy</code>.一些策略可能不能支持特定的数据库.</p>\n<ul>\n<li>CREATE 试图通过方法名构建一个指定查询.一般处理是从方法名移除一系列给定的前缀并解析方法其他部分.更多查询构建信息阅读Query creation.</li>\n<li>USE_DECLARED_QUERY试图查找一个准确的查询,并在找不到时抛出一个异常.查询可以被通过注解定义或者其它方式定义.查询特殊存储的文档了解存储的可用选择.如果repository基本组件在启动时不能为方法找到一个准确的查询,将会失败</li>\n<li>CREATE_IF_NOT_FOUND(默认)联合了CREATE和USE_DECLARED_QUERY.首先查找一个准确查询,如果没有找到,创建一个定制方法基于名字的查询.这是默认的查询策略,因此如果你没有做任何明确配置.它允许根据方法名快速查询定义,而且定制查询根据需要引入声明的查询.</li>\n</ul>\n<h3 id=\"4-4-2-查询创建\"><a href=\"#4-4-2-查询创建\" class=\"headerlink\" title=\"4.4.2 查询创建\"></a>4.4.2 查询创建</h3><p>建成Spring Data repository基本组件的查询构建机制有用的构建了repository所有实体类的约束查询.</p>\n<p>这个机制分隔方法前缀<code>find...By</code>,<code>read...By</code>,<code>query...By</code>,<code>count...By</code>以及<code>get...By</code>,并解析其他部分.这个引入条款可以表达包含的特性例如<code>Distinct</code>,来设置明确的标志在要生成的查询上.然而,第一个by扮演了分解符来指明真实条件的起始.分词在一个非常基本的水平,你可以在实体属性上定义条件并且连接使用and或or连接他们.</p>\n<p>例11.来自方法名的查询创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByEmailAddressAndLastname</span><span class=\"params\">(EmailAddress emailAddress, String</span></span></div><div class=\"line\">                                             lastname);</div><div class=\"line\">  <span class=\"comment\">// Enables the distinct flag for the query</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findDistinctPeopleByLastnameOrFirstname</span><span class=\"params\">(String lastname, String</span></span></div><div class=\"line\">                                                       firstname);</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findPeopleDistinctByLastnameOrFirstname</span><span class=\"params\">(String lastname, String</span></span></div><div class=\"line\">                                                       firstname);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Enabling ignoring case for an individual property</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameIgnoreCase</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">  <span class=\"comment\">// Enabling ignoring case for all suitable properties</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameAndFirstnameAllIgnoreCase</span><span class=\"params\">(String lastname, String</span></span></div><div class=\"line\">                                                       firstname);</div><div class=\"line\">  <span class=\"comment\">// Enabling static ORDER BY for a query</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameOrderByFirstnameAsc</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameOrderByFirstnameDesc</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析方法的实际结果取决于你创建查询的持久化存储.然而,这有些问题需要注意:</p>\n<ul>\n<li>表达式通常串行的连接属性的遍历与操作符.你可以使用and和or连接属性表达式.你也可以给属性表达式使用操作符,例如between,lessThan,granterThan,like.你可以使用的表达式操作符有between,LessThan,GreaterThan,Loke.被支持的操作符根据多样的数据库决定,因此查询你引用文档的恰当部分.</li>\n<li>方法解析支持为单独属性设置一个IgnoreCase标志(例如,findByLastnameIgnoreCase(…))或者为所有属性都支持忽略情况(通常是String情形,例如,findByLastnameAndFirstnameAllIgnoreCase(…)).忽略情况是否被支持由多样的数据库决定，所以具体存储查询方法在引用文档查询相关章节.</li>\n<li>你可以为查询方法引用的属性提供静态排序连接OrderBy子句并且提供排序方向(Asc或Desc).为创建一个查询方法支持动态排序,查看特殊参数处理.</li>\n</ul>\n<h3 id=\"4-4-3-属性表达式\"><a href=\"#4-4-3-属性表达式\" class=\"headerlink\" title=\"4.4.3 属性表达式\"></a>4.4.3 属性表达式</h3><p>属性表达式可以只为管理的实体类的直接属性使用，就像前面所展示的那样。查询常见时你已经确认解析的字段是管理的实体类的一个字段.然而,你也可以通过最近的字段定义一个约束.假设<code>Person</code>的<code>Address</code>有一个<code>ZipCode</code>字段.这种情况一个方法如果这样命名:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByAddressZipCode</span><span class=\"params\">(ZipCode zipCode)</span></span>;</div></pre></td></tr></table></figure>\n<p>创建属性遍历<code>x.address.zipCode</code>.决策算法从把全部(<code>AddressZipCode</code>)作为属性开始并且检查实体类依此命名的属性(小写开头).如果算法成功了,就是用这个属性.否则,算法将源码部分驼峰式大小写从右侧头部到尾巴分隔,并试图找到相应的属性,在我们的例子中,<code>AddressZip</code>和<code>Code</code>.如果从头部找到一个属性,算法将在这里生成树处理后面的部分,使用描述的方式分隔.如果第一个分隔没有匹配到,算法移动分割点到左侧继续(<code>Address</code>,<code>ZipCode</code>).</p>\n<p>这在大多数情况都可以使用,但也可能选择错误的属性.假设<code>Person</code>类也有一个<code>addressZip</code>属性.算法将匹配第一个匹配的,本质上选择了错误属性,最终失败(伴随的<code>addressZip</code>类型没有属性<code>code</code>).</p>\n<p>没了解决这种起义,你可以在方法名称内使用<code>_</code>手动的定义遍历点.所以我们的方法名称最终像这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByAddress_ZipCode</span><span class=\"params\">(ZipCode zipCode)</span></span>;</div></pre></td></tr></table></figure>\n<p>As we treat underscore as a reserved character we strongly advise to follow standard Java naming<br>conventions (i.e. not using underscores in property names but camel case instead) </p>\n<p>我们对待下划线当做一个保留关键字,我们强力建议遵循标准Java命名规范(例如,使用驼峰命名而不是下划线命名属性名称)</p>\n<h3 id=\"4-4-4-特殊参数处理\"><a href=\"#4-4-4-特殊参数处理\" class=\"headerlink\" title=\"4.4.4 特殊参数处理\"></a>4.4.4 特殊参数处理</h3><p>处理你查询中的参数,你可以定义简单的方法参数像上面的示例中.处理之外基本组件可以识别出某些特殊类型例如<code>Pageable</code>和<code>Sort</code>用来动态的编码和排序你的查询.</p>\n<p>例12.在查询方法使用<code>Pageable</code>,<code>Slice</code>和<code>Sort</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Page&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">Slice&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Sort sort)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<p>第一个方法允许你在通过一个<code>org.springframework.data.domain.Pageable</code>实例在查询方法中动态添加分页信息在你的静态定义查询中.一个<code>Page</code>清楚数据的全部数量和页面总数.它是通过触发计数的基础设施查询计算总数。这个代价可能是昂贵的具体取决于所使用的存储,可以用<code>Slice</code>代替.一个<code>Slict</code>只知道下一个<code>Slice</code>可到到哪里,当运行在一个大的结果集上时这可能已经足够了.排序选项也通过<code>Pageable</code>实例处理.如果你只需要排序,简单起见添加<code>org.springframework.data.domain.Sort</code>参数在你的方法.如你所见,简单返回一个列表.在这种情况下,额外元数据构建实际的<code>Page</code>实例将不会被创建(反过来这意味着,没有发出额外的统计查询所必须的)简单约束只在给定的范围内查询.</p>\n<blockquote>\n<p>注意</p>\n<p>为了尽早得到你查询了多少页,你必须出发一个格外统计查询.默认的,这个查询你实际触发的查询调用.</p>\n</blockquote>\n<h3 id=\"4-4-5-限制查询结果\"><a href=\"#4-4-5-限制查询结果\" class=\"headerlink\" title=\"4.4.5 限制查询结果\"></a>4.4.5 限制查询结果</h3><p>查询方法的结果可以通过关键<code>first</code>或者<code>top</code>限制,可以交换使用.一个可选的数值可以追加在top/first来指定返回的最大结果集.如果数字缺失,假定结果集大小是1.</p>\n<p>例13.查询中使用Top和First限制结果大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">User <span class=\"title\">findFirstByOrderByLastnameAsc</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\">User <span class=\"title\">findTopByOrderByAgeDesc</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\">Page&lt;User&gt; <span class=\"title\">queryFirst10ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">Slice&lt;User&gt; <span class=\"title\">findTop3ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findFirst10ByLastname</span><span class=\"params\">(String lastname, Sort sort)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findTop10ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<p>限制表达式也支持Distinct关键字.此外，对于将结果集设置为一个实例的查询，支持将结果包装到一个<code>Optional</code>.如果应用分页或分片限制查询分页(并且计算可用的页数)那么这可以应用limited结果.</p>\n<blockquote>\n<p>注意</p>\n<p>请注意，限制结果结合使用<code>Sort</code>的动态排序的结果允许参数可以表示“k”最小的查询方法以及“K”的查询方法最大的元素。</p>\n</blockquote>\n<h3 id=\"4-4-6-流式处理结果\"><a href=\"#4-4-6-流式处理结果\" class=\"headerlink\" title=\"4.4.6 流式处理结果\"></a>4.4.6 流式处理结果</h3><p>方法查询结果可以通过使用java 8<code>Stream&lt;T&gt;</code>逐步处理。</p>\n<p>特定的方法用来表示流而不是简单的包装查询结果在一个<code>Stream</code>数据存储</p>\n<p>例14 一个用java流8<code>Stream&lt;T&gt;</code>查询结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"select u from User u\"</span>)</div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">findAllByCustomQueryAndStream</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">readAllByFirstnameNotNull</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"select u from User u\"</span>)</div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">streamAllPaged</span><span class=\"params\">(Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>一个<code>Stream</code>潜在的包装底层数据存储在页数的资源中,因此使用完毕必须关闭.你可以使用<code>close()</code>方法手动关闭<code>Stream</code>或者使用一个Java7的try_with-resources块.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>(Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</div><div class=\"line\">  stream.forEach(...);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-4-7-异步查询结果\"><a href=\"#4-4-7-异步查询结果\" class=\"headerlink\" title=\"4.4.7 异步查询结果\"></a>4.4.7 异步查询结果</h3><p>Repository查询可以使用<code>Spring&#39;s asynchronous method execution capacity</code>执行异步.这意味着方法可以一执行立即返回,真实的查询执行发生在任务提交到一个Spring TaskExecutor.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">Future&lt;User&gt; <span class=\"title\">findByFirstname</span><span class=\"params\">(String firstname)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">CompletableFuture&lt;User&gt; <span class=\"title\">findOneByFirstname</span><span class=\"params\">(String firstname)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">ListenableFuture&lt;User&gt; <span class=\"title\">findOneByLastname</span><span class=\"params\">(String lastname)</span></span>;</div></pre></td></tr></table></figure>\n<ol>\n<li>使用<code>java.util.concurrent.Future</code>作为返回类型</li>\n<li>使用一个Java8<code>java.util.current.CompletableFuture</code>作为返回类型</li>\n<li>使用一个<code>org.springframework.util.concurrent.ListenableFuture</code>作为返回类型</li>\n</ol>\n<h2 id=\"创建repository实例\"><a href=\"#创建repository实例\" class=\"headerlink\" title=\"创建repository实例\"></a>创建repository实例</h2><p>这个章节你创建实例和bean定义为repository接口定义.方法之一是手动的支持repository使用包含各个Spring Data模块的Spring命名空间装载,然而我们一般推荐使用Java配置的方法配置.</p>\n<h3 id=\"4-5-1-XML配置\"><a href=\"#4-5-1-XML配置\" class=\"headerlink\" title=\"4.5.1 XML配置\"></a>4.5.1 XML配置</h3><p>每个Spring Data module包含一个repository 元素,这可以让你简单的定义一个基本包,Spring为你扫描它.</p>\n<p>例16 通过XML启用Spring Data repositories</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans:beans</span> <span class=\"attr\">xmlns:beans</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/jpa\"</span></div><div class=\"line\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></div><div class=\"line\">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">        http://www.springframework.org/schema/data/jpa</div><div class=\"line\">        http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\"&gt;</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repositories\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans:beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在前面的实例中,让Spring扫描<code>com.acme.repositories</code>包和它的子包里继承<code>Repository</code>的接口或者它的子接口.找到的每个接口,继承组件注册持久化技术的<code>FactoryBean</code>来创建合适的代理处理执行查询方法.每个bean被注册在一个接口名称确定的bean name下,所以一个叫<code>UserRepository</code>将注册<code>userRepository</code>.基本包属性允许通配符,所以你可以定义一个规则扫描包.</p>\n<p><strong>使用过滤</strong></p>\n<p>默认的基本组件选取所有在配置的基本包下继承了持久化技术<code>Repositpry</code>接口以及子接口</p>\n<p>并且为他们创建一个bean实例.然而,你可能希望更细粒度的控制哪个接口bean实例被创建.为了实现这个你可以在<code>&lt;repository/&gt;</code>中使用<code>&lt;include-filter/&gt;</code>和<code>&lt;exclude-filter/&gt;</code>元素.语义完全等同于Spring的上下文命名空间中的元素.更多细节,查看他们的元素<code>Spring reference documentation</code></p>\n<p>例如，要将某些确定的接口排除实例化为repository，可以使用以下配置:</p>\n<p>例17. 使用exclude-filter元素</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;repository base-package=\"com.acme.repositories\"&gt;</div><div class=\"line\">  &lt;context:exclude-filter type=\"regex\" expression=\".*SomeRepository\" /&gt;</div><div class=\"line\">&lt;/repositories&gt;</div></pre></td></tr></table></figure>\n<p>这个示例从待实例化对象中排除所有以SomeRepository结尾的接口.</p>\n<h3 id=\"4-5-2-JavaConfig\"><a href=\"#4-5-2-JavaConfig\" class=\"headerlink\" title=\"4.5.2 JavaConfig\"></a>4.5.2 JavaConfig</h3><p>repository基础组件也可以使用一个存储的特殊的<code>@Enable${store}Repositories</code>注解在一个JavaConfig类上.入门介绍Spring容器Java基本Spring容器查看文档:<code>JavaConfig in the Spring reference documentaional</code></p>\n<p>一个简单配置启用Spring Data repositories像这样:</p>\n<p>例18. repository配置基于简单注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(<span class=\"string\">\"com.acme.repositories\"</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationConfiguration</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Bean</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> EntityManagerFactory <span class=\"title\">entityManagerFactory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// …</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>示例使用了JPA特有的注解,根据你使用的存储模块决定实际如何替换.示例定义<code>EntityManagerFactory</code>bean.查阅具体存储的配置</p>\n</blockquote>\n<h3 id=\"4-5-3-单独使用\"><a href=\"#4-5-3-单独使用\" class=\"headerlink\" title=\"4.5.3 单独使用\"></a>4.5.3 单独使用</h3><p>你也可以在Spring容器之外使用repository基础组件,例如在CDI环境.你仍然需要一些Spring库在你的classpath中,但是你可以以编程的方式启动.repository包装持久化技术支持的Spring Data模块提供RepositoryFactory,你可以向下面这样使用:</p>\n<p>例19. repository工厂单独使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">RepositoryFactorySupport factory = … <span class=\"comment\">// Instantiate factory here</span></div><div class=\"line\">UserRepository repository = factory.getRepository(UserRepository.class);</div></pre></td></tr></table></figure>\n<h2 id=\"4-6-定制Spring-Data仓库实现\"><a href=\"#4-6-定制Spring-Data仓库实现\" class=\"headerlink\" title=\"4.6 定制Spring Data仓库实现\"></a>4.6 定制Spring Data仓库实现</h2><p>时常有必要为一少部分仓库方法提供一个定制的实现.Spring数据存储库很容易允许您提供自定义存储库代码并将其与通用CRUD集成抽象和查询方法功能整合.</p>\n<h3 id=\"4-6-1-为单独仓库添加定制行为\"><a href=\"#4-6-1-为单独仓库添加定制行为\" class=\"headerlink\" title=\"4.6.1 为单独仓库添加定制行为\"></a>4.6.1 为单独仓库添加定制行为</h3><p>为了定制功能丰富一个仓库,你首先为定制功能定义一个接口和实现.使用你提供的仓库接口来继承自定义接口.</p>\n<p>例20. 定制仓库功能的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">someCustomMethod</span><span class=\"params\">(User user)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例21.定制功能的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRepositoryImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">someCustomMethod</span><span class=\"params\">(User user)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Your custom implementation</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>类可以被找到最重要的点是名字以Impl为后缀区别于仓库的核心接口(见下文)</p>\n</blockquote>\n<p>实现的本身没有依赖Spring Data,可以是一个标准的Spring bean.所以你可以使用标准的依赖注入行为给其他bean注入引用,像<code>JdbcTemplate</code>,切面的一部分等等.</p>\n<p>例22 修改你基本的仓库接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// Declare query methods here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>让你的标准仓库接口继承定制的.这样做结合了CRUD和定制功能并使其可用于客户端.</p>\n<p><strong>配置</strong></p>\n<p>如果你使用命名空间配置,仓库基本组件扫描类所在包,根据扫描结果尝试自动定制实现.</p>\n<p>这些类需要遵循命名规范:给仓库接口名添加命名空间元素属性<code>repositoryimpl-postfix</code>.默认的后缀是<code>Impl</code></p>\n<p>例23. 配置示例</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> <span class=\"attr\">repository-impl-postfix</span>=<span class=\"string\">\"FooBar\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>第一个配置示例将查实查找一个类<code>com.acme.repository.UserRepositoryImpl</code>来作为定制藏局实现.然而第二个示例将尝试查找<code>com.acme.repository.UserRepositoryFooBar</code>.</p>\n<p><strong>手动指定</strong></p>\n<p>上面的方法可以正常工作,只有当你定制实现使用注解配置和自动注入,这将与其他Spring bean一样被对待.如果你定制的实现需要特殊处理,你可以像描述的简单定义一个bean并且命名它.基本组件将通过名称引用手动定义的bean定义而不是它自己创建一个.</p>\n<p>例24.手动指定定制实现</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans:bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userRepositoryImpl\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"…\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- further configuration --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans:bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-6-2为所有仓库添加定制行为\"><a href=\"#4-6-2为所有仓库添加定制行为\" class=\"headerlink\" title=\"4.6.2为所有仓库添加定制行为\"></a>4.6.2为所有仓库添加定制行为</h3><p>当你希望把一个单独的方法添加到你所有的仓库接口中时,上面的方法就不可行了.为了添加定制到所有的仓库,你首先添加一个中间接口来定义共享的行为.</p>\n<p>例25 定义共享定制行为接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt;</span></div><div class=\"line\">  <span class=\"keyword\">extends</span> <span class=\"title\">PagingAndSortingRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sharedCustomMethod</span><span class=\"params\">(ID id)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在你独立的仓库接口将继承这个中间接口而不是<code>Repository</code>接口来包含功能的定义.接下来创建一个中间接口的实现继承持久化具体仓库的基本类.这个类后面将作为仓库代理的基本类.</p>\n<p>例26 定制仓库基本类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRepositoryImpl</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt;</span></div><div class=\"line\">  <span class=\"keyword\">extends</span> <span class=\"title\">SimpleJpaRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; &#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EntityManager entityManager;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyRepositoryImpl</span><span class=\"params\">(JpaEntityInformation entityInformation,</span></span></div><div class=\"line\">                          EntityManager entityManager) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(entityInformation, entityManager);</div><div class=\"line\">    <span class=\"comment\">// Keep the EntityManager around to used from the newly introduced methods.</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.entityManager = entityManager;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sharedCustomMethod</span><span class=\"params\">(ID id)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// implementation goes here</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>警告</p>\n<p>这个类需要有一个构造方法调用父类具体存储仓库工厂实现.万一仓库基础类有多个构造,覆盖包括一个<code>EntityInformation</code>加上存储具体基本组件对象(例如一个<code>EntityManager</code>或者模板类)</p>\n</blockquote>\n<p>Spring<code>&lt;repository/&gt;</code>命名空间下的默认行为为所有接口提供一个实现.这意味着如果处于其当前状态，<code>MyRepository</code>的实现实例将由Spring创建.这当然不是被期望的,它只是作为一个用来定义实体的 <code>Repository</code>和真实仓库接口的中间接口.为了排除一个继承<code>Repository</code>的接口被当做一个仓库接口实例化,你可以给它使用<code>@NoRepositoryBean</code>(像上面)或者把它从配置中<code>base-package</code>移除.</p>\n<p>最后一步是让Spring Data基本组件识别到定制的仓库基本类.在JavaConf使用注解<code>@Enable...Repository</code>的属性<code>repositoryBaseClass</code>完成:</p>\n<p>例27 使用JavaConfig配置一个定制仓库基本类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(repositoryBaseClass = MyRepositoryImpl.class)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationConfiguration</span> </span>&#123; … &#125;</div></pre></td></tr></table></figure>\n<p>类似的属性在XML命名空间中也可以找到.</p>\n<p>例28 使用XML配置一个定制仓库基本类</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span></span></div><div class=\"line\">              <span class=\"attr\">base-class</span>=<span class=\"string\">\"….MyRepositoryImpl\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"4-7-Spring-Data扩展\"><a href=\"#4-7-Spring-Data扩展\" class=\"headerlink\" title=\"4.7 Spring Data扩展\"></a>4.7 Spring Data扩展</h2><p>这部分说明Spring Data一系列的扩展功能,可以使Spring Dta使用多样的上下文.目前大部分集成是针对Spring MVC.</p>\n<h3 id=\"4-7-1-Querydsl扩展\"><a href=\"#4-7-1-Querydsl扩展\" class=\"headerlink\" title=\"4.7.1 Querydsl扩展\"></a>4.7.1 Querydsl扩展</h3><p>Querydsl是一个框架,通过它的流式API构建静态类型的SQL类查询.</p>\n<p>多个Spring Data模块通过<code>QueryDslPredicateExecutor</code>与Querydsl集成.</p>\n<p>例29 QueryDslPredicateExecutor接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">findOne</span><span class=\"params\">(Predicate predicate)</span></span>; ①</div><div class=\"line\">    <span class=\"function\">Iterable&lt;T&gt; <span class=\"title\">findAll</span><span class=\"params\">(Predicate predicate)</span></span>; ②</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">count</span><span class=\"params\">(Predicate predicate)</span></span>; ③</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">exists</span><span class=\"params\">(Predicate predicate)</span></span>; ④</div><div class=\"line\">    <span class=\"comment\">// … more functionality omitted.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>① 查询并返回一个匹配<code>Predicate</code>的单例实体</p>\n<p>②查询并返回所有匹配<code>Predicate</code>的实体</p>\n<p>③ 返回匹配<code>Predicate</code>的实体数量</p>\n<p>④  返回是否存在一个匹配<code>Predicate</code>的实体</p>\n<p>为了简单的使用Querydsl功能,在你的仓库接口继承<code>QueryDslPredicateExecutor</code>.</p>\n<p>例30 在仓库集成QueryDsl</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt;,</span></div><div class=\"line\">  <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">User</span>&gt; &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面这样就可以使用Querydsl的<code>Predicate</code>书写类型安全的查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Predicate predicate = user.firstname.equalsIgnoreCase(<span class=\"string\">\"dave\"</span>)</div><div class=\"line\">  .and(user.lastname.startsWithIgnoreCase(<span class=\"string\">\"mathews\"</span>));</div><div class=\"line\">userRepository.findAll(predicate);</div></pre></td></tr></table></figure>\n<h3 id=\"4-7-2-Web支持\"><a href=\"#4-7-2-Web支持\" class=\"headerlink\" title=\"4.7.2 Web支持\"></a>4.7.2 Web支持</h3><blockquote>\n<p>注意</p>\n<p>本节包含Spring Data Web支持的文档是在1.6范围内的Spring Data Commons实现的.因为支持新引入的内容改变了很多东西，我们保留了旧行为的文档在”遗留Web支持”部分.</p>\n</blockquote>\n<p>如果模块支持仓库编程模型，那么Spring Data模块附带了各种Web模块支持.Web关联的东西需要Spring MVC的JAR包位于classpath路径下,它们中有些甚至提供了Spring HATEOAS集成.一般情况,集成方式支持使用<code>@EnableSpringDataWebSupport</code>注解在你的JavaConfig配置类.</p>\n<p>例31 启用Spring Data web支持</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableWebMvc</span></div><div class=\"line\"><span class=\"meta\">@EnableSpringDataWebSupport</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p><code>@EnableSpringDataWebSupport</code>注解注册了一些组件，我们将在稍后讨论.注解还将在类路径上检测Spring HATEOAS，如果才在将为其注册集成组件.</p>\n<p>作为可选项,如果你使用XML配置,注册<code>SpringDataWebSupport</code>或者<code>HateoasWareSpringDataWebSupport</code>作为Spring bean:</p>\n<p>例32 用XML启用Spring Data web支持</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.data.web.config.SpringDataWebConfiguration\"</span> /&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- If you're using Spring HATEOAS as well register this one *instead* of the</span></div><div class=\"line\">former --&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>= <span class=\"string\">\"org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>基本Web支持</strong></p>\n<p>上面展示的的配置设置将注册几个基本组件：</p>\n<ul>\n<li>一个<code>DomainClassConverter</code>启用Spring MVC来根据请求参数或路径变量管理仓例实体类的实例</li>\n<li><code>HandlerMethodArgumentResolver</code>实现让Spring MVC从请求参数解析Pageable和Sort实例.</li>\n</ul>\n<p><strong>实体类转换</strong></p>\n<p><code>DomainClassConverter</code>允许你在Spring MVC控制器方法签名中直接使用实体类型,因此你不必手动的通过仓库查询实例:</p>\n<p>例33 一个Spring MVC控制器在方法签名中使用实体类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> User user, Model model) </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"userForm\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如你所见,方法直接接收一个User实例并没有更进一步的查询是否必要.实例可以通过Spring MVC将路径变量转换为实体类的id类型并最终通过在实体类型注册的仓库实例上调用<code>findOne(...)</code>访问实例转换得到.</p>\n<blockquote>\n<p>注意</p>\n<p>当前的仓库必须实现<code>CrudRepository</code>做好准备被发现来进行转换.</p>\n</blockquote>\n<p><strong>为了分页和排序分解方法参数</strong></p>\n<p>上面的配置片段还注册了一个<code>PageableHandlerMethodArgumentResolver</code>和一个<code>SortHandlerMethodArgumentResolver</code>实例.注册使得Pageable和Sort成为有效的控制器方法参数.</p>\n<p>例34 使用Pageable作为控制器方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> UserRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUsers</span><span class=\"params\">(Model model, Pageable pageable)</span> </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"users\"</span>, repository.findAll(pageable));</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"users\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法签名将使Spring MVC尝试使用下面的默认配置从请求参数中转换一个Pageable实例:</p>\n<p>表1 请求参数转换Pageable实例</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>page</td>\n<td>要检索的页面,索引为0,默认为0</td>\n</tr>\n<tr>\n<td>size</td>\n<td>要检索的页面大小,默认20</td>\n</tr>\n<tr>\n<td>sort</td>\n<td>被排序的属性应以格式`property,property(, ASC\\</td>\n<td>DESC)`表示.默认生序排序,如果你希望改变排序顺序,则使用多个排序参数,例如?sort=firstname&amp;sort=lastname,asc</td>\n</tr>\n</tbody>\n</table>\n<p>为了定制行为,可以继承<code>SpringDataWebConfiguration</code>或者启用等效的HATEOAS并覆盖<code>pageableResolver()</code>或<code>sortResolver()</code>方法并导入你的自定义配置文件替代@Enable-注解.</p>\n<p>有一种情况你需要多个<code>Pageable</code>或<code>Sort</code>实例从请求转换(例如处理多个表单),你可以使用Spring的<code>@Qualifier</code>注解来互相区别.请求参数必须以<code>${qualifier}为</code>前缀.这样一个方法的签名像这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUsers</span><span class=\"params\">(Model model, </span></span></div><div class=\"line\">                        @Qualifier(<span class=\"string\">\"foo\"</span>)Pagebale first, </div><div class=\"line\">                        @<span class=\"title\">Qualifier</span><span class=\"params\">(<span class=\"string\">\"bar\"</span>)</span> Pageable second) &#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你必须填充foo_page和bar_page等.</p>\n<p>默认的<code>Pageable</code>在方法中处理等价于一个<code>new PageRequest(0, 20)</code>,但是可以使用<code>@PageableDefaults</code>注解在<code>Pageable</code>参数上定制.</p>\n<p><strong>Hypermedia支持分页</strong></p>\n<p>Spring HATEOAS包装了一个代表模型的类<code>PageResources</code> ,</p>\n<p>它可以使用Page实例包装必要的Page元数据内容作为连接让客户端导航页面.一个页面到一个<code>PageResources</code>的转换被Spring HATEOAS的<code>ResourceAssembler</code>接口实现<code>PagedResourcesAssembler</code>来完成.</p>\n<p>例35 使用一个PagedResourcesAssembler作为控制器方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> PersonRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/persons\"</span>, method = RequestMethod.GET)</div><div class=\"line\">  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,</div><div class=\"line\">                                             PagedResourcesAssembler assembler) &#123;</div><div class=\"line\">    Page&lt;Person&gt; persons = repository.findAll(pageable);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面这样配置将允许<code>PageResourcesAssembler</code>作为控制器方法的一个参数.在这调用toResources(…)方法有以下作用:</p>\n<ul>\n<li><code>Page</code>的内容将<code>PageResources</code>实例的内容</li>\n<li><code>PageResources</code>将获得<code>PageMetadata</code>实例,该实例由Page和基础的PageRequest中的信息填充</li>\n<li><code>PageResources</code>获得<code>prev</code>和<code>next</code>连接,添加这些依赖在页面.这些链接将指向uri方法的调用映射.页码参数根据<code>PageableHandlerMethodArgumentResolver</code>添加到参数以在后面被转换.</li>\n</ul>\n<p>假设我们有30个Person实例在数据库.你现在可以触发一个GET请求 <a href=\"http://localhost:8080/persons\" target=\"_blank\" rel=\"external\">http://localhost:8080/persons</a>, 你将可以看到类似下面的内容:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; \"links\" : [ &#123; \"rel\" : \"next\",</div><div class=\"line\">\"href\" : \"http://localhost:8080/persons?page=1&amp;size=20 &#125;</div><div class=\"line\">],</div><div class=\"line\">\"content\" : [</div><div class=\"line\">… // 20 Person instances rendered here</div><div class=\"line\">],</div><div class=\"line\">\"pageMetadata\" : &#123;</div><div class=\"line\">\"size\" : 20,</div><div class=\"line\">\"totalElements\" : 30,</div><div class=\"line\">\"totalPages\" : 2,</div><div class=\"line\">\"number\" : 0</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以看到编译生成了正确的URI，并且还会提取默认配置转换参数到即将到来的请求中的<code>Pageable</code>.这意味着,如果你改变配置,链接也将自动跟随改变.默认情况下，编译指向控制器执行的方法，但是这可以被一个自定义链接作为基本构建来构成分页的<code>Link</code>重载<code>PagedResourcesAssembler.toResource（...）</code>方法定制.</p>\n<p><strong>Querydsl web 支持</strong></p>\n<p>那些整合了<code>QueryDSL</code>的存储可能从<code>Request</code>查询字符串中的属性驱动查询.</p>\n<p>这意味着前面例子的查询字符串可以给出<code>User</code>的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?firstname=Dave&amp;lastname=Matthews</div></pre></td></tr></table></figure>\n<p>可以被转换为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">QUser.user.firstname.eq(<span class=\"string\">\"Dave\"</span>).and(QUser.user.lastname.eq(<span class=\"string\">\"Matthews\"</span>))</div></pre></td></tr></table></figure>\n<p>使用了<code>QuerydslPredicateArgumentResolver</code>.</p>\n<blockquote>\n<p>注意</p>\n<p>当在类路径上找到Querydsl时，该功能将在@EnableSpringDataWebSupport注解中自动启用</p>\n</blockquote>\n<p>添加一个<code>@QuerydslPredicate</code>到一个方法签名将提供一个就绪的<code>Predicate</code>,可以通过<code>QueryDslPredicateExecutor</code>执行.</p>\n<blockquote>\n<p>提示</p>\n<p>类型信息通常从返回方法上解析.由于这些信息不一定匹配实体类型,使用<code>QuerydslPredicate</code>的<code>root</code>属性可能是个好主意.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> UserRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/\"</span>, method = RequestMethod.GET)</div><div class=\"line\">  <span class=\"function\">String <span class=\"title\">index</span><span class=\"params\">(Model model, @QuerydslPredicate(root = User.class)</span> Predicate predicate,</span></div><div class=\"line\">              Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt;</div><div class=\"line\">    parameters) &#123;</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"users\"</span>, repository.findAll(predicate, pageable));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"index\"</span>;</div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为User转换匹配查询字符串参数的<code>Predicate</code></p>\n<p>默认的绑定规则如下:</p>\n<ol>\n<li><p><code>Object</code>在简单属性上如同<code>eq</code></p>\n</li>\n<li><p><code>Object</code>在集合作为属性如同<code>contains</code></p>\n</li>\n<li><p><code>Collection</code>在简单属性上如同<code>in</code></p>\n</li>\n</ol>\n<p>这些绑定可以通过<code>@QuerydslPredicate</code>的<code>bindings</code>属性定制或者使用Java8<code>default methods</code>给仓库接口添加<code>QuerydslBinderCustomizer</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserReposotory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CurdRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">String</span>&gt;, </span></div><div class=\"line\">  <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">User</span>&gt;,</div><div class=\"line\">  <span class=\"title\">QuerydslBinderCustomizer</span>&lt;<span class=\"title\">QUser</span>&gt; &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customize</span><span class=\"params\">(QuerydslBindings bindings, QUser user)</span> </span>&#123;</div><div class=\"line\">      bindings.bind(user.username).first((path, value) -&gt; path.contains(value));</div><div class=\"line\">      bindings.bind(String.class).first((StringPath path, String value) -&gt;</div><div class=\"line\">                                        path.containsIgnoreCase(value));</div><div class=\"line\">      bindings.excluding(user.password);</div><div class=\"line\">  \t&#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><code>QueryDslPredicateExecutor</code>为<code>Predicate</code>提供特殊的查询方法提供入口</li>\n<li>在仓库接口定义<code>QuerydslBinderCustomizer</code>将自动注解<code>@QuerydslPredicate(bindings=...)</code></li>\n<li>为<code>username</code>属性定义绑定,绑定到一个简单集合</li>\n<li>为<code>String</code>属性定义默认绑定到一个不区分大小写的集合</li>\n<li>从<code>Predicate</code>移除密码属性</li>\n</ol>\n<h3 id=\"4-7-3-仓库填充\"><a href=\"#4-7-3-仓库填充\" class=\"headerlink\" title=\"4.7.3 仓库填充\"></a>4.7.3 仓库填充</h3><p>如果你使用Spring JDBC模块,你可能熟悉在<code>DataSource</code>使用SQL脚本来填充.一个类似的抽象在仓库级别可以使用,尽管它不是使用SQL作为数据定义语言,因为它必须由存储决定.填充根据仓库支持XML(通过Spring的OXM抽象)和JSON(通过Jackson)定义数据.</p>\n<p>假设你有一个文件<code>data.json</code>内容如下:</p>\n<p>例36 JSON定义的数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ &#123; <span class=\"attr\">\"_class\"</span> : <span class=\"string\">\"com.acme.Person\"</span>,</div><div class=\"line\">     <span class=\"attr\">\"firstname\"</span> : <span class=\"string\">\"Dave\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"lastname\"</span> : <span class=\"string\">\"Matthews\"</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">\"_class\"</span> : <span class=\"string\">\"com.acme.Person\"</span>,</div><div class=\"line\">     <span class=\"attr\">\"firstname\"</span> : <span class=\"string\">\"Carter\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"lastname\"</span> : <span class=\"string\">\"Beauford\"</span> &#125; ]</div></pre></td></tr></table></figure>\n<p>你可以容易的根据Spring Data Commons提供仓库的命名空间填充元素填充你的仓库.为了填充前面的数据到你的PersonRepository,像下面这样配置:</p>\n<p>例37 声明一个Jackson仓库填充</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">    <span class=\"attr\">xmlns:repository</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/repository\"</span></div><div class=\"line\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></div><div class=\"line\">      http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">      http://www.springframework.org/schema/data/repository</div><div class=\"line\">      http://www.springframework.org/schema/data/repository/spring-repository.xsd\"&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">repository:jackson2-populator</span> <span class=\"attr\">locations</span>=<span class=\"string\">\"classpath:data.json\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这样的声明可以让<code>data.json</code>文件可以被一个Jackson的<code>ObjectMpper</code>读取和反序列化.</p>\n<p>JSON将要解析的对象类型由检查JSON文档的<code>_class</code>属性决定.基本组件将最终选择合适的仓库去处理反序列化的对象.</p>\n<p>要使用XML定义数据填充仓库,你可以使用<code>unmarshaller-populator</code>元素.你配置它使用Spring OXM提供给你的XML装配选项.在Spring reference documentation查看更多细节.</p>\n<p>例38 声明一个装配仓库填充器(使用JAXB)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:repository</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/repository\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:oxm</span>=<span class=\"string\">\"http://www.springframework.org/schema/oxm\"</span></div><div class=\"line\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></div><div class=\"line\">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">        http://www.springframework.org/schema/data/repository</div><div class=\"line\">        http://www.springframework.org/schema/data/repository/spring-repository.xsd</div><div class=\"line\">        http://www.springframework.org/schema/oxm</div><div class=\"line\">        http://www.springframework.org/schema/oxm/spring-oxm.xsd\"&gt;</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repository:unmarshaller-populator</span> <span class=\"attr\">locations</span>=<span class=\"string\">\"classpath:data.json\"</span></span></div><div class=\"line\">        <span class=\"attr\">unmarshaller-ref</span>=<span class=\"string\">\"unmarshaller\"</span> /&gt;</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">oxm:jaxb2-marshaller</span> <span class=\"attr\">contextPath</span>=<span class=\"string\">\"com.acme\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-7-4-遗留web支持\"><a href=\"#4-7-4-遗留web支持\" class=\"headerlink\" title=\"4.7.4 遗留web支持\"></a>4.7.4 遗留web支持</h3><p><strong>Spring MVC的实体类绑定</strong></p>\n<p>如果正在开发Spring MVC web应用,你通常必须从URL中解析实体类的id.默认的,你的任务是转化请求参数或URL参数到实体类并将它移交给下面或直接在实体上操作业务逻辑.这看起来像下面这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> UserRepository userRepository;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</div><div class=\"line\">    Assert.notNull(repository, <span class=\"string\">\"Repository must not be null!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.userRepository = userRepository;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> Long id, Model model) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Do null check for id</span></div><div class=\"line\">    User user = userRepository.findOne(id);</div><div class=\"line\">    <span class=\"comment\">// Do null check for user</span></div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"user\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先你为每个控制器定义一个依赖的仓库来查找它们分别管理的实体.查询实体也是样板,因为它总是一个<code>findOne(...)</code>调用.幸运的Spring提供了方法来注册自定义组件,允许一个String值转换到一个属性类型.</p>\n<p><strong>属性编辑</strong></p>\n<p>Spring3.0之前Java<code>PropertyEditors</code>被使用.为了集成这些,Spring Data提出一个<code>DomainClassPropertyEditorRegistrar</code>来查询所有注册到<code>ApplicatonContext</code>的Spring Data仓库和一个定制的<code>PropertyEditor</code>来管理实体类.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"webBindingInitializer\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"….web.bind.support.ConfigurableWebBindingInitializer\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"propertyEditorRegistrars\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=</span></div><div class=\"line\">          <span class=\"string\">\"org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar\"</span> /&gt;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果你已经像上面这样配置Spring MVC,你可以向下面这样配置你的控制器,从而减少不清晰和样板式的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> User user, Model model) </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"userForm\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>说明：本翻译<a href=\"http://ifeve.com/repositories-custom-implementations/\">4.6</a>和<a href=\"http://ifeve.com/spring-data-4-7/\">4.7</a>段发布在<a href=\"http://ifeve.com/\">并发编程网</a>,其他段落为了熟悉上下文而翻译，没有精校。首次参与翻译任务，翻译的不好请指正。</p>\n<hr>\n<h1 id=\"第四章-使用Spring-Data-Repositories\"><a href=\"#第四章-使用Spring-Data-Repositories\" class=\"headerlink\" title=\"第四章 使用Spring Data Repositories\"></a>第四章 使用Spring Data Repositories</h1><p>Spring Data repository abstraction目的是为了显著的简化必要的样板式代码来为多种持久化数据存储实现数据层。</p>\n<blockquote>\n<p>重要</p>\n<p>本章解释Spring Data repositories核心的概念和接口。Spring Data repository documentation 与 你的模块。本章这些信息是从Spring Data Commons模块获取的。它使用了JPA模块的配置和代码示范,命名引用覆盖XML配置，它支持所有的Spring Data模块支持的repository API，Repository查询关键字覆盖被repository 接口一般的关键字查询方法。你的模块特性的细节信息，查询文档对应模块。</p>\n</blockquote>\n<h2 id=\"4-1-核心概念\"><a href=\"#4-1-核心概念\" class=\"headerlink\" title=\"4.1 核心概念\"></a>4.1 核心概念</h2><p>Spring Data repository抽象接口的核心是<code>Repository</code>（可能没有那么惊喜）。它需要管理实体类以及实体类的id作为参数。此接口主要用作是获取要使用的类型接口并帮助扩展这个接口。</p>\n<p><code>CrudRepository</code>为被管理的实体类提供复杂CRUD功能。</p>\n<h2 id=\"4-2-查询方法\"><a href=\"#4-2-查询方法\" class=\"headerlink\" title=\"4.2 查询方法\"></a>4.2 查询方法</h2><p>标准的CRUD功能repositories通常有查询底层数据库。</p>\n<p>在Spring Data中，分词声明这些查询变成了四个步骤的过程：</p>\n<ol>\n<li><p>声明一个接口继承<code>Repository</code>或者它的一个子类，并且指定要被处理的实体类和Id类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123; … &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在接口中声明查询方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建Spring生成代理实现上面接口，通过JavaConfig：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>或者通过XML配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xmlns:jpa</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/jpa\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</div><div class=\"line\">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">http://www.springframework.org/schema/data/jpa</div><div class=\"line\">http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jpa:repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repositories\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个实例中使用了JPA命名空间。</p>\n<p>如果你为其他存储使用repository接口，你需要修改来适应你的存储模块命名空间的声明，大概就是替换jpa为期望的，例如mongodb。</p>\n<p>当然，注意JavaConfig并没有明确配置一个包默认使用注解的包。</p>\n<p>为了定制包被扫描可以使用数据存储注解<code>@Enable</code>的一个属性<code>basePackage</code>。</p>\n</li>\n</ol>\n<ol>\n<li><p>获得repository实例注入并使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClient</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"keyword\">private</span> PersonRepository repository;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    List&lt;Person&gt; persons = repository.findByLastname(<span class=\"string\">\"Matthews\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>以下部分详细说明每个步骤。</p>\n<h2 id=\"4-3-定义repository接口\"><a href=\"#4-3-定义repository接口\" class=\"headerlink\" title=\"4.3 定义repository接口\"></a>4.3 定义repository接口</h2><p>第一步定义一个实体类依赖repository接口。</p>\n<p>这个接口必须继承<code>Repository</code>接口并且指定实体类型和Id类型。</p>\n<p>如果你希望实体类型拥有CRUD方法，将<code>Repository</code>接口替换成继承<code>CrudRepository</code>。</p>\n<h3 id=\"4-3-1-小巧repository定义\"><a href=\"#4-3-1-小巧repository定义\" class=\"headerlink\" title=\"4.3.1 小巧repository定义\"></a>4.3.1 小巧repository定义</h3><p>一般情况下，你的repository接口应该继承<code>Repository</code>，<code>CrudRepository</code>或者<code>PagingAndSortingRepository</code></p>\n<p>除此之外,如果你不想继承Spring Data接口,你也可以使用<code>@Repository</code>注解定义你的接口</p>\n<p>继承<code>CrudRepository</code>提供了一系列完整的方法来操纵你的实体.</p>\n<p>如果你希望选择方法,简单的从<code>CurdRepository</code>复制你希望获得的方法到你的<code>Repository</code></p>\n<blockquote>\n<p>注意</p>\n<p>注意这允许你定义你自己的抽闲建立在Spring Data Repositories功能.</p>\n</blockquote>\n<p>例5.有选择的展现<code>CRUD</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">findOne</span><span class=\"params\">(ID id)</span></span>;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">save</span><span class=\"params\">(T entity)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">User <span class=\"title\">findByEmailAddress</span><span class=\"params\">(EmailAddress emailAddress)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是第一步你定义一个通用的基本接口,接口供你所有的实体repositories使用并提供<code>findOne()</code>和<code>save()</code>方法</p>\n<p>这些方法会被转发到你选择的Spring Data提供的基本repository实现,例如JPA<code>SimpleJpaRepository</code>,因为他们匹配<code>CrudRepository</code>的方法签名.</p>\n<p>因此<code>UserPepository</code>现在可以保存用户,查找唯一用户根据id,并且触发一个查询去查找<code>Users</code>根据他们的邮箱地址</p>\n<blockquote>\n<p>注意</p>\n<p>注意,中间的repository接口使用了注解<code>NoRepositoryBean</code>.</p>\n<p>对所有Spring Data在运行时不需要生成实例的repository接口,确保你为他们添加了注解.</p>\n</blockquote>\n<h3 id=\"4-3-2-在多个Spring-Data模块使用Repositories\"><a href=\"#4-3-2-在多个Spring-Data模块使用Repositories\" class=\"headerlink\" title=\"4.3.2 在多个Spring Data模块使用Repositories\"></a>4.3.2 在多个Spring Data模块使用Repositories</h3><p>在你的应用中使用唯一的Spring Data模块,所有repository接口定义范围限制在Spring Data模块.</p>\n<p>有时候应用需要使用不止一个Spring Data模块.</p>\n<p>这种情况下,需要repository定义在持久化技术之间有所区别.</p>\n<p>在class path发现多个repository工厂时,Spring Data严格检测repository配置模块.</p>\n<p>在repository或者实体类严格配置需要得细节以决定Spring Data模块绑定一个repository的定义:</p>\n<ol>\n<li>如果repository定义继承模块特殊的repository,那么对Spring Data模块这是一个有效的备选.</li>\n</ol>\n<ol>\n<li><p>如果实体类被模块特有的注解类型注解,那么对Spring Data模块这是一个有效的备选.</p>\n<p>Spring Data模块接收第三方注解(例如 JPA的<code>@Entity</code>)或者提供自己的注解例如<code>@Document</code>为Spring Data MongoDB/Spring Data Elasticsearch.</p>\n</li>\n</ol>\n<p>例6.使用模块特有的接口定义Repository</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123; &#125;</div><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">T</span>,<span class=\"title\">ID</span></span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>MyRepository</code>和<code>UserRepository</code>继承<code>JpaRepository</code>在他们类型层级.他们有效的表示了Spring Data JPA模块.</p>\n<p>例7.使用通用的接口定义<code>Repository</code>.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AmbiguousRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span></div><div class=\"line\">  <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">T</span>,<span class=\"title\">ID</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AmbiguousUserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>AmbiguousRepository</code>和<code>AmbiguousUserRepository</code>在它们继承体系里只继承了<code>Repository</code>和<code>CrudRepository</code>.使用唯一的Spring Data模块是这是完成正确的,多个模块不能识别<code>Repository</code>到底绑定哪个Spring Data.</p>\n<p>例8.使用注解配合实体类定义<code>Repositor</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Entity</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Document</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>PersonRepository</code>引用使用了JPA的注解<code>@Entity</code>进行注解的<code>Person</code>,所以这个repository明确的属于Spring Data JPA.<code>UserRepository</code>使用了Spring Data MongoDB的注解<code>@Document</code>进行注解.</p>\n<p>例9.使用混合注解配合实体类定义<code>Repositor</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">JpaPersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MongoDBPersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Entity</span></div><div class=\"line\"><span class=\"meta\">@Document</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个示例展示实体类同时使用JPA和Spring Data MongoDB注解.</p>\n<p>这里定义了两个repository,<code>JpaPersonRepository</code>和<code>MongoDBPersonRepository</code>.</p>\n<p>一个被JPA使用,另一个被MongoDB使用.</p>\n<p>Spring Data不再能告诉repository区分,这将导致不清晰的行为</p>\n<p>“使用模块特有的接口定义Repository”和”使用注解配合实体类定义<code>Repositor</code>“都使用了严格的repository配置为一个特定的Spring Data模块识别可选的repository</p>\n<p>使用多种持久化技术特定的注解在同一个实体类上可能在锅中持久化技术上重用了实体类,但是这样做Spring Data将不能确定为repository绑定唯一的模块</p>\n<p>最后一种方式区分repository是划分repository的基本包.</p>\n<p>基本包定义起始点是扫描repository接口定义,这意味着在合适的包定义repository.</p>\n<p>默认的,注解配置使用类配置的包</p>\n<p>基于XML基本配置在这里.</p>\n<p>例10.注解配置基本包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(basePackages = <span class=\"string\">\"com.acme.repositories.jpa\"</span>)</div><div class=\"line\"><span class=\"meta\">@EnableMongoRepositories</span>(basePackages = <span class=\"string\">\"com.acme.repositories.mongo\"</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Configuration</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4-4-Defining-query-methods\"><a href=\"#4-4-Defining-query-methods\" class=\"headerlink\" title=\"4.4 Defining query methods\"></a>4.4 Defining query methods</h2><h2 id=\"4-4-定义查询方法\"><a href=\"#4-4-定义查询方法\" class=\"headerlink\" title=\"4.4 定义查询方法\"></a>4.4 定义查询方法</h2><p>repository代理有两种方式获得通过方法名获得指定查询.可以通过方法名直接获得查询,或者手动定义查询.有可用的选项定义在实际的存储.这有一些策略决定实际查询如何被创建.让我们一些看看可用的选项.</p>\n<h3 id=\"4-4-1-Query-lookup-strategies\"><a href=\"#4-4-1-Query-lookup-strategies\" class=\"headerlink\" title=\"4.4.1 Query lookup strategies\"></a>4.4.1 Query lookup strategies</h3><p>下面这些repository基本组件的决定查询可用的策略.你可以配置策略,在XML配置中通过命名空间<code>query-look-strategy</code>属性或者在Java配置中通过启用${store} Repository的属性注解<code>queryLookupStrategy</code>.一些策略可能不能支持特定的数据库.</p>\n<ul>\n<li>CREATE 试图通过方法名构建一个指定查询.一般处理是从方法名移除一系列给定的前缀并解析方法其他部分.更多查询构建信息阅读Query creation.</li>\n<li>USE_DECLARED_QUERY试图查找一个准确的查询,并在找不到时抛出一个异常.查询可以被通过注解定义或者其它方式定义.查询特殊存储的文档了解存储的可用选择.如果repository基本组件在启动时不能为方法找到一个准确的查询,将会失败</li>\n<li>CREATE_IF_NOT_FOUND(默认)联合了CREATE和USE_DECLARED_QUERY.首先查找一个准确查询,如果没有找到,创建一个定制方法基于名字的查询.这是默认的查询策略,因此如果你没有做任何明确配置.它允许根据方法名快速查询定义,而且定制查询根据需要引入声明的查询.</li>\n</ul>\n<h3 id=\"4-4-2-查询创建\"><a href=\"#4-4-2-查询创建\" class=\"headerlink\" title=\"4.4.2 查询创建\"></a>4.4.2 查询创建</h3><p>建成Spring Data repository基本组件的查询构建机制有用的构建了repository所有实体类的约束查询.</p>\n<p>这个机制分隔方法前缀<code>find...By</code>,<code>read...By</code>,<code>query...By</code>,<code>count...By</code>以及<code>get...By</code>,并解析其他部分.这个引入条款可以表达包含的特性例如<code>Distinct</code>,来设置明确的标志在要生成的查询上.然而,第一个by扮演了分解符来指明真实条件的起始.分词在一个非常基本的水平,你可以在实体属性上定义条件并且连接使用and或or连接他们.</p>\n<p>例11.来自方法名的查询创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByEmailAddressAndLastname</span><span class=\"params\">(EmailAddress emailAddress, String</div><div class=\"line\">                                             lastname)</span></span>;</div><div class=\"line\">  <span class=\"comment\">// Enables the distinct flag for the query</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findDistinctPeopleByLastnameOrFirstname</span><span class=\"params\">(String lastname, String</div><div class=\"line\">                                                       firstname)</span></span>;</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findPeopleDistinctByLastnameOrFirstname</span><span class=\"params\">(String lastname, String</div><div class=\"line\">                                                       firstname)</span></span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Enabling ignoring case for an individual property</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameIgnoreCase</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">  <span class=\"comment\">// Enabling ignoring case for all suitable properties</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameAndFirstnameAllIgnoreCase</span><span class=\"params\">(String lastname, String</div><div class=\"line\">                                                       firstname)</span></span>;</div><div class=\"line\">  <span class=\"comment\">// Enabling static ORDER BY for a query</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameOrderByFirstnameAsc</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameOrderByFirstnameDesc</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析方法的实际结果取决于你创建查询的持久化存储.然而,这有些问题需要注意:</p>\n<ul>\n<li>表达式通常串行的连接属性的遍历与操作符.你可以使用and和or连接属性表达式.你也可以给属性表达式使用操作符,例如between,lessThan,granterThan,like.你可以使用的表达式操作符有between,LessThan,GreaterThan,Loke.被支持的操作符根据多样的数据库决定,因此查询你引用文档的恰当部分.</li>\n<li>方法解析支持为单独属性设置一个IgnoreCase标志(例如,findByLastnameIgnoreCase(…))或者为所有属性都支持忽略情况(通常是String情形,例如,findByLastnameAndFirstnameAllIgnoreCase(…)).忽略情况是否被支持由多样的数据库决定，所以具体存储查询方法在引用文档查询相关章节.</li>\n<li>你可以为查询方法引用的属性提供静态排序连接OrderBy子句并且提供排序方向(Asc或Desc).为创建一个查询方法支持动态排序,查看特殊参数处理.</li>\n</ul>\n<h3 id=\"4-4-3-属性表达式\"><a href=\"#4-4-3-属性表达式\" class=\"headerlink\" title=\"4.4.3 属性表达式\"></a>4.4.3 属性表达式</h3><p>属性表达式可以只为管理的实体类的直接属性使用，就像前面所展示的那样。查询常见时你已经确认解析的字段是管理的实体类的一个字段.然而,你也可以通过最近的字段定义一个约束.假设<code>Person</code>的<code>Address</code>有一个<code>ZipCode</code>字段.这种情况一个方法如果这样命名:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByAddressZipCode</span><span class=\"params\">(ZipCode zipCode)</span></span>;</div></pre></td></tr></table></figure>\n<p>创建属性遍历<code>x.address.zipCode</code>.决策算法从把全部(<code>AddressZipCode</code>)作为属性开始并且检查实体类依此命名的属性(小写开头).如果算法成功了,就是用这个属性.否则,算法将源码部分驼峰式大小写从右侧头部到尾巴分隔,并试图找到相应的属性,在我们的例子中,<code>AddressZip</code>和<code>Code</code>.如果从头部找到一个属性,算法将在这里生成树处理后面的部分,使用描述的方式分隔.如果第一个分隔没有匹配到,算法移动分割点到左侧继续(<code>Address</code>,<code>ZipCode</code>).</p>\n<p>这在大多数情况都可以使用,但也可能选择错误的属性.假设<code>Person</code>类也有一个<code>addressZip</code>属性.算法将匹配第一个匹配的,本质上选择了错误属性,最终失败(伴随的<code>addressZip</code>类型没有属性<code>code</code>).</p>\n<p>没了解决这种起义,你可以在方法名称内使用<code>_</code>手动的定义遍历点.所以我们的方法名称最终像这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByAddress_ZipCode</span><span class=\"params\">(ZipCode zipCode)</span></span>;</div></pre></td></tr></table></figure>\n<p>As we treat underscore as a reserved character we strongly advise to follow standard Java naming<br>conventions (i.e. not using underscores in property names but camel case instead) </p>\n<p>我们对待下划线当做一个保留关键字,我们强力建议遵循标准Java命名规范(例如,使用驼峰命名而不是下划线命名属性名称)</p>\n<h3 id=\"4-4-4-特殊参数处理\"><a href=\"#4-4-4-特殊参数处理\" class=\"headerlink\" title=\"4.4.4 特殊参数处理\"></a>4.4.4 特殊参数处理</h3><p>处理你查询中的参数,你可以定义简单的方法参数像上面的示例中.处理之外基本组件可以识别出某些特殊类型例如<code>Pageable</code>和<code>Sort</code>用来动态的编码和排序你的查询.</p>\n<p>例12.在查询方法使用<code>Pageable</code>,<code>Slice</code>和<code>Sort</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Page&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">Slice&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Sort sort)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<p>第一个方法允许你在通过一个<code>org.springframework.data.domain.Pageable</code>实例在查询方法中动态添加分页信息在你的静态定义查询中.一个<code>Page</code>清楚数据的全部数量和页面总数.它是通过触发计数的基础设施查询计算总数。这个代价可能是昂贵的具体取决于所使用的存储,可以用<code>Slice</code>代替.一个<code>Slict</code>只知道下一个<code>Slice</code>可到到哪里,当运行在一个大的结果集上时这可能已经足够了.排序选项也通过<code>Pageable</code>实例处理.如果你只需要排序,简单起见添加<code>org.springframework.data.domain.Sort</code>参数在你的方法.如你所见,简单返回一个列表.在这种情况下,额外元数据构建实际的<code>Page</code>实例将不会被创建(反过来这意味着,没有发出额外的统计查询所必须的)简单约束只在给定的范围内查询.</p>\n<blockquote>\n<p>注意</p>\n<p>为了尽早得到你查询了多少页,你必须出发一个格外统计查询.默认的,这个查询你实际触发的查询调用.</p>\n</blockquote>\n<h3 id=\"4-4-5-限制查询结果\"><a href=\"#4-4-5-限制查询结果\" class=\"headerlink\" title=\"4.4.5 限制查询结果\"></a>4.4.5 限制查询结果</h3><p>查询方法的结果可以通过关键<code>first</code>或者<code>top</code>限制,可以交换使用.一个可选的数值可以追加在top/first来指定返回的最大结果集.如果数字缺失,假定结果集大小是1.</p>\n<p>例13.查询中使用Top和First限制结果大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">User <span class=\"title\">findFirstByOrderByLastnameAsc</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\">User <span class=\"title\">findTopByOrderByAgeDesc</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\">Page&lt;User&gt; <span class=\"title\">queryFirst10ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">Slice&lt;User&gt; <span class=\"title\">findTop3ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findFirst10ByLastname</span><span class=\"params\">(String lastname, Sort sort)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findTop10ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<p>限制表达式也支持Distinct关键字.此外，对于将结果集设置为一个实例的查询，支持将结果包装到一个<code>Optional</code>.如果应用分页或分片限制查询分页(并且计算可用的页数)那么这可以应用limited结果.</p>\n<blockquote>\n<p>注意</p>\n<p>请注意，限制结果结合使用<code>Sort</code>的动态排序的结果允许参数可以表示“k”最小的查询方法以及“K”的查询方法最大的元素。</p>\n</blockquote>\n<h3 id=\"4-4-6-流式处理结果\"><a href=\"#4-4-6-流式处理结果\" class=\"headerlink\" title=\"4.4.6 流式处理结果\"></a>4.4.6 流式处理结果</h3><p>方法查询结果可以通过使用java 8<code>Stream&lt;T&gt;</code>逐步处理。</p>\n<p>特定的方法用来表示流而不是简单的包装查询结果在一个<code>Stream</code>数据存储</p>\n<p>例14 一个用java流8<code>Stream&lt;T&gt;</code>查询结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"select u from User u\"</span>)</div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">findAllByCustomQueryAndStream</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">readAllByFirstnameNotNull</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"select u from User u\"</span>)</div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">streamAllPaged</span><span class=\"params\">(Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>一个<code>Stream</code>潜在的包装底层数据存储在页数的资源中,因此使用完毕必须关闭.你可以使用<code>close()</code>方法手动关闭<code>Stream</code>或者使用一个Java7的try_with-resources块.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>(Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</div><div class=\"line\">  stream.forEach(...);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-4-7-异步查询结果\"><a href=\"#4-4-7-异步查询结果\" class=\"headerlink\" title=\"4.4.7 异步查询结果\"></a>4.4.7 异步查询结果</h3><p>Repository查询可以使用<code>Spring&#39;s asynchronous method execution capacity</code>执行异步.这意味着方法可以一执行立即返回,真实的查询执行发生在任务提交到一个Spring TaskExecutor.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">Future&lt;User&gt; <span class=\"title\">findByFirstname</span><span class=\"params\">(String firstname)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">CompletableFuture&lt;User&gt; <span class=\"title\">findOneByFirstname</span><span class=\"params\">(String firstname)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">ListenableFuture&lt;User&gt; <span class=\"title\">findOneByLastname</span><span class=\"params\">(String lastname)</span></span>;</div></pre></td></tr></table></figure>\n<ol>\n<li>使用<code>java.util.concurrent.Future</code>作为返回类型</li>\n<li>使用一个Java8<code>java.util.current.CompletableFuture</code>作为返回类型</li>\n<li>使用一个<code>org.springframework.util.concurrent.ListenableFuture</code>作为返回类型</li>\n</ol>\n<h2 id=\"创建repository实例\"><a href=\"#创建repository实例\" class=\"headerlink\" title=\"创建repository实例\"></a>创建repository实例</h2><p>这个章节你创建实例和bean定义为repository接口定义.方法之一是手动的支持repository使用包含各个Spring Data模块的Spring命名空间装载,然而我们一般推荐使用Java配置的方法配置.</p>\n<h3 id=\"4-5-1-XML配置\"><a href=\"#4-5-1-XML配置\" class=\"headerlink\" title=\"4.5.1 XML配置\"></a>4.5.1 XML配置</h3><p>每个Spring Data module包含一个repository 元素,这可以让你简单的定义一个基本包,Spring为你扫描它.</p>\n<p>例16 通过XML启用Spring Data repositories</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans:beans</span> <span class=\"attr\">xmlns:beans</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/jpa\"</span></div><div class=\"line\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</div><div class=\"line\">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">        http://www.springframework.org/schema/data/jpa</div><div class=\"line\">        http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repositories\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans:beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在前面的实例中,让Spring扫描<code>com.acme.repositories</code>包和它的子包里继承<code>Repository</code>的接口或者它的子接口.找到的每个接口,继承组件注册持久化技术的<code>FactoryBean</code>来创建合适的代理处理执行查询方法.每个bean被注册在一个接口名称确定的bean name下,所以一个叫<code>UserRepository</code>将注册<code>userRepository</code>.基本包属性允许通配符,所以你可以定义一个规则扫描包.</p>\n<p><strong>使用过滤</strong></p>\n<p>默认的基本组件选取所有在配置的基本包下继承了持久化技术<code>Repositpry</code>接口以及子接口</p>\n<p>并且为他们创建一个bean实例.然而,你可能希望更细粒度的控制哪个接口bean实例被创建.为了实现这个你可以在<code>&lt;repository/&gt;</code>中使用<code>&lt;include-filter/&gt;</code>和<code>&lt;exclude-filter/&gt;</code>元素.语义完全等同于Spring的上下文命名空间中的元素.更多细节,查看他们的元素<code>Spring reference documentation</code></p>\n<p>例如，要将某些确定的接口排除实例化为repository，可以使用以下配置:</p>\n<p>例17. 使用exclude-filter元素</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;repository base-package=\"com.acme.repositories\"&gt;</div><div class=\"line\">  &lt;context:exclude-filter type=\"regex\" expression=\".*SomeRepository\" /&gt;</div><div class=\"line\">&lt;/repositories&gt;</div></pre></td></tr></table></figure>\n<p>这个示例从待实例化对象中排除所有以SomeRepository结尾的接口.</p>\n<h3 id=\"4-5-2-JavaConfig\"><a href=\"#4-5-2-JavaConfig\" class=\"headerlink\" title=\"4.5.2 JavaConfig\"></a>4.5.2 JavaConfig</h3><p>repository基础组件也可以使用一个存储的特殊的<code>@Enable${store}Repositories</code>注解在一个JavaConfig类上.入门介绍Spring容器Java基本Spring容器查看文档:<code>JavaConfig in the Spring reference documentaional</code></p>\n<p>一个简单配置启用Spring Data repositories像这样:</p>\n<p>例18. repository配置基于简单注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(<span class=\"string\">\"com.acme.repositories\"</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationConfiguration</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Bean</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> EntityManagerFactory <span class=\"title\">entityManagerFactory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// …</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>示例使用了JPA特有的注解,根据你使用的存储模块决定实际如何替换.示例定义<code>EntityManagerFactory</code>bean.查阅具体存储的配置</p>\n</blockquote>\n<h3 id=\"4-5-3-单独使用\"><a href=\"#4-5-3-单独使用\" class=\"headerlink\" title=\"4.5.3 单独使用\"></a>4.5.3 单独使用</h3><p>你也可以在Spring容器之外使用repository基础组件,例如在CDI环境.你仍然需要一些Spring库在你的classpath中,但是你可以以编程的方式启动.repository包装持久化技术支持的Spring Data模块提供RepositoryFactory,你可以向下面这样使用:</p>\n<p>例19. repository工厂单独使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">RepositoryFactorySupport factory = … <span class=\"comment\">// Instantiate factory here</span></div><div class=\"line\">UserRepository repository = factory.getRepository(UserRepository.class);</div></pre></td></tr></table></figure>\n<h2 id=\"4-6-定制Spring-Data仓库实现\"><a href=\"#4-6-定制Spring-Data仓库实现\" class=\"headerlink\" title=\"4.6 定制Spring Data仓库实现\"></a>4.6 定制Spring Data仓库实现</h2><p>时常有必要为一少部分仓库方法提供一个定制的实现.Spring数据存储库很容易允许您提供自定义存储库代码并将其与通用CRUD集成抽象和查询方法功能整合.</p>\n<h3 id=\"4-6-1-为单独仓库添加定制行为\"><a href=\"#4-6-1-为单独仓库添加定制行为\" class=\"headerlink\" title=\"4.6.1 为单独仓库添加定制行为\"></a>4.6.1 为单独仓库添加定制行为</h3><p>为了定制功能丰富一个仓库,你首先为定制功能定义一个接口和实现.使用你提供的仓库接口来继承自定义接口.</p>\n<p>例20. 定制仓库功能的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">someCustomMethod</span><span class=\"params\">(User user)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例21.定制功能的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRepositoryImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">someCustomMethod</span><span class=\"params\">(User user)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Your custom implementation</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>类可以被找到最重要的点是名字以Impl为后缀区别于仓库的核心接口(见下文)</p>\n</blockquote>\n<p>实现的本身没有依赖Spring Data,可以是一个标准的Spring bean.所以你可以使用标准的依赖注入行为给其他bean注入引用,像<code>JdbcTemplate</code>,切面的一部分等等.</p>\n<p>例22 修改你基本的仓库接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// Declare query methods here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>让你的标准仓库接口继承定制的.这样做结合了CRUD和定制功能并使其可用于客户端.</p>\n<p><strong>配置</strong></p>\n<p>如果你使用命名空间配置,仓库基本组件扫描类所在包,根据扫描结果尝试自动定制实现.</p>\n<p>这些类需要遵循命名规范:给仓库接口名添加命名空间元素属性<code>repositoryimpl-postfix</code>.默认的后缀是<code>Impl</code></p>\n<p>例23. 配置示例</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> <span class=\"attr\">repository-impl-postfix</span>=<span class=\"string\">\"FooBar\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>第一个配置示例将查实查找一个类<code>com.acme.repository.UserRepositoryImpl</code>来作为定制藏局实现.然而第二个示例将尝试查找<code>com.acme.repository.UserRepositoryFooBar</code>.</p>\n<p><strong>手动指定</strong></p>\n<p>上面的方法可以正常工作,只有当你定制实现使用注解配置和自动注入,这将与其他Spring bean一样被对待.如果你定制的实现需要特殊处理,你可以像描述的简单定义一个bean并且命名它.基本组件将通过名称引用手动定义的bean定义而不是它自己创建一个.</p>\n<p>例24.手动指定定制实现</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans:bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userRepositoryImpl\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"…\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- further configuration --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans:bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-6-2为所有仓库添加定制行为\"><a href=\"#4-6-2为所有仓库添加定制行为\" class=\"headerlink\" title=\"4.6.2为所有仓库添加定制行为\"></a>4.6.2为所有仓库添加定制行为</h3><p>当你希望把一个单独的方法添加到你所有的仓库接口中时,上面的方法就不可行了.为了添加定制到所有的仓库,你首先添加一个中间接口来定义共享的行为.</p>\n<p>例25 定义共享定制行为接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt;</div><div class=\"line\">  <span class=\"keyword\">extends</span> <span class=\"title\">PagingAndSortingRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sharedCustomMethod</span><span class=\"params\">(ID id)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在你独立的仓库接口将继承这个中间接口而不是<code>Repository</code>接口来包含功能的定义.接下来创建一个中间接口的实现继承持久化具体仓库的基本类.这个类后面将作为仓库代理的基本类.</p>\n<p>例26 定制仓库基本类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRepositoryImpl</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt;</div><div class=\"line\">  <span class=\"keyword\">extends</span> <span class=\"title\">SimpleJpaRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EntityManager entityManager;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyRepositoryImpl</span><span class=\"params\">(JpaEntityInformation entityInformation,</div><div class=\"line\">                          EntityManager entityManager)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(entityInformation, entityManager);</div><div class=\"line\">    <span class=\"comment\">// Keep the EntityManager around to used from the newly introduced methods.</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.entityManager = entityManager;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sharedCustomMethod</span><span class=\"params\">(ID id)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// implementation goes here</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>警告</p>\n<p>这个类需要有一个构造方法调用父类具体存储仓库工厂实现.万一仓库基础类有多个构造,覆盖包括一个<code>EntityInformation</code>加上存储具体基本组件对象(例如一个<code>EntityManager</code>或者模板类)</p>\n</blockquote>\n<p>Spring<code>&lt;repository/&gt;</code>命名空间下的默认行为为所有接口提供一个实现.这意味着如果处于其当前状态，<code>MyRepository</code>的实现实例将由Spring创建.这当然不是被期望的,它只是作为一个用来定义实体的 <code>Repository</code>和真实仓库接口的中间接口.为了排除一个继承<code>Repository</code>的接口被当做一个仓库接口实例化,你可以给它使用<code>@NoRepositoryBean</code>(像上面)或者把它从配置中<code>base-package</code>移除.</p>\n<p>最后一步是让Spring Data基本组件识别到定制的仓库基本类.在JavaConf使用注解<code>@Enable...Repository</code>的属性<code>repositoryBaseClass</code>完成:</p>\n<p>例27 使用JavaConfig配置一个定制仓库基本类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(repositoryBaseClass = MyRepositoryImpl.class)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationConfiguration</span> </span>&#123; … &#125;</div></pre></td></tr></table></figure>\n<p>类似的属性在XML命名空间中也可以找到.</p>\n<p>例28 使用XML配置一个定制仓库基本类</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span></div><div class=\"line\">              <span class=\"attr\">base-class</span>=<span class=\"string\">\"….MyRepositoryImpl\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"4-7-Spring-Data扩展\"><a href=\"#4-7-Spring-Data扩展\" class=\"headerlink\" title=\"4.7 Spring Data扩展\"></a>4.7 Spring Data扩展</h2><p>这部分说明Spring Data一系列的扩展功能,可以使Spring Dta使用多样的上下文.目前大部分集成是针对Spring MVC.</p>\n<h3 id=\"4-7-1-Querydsl扩展\"><a href=\"#4-7-1-Querydsl扩展\" class=\"headerlink\" title=\"4.7.1 Querydsl扩展\"></a>4.7.1 Querydsl扩展</h3><p>Querydsl是一个框架,通过它的流式API构建静态类型的SQL类查询.</p>\n<p>多个Spring Data模块通过<code>QueryDslPredicateExecutor</code>与Querydsl集成.</p>\n<p>例29 QueryDslPredicateExecutor接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">findOne</span><span class=\"params\">(Predicate predicate)</span></span>; ①</div><div class=\"line\">    <span class=\"function\">Iterable&lt;T&gt; <span class=\"title\">findAll</span><span class=\"params\">(Predicate predicate)</span></span>; ②</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">count</span><span class=\"params\">(Predicate predicate)</span></span>; ③</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">exists</span><span class=\"params\">(Predicate predicate)</span></span>; ④</div><div class=\"line\">    <span class=\"comment\">// … more functionality omitted.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>① 查询并返回一个匹配<code>Predicate</code>的单例实体</p>\n<p>②查询并返回所有匹配<code>Predicate</code>的实体</p>\n<p>③ 返回匹配<code>Predicate</code>的实体数量</p>\n<p>④  返回是否存在一个匹配<code>Predicate</code>的实体</p>\n<p>为了简单的使用Querydsl功能,在你的仓库接口继承<code>QueryDslPredicateExecutor</code>.</p>\n<p>例30 在仓库集成QueryDsl</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt;,</div><div class=\"line\">  <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面这样就可以使用Querydsl的<code>Predicate</code>书写类型安全的查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Predicate predicate = user.firstname.equalsIgnoreCase(<span class=\"string\">\"dave\"</span>)</div><div class=\"line\">  .and(user.lastname.startsWithIgnoreCase(<span class=\"string\">\"mathews\"</span>));</div><div class=\"line\">userRepository.findAll(predicate);</div></pre></td></tr></table></figure>\n<h3 id=\"4-7-2-Web支持\"><a href=\"#4-7-2-Web支持\" class=\"headerlink\" title=\"4.7.2 Web支持\"></a>4.7.2 Web支持</h3><blockquote>\n<p>注意</p>\n<p>本节包含Spring Data Web支持的文档是在1.6范围内的Spring Data Commons实现的.因为支持新引入的内容改变了很多东西，我们保留了旧行为的文档在”遗留Web支持”部分.</p>\n</blockquote>\n<p>如果模块支持仓库编程模型，那么Spring Data模块附带了各种Web模块支持.Web关联的东西需要Spring MVC的JAR包位于classpath路径下,它们中有些甚至提供了Spring HATEOAS集成.一般情况,集成方式支持使用<code>@EnableSpringDataWebSupport</code>注解在你的JavaConfig配置类.</p>\n<p>例31 启用Spring Data web支持</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableWebMvc</span></div><div class=\"line\"><span class=\"meta\">@EnableSpringDataWebSupport</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p><code>@EnableSpringDataWebSupport</code>注解注册了一些组件，我们将在稍后讨论.注解还将在类路径上检测Spring HATEOAS，如果才在将为其注册集成组件.</p>\n<p>作为可选项,如果你使用XML配置,注册<code>SpringDataWebSupport</code>或者<code>HateoasWareSpringDataWebSupport</code>作为Spring bean:</p>\n<p>例32 用XML启用Spring Data web支持</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.data.web.config.SpringDataWebConfiguration\"</span> /&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- If you're using Spring HATEOAS as well register this one *instead* of the</div><div class=\"line\">former --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>= <span class=\"string\">\"org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>基本Web支持</strong></p>\n<p>上面展示的的配置设置将注册几个基本组件：</p>\n<ul>\n<li>一个<code>DomainClassConverter</code>启用Spring MVC来根据请求参数或路径变量管理仓例实体类的实例</li>\n<li><code>HandlerMethodArgumentResolver</code>实现让Spring MVC从请求参数解析Pageable和Sort实例.</li>\n</ul>\n<p><strong>实体类转换</strong></p>\n<p><code>DomainClassConverter</code>允许你在Spring MVC控制器方法签名中直接使用实体类型,因此你不必手动的通过仓库查询实例:</p>\n<p>例33 一个Spring MVC控制器在方法签名中使用实体类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> User user, Model model) </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"userForm\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如你所见,方法直接接收一个User实例并没有更进一步的查询是否必要.实例可以通过Spring MVC将路径变量转换为实体类的id类型并最终通过在实体类型注册的仓库实例上调用<code>findOne(...)</code>访问实例转换得到.</p>\n<blockquote>\n<p>注意</p>\n<p>当前的仓库必须实现<code>CrudRepository</code>做好准备被发现来进行转换.</p>\n</blockquote>\n<p><strong>为了分页和排序分解方法参数</strong></p>\n<p>上面的配置片段还注册了一个<code>PageableHandlerMethodArgumentResolver</code>和一个<code>SortHandlerMethodArgumentResolver</code>实例.注册使得Pageable和Sort成为有效的控制器方法参数.</p>\n<p>例34 使用Pageable作为控制器方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> UserRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUsers</span><span class=\"params\">(Model model, Pageable pageable)</span> </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"users\"</span>, repository.findAll(pageable));</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"users\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法签名将使Spring MVC尝试使用下面的默认配置从请求参数中转换一个Pageable实例:</p>\n<p>表1 请求参数转换Pageable实例</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>page</td>\n<td>要检索的页面,索引为0,默认为0</td>\n</tr>\n<tr>\n<td>size</td>\n<td>要检索的页面大小,默认20</td>\n</tr>\n<tr>\n<td>sort</td>\n<td>被排序的属性应以格式`property,property(, ASC\\</td>\n<td>DESC)`表示.默认生序排序,如果你希望改变排序顺序,则使用多个排序参数,例如?sort=firstname&amp;sort=lastname,asc</td>\n</tr>\n</tbody>\n</table>\n<p>为了定制行为,可以继承<code>SpringDataWebConfiguration</code>或者启用等效的HATEOAS并覆盖<code>pageableResolver()</code>或<code>sortResolver()</code>方法并导入你的自定义配置文件替代@Enable-注解.</p>\n<p>有一种情况你需要多个<code>Pageable</code>或<code>Sort</code>实例从请求转换(例如处理多个表单),你可以使用Spring的<code>@Qualifier</code>注解来互相区别.请求参数必须以<code>${qualifier}为</code>前缀.这样一个方法的签名像这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUsers</span><span class=\"params\">(Model model, </div><div class=\"line\">                        @Qualifier(<span class=\"string\">\"foo\"</span>)</span>Pagebale first, </div><div class=\"line\">                        @<span class=\"title\">Qualifier</span><span class=\"params\">(<span class=\"string\">\"bar\"</span>)</span> Pageable second) </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你必须填充foo_page和bar_page等.</p>\n<p>默认的<code>Pageable</code>在方法中处理等价于一个<code>new PageRequest(0, 20)</code>,但是可以使用<code>@PageableDefaults</code>注解在<code>Pageable</code>参数上定制.</p>\n<p><strong>Hypermedia支持分页</strong></p>\n<p>Spring HATEOAS包装了一个代表模型的类<code>PageResources</code> ,</p>\n<p>它可以使用Page实例包装必要的Page元数据内容作为连接让客户端导航页面.一个页面到一个<code>PageResources</code>的转换被Spring HATEOAS的<code>ResourceAssembler</code>接口实现<code>PagedResourcesAssembler</code>来完成.</p>\n<p>例35 使用一个PagedResourcesAssembler作为控制器方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> PersonRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/persons\"</span>, method = RequestMethod.GET)</div><div class=\"line\">  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,</div><div class=\"line\">                                             PagedResourcesAssembler assembler) &#123;</div><div class=\"line\">    Page&lt;Person&gt; persons = repository.findAll(pageable);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面这样配置将允许<code>PageResourcesAssembler</code>作为控制器方法的一个参数.在这调用toResources(…)方法有以下作用:</p>\n<ul>\n<li><code>Page</code>的内容将<code>PageResources</code>实例的内容</li>\n<li><code>PageResources</code>将获得<code>PageMetadata</code>实例,该实例由Page和基础的PageRequest中的信息填充</li>\n<li><code>PageResources</code>获得<code>prev</code>和<code>next</code>连接,添加这些依赖在页面.这些链接将指向uri方法的调用映射.页码参数根据<code>PageableHandlerMethodArgumentResolver</code>添加到参数以在后面被转换.</li>\n</ul>\n<p>假设我们有30个Person实例在数据库.你现在可以触发一个GET请求 <a href=\"http://localhost:8080/persons\">http://localhost:8080/persons</a>, 你将可以看到类似下面的内容:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; \"links\" : [ &#123; \"rel\" : \"next\",</div><div class=\"line\">\"href\" : \"http://localhost:8080/persons?page=1&amp;size=20 &#125;</div><div class=\"line\">],</div><div class=\"line\">\"content\" : [</div><div class=\"line\">… // 20 Person instances rendered here</div><div class=\"line\">],</div><div class=\"line\">\"pageMetadata\" : &#123;</div><div class=\"line\">\"size\" : 20,</div><div class=\"line\">\"totalElements\" : 30,</div><div class=\"line\">\"totalPages\" : 2,</div><div class=\"line\">\"number\" : 0</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以看到编译生成了正确的URI，并且还会提取默认配置转换参数到即将到来的请求中的<code>Pageable</code>.这意味着,如果你改变配置,链接也将自动跟随改变.默认情况下，编译指向控制器执行的方法，但是这可以被一个自定义链接作为基本构建来构成分页的<code>Link</code>重载<code>PagedResourcesAssembler.toResource（...）</code>方法定制.</p>\n<p><strong>Querydsl web 支持</strong></p>\n<p>那些整合了<code>QueryDSL</code>的存储可能从<code>Request</code>查询字符串中的属性驱动查询.</p>\n<p>这意味着前面例子的查询字符串可以给出<code>User</code>的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?firstname=Dave&amp;lastname=Matthews</div></pre></td></tr></table></figure>\n<p>可以被转换为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">QUser.user.firstname.eq(<span class=\"string\">\"Dave\"</span>).and(QUser.user.lastname.eq(<span class=\"string\">\"Matthews\"</span>))</div></pre></td></tr></table></figure>\n<p>使用了<code>QuerydslPredicateArgumentResolver</code>.</p>\n<blockquote>\n<p>注意</p>\n<p>当在类路径上找到Querydsl时，该功能将在@EnableSpringDataWebSupport注解中自动启用</p>\n</blockquote>\n<p>添加一个<code>@QuerydslPredicate</code>到一个方法签名将提供一个就绪的<code>Predicate</code>,可以通过<code>QueryDslPredicateExecutor</code>执行.</p>\n<blockquote>\n<p>提示</p>\n<p>类型信息通常从返回方法上解析.由于这些信息不一定匹配实体类型,使用<code>QuerydslPredicate</code>的<code>root</code>属性可能是个好主意.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> UserRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/\"</span>, method = RequestMethod.GET)</div><div class=\"line\">  <span class=\"function\">String <span class=\"title\">index</span><span class=\"params\">(Model model, @QuerydslPredicate(root = User.class)</span> Predicate predicate,</div><div class=\"line\">              Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt;</div><div class=\"line\">    parameters) </span>&#123;</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"users\"</span>, repository.findAll(predicate, pageable));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"index\"</span>;</div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为User转换匹配查询字符串参数的<code>Predicate</code></p>\n<p>默认的绑定规则如下:</p>\n<ol>\n<li><p><code>Object</code>在简单属性上如同<code>eq</code></p>\n</li>\n<li><p><code>Object</code>在集合作为属性如同<code>contains</code></p>\n</li>\n<li><p><code>Collection</code>在简单属性上如同<code>in</code></p>\n</li>\n</ol>\n<p>这些绑定可以通过<code>@QuerydslPredicate</code>的<code>bindings</code>属性定制或者使用Java8<code>default methods</code>给仓库接口添加<code>QuerydslBinderCustomizer</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserReposotory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CurdRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">String</span>&gt;, </div><div class=\"line\">  <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">User</span>&gt;,</div><div class=\"line\">  <span class=\"title\">QuerydslBinderCustomizer</span>&lt;<span class=\"title\">QUser</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customize</span><span class=\"params\">(QuerydslBindings bindings, QUser user)</span> </span>&#123;</div><div class=\"line\">      bindings.bind(user.username).first((path, value) -&gt; path.contains(value));</div><div class=\"line\">      bindings.bind(String.class).first((StringPath path, String value) -&gt;</div><div class=\"line\">                                        path.containsIgnoreCase(value));</div><div class=\"line\">      bindings.excluding(user.password);</div><div class=\"line\">  \t&#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><code>QueryDslPredicateExecutor</code>为<code>Predicate</code>提供特殊的查询方法提供入口</li>\n<li>在仓库接口定义<code>QuerydslBinderCustomizer</code>将自动注解<code>@QuerydslPredicate(bindings=...)</code></li>\n<li>为<code>username</code>属性定义绑定,绑定到一个简单集合</li>\n<li>为<code>String</code>属性定义默认绑定到一个不区分大小写的集合</li>\n<li>从<code>Predicate</code>移除密码属性</li>\n</ol>\n<h3 id=\"4-7-3-仓库填充\"><a href=\"#4-7-3-仓库填充\" class=\"headerlink\" title=\"4.7.3 仓库填充\"></a>4.7.3 仓库填充</h3><p>如果你使用Spring JDBC模块,你可能熟悉在<code>DataSource</code>使用SQL脚本来填充.一个类似的抽象在仓库级别可以使用,尽管它不是使用SQL作为数据定义语言,因为它必须由存储决定.填充根据仓库支持XML(通过Spring的OXM抽象)和JSON(通过Jackson)定义数据.</p>\n<p>假设你有一个文件<code>data.json</code>内容如下:</p>\n<p>例36 JSON定义的数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ &#123; <span class=\"attr\">\"_class\"</span> : <span class=\"string\">\"com.acme.Person\"</span>,</div><div class=\"line\">     <span class=\"attr\">\"firstname\"</span> : <span class=\"string\">\"Dave\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"lastname\"</span> : <span class=\"string\">\"Matthews\"</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">\"_class\"</span> : <span class=\"string\">\"com.acme.Person\"</span>,</div><div class=\"line\">     <span class=\"attr\">\"firstname\"</span> : <span class=\"string\">\"Carter\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"lastname\"</span> : <span class=\"string\">\"Beauford\"</span> &#125; ]</div></pre></td></tr></table></figure>\n<p>你可以容易的根据Spring Data Commons提供仓库的命名空间填充元素填充你的仓库.为了填充前面的数据到你的PersonRepository,像下面这样配置:</p>\n<p>例37 声明一个Jackson仓库填充</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">    <span class=\"attr\">xmlns:repository</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/repository\"</span></div><div class=\"line\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</div><div class=\"line\">      http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">      http://www.springframework.org/schema/data/repository</div><div class=\"line\">      http://www.springframework.org/schema/data/repository/spring-repository.xsd\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">repository:jackson2-populator</span> <span class=\"attr\">locations</span>=<span class=\"string\">\"classpath:data.json\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这样的声明可以让<code>data.json</code>文件可以被一个Jackson的<code>ObjectMpper</code>读取和反序列化.</p>\n<p>JSON将要解析的对象类型由检查JSON文档的<code>_class</code>属性决定.基本组件将最终选择合适的仓库去处理反序列化的对象.</p>\n<p>要使用XML定义数据填充仓库,你可以使用<code>unmarshaller-populator</code>元素.你配置它使用Spring OXM提供给你的XML装配选项.在Spring reference documentation查看更多细节.</p>\n<p>例38 声明一个装配仓库填充器(使用JAXB)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:repository</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/repository\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:oxm</span>=<span class=\"string\">\"http://www.springframework.org/schema/oxm\"</span></div><div class=\"line\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</div><div class=\"line\">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">        http://www.springframework.org/schema/data/repository</div><div class=\"line\">        http://www.springframework.org/schema/data/repository/spring-repository.xsd</div><div class=\"line\">        http://www.springframework.org/schema/oxm</div><div class=\"line\">        http://www.springframework.org/schema/oxm/spring-oxm.xsd\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repository:unmarshaller-populator</span> <span class=\"attr\">locations</span>=<span class=\"string\">\"classpath:data.json\"</span></div><div class=\"line\">        <span class=\"attr\">unmarshaller-ref</span>=<span class=\"string\">\"unmarshaller\"</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">oxm:jaxb2-marshaller</span> <span class=\"attr\">contextPath</span>=<span class=\"string\">\"com.acme\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-7-4-遗留web支持\"><a href=\"#4-7-4-遗留web支持\" class=\"headerlink\" title=\"4.7.4 遗留web支持\"></a>4.7.4 遗留web支持</h3><p><strong>Spring MVC的实体类绑定</strong></p>\n<p>如果正在开发Spring MVC web应用,你通常必须从URL中解析实体类的id.默认的,你的任务是转化请求参数或URL参数到实体类并将它移交给下面或直接在实体上操作业务逻辑.这看起来像下面这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> UserRepository userRepository;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</div><div class=\"line\">    Assert.notNull(repository, <span class=\"string\">\"Repository must not be null!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.userRepository = userRepository;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> Long id, Model model) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Do null check for id</span></div><div class=\"line\">    User user = userRepository.findOne(id);</div><div class=\"line\">    <span class=\"comment\">// Do null check for user</span></div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"user\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先你为每个控制器定义一个依赖的仓库来查找它们分别管理的实体.查询实体也是样板,因为它总是一个<code>findOne(...)</code>调用.幸运的Spring提供了方法来注册自定义组件,允许一个String值转换到一个属性类型.</p>\n<p><strong>属性编辑</strong></p>\n<p>Spring3.0之前Java<code>PropertyEditors</code>被使用.为了集成这些,Spring Data提出一个<code>DomainClassPropertyEditorRegistrar</code>来查询所有注册到<code>ApplicatonContext</code>的Spring Data仓库和一个定制的<code>PropertyEditor</code>来管理实体类.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"webBindingInitializer\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"….web.bind.support.ConfigurableWebBindingInitializer\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"propertyEditorRegistrars\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=</div><div class=\"line\">          <span class=\"string\">\"org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar\"</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果你已经像上面这样配置Spring MVC,你可以向下面这样配置你的控制器,从而减少不清晰和样板式的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> User user, Model model) </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"userForm\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"2016's Summary","date":"2016-12-29T16:00:00.000Z","_content":"\n## 2016’s Summary\n\n\n| 时间      | 任务                                       |\n| ------- | ---------------------------------------- |\n| 2016.01 | 开始阅读《Java核心技术》，《Head First Java》         |\n| 2016.02 | [阅读《Java核心技术》完成，《Head First Java》](https://github.com/zhanghTK/HelloJava) |\n| 2016.03 | [阅读《Head First 设计模式》完成一半](https://github.com/zhanghTK/HelloDesignPattern) |\n| 2016.04 | 阅读《架构探险》完成一半，《看透Spring MVC》完成一半          |\n| 2016.05 | Hibernate4学习，协助强锦昕同学完成了毕业设计的编码工作（[素性检测](https://github.com/zhanghTK/PrimalityTesting) ） |\n| 2016.06 | 阅读《Spring实战》完成一半，《Spring Boot实战》完成       |\n| 2016.07 | 搭建[博客](http://zhangh.tk/)，[阅读《Head First HTML CSS》完成](http://zhangh.tk/2016/07/31/HTML%E4%B8%8ECSS%E5%B0%8F%E8%AE%B0/)，了解Docker，Dubbo |\n| 2016.08 | [阅读《函数式编程思维》完成](http://zhangh.tk/2016/08/27/%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/)，《MySQL必知必会》完成 |\n| 2016.09 | [阅读《Java并发编程实战》完成](http://zhangh.tk/2016/09/29/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/)， 阅读《Head First Servlet&JSP》完成不包含JSP部分 |\n| 2016.10 | [阅读《Java Persistence with MyBatis 3》完成](https://github.com/zhanghTK/HelloMyBatis)，参加了“编码武者”线下培训[1](http://zhangh.tk/2016/10/22/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/),[2](http://zhangh.tk/2016/10/22/%E4%BB%8E%E4%BE%9D%E8%B5%96%E5%AE%9E%E7%8E%B0%E5%88%B0%E4%BE%9D%E8%B5%96%E8%A1%8C%E4%B8%BA/),[3](http://zhangh.tk/2016/10/22/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E2%80%94%E2%80%94%E5%90%88%E7%90%86%E7%9A%84%E5%B0%81%E8%A3%85/) |\n| 2016.11 | 翻译《Spring Data官方文档》第四章,[临摹了一个IoC容器Demo](https://github.com/zhanghTK/HelloIoC)，阅读《Effective Java》完成 |\n| 2016.12 | [模仿Struts1实现一个MVC框架](https://github.com/zhanghTK/HelloStruts1)，阅读《深入理解Java虚拟机》完成 |\n\n---\n\n2016年的改善：\n\n1. 熟悉了Java以及相关的工具\n2. 对日常开源框架大体有了了解\n3. 代码质量整体提升\n\n2016年的不足：\n\n1. 乱，学习没有计划，尤其上半年，基础的积累不够，追逐时髦技术；\n2. 懒，产出不多，很多内容停留在读的层面，缺乏实现，理解不够不深入；\n3. 急，书读的囫囵吞枣，实践不够，实践的代码可维护性差；\n\n---\n\n## 2017‘s Flag\n\n![2017任务](https://ooo.0o0.ooo/2016/12/30/586615ad1ca69.jpg)\n\n![阅读计划](https://ooo.0o0.ooo/2016/12/30/586615ff1a321.jpg)\n","source":"_posts/二零一六年度总结.md","raw":"---\ntitle: 2016's Summary\ndate: 2016-12-30\ntags:\ncategories: 随笔\n---\n\n## 2016’s Summary\n\n\n| 时间      | 任务                                       |\n| ------- | ---------------------------------------- |\n| 2016.01 | 开始阅读《Java核心技术》，《Head First Java》         |\n| 2016.02 | [阅读《Java核心技术》完成，《Head First Java》](https://github.com/zhanghTK/HelloJava) |\n| 2016.03 | [阅读《Head First 设计模式》完成一半](https://github.com/zhanghTK/HelloDesignPattern) |\n| 2016.04 | 阅读《架构探险》完成一半，《看透Spring MVC》完成一半          |\n| 2016.05 | Hibernate4学习，协助强锦昕同学完成了毕业设计的编码工作（[素性检测](https://github.com/zhanghTK/PrimalityTesting) ） |\n| 2016.06 | 阅读《Spring实战》完成一半，《Spring Boot实战》完成       |\n| 2016.07 | 搭建[博客](http://zhangh.tk/)，[阅读《Head First HTML CSS》完成](http://zhangh.tk/2016/07/31/HTML%E4%B8%8ECSS%E5%B0%8F%E8%AE%B0/)，了解Docker，Dubbo |\n| 2016.08 | [阅读《函数式编程思维》完成](http://zhangh.tk/2016/08/27/%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/)，《MySQL必知必会》完成 |\n| 2016.09 | [阅读《Java并发编程实战》完成](http://zhangh.tk/2016/09/29/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/)， 阅读《Head First Servlet&JSP》完成不包含JSP部分 |\n| 2016.10 | [阅读《Java Persistence with MyBatis 3》完成](https://github.com/zhanghTK/HelloMyBatis)，参加了“编码武者”线下培训[1](http://zhangh.tk/2016/10/22/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/),[2](http://zhangh.tk/2016/10/22/%E4%BB%8E%E4%BE%9D%E8%B5%96%E5%AE%9E%E7%8E%B0%E5%88%B0%E4%BE%9D%E8%B5%96%E8%A1%8C%E4%B8%BA/),[3](http://zhangh.tk/2016/10/22/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E2%80%94%E2%80%94%E5%90%88%E7%90%86%E7%9A%84%E5%B0%81%E8%A3%85/) |\n| 2016.11 | 翻译《Spring Data官方文档》第四章,[临摹了一个IoC容器Demo](https://github.com/zhanghTK/HelloIoC)，阅读《Effective Java》完成 |\n| 2016.12 | [模仿Struts1实现一个MVC框架](https://github.com/zhanghTK/HelloStruts1)，阅读《深入理解Java虚拟机》完成 |\n\n---\n\n2016年的改善：\n\n1. 熟悉了Java以及相关的工具\n2. 对日常开源框架大体有了了解\n3. 代码质量整体提升\n\n2016年的不足：\n\n1. 乱，学习没有计划，尤其上半年，基础的积累不够，追逐时髦技术；\n2. 懒，产出不多，很多内容停留在读的层面，缺乏实现，理解不够不深入；\n3. 急，书读的囫囵吞枣，实践不够，实践的代码可维护性差；\n\n---\n\n## 2017‘s Flag\n\n![2017任务](https://ooo.0o0.ooo/2016/12/30/586615ad1ca69.jpg)\n\n![阅读计划](https://ooo.0o0.ooo/2016/12/30/586615ff1a321.jpg)\n","slug":"二零一六年度总结","published":1,"updated":"2017-01-07T08:23:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gaz0011yi2ewwk3b3vq","content":"<h2 id=\"2016’s-Summary\"><a href=\"#2016’s-Summary\" class=\"headerlink\" title=\"2016’s Summary\"></a>2016’s Summary</h2><table>\n<thead>\n<tr>\n<th>时间</th>\n<th>任务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2016.01</td>\n<td>开始阅读《Java核心技术》，《Head First Java》</td>\n</tr>\n<tr>\n<td>2016.02</td>\n<td><a href=\"https://github.com/zhanghTK/HelloJava\" target=\"_blank\" rel=\"external\">阅读《Java核心技术》完成，《Head First Java》</a></td>\n</tr>\n<tr>\n<td>2016.03</td>\n<td><a href=\"https://github.com/zhanghTK/HelloDesignPattern\" target=\"_blank\" rel=\"external\">阅读《Head First 设计模式》完成一半</a></td>\n</tr>\n<tr>\n<td>2016.04</td>\n<td>阅读《架构探险》完成一半，《看透Spring MVC》完成一半</td>\n</tr>\n<tr>\n<td>2016.05</td>\n<td>Hibernate4学习，协助强锦昕同学完成了毕业设计的编码工作（<a href=\"https://github.com/zhanghTK/PrimalityTesting\" target=\"_blank\" rel=\"external\">素性检测</a> ）</td>\n</tr>\n<tr>\n<td>2016.06</td>\n<td>阅读《Spring实战》完成一半，《Spring Boot实战》完成</td>\n</tr>\n<tr>\n<td>2016.07</td>\n<td>搭建<a href=\"http://zhangh.tk/\" target=\"_blank\" rel=\"external\">博客</a>，<a href=\"http://zhangh.tk/2016/07/31/HTML%E4%B8%8ECSS%E5%B0%8F%E8%AE%B0/\" target=\"_blank\" rel=\"external\">阅读《Head First HTML CSS》完成</a>，了解Docker，Dubbo</td>\n</tr>\n<tr>\n<td>2016.08</td>\n<td><a href=\"http://zhangh.tk/2016/08/27/%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"external\">阅读《函数式编程思维》完成</a>，《MySQL必知必会》完成</td>\n</tr>\n<tr>\n<td>2016.09</td>\n<td><a href=\"http://zhangh.tk/2016/09/29/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"external\">阅读《Java并发编程实战》完成</a>， 阅读《Head First Servlet&amp;JSP》完成不包含JSP部分</td>\n</tr>\n<tr>\n<td>2016.10</td>\n<td><a href=\"https://github.com/zhanghTK/HelloMyBatis\" target=\"_blank\" rel=\"external\">阅读《Java Persistence with MyBatis 3》完成</a>，参加了“编码武者”线下培训<a href=\"http://zhangh.tk/2016/10/22/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/\" target=\"_blank\" rel=\"external\">1</a>,<a href=\"http://zhangh.tk/2016/10/22/%E4%BB%8E%E4%BE%9D%E8%B5%96%E5%AE%9E%E7%8E%B0%E5%88%B0%E4%BE%9D%E8%B5%96%E8%A1%8C%E4%B8%BA/\" target=\"_blank\" rel=\"external\">2</a>,<a href=\"http://zhangh.tk/2016/10/22/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E2%80%94%E2%80%94%E5%90%88%E7%90%86%E7%9A%84%E5%B0%81%E8%A3%85/\" target=\"_blank\" rel=\"external\">3</a></td>\n</tr>\n<tr>\n<td>2016.11</td>\n<td>翻译《Spring Data官方文档》第四章,<a href=\"https://github.com/zhanghTK/HelloIoC\" target=\"_blank\" rel=\"external\">临摹了一个IoC容器Demo</a>，阅读《Effective Java》完成</td>\n</tr>\n<tr>\n<td>2016.12</td>\n<td><a href=\"https://github.com/zhanghTK/HelloStruts1\" target=\"_blank\" rel=\"external\">模仿Struts1实现一个MVC框架</a>，阅读《深入理解Java虚拟机》完成</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>2016年的改善：</p>\n<ol>\n<li>熟悉了Java以及相关的工具</li>\n<li>对日常开源框架大体有了了解</li>\n<li>代码质量整体提升</li>\n</ol>\n<p>2016年的不足：</p>\n<ol>\n<li>乱，学习没有计划，尤其上半年，基础的积累不够，追逐时髦技术；</li>\n<li>懒，产出不多，很多内容停留在读的层面，缺乏实现，理解不够不深入；</li>\n<li>急，书读的囫囵吞枣，实践不够，实践的代码可维护性差；</li>\n</ol>\n<hr>\n<h2 id=\"2017‘s-Flag\"><a href=\"#2017‘s-Flag\" class=\"headerlink\" title=\"2017‘s Flag\"></a>2017‘s Flag</h2><p><img src=\"https://ooo.0o0.ooo/2016/12/30/586615ad1ca69.jpg\" alt=\"2017任务\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2016/12/30/586615ff1a321.jpg\" alt=\"阅读计划\"></p>\n","excerpt":"","more":"<h2 id=\"2016’s-Summary\"><a href=\"#2016’s-Summary\" class=\"headerlink\" title=\"2016’s Summary\"></a>2016’s Summary</h2><table>\n<thead>\n<tr>\n<th>时间</th>\n<th>任务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2016.01</td>\n<td>开始阅读《Java核心技术》，《Head First Java》</td>\n</tr>\n<tr>\n<td>2016.02</td>\n<td><a href=\"https://github.com/zhanghTK/HelloJava\">阅读《Java核心技术》完成，《Head First Java》</a></td>\n</tr>\n<tr>\n<td>2016.03</td>\n<td><a href=\"https://github.com/zhanghTK/HelloDesignPattern\">阅读《Head First 设计模式》完成一半</a></td>\n</tr>\n<tr>\n<td>2016.04</td>\n<td>阅读《架构探险》完成一半，《看透Spring MVC》完成一半</td>\n</tr>\n<tr>\n<td>2016.05</td>\n<td>Hibernate4学习，协助强锦昕同学完成了毕业设计的编码工作（<a href=\"https://github.com/zhanghTK/PrimalityTesting\">素性检测</a> ）</td>\n</tr>\n<tr>\n<td>2016.06</td>\n<td>阅读《Spring实战》完成一半，《Spring Boot实战》完成</td>\n</tr>\n<tr>\n<td>2016.07</td>\n<td>搭建<a href=\"http://zhangh.tk/\">博客</a>，<a href=\"http://zhangh.tk/2016/07/31/HTML%E4%B8%8ECSS%E5%B0%8F%E8%AE%B0/\">阅读《Head First HTML CSS》完成</a>，了解Docker，Dubbo</td>\n</tr>\n<tr>\n<td>2016.08</td>\n<td><a href=\"http://zhangh.tk/2016/08/27/%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/\">阅读《函数式编程思维》完成</a>，《MySQL必知必会》完成</td>\n</tr>\n<tr>\n<td>2016.09</td>\n<td><a href=\"http://zhangh.tk/2016/09/29/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/\">阅读《Java并发编程实战》完成</a>， 阅读《Head First Servlet&amp;JSP》完成不包含JSP部分</td>\n</tr>\n<tr>\n<td>2016.10</td>\n<td><a href=\"https://github.com/zhanghTK/HelloMyBatis\">阅读《Java Persistence with MyBatis 3》完成</a>，参加了“编码武者”线下培训<a href=\"http://zhangh.tk/2016/10/22/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/\">1</a>,<a href=\"http://zhangh.tk/2016/10/22/%E4%BB%8E%E4%BE%9D%E8%B5%96%E5%AE%9E%E7%8E%B0%E5%88%B0%E4%BE%9D%E8%B5%96%E8%A1%8C%E4%B8%BA/\">2</a>,<a href=\"http://zhangh.tk/2016/10/22/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E2%80%94%E2%80%94%E5%90%88%E7%90%86%E7%9A%84%E5%B0%81%E8%A3%85/\">3</a></td>\n</tr>\n<tr>\n<td>2016.11</td>\n<td>翻译《Spring Data官方文档》第四章,<a href=\"https://github.com/zhanghTK/HelloIoC\">临摹了一个IoC容器Demo</a>，阅读《Effective Java》完成</td>\n</tr>\n<tr>\n<td>2016.12</td>\n<td><a href=\"https://github.com/zhanghTK/HelloStruts1\">模仿Struts1实现一个MVC框架</a>，阅读《深入理解Java虚拟机》完成</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>2016年的改善：</p>\n<ol>\n<li>熟悉了Java以及相关的工具</li>\n<li>对日常开源框架大体有了了解</li>\n<li>代码质量整体提升</li>\n</ol>\n<p>2016年的不足：</p>\n<ol>\n<li>乱，学习没有计划，尤其上半年，基础的积累不够，追逐时髦技术；</li>\n<li>懒，产出不多，很多内容停留在读的层面，缺乏实现，理解不够不深入；</li>\n<li>急，书读的囫囵吞枣，实践不够，实践的代码可维护性差；</li>\n</ol>\n<hr>\n<h2 id=\"2017‘s-Flag\"><a href=\"#2017‘s-Flag\" class=\"headerlink\" title=\"2017‘s Flag\"></a>2017‘s Flag</h2><p><img src=\"https://ooo.0o0.ooo/2016/12/30/586615ad1ca69.jpg\" alt=\"2017任务\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2016/12/30/586615ff1a321.jpg\" alt=\"阅读计划\"></p>\n"},{"title":"使用Builder模式改进多参数方法","date":"2016-10-16T03:58:39.000Z","_content":"\n## 概述\n\n记一次工作当中对多参数方法重构。\n\n1. 使用对象封装对多参数，简化方法调用\n2. 使用Builder（创建者）模式简化多属性对象的创建\n\n## 问题\n\n业务系统中统一的邮件发送服务接口在改造前大概长着个样子：\n\n```java\n\t/**\n     * 不帶附件的邮件发送\n     * 未使用建造者模式的原始方法（不良代码）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons){\n        logger.info(\"send email\");\n    }\n\n\n    /**\n     * 带附件的邮件发送\n     * 未使用建造者模式的原始方法（不良）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     * @param docName                       文档名称\n     * @param fileName                      文件名称(单个文件)\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons, String docName, String fileName){\n        logger.info(\"send email\");\n    }\n\n    /**\n     * 带附件的邮件发送\n     * 未使用建造者模式的原始方法（不良代码）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     * @param docName                       文档名称\n     * @param fileNames                     文件名称(多个文件,文件名称列表)\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons, String docName, List<String> fileNames){\n        logger.info(\"send email\");\n    }\n```\n\n接口有个重要的内容注释中并没有说明：参数中“模板”和“收件人”是必填的，而其他参数是非必填的。\n\n接口的可配置程度还是不错的，但是调用的过程就比较痛苦了。\n\n一大堆String和List接口暴露出来，同时又使用了不同的参数个数来进行重载。\n\n调用的时候光是创建这些参数就够麻烦的了，还要考虑哪些参数是必填的以及参数的正确位置。更糟糕的是参数传错位置你会发现很有可能并没有显式的暴露出问题，邮件还是发送了只是发送到错误的相关人员那里。\n\n其他人看到方法调用也无法清晰知道这个到底是要发什么邮件，给哪些人。\n\n这应该就是坏代码的味道吧。\n\n## 改进\n\n简单的改进思路就是把参数做成一个modle封装起来，以后传递model给方法。就像这样：\n\n```java\n    /**\n     * 邮件发送通用接口\n     * @param email 邮件发送参数对象\n     */\n    public static void sendEmail(EmailSendMain email){\n    \tlogger.info(\"send email:\" + email);\n    }\n```\n\n但是问题还是没有根本解决，对象的构造还是需要多个参数的构造方法，可能还需要重载。\n\n比较容易想到的改进是使用Java Bean模式。简化构造方法字段，构造方法只传入必要的字段，使用setter方法设置其他值。我就是这么肤浅的想到这个地步了。\n\n乍一看问题是解决了，其实不然。\n\n1. 在对象创建过程中Java Bean可能处于不一致状态\n2. 使用Java Bean就将不能创建不可变对象\n\n读了《Effective Java》只是第二章就有了更好的解决思路——Builder模式。\n\n先看改进后的代码：\n\n```java\n/**\n * 复杂类型构建接口\n *\n * 建造者模式中的抽象构建者\n * Created by ZhangHao on 2016/10/15.\n */\npublic interface Builder<T> {\n    T build();\n}\n\n/**\n * 邮件发送参数对象\n * 包含多个字段的复杂类型，使用内部类实现Builder接口创建对象\n *\n * 建造者模式中的产品类\n * Created by ZhangHao on 2016/10/15.\n */\npublic final class EmailSendMain {\n    private final String template;  // 模板名称\n    private final List<String> subjects;  // 主题参数列表\n    private final List<String> contents;  // 内容参数列表\n    private final List<String> toPersons;  // 收件人列表\n    private final List<String> ccPersons;  // 抄送人列表\n    private final List<String> bccPersons;  // 暗送人列表\n    private final String docName;  // 文档名称\n    private final List<String> fileNames;  // 文件名称列表\n\n    private EmailSendMain(Builder builder) {\n        this.template = builder.template;\n        this.subjects = builder.subjects;\n        this.contents = builder.contents;\n        this.toPersons = builder.toPersons;\n        this.ccPersons = builder.ccPersons;\n        this.bccPersons = builder.bccPersons;\n        this.docName = builder.docName;\n        this.fileNames = builder.fileNames;\n    }\n\n    /**\n     * 实现Builder接口的构建类，用于创建EmailSendMain\n     *\n     * 建造者模式中的建造类\n     */\n    public static class Builder implements tk.zhangh.pattern.create.builder.demo1.Builder<EmailSendMain> {\n        private String template;  // 模板名称\n        private List<String> subjects;  // 主题参数列表\n        private List<String> contents;  // 内容参数列表\n        private List<String> toPersons;  // 收件人列表\n        private List<String> ccPersons;  // 抄送人列表\n        private List<String> bccPersons;  // 暗送人列表\n        private String docName;  // 文档名称\n        private List<String> fileNames;  // 文件名称列表\n\n        public Builder(String template, List<String> toPersons) {\n            this.template = template;\n            this.toPersons = toPersons;\n        }\n\n        @Override\n        public EmailSendMain build() {\n            return new EmailSendMain(this);\n        }\n\n        public Builder subjects(List<String> subjects) {\n            this.subjects = subjects;\n            return this;\n        }\n\n        public Builder contents(List<String> contents) {\n            this.contents = contents;\n            return this;\n        }\n\n        public Builder ccPersons(List<String> ccPersons) {\n            this.ccPersons = ccPersons;\n            return this;\n        }\n\n        public Builder bccPersons(List<String> bccPersons) {\n            this.bccPersons = bccPersons;\n            return this;\n        }\n\n        public Builder docName(String docName) {\n            this.docName = docName;\n            return this;\n        }\n\n        public Builder fileNames(List<String> fileNames) {\n            this.fileNames = fileNames;\n            return this;\n        }\n    }\n\n    // getter,toString方法省略\n}\n```\n\n重写做的接口方法封装：\n\n```java\n    /**\n     * 邮件发送通用接口\n     * @param email 邮件发送参数对象\n     */\n    public static void sendEmail(EmailSendMain email){\n        logger.info(\"send email:\" + email);\n        if ((email.getDocName() == null || email.getDocName().equals(\"\")) ||\n                (email.getFileNames() == null || email.getFileNames().size() == 0)) {\n            sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),\n                    email.getCcPersons(), email.getBccPersons());\n        }else {\n            sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),\n                    email.getCcPersons(), email.getBccPersons(), email.getDocName(), email.getFileNames());\n        }\n    }\n```\n\n客户端调用：\n\n```java\n    @Test\n    public void testSendEmail() throws Exception {\n        EmailSendMain email =\n                new EmailSendMain.Builder(\"邮件模版名\",toPersons).\n                        subjects(subjects).\n                        contents(contents).\n                        ccPersons(ccPersons).\n                        bccPersons(bccPersons).build();\n        SendEmailUtil.sendEmail(email);\n    }\n```\n\n问题圆满解决，支持可选参数的链式结构调用，创建过程也确保了一致性，使用不可变类也没问题。\n\n如果说缺点，其实不难看出EmailSendMain的字段和它的内部类Builder字段完全重复了。为了创建EmailSendMain的对象将必须先创建Builder也会带来轻微的性能问题。创建的调用过程虽然看起来更清晰，但也更加冗长。\n\n但是Builder模式还是创建多参数类的不错选择，尤其是大多数参数是可选。\n\n## 扩展\n\n这篇文章的思路是根据《Effective Java》得来的，文章只提到书中建议的第二条，实际关于上面使用到的内部类，泛型，在书中的建议都让我有了更多的认识。我就不赘述了，连上8天班我要去偷懒了。\n\n写这篇文章的时候看到有个系列专门讲Java方法参数太多的问题\n\n传送门：https://dzone.com/articles/too-many-parameters-java\n\n以及翻译：http://www.importnew.com/6518.html\n\n代码我放在了学习设计模式的项目下：\n\n传送门：https://github.com/zhanghTK/HelloDesignPattern\n","source":"_posts/使用Builder模式改进多参数方法.md","raw":"---\ntitle: 使用Builder模式改进多参数方法\ndate: 2016-10-16 11:58:39\ntags: \n  - 设计模式\n  - Java\ncategory: 设计模式\n---\n\n## 概述\n\n记一次工作当中对多参数方法重构。\n\n1. 使用对象封装对多参数，简化方法调用\n2. 使用Builder（创建者）模式简化多属性对象的创建\n\n## 问题\n\n业务系统中统一的邮件发送服务接口在改造前大概长着个样子：\n\n```java\n\t/**\n     * 不帶附件的邮件发送\n     * 未使用建造者模式的原始方法（不良代码）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons){\n        logger.info(\"send email\");\n    }\n\n\n    /**\n     * 带附件的邮件发送\n     * 未使用建造者模式的原始方法（不良）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     * @param docName                       文档名称\n     * @param fileName                      文件名称(单个文件)\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons, String docName, String fileName){\n        logger.info(\"send email\");\n    }\n\n    /**\n     * 带附件的邮件发送\n     * 未使用建造者模式的原始方法（不良代码）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     * @param docName                       文档名称\n     * @param fileNames                     文件名称(多个文件,文件名称列表)\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons, String docName, List<String> fileNames){\n        logger.info(\"send email\");\n    }\n```\n\n接口有个重要的内容注释中并没有说明：参数中“模板”和“收件人”是必填的，而其他参数是非必填的。\n\n接口的可配置程度还是不错的，但是调用的过程就比较痛苦了。\n\n一大堆String和List接口暴露出来，同时又使用了不同的参数个数来进行重载。\n\n调用的时候光是创建这些参数就够麻烦的了，还要考虑哪些参数是必填的以及参数的正确位置。更糟糕的是参数传错位置你会发现很有可能并没有显式的暴露出问题，邮件还是发送了只是发送到错误的相关人员那里。\n\n其他人看到方法调用也无法清晰知道这个到底是要发什么邮件，给哪些人。\n\n这应该就是坏代码的味道吧。\n\n## 改进\n\n简单的改进思路就是把参数做成一个modle封装起来，以后传递model给方法。就像这样：\n\n```java\n    /**\n     * 邮件发送通用接口\n     * @param email 邮件发送参数对象\n     */\n    public static void sendEmail(EmailSendMain email){\n    \tlogger.info(\"send email:\" + email);\n    }\n```\n\n但是问题还是没有根本解决，对象的构造还是需要多个参数的构造方法，可能还需要重载。\n\n比较容易想到的改进是使用Java Bean模式。简化构造方法字段，构造方法只传入必要的字段，使用setter方法设置其他值。我就是这么肤浅的想到这个地步了。\n\n乍一看问题是解决了，其实不然。\n\n1. 在对象创建过程中Java Bean可能处于不一致状态\n2. 使用Java Bean就将不能创建不可变对象\n\n读了《Effective Java》只是第二章就有了更好的解决思路——Builder模式。\n\n先看改进后的代码：\n\n```java\n/**\n * 复杂类型构建接口\n *\n * 建造者模式中的抽象构建者\n * Created by ZhangHao on 2016/10/15.\n */\npublic interface Builder<T> {\n    T build();\n}\n\n/**\n * 邮件发送参数对象\n * 包含多个字段的复杂类型，使用内部类实现Builder接口创建对象\n *\n * 建造者模式中的产品类\n * Created by ZhangHao on 2016/10/15.\n */\npublic final class EmailSendMain {\n    private final String template;  // 模板名称\n    private final List<String> subjects;  // 主题参数列表\n    private final List<String> contents;  // 内容参数列表\n    private final List<String> toPersons;  // 收件人列表\n    private final List<String> ccPersons;  // 抄送人列表\n    private final List<String> bccPersons;  // 暗送人列表\n    private final String docName;  // 文档名称\n    private final List<String> fileNames;  // 文件名称列表\n\n    private EmailSendMain(Builder builder) {\n        this.template = builder.template;\n        this.subjects = builder.subjects;\n        this.contents = builder.contents;\n        this.toPersons = builder.toPersons;\n        this.ccPersons = builder.ccPersons;\n        this.bccPersons = builder.bccPersons;\n        this.docName = builder.docName;\n        this.fileNames = builder.fileNames;\n    }\n\n    /**\n     * 实现Builder接口的构建类，用于创建EmailSendMain\n     *\n     * 建造者模式中的建造类\n     */\n    public static class Builder implements tk.zhangh.pattern.create.builder.demo1.Builder<EmailSendMain> {\n        private String template;  // 模板名称\n        private List<String> subjects;  // 主题参数列表\n        private List<String> contents;  // 内容参数列表\n        private List<String> toPersons;  // 收件人列表\n        private List<String> ccPersons;  // 抄送人列表\n        private List<String> bccPersons;  // 暗送人列表\n        private String docName;  // 文档名称\n        private List<String> fileNames;  // 文件名称列表\n\n        public Builder(String template, List<String> toPersons) {\n            this.template = template;\n            this.toPersons = toPersons;\n        }\n\n        @Override\n        public EmailSendMain build() {\n            return new EmailSendMain(this);\n        }\n\n        public Builder subjects(List<String> subjects) {\n            this.subjects = subjects;\n            return this;\n        }\n\n        public Builder contents(List<String> contents) {\n            this.contents = contents;\n            return this;\n        }\n\n        public Builder ccPersons(List<String> ccPersons) {\n            this.ccPersons = ccPersons;\n            return this;\n        }\n\n        public Builder bccPersons(List<String> bccPersons) {\n            this.bccPersons = bccPersons;\n            return this;\n        }\n\n        public Builder docName(String docName) {\n            this.docName = docName;\n            return this;\n        }\n\n        public Builder fileNames(List<String> fileNames) {\n            this.fileNames = fileNames;\n            return this;\n        }\n    }\n\n    // getter,toString方法省略\n}\n```\n\n重写做的接口方法封装：\n\n```java\n    /**\n     * 邮件发送通用接口\n     * @param email 邮件发送参数对象\n     */\n    public static void sendEmail(EmailSendMain email){\n        logger.info(\"send email:\" + email);\n        if ((email.getDocName() == null || email.getDocName().equals(\"\")) ||\n                (email.getFileNames() == null || email.getFileNames().size() == 0)) {\n            sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),\n                    email.getCcPersons(), email.getBccPersons());\n        }else {\n            sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),\n                    email.getCcPersons(), email.getBccPersons(), email.getDocName(), email.getFileNames());\n        }\n    }\n```\n\n客户端调用：\n\n```java\n    @Test\n    public void testSendEmail() throws Exception {\n        EmailSendMain email =\n                new EmailSendMain.Builder(\"邮件模版名\",toPersons).\n                        subjects(subjects).\n                        contents(contents).\n                        ccPersons(ccPersons).\n                        bccPersons(bccPersons).build();\n        SendEmailUtil.sendEmail(email);\n    }\n```\n\n问题圆满解决，支持可选参数的链式结构调用，创建过程也确保了一致性，使用不可变类也没问题。\n\n如果说缺点，其实不难看出EmailSendMain的字段和它的内部类Builder字段完全重复了。为了创建EmailSendMain的对象将必须先创建Builder也会带来轻微的性能问题。创建的调用过程虽然看起来更清晰，但也更加冗长。\n\n但是Builder模式还是创建多参数类的不错选择，尤其是大多数参数是可选。\n\n## 扩展\n\n这篇文章的思路是根据《Effective Java》得来的，文章只提到书中建议的第二条，实际关于上面使用到的内部类，泛型，在书中的建议都让我有了更多的认识。我就不赘述了，连上8天班我要去偷懒了。\n\n写这篇文章的时候看到有个系列专门讲Java方法参数太多的问题\n\n传送门：https://dzone.com/articles/too-many-parameters-java\n\n以及翻译：http://www.importnew.com/6518.html\n\n代码我放在了学习设计模式的项目下：\n\n传送门：https://github.com/zhanghTK/HelloDesignPattern\n","slug":"使用Builder模式改进多参数方法","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gb10015yi2e3zz20qxs","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>记一次工作当中对多参数方法重构。</p>\n<ol>\n<li>使用对象封装对多参数，简化方法调用</li>\n<li>使用Builder（创建者）模式简化多属性对象的创建</li>\n</ol>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>业务系统中统一的邮件发送服务接口在改造前大概长着个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">    * 不帶附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良代码）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</span></span></div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons)&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">    * 带附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> docName                       文档名称</div><div class=\"line\">    * <span class=\"doctag\">@param</span> fileName                      文件名称(单个文件)</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</span></span></div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons, String docName, String fileName)&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">    * 带附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良代码）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> docName                       文档名称</div><div class=\"line\">    * <span class=\"doctag\">@param</span> fileNames                     文件名称(多个文件,文件名称列表)</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</span></span></div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons, String docName, List&lt;String&gt; fileNames)&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>接口有个重要的内容注释中并没有说明：参数中“模板”和“收件人”是必填的，而其他参数是非必填的。</p>\n<p>接口的可配置程度还是不错的，但是调用的过程就比较痛苦了。</p>\n<p>一大堆String和List接口暴露出来，同时又使用了不同的参数个数来进行重载。</p>\n<p>调用的时候光是创建这些参数就够麻烦的了，还要考虑哪些参数是必填的以及参数的正确位置。更糟糕的是参数传错位置你会发现很有可能并没有显式的暴露出问题，邮件还是发送了只是发送到错误的相关人员那里。</p>\n<p>其他人看到方法调用也无法清晰知道这个到底是要发什么邮件，给哪些人。</p>\n<p>这应该就是坏代码的味道吧。</p>\n<h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><p>简单的改进思路就是把参数做成一个modle封装起来，以后传递model给方法。就像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 邮件发送通用接口</div><div class=\"line\"> * <span class=\"doctag\">@param</span> email 邮件发送参数对象</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(EmailSendMain email)</span></span>&#123;</div><div class=\"line\">\tlogger.info(<span class=\"string\">\"send email:\"</span> + email);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是问题还是没有根本解决，对象的构造还是需要多个参数的构造方法，可能还需要重载。</p>\n<p>比较容易想到的改进是使用Java Bean模式。简化构造方法字段，构造方法只传入必要的字段，使用setter方法设置其他值。我就是这么肤浅的想到这个地步了。</p>\n<p>乍一看问题是解决了，其实不然。</p>\n<ol>\n<li>在对象创建过程中Java Bean可能处于不一致状态</li>\n<li>使用Java Bean就将不能创建不可变对象</li>\n</ol>\n<p>读了《Effective Java》只是第二章就有了更好的解决思路——Builder模式。</p>\n<p>先看改进后的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 复杂类型构建接口</div><div class=\"line\"> *</div><div class=\"line\"> * 建造者模式中的抽象构建者</div><div class=\"line\"> * Created by ZhangHao on 2016/10/15.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Builder</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\">T <span class=\"title\">build</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 邮件发送参数对象</div><div class=\"line\"> * 包含多个字段的复杂类型，使用内部类实现Builder接口创建对象</div><div class=\"line\"> *</div><div class=\"line\"> * 建造者模式中的产品类</div><div class=\"line\"> * Created by ZhangHao on 2016/10/15.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmailSendMain</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String template;  <span class=\"comment\">// 模板名称</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; subjects;  <span class=\"comment\">// 主题参数列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; contents;  <span class=\"comment\">// 内容参数列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; toPersons;  <span class=\"comment\">// 收件人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; ccPersons;  <span class=\"comment\">// 抄送人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; bccPersons;  <span class=\"comment\">// 暗送人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String docName;  <span class=\"comment\">// 文档名称</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; fileNames;  <span class=\"comment\">// 文件名称列表</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">EmailSendMain</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.template = builder.template;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subjects = builder.subjects;</div><div class=\"line\">        <span class=\"keyword\">this</span>.contents = builder.contents;</div><div class=\"line\">        <span class=\"keyword\">this</span>.toPersons = builder.toPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.ccPersons = builder.ccPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.bccPersons = builder.bccPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.docName = builder.docName;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fileNames = builder.fileNames;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 实现Builder接口的构建类，用于创建EmailSendMain</div><div class=\"line\">     *</div><div class=\"line\">     * 建造者模式中的建造类</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> <span class=\"keyword\">implements</span> <span class=\"title\">tk</span>.<span class=\"title\">zhangh</span>.<span class=\"title\">pattern</span>.<span class=\"title\">create</span>.<span class=\"title\">builder</span>.<span class=\"title\">demo1</span>.<span class=\"title\">Builder</span>&lt;<span class=\"title\">EmailSendMain</span>&gt; </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> String template;  <span class=\"comment\">// 模板名称</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; subjects;  <span class=\"comment\">// 主题参数列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; contents;  <span class=\"comment\">// 内容参数列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; toPersons;  <span class=\"comment\">// 收件人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; ccPersons;  <span class=\"comment\">// 抄送人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; bccPersons;  <span class=\"comment\">// 暗送人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> String docName;  <span class=\"comment\">// 文档名称</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; fileNames;  <span class=\"comment\">// 文件名称列表</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(String template, List&lt;String&gt; toPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.template = template;</div><div class=\"line\">            <span class=\"keyword\">this</span>.toPersons = toPersons;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> EmailSendMain <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EmailSendMain(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">subjects</span><span class=\"params\">(List&lt;String&gt; subjects)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.subjects = subjects;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">contents</span><span class=\"params\">(List&lt;String&gt; contents)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.contents = contents;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">ccPersons</span><span class=\"params\">(List&lt;String&gt; ccPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.ccPersons = ccPersons;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">bccPersons</span><span class=\"params\">(List&lt;String&gt; bccPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.bccPersons = bccPersons;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">docName</span><span class=\"params\">(String docName)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.docName = docName;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">fileNames</span><span class=\"params\">(List&lt;String&gt; fileNames)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.fileNames = fileNames;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// getter,toString方法省略</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重写做的接口方法封装：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 邮件发送通用接口</div><div class=\"line\"> * <span class=\"doctag\">@param</span> email 邮件发送参数对象</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(EmailSendMain email)</span></span>&#123;</div><div class=\"line\">    logger.info(<span class=\"string\">\"send email:\"</span> + email);</div><div class=\"line\">    <span class=\"keyword\">if</span> ((email.getDocName() == <span class=\"keyword\">null</span> || email.getDocName().equals(<span class=\"string\">\"\"</span>)) ||</div><div class=\"line\">            (email.getFileNames() == <span class=\"keyword\">null</span> || email.getFileNames().size() == <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">        sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),</div><div class=\"line\">                email.getCcPersons(), email.getBccPersons());</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),</div><div class=\"line\">                email.getCcPersons(), email.getBccPersons(), email.getDocName(), email.getFileNames());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>客户端调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testSendEmail</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    EmailSendMain email =</div><div class=\"line\">            <span class=\"keyword\">new</span> EmailSendMain.Builder(<span class=\"string\">\"邮件模版名\"</span>,toPersons).</div><div class=\"line\">                    subjects(subjects).</div><div class=\"line\">                    contents(contents).</div><div class=\"line\">                    ccPersons(ccPersons).</div><div class=\"line\">                    bccPersons(bccPersons).build();</div><div class=\"line\">    SendEmailUtil.sendEmail(email);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题圆满解决，支持可选参数的链式结构调用，创建过程也确保了一致性，使用不可变类也没问题。</p>\n<p>如果说缺点，其实不难看出EmailSendMain的字段和它的内部类Builder字段完全重复了。为了创建EmailSendMain的对象将必须先创建Builder也会带来轻微的性能问题。创建的调用过程虽然看起来更清晰，但也更加冗长。</p>\n<p>但是Builder模式还是创建多参数类的不错选择，尤其是大多数参数是可选。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>这篇文章的思路是根据《Effective Java》得来的，文章只提到书中建议的第二条，实际关于上面使用到的内部类，泛型，在书中的建议都让我有了更多的认识。我就不赘述了，连上8天班我要去偷懒了。</p>\n<p>写这篇文章的时候看到有个系列专门讲Java方法参数太多的问题</p>\n<p>传送门：<a href=\"https://dzone.com/articles/too-many-parameters-java\" target=\"_blank\" rel=\"external\">https://dzone.com/articles/too-many-parameters-java</a></p>\n<p>以及翻译：<a href=\"http://www.importnew.com/6518.html\" target=\"_blank\" rel=\"external\">http://www.importnew.com/6518.html</a></p>\n<p>代码我放在了学习设计模式的项目下：</p>\n<p>传送门：<a href=\"https://github.com/zhanghTK/HelloDesignPattern\" target=\"_blank\" rel=\"external\">https://github.com/zhanghTK/HelloDesignPattern</a></p>\n","excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>记一次工作当中对多参数方法重构。</p>\n<ol>\n<li>使用对象封装对多参数，简化方法调用</li>\n<li>使用Builder（创建者）模式简化多属性对象的创建</li>\n</ol>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>业务系统中统一的邮件发送服务接口在改造前大概长着个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">    * 不帶附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良代码）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons)</span></span>&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">    * 带附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> docName                       文档名称</div><div class=\"line\">    * <span class=\"doctag\">@param</span> fileName                      文件名称(单个文件)</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons, String docName, String fileName)</span></span>&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">    * 带附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良代码）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> docName                       文档名称</div><div class=\"line\">    * <span class=\"doctag\">@param</span> fileNames                     文件名称(多个文件,文件名称列表)</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons, String docName, List&lt;String&gt; fileNames)</span></span>&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>接口有个重要的内容注释中并没有说明：参数中“模板”和“收件人”是必填的，而其他参数是非必填的。</p>\n<p>接口的可配置程度还是不错的，但是调用的过程就比较痛苦了。</p>\n<p>一大堆String和List接口暴露出来，同时又使用了不同的参数个数来进行重载。</p>\n<p>调用的时候光是创建这些参数就够麻烦的了，还要考虑哪些参数是必填的以及参数的正确位置。更糟糕的是参数传错位置你会发现很有可能并没有显式的暴露出问题，邮件还是发送了只是发送到错误的相关人员那里。</p>\n<p>其他人看到方法调用也无法清晰知道这个到底是要发什么邮件，给哪些人。</p>\n<p>这应该就是坏代码的味道吧。</p>\n<h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><p>简单的改进思路就是把参数做成一个modle封装起来，以后传递model给方法。就像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 邮件发送通用接口</div><div class=\"line\"> * <span class=\"doctag\">@param</span> email 邮件发送参数对象</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(EmailSendMain email)</span></span>&#123;</div><div class=\"line\">\tlogger.info(<span class=\"string\">\"send email:\"</span> + email);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是问题还是没有根本解决，对象的构造还是需要多个参数的构造方法，可能还需要重载。</p>\n<p>比较容易想到的改进是使用Java Bean模式。简化构造方法字段，构造方法只传入必要的字段，使用setter方法设置其他值。我就是这么肤浅的想到这个地步了。</p>\n<p>乍一看问题是解决了，其实不然。</p>\n<ol>\n<li>在对象创建过程中Java Bean可能处于不一致状态</li>\n<li>使用Java Bean就将不能创建不可变对象</li>\n</ol>\n<p>读了《Effective Java》只是第二章就有了更好的解决思路——Builder模式。</p>\n<p>先看改进后的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 复杂类型构建接口</div><div class=\"line\"> *</div><div class=\"line\"> * 建造者模式中的抽象构建者</div><div class=\"line\"> * Created by ZhangHao on 2016/10/15.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Builder</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\">T <span class=\"title\">build</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 邮件发送参数对象</div><div class=\"line\"> * 包含多个字段的复杂类型，使用内部类实现Builder接口创建对象</div><div class=\"line\"> *</div><div class=\"line\"> * 建造者模式中的产品类</div><div class=\"line\"> * Created by ZhangHao on 2016/10/15.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmailSendMain</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String template;  <span class=\"comment\">// 模板名称</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; subjects;  <span class=\"comment\">// 主题参数列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; contents;  <span class=\"comment\">// 内容参数列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; toPersons;  <span class=\"comment\">// 收件人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; ccPersons;  <span class=\"comment\">// 抄送人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; bccPersons;  <span class=\"comment\">// 暗送人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String docName;  <span class=\"comment\">// 文档名称</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; fileNames;  <span class=\"comment\">// 文件名称列表</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">EmailSendMain</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.template = builder.template;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subjects = builder.subjects;</div><div class=\"line\">        <span class=\"keyword\">this</span>.contents = builder.contents;</div><div class=\"line\">        <span class=\"keyword\">this</span>.toPersons = builder.toPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.ccPersons = builder.ccPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.bccPersons = builder.bccPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.docName = builder.docName;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fileNames = builder.fileNames;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 实现Builder接口的构建类，用于创建EmailSendMain</div><div class=\"line\">     *</div><div class=\"line\">     * 建造者模式中的建造类</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> <span class=\"keyword\">implements</span> <span class=\"title\">tk</span>.<span class=\"title\">zhangh</span>.<span class=\"title\">pattern</span>.<span class=\"title\">create</span>.<span class=\"title\">builder</span>.<span class=\"title\">demo1</span>.<span class=\"title\">Builder</span>&lt;<span class=\"title\">EmailSendMain</span>&gt; </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> String template;  <span class=\"comment\">// 模板名称</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; subjects;  <span class=\"comment\">// 主题参数列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; contents;  <span class=\"comment\">// 内容参数列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; toPersons;  <span class=\"comment\">// 收件人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; ccPersons;  <span class=\"comment\">// 抄送人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; bccPersons;  <span class=\"comment\">// 暗送人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> String docName;  <span class=\"comment\">// 文档名称</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; fileNames;  <span class=\"comment\">// 文件名称列表</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(String template, List&lt;String&gt; toPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.template = template;</div><div class=\"line\">            <span class=\"keyword\">this</span>.toPersons = toPersons;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> EmailSendMain <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EmailSendMain(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">subjects</span><span class=\"params\">(List&lt;String&gt; subjects)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.subjects = subjects;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">contents</span><span class=\"params\">(List&lt;String&gt; contents)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.contents = contents;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">ccPersons</span><span class=\"params\">(List&lt;String&gt; ccPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.ccPersons = ccPersons;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">bccPersons</span><span class=\"params\">(List&lt;String&gt; bccPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.bccPersons = bccPersons;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">docName</span><span class=\"params\">(String docName)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.docName = docName;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">fileNames</span><span class=\"params\">(List&lt;String&gt; fileNames)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.fileNames = fileNames;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// getter,toString方法省略</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重写做的接口方法封装：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 邮件发送通用接口</div><div class=\"line\"> * <span class=\"doctag\">@param</span> email 邮件发送参数对象</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(EmailSendMain email)</span></span>&#123;</div><div class=\"line\">    logger.info(<span class=\"string\">\"send email:\"</span> + email);</div><div class=\"line\">    <span class=\"keyword\">if</span> ((email.getDocName() == <span class=\"keyword\">null</span> || email.getDocName().equals(<span class=\"string\">\"\"</span>)) ||</div><div class=\"line\">            (email.getFileNames() == <span class=\"keyword\">null</span> || email.getFileNames().size() == <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">        sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),</div><div class=\"line\">                email.getCcPersons(), email.getBccPersons());</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),</div><div class=\"line\">                email.getCcPersons(), email.getBccPersons(), email.getDocName(), email.getFileNames());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>客户端调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testSendEmail</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    EmailSendMain email =</div><div class=\"line\">            <span class=\"keyword\">new</span> EmailSendMain.Builder(<span class=\"string\">\"邮件模版名\"</span>,toPersons).</div><div class=\"line\">                    subjects(subjects).</div><div class=\"line\">                    contents(contents).</div><div class=\"line\">                    ccPersons(ccPersons).</div><div class=\"line\">                    bccPersons(bccPersons).build();</div><div class=\"line\">    SendEmailUtil.sendEmail(email);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题圆满解决，支持可选参数的链式结构调用，创建过程也确保了一致性，使用不可变类也没问题。</p>\n<p>如果说缺点，其实不难看出EmailSendMain的字段和它的内部类Builder字段完全重复了。为了创建EmailSendMain的对象将必须先创建Builder也会带来轻微的性能问题。创建的调用过程虽然看起来更清晰，但也更加冗长。</p>\n<p>但是Builder模式还是创建多参数类的不错选择，尤其是大多数参数是可选。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>这篇文章的思路是根据《Effective Java》得来的，文章只提到书中建议的第二条，实际关于上面使用到的内部类，泛型，在书中的建议都让我有了更多的认识。我就不赘述了，连上8天班我要去偷懒了。</p>\n<p>写这篇文章的时候看到有个系列专门讲Java方法参数太多的问题</p>\n<p>传送门：<a href=\"https://dzone.com/articles/too-many-parameters-java\">https://dzone.com/articles/too-many-parameters-java</a></p>\n<p>以及翻译：<a href=\"http://www.importnew.com/6518.html\">http://www.importnew.com/6518.html</a></p>\n<p>代码我放在了学习设计模式的项目下：</p>\n<p>传送门：<a href=\"https://github.com/zhanghTK/HelloDesignPattern\">https://github.com/zhanghTK/HelloDesignPattern</a></p>\n"},{"title":"使用CI发布Hexo","date":"2017-01-07T05:34:08.000Z","_content":"\n**测试使用CI发布Hexo**\n\n从此刻开始本站开始使用[Travis-CI](https://travis-ci.org)发布。\n博客已有两个月没有更新内容了，年底各项事宜又赶上上冲刺，这一个月忙的焦头烂额。\n整理了一点东西准备发布也就放弃了，整个发布都得手工执行，今年起始的目标就有使用CI让开发更高效。\n今天在博客上实践了一下持续集成，一口气把之前整理的几篇文章都发布了，整个流程还是简单了不少。\n\n\n网上关于Travis-CI的说明还是比较多的，我主要参考了[这里](http://blog.csdn.net/woblog/article/details/51319364)。\n\n但是我掉了一个坑，我使用的主题是[nexT](http://theme-next.iissnan.com/)，直接从Github上clone得到并做了自定义，同时没有删除next主题文件夹内的`.git`文件夹。所以博客的版本控制没有直接管理next主题文件夹，在提交的时候整个next主题文件夹就没有提交上去，所以不能正确生成页面文件，导致最终网站的所有页面都成了空白页面。\n\n解决办法很简单，删除themes/next的.git和.gitignore，加入版本控制提交就可以了。\n\n同时我还根据报错调整了`.travis.yml`, like this:\n\n```yaml\nanguage: node_js\nnode_js: stable\n\ninstall:\n  - npm install -g hexo\n  - npm install -g hexo-cli\n  - npm install\n\nscript:\n  - hexo clean\n  - hexo g\n\nafter_script:\n  - cd ./public\n  - git init\n  - git config user.name \"zahnghTK\"\n  - git config user.email \"510223064@qq.com\"\n  - git add .\n  - git commit -m \"Update docs\"\n  - git push --force --quiet \"https://${GH_TOKEN}@${GH_REF}\" master:master\n\nbranches:\n  only:\n    - hexo\nenv:\n global:\n   - GH_REF: github.com/zhanghTK/zhanghTK.github.io.git\n```\n\n好啦，本篇文章就到这里，2017起始，容我水一文。\n","source":"_posts/使用CI发布Hexo.md","raw":"---\ntitle: 使用CI发布Hexo\ndate: 2017-01-07 13:34:08\ntags:\ncategories: 随笔\n---\n\n**测试使用CI发布Hexo**\n\n从此刻开始本站开始使用[Travis-CI](https://travis-ci.org)发布。\n博客已有两个月没有更新内容了，年底各项事宜又赶上上冲刺，这一个月忙的焦头烂额。\n整理了一点东西准备发布也就放弃了，整个发布都得手工执行，今年起始的目标就有使用CI让开发更高效。\n今天在博客上实践了一下持续集成，一口气把之前整理的几篇文章都发布了，整个流程还是简单了不少。\n\n\n网上关于Travis-CI的说明还是比较多的，我主要参考了[这里](http://blog.csdn.net/woblog/article/details/51319364)。\n\n但是我掉了一个坑，我使用的主题是[nexT](http://theme-next.iissnan.com/)，直接从Github上clone得到并做了自定义，同时没有删除next主题文件夹内的`.git`文件夹。所以博客的版本控制没有直接管理next主题文件夹，在提交的时候整个next主题文件夹就没有提交上去，所以不能正确生成页面文件，导致最终网站的所有页面都成了空白页面。\n\n解决办法很简单，删除themes/next的.git和.gitignore，加入版本控制提交就可以了。\n\n同时我还根据报错调整了`.travis.yml`, like this:\n\n```yaml\nanguage: node_js\nnode_js: stable\n\ninstall:\n  - npm install -g hexo\n  - npm install -g hexo-cli\n  - npm install\n\nscript:\n  - hexo clean\n  - hexo g\n\nafter_script:\n  - cd ./public\n  - git init\n  - git config user.name \"zahnghTK\"\n  - git config user.email \"510223064@qq.com\"\n  - git add .\n  - git commit -m \"Update docs\"\n  - git push --force --quiet \"https://${GH_TOKEN}@${GH_REF}\" master:master\n\nbranches:\n  only:\n    - hexo\nenv:\n global:\n   - GH_REF: github.com/zhanghTK/zhanghTK.github.io.git\n```\n\n好啦，本篇文章就到这里，2017起始，容我水一文。\n","slug":"使用CI发布Hexo","published":1,"updated":"2017-01-07T08:38:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gb20016yi2ekq1yrcq7","content":"<p><strong>测试使用CI发布Hexo</strong></p>\n<p>从此刻开始本站开始使用<a href=\"https://travis-ci.org\" target=\"_blank\" rel=\"external\">Travis-CI</a>发布。<br>博客已有两个月没有更新内容了，年底各项事宜又赶上上冲刺，这一个月忙的焦头烂额。<br>整理了一点东西准备发布也就放弃了，整个发布都得手工执行，今年起始的目标就有使用CI让开发更高效。<br>今天在博客上实践了一下持续集成，一口气把之前整理的几篇文章都发布了，整个流程还是简单了不少。</p>\n<p>网上关于Travis-CI的说明还是比较多的，我主要参考了<a href=\"http://blog.csdn.net/woblog/article/details/51319364\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<p>但是我掉了一个坑，我使用的主题是<a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"external\">nexT</a>，直接从Github上clone得到并做了自定义，同时没有删除next主题文件夹内的<code>.git</code>文件夹。所以博客的版本控制没有直接管理next主题文件夹，在提交的时候整个next主题文件夹就没有提交上去，所以不能正确生成页面文件，导致最终网站的所有页面都成了空白页面。</p>\n<p>解决办法很简单，删除themes/next的.git和.gitignore，加入版本控制提交就可以了。</p>\n<p>同时我还根据报错调整了<code>.travis.yml</code>, like this:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">anguage:</span> node_js</div><div class=\"line\"><span class=\"attr\">node_js:</span> stable</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">install:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> npm install -g hexo</div><div class=\"line\"><span class=\"bullet\">  -</span> npm install -g hexo-cli</div><div class=\"line\"><span class=\"bullet\">  -</span> npm install</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> hexo clean</div><div class=\"line\"><span class=\"bullet\">  -</span> hexo g</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">after_script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> cd ./public</div><div class=\"line\"><span class=\"bullet\">  -</span> git init</div><div class=\"line\"><span class=\"bullet\">  -</span> git config user.name <span class=\"string\">\"zahnghTK\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git config user.email <span class=\"string\">\"510223064@qq.com\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git add .</div><div class=\"line\"><span class=\"bullet\">  -</span> git commit -m <span class=\"string\">\"Update docs\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git push --force --quiet <span class=\"string\">\"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;\"</span> master:master</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">branches:</span></div><div class=\"line\"><span class=\"attr\">  only:</span></div><div class=\"line\"><span class=\"bullet\">    -</span> hexo</div><div class=\"line\"><span class=\"attr\">env:</span></div><div class=\"line\"><span class=\"attr\"> global:</span></div><div class=\"line\"><span class=\"attr\">   - GH_REF:</span> github.com/zhanghTK/zhanghTK.github.io.git</div></pre></td></tr></table></figure>\n<p>好啦，本篇文章就到这里，2017起始，容我水一文。</p>\n","excerpt":"","more":"<p><strong>测试使用CI发布Hexo</strong></p>\n<p>从此刻开始本站开始使用<a href=\"https://travis-ci.org\">Travis-CI</a>发布。<br>博客已有两个月没有更新内容了，年底各项事宜又赶上上冲刺，这一个月忙的焦头烂额。<br>整理了一点东西准备发布也就放弃了，整个发布都得手工执行，今年起始的目标就有使用CI让开发更高效。<br>今天在博客上实践了一下持续集成，一口气把之前整理的几篇文章都发布了，整个流程还是简单了不少。</p>\n<p>网上关于Travis-CI的说明还是比较多的，我主要参考了<a href=\"http://blog.csdn.net/woblog/article/details/51319364\">这里</a>。</p>\n<p>但是我掉了一个坑，我使用的主题是<a href=\"http://theme-next.iissnan.com/\">nexT</a>，直接从Github上clone得到并做了自定义，同时没有删除next主题文件夹内的<code>.git</code>文件夹。所以博客的版本控制没有直接管理next主题文件夹，在提交的时候整个next主题文件夹就没有提交上去，所以不能正确生成页面文件，导致最终网站的所有页面都成了空白页面。</p>\n<p>解决办法很简单，删除themes/next的.git和.gitignore，加入版本控制提交就可以了。</p>\n<p>同时我还根据报错调整了<code>.travis.yml</code>, like this:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">anguage:</span> node_js</div><div class=\"line\"><span class=\"attr\">node_js:</span> stable</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">install:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> npm install -g hexo</div><div class=\"line\"><span class=\"bullet\">  -</span> npm install -g hexo-cli</div><div class=\"line\"><span class=\"bullet\">  -</span> npm install</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> hexo clean</div><div class=\"line\"><span class=\"bullet\">  -</span> hexo g</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">after_script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> cd ./public</div><div class=\"line\"><span class=\"bullet\">  -</span> git init</div><div class=\"line\"><span class=\"bullet\">  -</span> git config user.name <span class=\"string\">\"zahnghTK\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git config user.email <span class=\"string\">\"510223064@qq.com\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git add .</div><div class=\"line\"><span class=\"bullet\">  -</span> git commit -m <span class=\"string\">\"Update docs\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git push --force --quiet <span class=\"string\">\"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;\"</span> master:master</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">branches:</span></div><div class=\"line\"><span class=\"attr\">  only:</span></div><div class=\"line\"><span class=\"bullet\">    -</span> hexo</div><div class=\"line\"><span class=\"attr\">env:</span></div><div class=\"line\"><span class=\"attr\"> global:</span></div><div class=\"line\"><span class=\"attr\">   - GH_REF:</span> github.com/zhanghTK/zhanghTK.github.io.git</div></pre></td></tr></table></figure>\n<p>好啦，本篇文章就到这里，2017起始，容我水一文。</p>\n"},{"title":"命令模式","date":"2017-01-15T18:29:27.000Z","_content":"\n\n提到命令模式先别管他干什么，名字里有命令那肯定离不开命令，好的，开始编码：\n\n```\ncommandSender.order();\n```\n\n写完收工！当然是不行的，要面向对象，要遵循设计模式的几大原则的。\n\n（到底是几？我也不知道，有人说是五大原则，也有人说六大原则，还有说七大原则）\n\n简单划分一下职责，很自然的就能想到三个角色：\n\n1. 命令的发出者\n2. 命令\n3. 命令的接收者\n\n```java\nCommand command = commandSender.createCommend();\ncommandReceiver.execute(command);\n```\n\n《Head First 设计模式》中是以一个为多个电器设计通用遥控器的例子开始介绍命令模式的。\n\n假如我们认为遥控器是命令的发出者，那么谁是命令的接收者呢？\n\n我们无法根据命令就知道接受者到底是电视机，电灯还是其他。\n\n那么就有两种选择了，\n\n第一种：\n\n```\nCommand command = commandSender.createCommand();\nCommandReceiver commandReceiver = commandSender.getCommandReceiver();\ncommandReceiver.execute(command);\n```\n\n第二种：\n\n```java\nCommand command = commandSender.createCommandWithReceiver();\nCommandReceiver commandReceiver = command.getReceiver();\ncommandReceiver.execute(command);\n```\n\n如果遥控器是命令的发出者，第一种方式将造成遥控器与电器紧密的耦合在一起。\n\n当电器发生变化，遥控器也必须跟随发生变化，这就违反开闭原则。\n\n第二种方式其实就是命令模式，只不过习惯上命令模式把命令发出者成为调用者。UML类图如下：\n![19. 命令模式.png](https://ooo.0o0.ooo/2017/01/09/5873103fcee67.png)\n\n调用者封装命令，命令的具体执行由调用者委托给具体的命令。\n\n命令又封装了具体的命令接受者，命令的执行委托给命令的接受者。\n\n整个命令的执行起来时序图如下：\n\n![命令模式时序图.png](https://ooo.0o0.ooo/2017/01/09/5873353bc9c8e.png)\n\n除了遥控器的例子《Head First 设计模式》中还举了个餐厅订餐的例子，其中角色对应关系如下：\n\n| 命令模式  | 遥控器  | 餐厅   |\n| ----- | ---- | ---- |\n| 客户端   | 用户   | 顾客   |\n| 调用者   | 遥控器  | 女招待  |\n| 命令    | 按钮   | 订单   |\n| 命令接受者 | 电器   | 厨师   |\n\n关于点餐的例子我觉得不是很恰当，当然也可能是我理解的不对，书上描述顾客创建订单，订单作为命令包含具体的命令接受者厨师，这点怎么都不能接受，谁家点餐的时候会关注厨师呢？\n\n我的理解应该是顾客到店前，女招待，订单，厨师已经做好了准备。\n\n顾客要下单时直接找女招待就可以了，由女招待根据订单找厨师做菜。\n\n在通俗的说就是客户端只需要与调用者交互，不需要关心其他。其他部分的装配应给交给系统（例如，Spring）\n\n理清了这层关系，我们把目光停留在调用者身上。\n\n对于客户端来说，调用实际是从调用者这里发出的，换句话说，调用者实际上决定了命令实际的执行时机。\n\n假设一个场景，调用者和命令的关系不是一对一，而是一对多。\n\n当多个命令排队，依次等待调用者执行命令，这不就是队列请求模型？\n\n---\n\n命令模式的总结：\n\n所属类别：行为模式\n\n最大的优点：调用者与接受者的充分解耦\n\n基于命令模式可以方便的做出如下扩展：\n\n1. 调用者可以不知道接受者，甚至是不知道具体的命令，只需要预留接口；\n2. 一个命令中可以由多个命令组成，当此命令被调用时可以，触发多个命令的调用：宏命令；\n3. 方便命令执行前后增加切面，方便记录，回滚操作；\n4. 延迟命令执行的时机：队列请求模式；\n","source":"_posts/命令模式.md","raw":"---\ntitle: 命令模式\ndate: 2017-01-16 02:29:27\ntags:\n - 设计模式\n - Java\ncategory: 设计模式\n---\n\n\n提到命令模式先别管他干什么，名字里有命令那肯定离不开命令，好的，开始编码：\n\n```\ncommandSender.order();\n```\n\n写完收工！当然是不行的，要面向对象，要遵循设计模式的几大原则的。\n\n（到底是几？我也不知道，有人说是五大原则，也有人说六大原则，还有说七大原则）\n\n简单划分一下职责，很自然的就能想到三个角色：\n\n1. 命令的发出者\n2. 命令\n3. 命令的接收者\n\n```java\nCommand command = commandSender.createCommend();\ncommandReceiver.execute(command);\n```\n\n《Head First 设计模式》中是以一个为多个电器设计通用遥控器的例子开始介绍命令模式的。\n\n假如我们认为遥控器是命令的发出者，那么谁是命令的接收者呢？\n\n我们无法根据命令就知道接受者到底是电视机，电灯还是其他。\n\n那么就有两种选择了，\n\n第一种：\n\n```\nCommand command = commandSender.createCommand();\nCommandReceiver commandReceiver = commandSender.getCommandReceiver();\ncommandReceiver.execute(command);\n```\n\n第二种：\n\n```java\nCommand command = commandSender.createCommandWithReceiver();\nCommandReceiver commandReceiver = command.getReceiver();\ncommandReceiver.execute(command);\n```\n\n如果遥控器是命令的发出者，第一种方式将造成遥控器与电器紧密的耦合在一起。\n\n当电器发生变化，遥控器也必须跟随发生变化，这就违反开闭原则。\n\n第二种方式其实就是命令模式，只不过习惯上命令模式把命令发出者成为调用者。UML类图如下：\n![19. 命令模式.png](https://ooo.0o0.ooo/2017/01/09/5873103fcee67.png)\n\n调用者封装命令，命令的具体执行由调用者委托给具体的命令。\n\n命令又封装了具体的命令接受者，命令的执行委托给命令的接受者。\n\n整个命令的执行起来时序图如下：\n\n![命令模式时序图.png](https://ooo.0o0.ooo/2017/01/09/5873353bc9c8e.png)\n\n除了遥控器的例子《Head First 设计模式》中还举了个餐厅订餐的例子，其中角色对应关系如下：\n\n| 命令模式  | 遥控器  | 餐厅   |\n| ----- | ---- | ---- |\n| 客户端   | 用户   | 顾客   |\n| 调用者   | 遥控器  | 女招待  |\n| 命令    | 按钮   | 订单   |\n| 命令接受者 | 电器   | 厨师   |\n\n关于点餐的例子我觉得不是很恰当，当然也可能是我理解的不对，书上描述顾客创建订单，订单作为命令包含具体的命令接受者厨师，这点怎么都不能接受，谁家点餐的时候会关注厨师呢？\n\n我的理解应该是顾客到店前，女招待，订单，厨师已经做好了准备。\n\n顾客要下单时直接找女招待就可以了，由女招待根据订单找厨师做菜。\n\n在通俗的说就是客户端只需要与调用者交互，不需要关心其他。其他部分的装配应给交给系统（例如，Spring）\n\n理清了这层关系，我们把目光停留在调用者身上。\n\n对于客户端来说，调用实际是从调用者这里发出的，换句话说，调用者实际上决定了命令实际的执行时机。\n\n假设一个场景，调用者和命令的关系不是一对一，而是一对多。\n\n当多个命令排队，依次等待调用者执行命令，这不就是队列请求模型？\n\n---\n\n命令模式的总结：\n\n所属类别：行为模式\n\n最大的优点：调用者与接受者的充分解耦\n\n基于命令模式可以方便的做出如下扩展：\n\n1. 调用者可以不知道接受者，甚至是不知道具体的命令，只需要预留接口；\n2. 一个命令中可以由多个命令组成，当此命令被调用时可以，触发多个命令的调用：宏命令；\n3. 方便命令执行前后增加切面，方便记录，回滚操作；\n4. 延迟命令执行的时机：队列请求模式；\n","slug":"命令模式","published":1,"updated":"2017-01-15T18:32:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gb4001ayi2ezqez57zs","content":"<p>提到命令模式先别管他干什么，名字里有命令那肯定离不开命令，好的，开始编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">commandSender.order();</div></pre></td></tr></table></figure>\n<p>写完收工！当然是不行的，要面向对象，要遵循设计模式的几大原则的。</p>\n<p>（到底是几？我也不知道，有人说是五大原则，也有人说六大原则，还有说七大原则）</p>\n<p>简单划分一下职责，很自然的就能想到三个角色：</p>\n<ol>\n<li>命令的发出者</li>\n<li>命令</li>\n<li>命令的接收者</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommend();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>《Head First 设计模式》中是以一个为多个电器设计通用遥控器的例子开始介绍命令模式的。</p>\n<p>假如我们认为遥控器是命令的发出者，那么谁是命令的接收者呢？</p>\n<p>我们无法根据命令就知道接受者到底是电视机，电灯还是其他。</p>\n<p>那么就有两种选择了，</p>\n<p>第一种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommand();</div><div class=\"line\">CommandReceiver commandReceiver = commandSender.getCommandReceiver();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>第二种：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommandWithReceiver();</div><div class=\"line\">CommandReceiver commandReceiver = command.getReceiver();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>如果遥控器是命令的发出者，第一种方式将造成遥控器与电器紧密的耦合在一起。</p>\n<p>当电器发生变化，遥控器也必须跟随发生变化，这就违反开闭原则。</p>\n<p>第二种方式其实就是命令模式，只不过习惯上命令模式把命令发出者成为调用者。UML类图如下：<br><img src=\"https://ooo.0o0.ooo/2017/01/09/5873103fcee67.png\" alt=\"19. 命令模式.png\"></p>\n<p>调用者封装命令，命令的具体执行由调用者委托给具体的命令。</p>\n<p>命令又封装了具体的命令接受者，命令的执行委托给命令的接受者。</p>\n<p>整个命令的执行起来时序图如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/09/5873353bc9c8e.png\" alt=\"命令模式时序图.png\"></p>\n<p>除了遥控器的例子《Head First 设计模式》中还举了个餐厅订餐的例子，其中角色对应关系如下：</p>\n<table>\n<thead>\n<tr>\n<th>命令模式</th>\n<th>遥控器</th>\n<th>餐厅</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>客户端</td>\n<td>用户</td>\n<td>顾客</td>\n</tr>\n<tr>\n<td>调用者</td>\n<td>遥控器</td>\n<td>女招待</td>\n</tr>\n<tr>\n<td>命令</td>\n<td>按钮</td>\n<td>订单</td>\n</tr>\n<tr>\n<td>命令接受者</td>\n<td>电器</td>\n<td>厨师</td>\n</tr>\n</tbody>\n</table>\n<p>关于点餐的例子我觉得不是很恰当，当然也可能是我理解的不对，书上描述顾客创建订单，订单作为命令包含具体的命令接受者厨师，这点怎么都不能接受，谁家点餐的时候会关注厨师呢？</p>\n<p>我的理解应该是顾客到店前，女招待，订单，厨师已经做好了准备。</p>\n<p>顾客要下单时直接找女招待就可以了，由女招待根据订单找厨师做菜。</p>\n<p>在通俗的说就是客户端只需要与调用者交互，不需要关心其他。其他部分的装配应给交给系统（例如，Spring）</p>\n<p>理清了这层关系，我们把目光停留在调用者身上。</p>\n<p>对于客户端来说，调用实际是从调用者这里发出的，换句话说，调用者实际上决定了命令实际的执行时机。</p>\n<p>假设一个场景，调用者和命令的关系不是一对一，而是一对多。</p>\n<p>当多个命令排队，依次等待调用者执行命令，这不就是队列请求模型？</p>\n<hr>\n<p>命令模式的总结：</p>\n<p>所属类别：行为模式</p>\n<p>最大的优点：调用者与接受者的充分解耦</p>\n<p>基于命令模式可以方便的做出如下扩展：</p>\n<ol>\n<li>调用者可以不知道接受者，甚至是不知道具体的命令，只需要预留接口；</li>\n<li>一个命令中可以由多个命令组成，当此命令被调用时可以，触发多个命令的调用：宏命令；</li>\n<li>方便命令执行前后增加切面，方便记录，回滚操作；</li>\n<li>延迟命令执行的时机：队列请求模式；</li>\n</ol>\n","excerpt":"","more":"<p>提到命令模式先别管他干什么，名字里有命令那肯定离不开命令，好的，开始编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">commandSender.order();</div></pre></td></tr></table></figure>\n<p>写完收工！当然是不行的，要面向对象，要遵循设计模式的几大原则的。</p>\n<p>（到底是几？我也不知道，有人说是五大原则，也有人说六大原则，还有说七大原则）</p>\n<p>简单划分一下职责，很自然的就能想到三个角色：</p>\n<ol>\n<li>命令的发出者</li>\n<li>命令</li>\n<li>命令的接收者</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommend();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>《Head First 设计模式》中是以一个为多个电器设计通用遥控器的例子开始介绍命令模式的。</p>\n<p>假如我们认为遥控器是命令的发出者，那么谁是命令的接收者呢？</p>\n<p>我们无法根据命令就知道接受者到底是电视机，电灯还是其他。</p>\n<p>那么就有两种选择了，</p>\n<p>第一种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommand();</div><div class=\"line\">CommandReceiver commandReceiver = commandSender.getCommandReceiver();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>第二种：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommandWithReceiver();</div><div class=\"line\">CommandReceiver commandReceiver = command.getReceiver();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>如果遥控器是命令的发出者，第一种方式将造成遥控器与电器紧密的耦合在一起。</p>\n<p>当电器发生变化，遥控器也必须跟随发生变化，这就违反开闭原则。</p>\n<p>第二种方式其实就是命令模式，只不过习惯上命令模式把命令发出者成为调用者。UML类图如下：<br><img src=\"https://ooo.0o0.ooo/2017/01/09/5873103fcee67.png\" alt=\"19. 命令模式.png\"></p>\n<p>调用者封装命令，命令的具体执行由调用者委托给具体的命令。</p>\n<p>命令又封装了具体的命令接受者，命令的执行委托给命令的接受者。</p>\n<p>整个命令的执行起来时序图如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/09/5873353bc9c8e.png\" alt=\"命令模式时序图.png\"></p>\n<p>除了遥控器的例子《Head First 设计模式》中还举了个餐厅订餐的例子，其中角色对应关系如下：</p>\n<table>\n<thead>\n<tr>\n<th>命令模式</th>\n<th>遥控器</th>\n<th>餐厅</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>客户端</td>\n<td>用户</td>\n<td>顾客</td>\n</tr>\n<tr>\n<td>调用者</td>\n<td>遥控器</td>\n<td>女招待</td>\n</tr>\n<tr>\n<td>命令</td>\n<td>按钮</td>\n<td>订单</td>\n</tr>\n<tr>\n<td>命令接受者</td>\n<td>电器</td>\n<td>厨师</td>\n</tr>\n</tbody>\n</table>\n<p>关于点餐的例子我觉得不是很恰当，当然也可能是我理解的不对，书上描述顾客创建订单，订单作为命令包含具体的命令接受者厨师，这点怎么都不能接受，谁家点餐的时候会关注厨师呢？</p>\n<p>我的理解应该是顾客到店前，女招待，订单，厨师已经做好了准备。</p>\n<p>顾客要下单时直接找女招待就可以了，由女招待根据订单找厨师做菜。</p>\n<p>在通俗的说就是客户端只需要与调用者交互，不需要关心其他。其他部分的装配应给交给系统（例如，Spring）</p>\n<p>理清了这层关系，我们把目光停留在调用者身上。</p>\n<p>对于客户端来说，调用实际是从调用者这里发出的，换句话说，调用者实际上决定了命令实际的执行时机。</p>\n<p>假设一个场景，调用者和命令的关系不是一对一，而是一对多。</p>\n<p>当多个命令排队，依次等待调用者执行命令，这不就是队列请求模型？</p>\n<hr>\n<p>命令模式的总结：</p>\n<p>所属类别：行为模式</p>\n<p>最大的优点：调用者与接受者的充分解耦</p>\n<p>基于命令模式可以方便的做出如下扩展：</p>\n<ol>\n<li>调用者可以不知道接受者，甚至是不知道具体的命令，只需要预留接口；</li>\n<li>一个命令中可以由多个命令组成，当此命令被调用时可以，触发多个命令的调用：宏命令；</li>\n<li>方便命令执行前后增加切面，方便记录，回滚操作；</li>\n<li>延迟命令执行的时机：队列请求模式；</li>\n</ol>\n"},{"title":"责任链模式","date":"2017-01-15T18:35:47.000Z","_content":"\n> 当你想要让一个以上的对象有机会能够处理某个请求的时候,就是用责任链模式(Chain of Responsibility Pattern).\n>\n> ——《Head First 设计模式》\n\n所属类别:行为型模式。\n\n典型使用场景：一个事件或请求需要多步判断/处理\n\n针对这样的场景直接编码会造成哪些问题？\n1. 多步的判断、处理集中在一起，违反单一职责\n2. 事件的处理依赖具体的过程，而不是行为或接口，违反依赖倒置\n3. 维护期需要新的处理过程时，必须修改原有代码，违反开闭原则\n\n首先，可以对具体在一起的业务代码代码进行了拆分，使业务逻辑的处理分散到多个模块；\n\n其次，为了统一整个请求处理逻辑，抽象接口，整个请求的处理过程对外只需要暴露入口。\n\n实现以上过程的UML类图如下：\n\n![责任链模式.png](https://ooo.0o0.ooo/2017/01/04/586ceaf92cc2c.png)\n\n责任链模式处理请求的一般过程：\n\n![责任链模式处理流程 (1).png](https://ooo.0o0.ooo/2017/01/04/586cef1ec3144.png)\n\n责任链模式的优点：\n\n1. 对客户端来说并不能感知到责任链的存在（迪米特法则）；\n2. 整个责任链的配置过程可以使用配置方式组装，后续处理节点的调整可以修改配置（开闭原则）；\n3. 请求发送者与处理者的解耦\n4. 简化了请求处理过程（单一职责）\n\n典型的责任链模式使用场景：JavaEE Servlet Filter\n\n","source":"_posts/责任链模式.md","raw":"---\ntitle: 责任链模式\ndate: 2017-01-16 02:35:47\ntags:\n - 设计模式\n - Java\ncategory: 设计模式\n---\n\n> 当你想要让一个以上的对象有机会能够处理某个请求的时候,就是用责任链模式(Chain of Responsibility Pattern).\n>\n> ——《Head First 设计模式》\n\n所属类别:行为型模式。\n\n典型使用场景：一个事件或请求需要多步判断/处理\n\n针对这样的场景直接编码会造成哪些问题？\n1. 多步的判断、处理集中在一起，违反单一职责\n2. 事件的处理依赖具体的过程，而不是行为或接口，违反依赖倒置\n3. 维护期需要新的处理过程时，必须修改原有代码，违反开闭原则\n\n首先，可以对具体在一起的业务代码代码进行了拆分，使业务逻辑的处理分散到多个模块；\n\n其次，为了统一整个请求处理逻辑，抽象接口，整个请求的处理过程对外只需要暴露入口。\n\n实现以上过程的UML类图如下：\n\n![责任链模式.png](https://ooo.0o0.ooo/2017/01/04/586ceaf92cc2c.png)\n\n责任链模式处理请求的一般过程：\n\n![责任链模式处理流程 (1).png](https://ooo.0o0.ooo/2017/01/04/586cef1ec3144.png)\n\n责任链模式的优点：\n\n1. 对客户端来说并不能感知到责任链的存在（迪米特法则）；\n2. 整个责任链的配置过程可以使用配置方式组装，后续处理节点的调整可以修改配置（开闭原则）；\n3. 请求发送者与处理者的解耦\n4. 简化了请求处理过程（单一职责）\n\n典型的责任链模式使用场景：JavaEE Servlet Filter\n\n","slug":"责任链模式","published":1,"updated":"2017-01-15T18:37:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gb6001cyi2ecr33dnn5","content":"<blockquote>\n<p>当你想要让一个以上的对象有机会能够处理某个请求的时候,就是用责任链模式(Chain of Responsibility Pattern).</p>\n<p>——《Head First 设计模式》</p>\n</blockquote>\n<p>所属类别:行为型模式。</p>\n<p>典型使用场景：一个事件或请求需要多步判断/处理</p>\n<p>针对这样的场景直接编码会造成哪些问题？</p>\n<ol>\n<li>多步的判断、处理集中在一起，违反单一职责</li>\n<li>事件的处理依赖具体的过程，而不是行为或接口，违反依赖倒置</li>\n<li>维护期需要新的处理过程时，必须修改原有代码，违反开闭原则</li>\n</ol>\n<p>首先，可以对具体在一起的业务代码代码进行了拆分，使业务逻辑的处理分散到多个模块；</p>\n<p>其次，为了统一整个请求处理逻辑，抽象接口，整个请求的处理过程对外只需要暴露入口。</p>\n<p>实现以上过程的UML类图如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/04/586ceaf92cc2c.png\" alt=\"责任链模式.png\"></p>\n<p>责任链模式处理请求的一般过程：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/04/586cef1ec3144.png\" alt=\"责任链模式处理流程 (1).png\"></p>\n<p>责任链模式的优点：</p>\n<ol>\n<li>对客户端来说并不能感知到责任链的存在（迪米特法则）；</li>\n<li>整个责任链的配置过程可以使用配置方式组装，后续处理节点的调整可以修改配置（开闭原则）；</li>\n<li>请求发送者与处理者的解耦</li>\n<li>简化了请求处理过程（单一职责）</li>\n</ol>\n<p>典型的责任链模式使用场景：JavaEE Servlet Filter</p>\n","excerpt":"","more":"<blockquote>\n<p>当你想要让一个以上的对象有机会能够处理某个请求的时候,就是用责任链模式(Chain of Responsibility Pattern).</p>\n<p>——《Head First 设计模式》</p>\n</blockquote>\n<p>所属类别:行为型模式。</p>\n<p>典型使用场景：一个事件或请求需要多步判断/处理</p>\n<p>针对这样的场景直接编码会造成哪些问题？</p>\n<ol>\n<li>多步的判断、处理集中在一起，违反单一职责</li>\n<li>事件的处理依赖具体的过程，而不是行为或接口，违反依赖倒置</li>\n<li>维护期需要新的处理过程时，必须修改原有代码，违反开闭原则</li>\n</ol>\n<p>首先，可以对具体在一起的业务代码代码进行了拆分，使业务逻辑的处理分散到多个模块；</p>\n<p>其次，为了统一整个请求处理逻辑，抽象接口，整个请求的处理过程对外只需要暴露入口。</p>\n<p>实现以上过程的UML类图如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/04/586ceaf92cc2c.png\" alt=\"责任链模式.png\"></p>\n<p>责任链模式处理请求的一般过程：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/04/586cef1ec3144.png\" alt=\"责任链模式处理流程 (1).png\"></p>\n<p>责任链模式的优点：</p>\n<ol>\n<li>对客户端来说并不能感知到责任链的存在（迪米特法则）；</li>\n<li>整个责任链的配置过程可以使用配置方式组装，后续处理节点的调整可以修改配置（开闭原则）；</li>\n<li>请求发送者与处理者的解耦</li>\n<li>简化了请求处理过程（单一职责）</li>\n</ol>\n<p>典型的责任链模式使用场景：JavaEE Servlet Filter</p>\n"},{"title":"浅谈测试驱动开发","date":"2017-02-05T13:58:28.000Z","_content":"\n近两日参加了名为“软件测试质量体系最佳实践”的分享，其中着重介绍了质量体系的建设，测试的经验以及方法，就我个人最大的收获更多的是关于TDD的思考，在此简单记录。\n\n# Bug的影响\n\n不成熟的团队中一个常见情况：\n\n频繁被突发问题打断，响应式的处理，目标达成率低，可以称这样的团队为响应式的团队。\n\n为什么频繁的响应Bug会严重消耗团队资源？\n\n1. 完整的Bug处理的过程时间长\n2. 一个Bug导致多个Bug的产生\n3. 人员缺乏动力\n\n# 预防Bug\n\n然而解决Bug并不能算作突出的贡献，针对Bug的预防工作要优于Bug解决。从被动的救火到主动的预防问题发生，减少突发问题。\n\n一个团队的重要指标，是有效代码的产出，而不是代码的产出。\n\n有效代码，如同字面意思，有效的，可复用的，没有大量Bug，可以赚钱的代码。\n\n如何保证代码有效？测试！\n\n# 测试\n\n手工测试无法做到连续提供测试服务，存在间断，代码修改后测试报告随即失效。为了解决测试的间断问题，必须引入自动化测试。\n\n开发工作中耗时最多的是在调试，如果能减少问题的出现，避免反复调试，可以节省大量的时间、精力。\n\n因此，测试并不会让团队的工作量出现明显增加，最终开发与测试的人数趋于接近。\n\n测试短期可以帮助我们找Bug，长期可以帮助我们建设质量体系。\n\n# 质量体系\n\n系统的健康状况，项目的完成情况应当从质量体系中直观，实时的获取，而不是通过大量的会议，讨论得出。\n\n数据的三个来源\n\n- 用例库\n\n  积累的测试用例\n\n  要求能复用（良好的测试框架）\n\n  能够与其它平台，系统方便集成（一个test case对应多个test Run）\n\n- 缺陷库\n\n  Bug的完整生命周期记录\n\n- 结果库\n\n  每次自动化测试的结果\n\n  最小的单位不是test case，而是test run\n\n质量体系，不仅用于预防问题，长远看还需要提供数据支持，需要辅助决策，辅助管理。\n\n# 团队\n\n当一个团队可以很好的预防问题的发生时，可以称这样的团队为建设型的团队。\n\n传统的瀑布模型中开发完成开始测试是导致项目进度缓慢的一个重要原因。\n\n如何让开发与测试并行？测试始终伴随开发，甚至优先于开发。\n\n开发，测试并行的三个重要保障：需求文档，开发文档，测试文档\n\n# TDD\n\n**文档评审**\n\n从执行过程上来看，当需求文档出来后，开发和测试需要同时整理对应文档，然后进入评审环节。\n\n需求作为开发，测试的输入项，要求需求文档不能出现偏差。\n\n从制度上可以做出一些规范化，例如：\n\n- 需求文档、开发文档、测试文档作为三个关键文档，任何一个都一定不能或缺\n- 三个关键文档都要有评审，三次的评审都要求产品、开发、测试负责的人员到场确认\n- 文档可以驳回，但确认后的文档不可更改\n- 任何一个文档出现滞后，都要记录，分析问题\n\n文档内容要细致，需求文档作为开发文档和测试文档输入，尤其重要。\n\n各个文档的基本标准：\n\n- 需求文档：明确各步骤输入输出\n- 测试文档：明确各个测试点，需要进行什么测试，是否要求自动化等信息，设计（复用）测试框架\n- 开发文档：提供设计架构，需要细致到开发阶段填充代码就可以了\n\n一个优秀文档的重要标准：评审打回次数。\n\n**开发，测试并行**\n\n三个文档评审结束后，开发和测试同时开始工作。\n\n\n\n# 其它\n\n**关于需求分析**\n\n需求分析需要专业的人专门处理，需求分析的过程如同医生看病：\n\n医生不能问病人想吃什么药，想怎么治疗，而是需要找到病人病因\n\n产品不能表面的询问用户想要什么，而是要发现用户的真实需求\n\n需求分析过程展开：\n\n1. 获取\n\n   得到最原始的需求，这些需求可能是凌乱的，甚至是矛盾的，不能直接用来开发\n\n2. 分析\n\n   剔除原始需求中的噪音，获取真实的需求，这个阶段产品应该基本确认需求\n\n3. 细化\n\n   产出原型，与美术，设计确认沟通，明确每步的输入输出\n\n4. 固化\n\n   与用户确认，得到最终版本的需求文档\n\n**关于团队成员能力**\n\n1. 不能迁就最低能力人员，要推动团队成长，进步\n2. 开发与测试要互相促进，测试需要考虑开发设计的文档是否可以进行测试，有哪些改进，开发需要考虑代码的覆盖\n3. 通过模板让人员能力可流动，可转化。总结高质量方法，模板，流程给团队复用，提高整体质量\n\n**关于测试**\n\n- Bug分级\n- 不要首先搞UI测试\n- 尽量使用真实数据，边界数据\n- 避免对其它模块，代码的依赖\n- 发布时不一定就能做到所有测试都通过\n- 测试要可复用，粒度，范围要注意\n","source":"_posts/浅谈测试驱动开发.md","raw":"---\ntitle: 浅谈测试驱动开发\ndate: 2017-02-05 21:58:28\ntags:\n  - 设计模式\ncategories: 设计模式\n---\n\n近两日参加了名为“软件测试质量体系最佳实践”的分享，其中着重介绍了质量体系的建设，测试的经验以及方法，就我个人最大的收获更多的是关于TDD的思考，在此简单记录。\n\n# Bug的影响\n\n不成熟的团队中一个常见情况：\n\n频繁被突发问题打断，响应式的处理，目标达成率低，可以称这样的团队为响应式的团队。\n\n为什么频繁的响应Bug会严重消耗团队资源？\n\n1. 完整的Bug处理的过程时间长\n2. 一个Bug导致多个Bug的产生\n3. 人员缺乏动力\n\n# 预防Bug\n\n然而解决Bug并不能算作突出的贡献，针对Bug的预防工作要优于Bug解决。从被动的救火到主动的预防问题发生，减少突发问题。\n\n一个团队的重要指标，是有效代码的产出，而不是代码的产出。\n\n有效代码，如同字面意思，有效的，可复用的，没有大量Bug，可以赚钱的代码。\n\n如何保证代码有效？测试！\n\n# 测试\n\n手工测试无法做到连续提供测试服务，存在间断，代码修改后测试报告随即失效。为了解决测试的间断问题，必须引入自动化测试。\n\n开发工作中耗时最多的是在调试，如果能减少问题的出现，避免反复调试，可以节省大量的时间、精力。\n\n因此，测试并不会让团队的工作量出现明显增加，最终开发与测试的人数趋于接近。\n\n测试短期可以帮助我们找Bug，长期可以帮助我们建设质量体系。\n\n# 质量体系\n\n系统的健康状况，项目的完成情况应当从质量体系中直观，实时的获取，而不是通过大量的会议，讨论得出。\n\n数据的三个来源\n\n- 用例库\n\n  积累的测试用例\n\n  要求能复用（良好的测试框架）\n\n  能够与其它平台，系统方便集成（一个test case对应多个test Run）\n\n- 缺陷库\n\n  Bug的完整生命周期记录\n\n- 结果库\n\n  每次自动化测试的结果\n\n  最小的单位不是test case，而是test run\n\n质量体系，不仅用于预防问题，长远看还需要提供数据支持，需要辅助决策，辅助管理。\n\n# 团队\n\n当一个团队可以很好的预防问题的发生时，可以称这样的团队为建设型的团队。\n\n传统的瀑布模型中开发完成开始测试是导致项目进度缓慢的一个重要原因。\n\n如何让开发与测试并行？测试始终伴随开发，甚至优先于开发。\n\n开发，测试并行的三个重要保障：需求文档，开发文档，测试文档\n\n# TDD\n\n**文档评审**\n\n从执行过程上来看，当需求文档出来后，开发和测试需要同时整理对应文档，然后进入评审环节。\n\n需求作为开发，测试的输入项，要求需求文档不能出现偏差。\n\n从制度上可以做出一些规范化，例如：\n\n- 需求文档、开发文档、测试文档作为三个关键文档，任何一个都一定不能或缺\n- 三个关键文档都要有评审，三次的评审都要求产品、开发、测试负责的人员到场确认\n- 文档可以驳回，但确认后的文档不可更改\n- 任何一个文档出现滞后，都要记录，分析问题\n\n文档内容要细致，需求文档作为开发文档和测试文档输入，尤其重要。\n\n各个文档的基本标准：\n\n- 需求文档：明确各步骤输入输出\n- 测试文档：明确各个测试点，需要进行什么测试，是否要求自动化等信息，设计（复用）测试框架\n- 开发文档：提供设计架构，需要细致到开发阶段填充代码就可以了\n\n一个优秀文档的重要标准：评审打回次数。\n\n**开发，测试并行**\n\n三个文档评审结束后，开发和测试同时开始工作。\n\n\n\n# 其它\n\n**关于需求分析**\n\n需求分析需要专业的人专门处理，需求分析的过程如同医生看病：\n\n医生不能问病人想吃什么药，想怎么治疗，而是需要找到病人病因\n\n产品不能表面的询问用户想要什么，而是要发现用户的真实需求\n\n需求分析过程展开：\n\n1. 获取\n\n   得到最原始的需求，这些需求可能是凌乱的，甚至是矛盾的，不能直接用来开发\n\n2. 分析\n\n   剔除原始需求中的噪音，获取真实的需求，这个阶段产品应该基本确认需求\n\n3. 细化\n\n   产出原型，与美术，设计确认沟通，明确每步的输入输出\n\n4. 固化\n\n   与用户确认，得到最终版本的需求文档\n\n**关于团队成员能力**\n\n1. 不能迁就最低能力人员，要推动团队成长，进步\n2. 开发与测试要互相促进，测试需要考虑开发设计的文档是否可以进行测试，有哪些改进，开发需要考虑代码的覆盖\n3. 通过模板让人员能力可流动，可转化。总结高质量方法，模板，流程给团队复用，提高整体质量\n\n**关于测试**\n\n- Bug分级\n- 不要首先搞UI测试\n- 尽量使用真实数据，边界数据\n- 避免对其它模块，代码的依赖\n- 发布时不一定就能做到所有测试都通过\n- 测试要可复用，粒度，范围要注意\n","slug":"浅谈测试驱动开发","published":1,"updated":"2017-02-05T14:13:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gb9001gyi2eq9ybqad3","content":"<p>近两日参加了名为“软件测试质量体系最佳实践”的分享，其中着重介绍了质量体系的建设，测试的经验以及方法，就我个人最大的收获更多的是关于TDD的思考，在此简单记录。</p>\n<h1 id=\"Bug的影响\"><a href=\"#Bug的影响\" class=\"headerlink\" title=\"Bug的影响\"></a>Bug的影响</h1><p>不成熟的团队中一个常见情况：</p>\n<p>频繁被突发问题打断，响应式的处理，目标达成率低，可以称这样的团队为响应式的团队。</p>\n<p>为什么频繁的响应Bug会严重消耗团队资源？</p>\n<ol>\n<li>完整的Bug处理的过程时间长</li>\n<li>一个Bug导致多个Bug的产生</li>\n<li>人员缺乏动力</li>\n</ol>\n<h1 id=\"预防Bug\"><a href=\"#预防Bug\" class=\"headerlink\" title=\"预防Bug\"></a>预防Bug</h1><p>然而解决Bug并不能算作突出的贡献，针对Bug的预防工作要优于Bug解决。从被动的救火到主动的预防问题发生，减少突发问题。</p>\n<p>一个团队的重要指标，是有效代码的产出，而不是代码的产出。</p>\n<p>有效代码，如同字面意思，有效的，可复用的，没有大量Bug，可以赚钱的代码。</p>\n<p>如何保证代码有效？测试！</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p>手工测试无法做到连续提供测试服务，存在间断，代码修改后测试报告随即失效。为了解决测试的间断问题，必须引入自动化测试。</p>\n<p>开发工作中耗时最多的是在调试，如果能减少问题的出现，避免反复调试，可以节省大量的时间、精力。</p>\n<p>因此，测试并不会让团队的工作量出现明显增加，最终开发与测试的人数趋于接近。</p>\n<p>测试短期可以帮助我们找Bug，长期可以帮助我们建设质量体系。</p>\n<h1 id=\"质量体系\"><a href=\"#质量体系\" class=\"headerlink\" title=\"质量体系\"></a>质量体系</h1><p>系统的健康状况，项目的完成情况应当从质量体系中直观，实时的获取，而不是通过大量的会议，讨论得出。</p>\n<p>数据的三个来源</p>\n<ul>\n<li><p>用例库</p>\n<p>积累的测试用例</p>\n<p>要求能复用（良好的测试框架）</p>\n<p>能够与其它平台，系统方便集成（一个test case对应多个test Run）</p>\n</li>\n<li><p>缺陷库</p>\n<p>Bug的完整生命周期记录</p>\n</li>\n<li><p>结果库</p>\n<p>每次自动化测试的结果</p>\n<p>最小的单位不是test case，而是test run</p>\n</li>\n</ul>\n<p>质量体系，不仅用于预防问题，长远看还需要提供数据支持，需要辅助决策，辅助管理。</p>\n<h1 id=\"团队\"><a href=\"#团队\" class=\"headerlink\" title=\"团队\"></a>团队</h1><p>当一个团队可以很好的预防问题的发生时，可以称这样的团队为建设型的团队。</p>\n<p>传统的瀑布模型中开发完成开始测试是导致项目进度缓慢的一个重要原因。</p>\n<p>如何让开发与测试并行？测试始终伴随开发，甚至优先于开发。</p>\n<p>开发，测试并行的三个重要保障：需求文档，开发文档，测试文档</p>\n<h1 id=\"TDD\"><a href=\"#TDD\" class=\"headerlink\" title=\"TDD\"></a>TDD</h1><p><strong>文档评审</strong></p>\n<p>从执行过程上来看，当需求文档出来后，开发和测试需要同时整理对应文档，然后进入评审环节。</p>\n<p>需求作为开发，测试的输入项，要求需求文档不能出现偏差。</p>\n<p>从制度上可以做出一些规范化，例如：</p>\n<ul>\n<li>需求文档、开发文档、测试文档作为三个关键文档，任何一个都一定不能或缺</li>\n<li>三个关键文档都要有评审，三次的评审都要求产品、开发、测试负责的人员到场确认</li>\n<li>文档可以驳回，但确认后的文档不可更改</li>\n<li>任何一个文档出现滞后，都要记录，分析问题</li>\n</ul>\n<p>文档内容要细致，需求文档作为开发文档和测试文档输入，尤其重要。</p>\n<p>各个文档的基本标准：</p>\n<ul>\n<li>需求文档：明确各步骤输入输出</li>\n<li>测试文档：明确各个测试点，需要进行什么测试，是否要求自动化等信息，设计（复用）测试框架</li>\n<li>开发文档：提供设计架构，需要细致到开发阶段填充代码就可以了</li>\n</ul>\n<p>一个优秀文档的重要标准：评审打回次数。</p>\n<p><strong>开发，测试并行</strong></p>\n<p>三个文档评审结束后，开发和测试同时开始工作。</p>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><p><strong>关于需求分析</strong></p>\n<p>需求分析需要专业的人专门处理，需求分析的过程如同医生看病：</p>\n<p>医生不能问病人想吃什么药，想怎么治疗，而是需要找到病人病因</p>\n<p>产品不能表面的询问用户想要什么，而是要发现用户的真实需求</p>\n<p>需求分析过程展开：</p>\n<ol>\n<li><p>获取</p>\n<p>得到最原始的需求，这些需求可能是凌乱的，甚至是矛盾的，不能直接用来开发</p>\n</li>\n<li><p>分析</p>\n<p>剔除原始需求中的噪音，获取真实的需求，这个阶段产品应该基本确认需求</p>\n</li>\n<li><p>细化</p>\n<p>产出原型，与美术，设计确认沟通，明确每步的输入输出</p>\n</li>\n<li><p>固化</p>\n<p>与用户确认，得到最终版本的需求文档</p>\n</li>\n</ol>\n<p><strong>关于团队成员能力</strong></p>\n<ol>\n<li>不能迁就最低能力人员，要推动团队成长，进步</li>\n<li>开发与测试要互相促进，测试需要考虑开发设计的文档是否可以进行测试，有哪些改进，开发需要考虑代码的覆盖</li>\n<li>通过模板让人员能力可流动，可转化。总结高质量方法，模板，流程给团队复用，提高整体质量</li>\n</ol>\n<p><strong>关于测试</strong></p>\n<ul>\n<li>Bug分级</li>\n<li>不要首先搞UI测试</li>\n<li>尽量使用真实数据，边界数据</li>\n<li>避免对其它模块，代码的依赖</li>\n<li>发布时不一定就能做到所有测试都通过</li>\n<li>测试要可复用，粒度，范围要注意</li>\n</ul>\n","excerpt":"","more":"<p>近两日参加了名为“软件测试质量体系最佳实践”的分享，其中着重介绍了质量体系的建设，测试的经验以及方法，就我个人最大的收获更多的是关于TDD的思考，在此简单记录。</p>\n<h1 id=\"Bug的影响\"><a href=\"#Bug的影响\" class=\"headerlink\" title=\"Bug的影响\"></a>Bug的影响</h1><p>不成熟的团队中一个常见情况：</p>\n<p>频繁被突发问题打断，响应式的处理，目标达成率低，可以称这样的团队为响应式的团队。</p>\n<p>为什么频繁的响应Bug会严重消耗团队资源？</p>\n<ol>\n<li>完整的Bug处理的过程时间长</li>\n<li>一个Bug导致多个Bug的产生</li>\n<li>人员缺乏动力</li>\n</ol>\n<h1 id=\"预防Bug\"><a href=\"#预防Bug\" class=\"headerlink\" title=\"预防Bug\"></a>预防Bug</h1><p>然而解决Bug并不能算作突出的贡献，针对Bug的预防工作要优于Bug解决。从被动的救火到主动的预防问题发生，减少突发问题。</p>\n<p>一个团队的重要指标，是有效代码的产出，而不是代码的产出。</p>\n<p>有效代码，如同字面意思，有效的，可复用的，没有大量Bug，可以赚钱的代码。</p>\n<p>如何保证代码有效？测试！</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p>手工测试无法做到连续提供测试服务，存在间断，代码修改后测试报告随即失效。为了解决测试的间断问题，必须引入自动化测试。</p>\n<p>开发工作中耗时最多的是在调试，如果能减少问题的出现，避免反复调试，可以节省大量的时间、精力。</p>\n<p>因此，测试并不会让团队的工作量出现明显增加，最终开发与测试的人数趋于接近。</p>\n<p>测试短期可以帮助我们找Bug，长期可以帮助我们建设质量体系。</p>\n<h1 id=\"质量体系\"><a href=\"#质量体系\" class=\"headerlink\" title=\"质量体系\"></a>质量体系</h1><p>系统的健康状况，项目的完成情况应当从质量体系中直观，实时的获取，而不是通过大量的会议，讨论得出。</p>\n<p>数据的三个来源</p>\n<ul>\n<li><p>用例库</p>\n<p>积累的测试用例</p>\n<p>要求能复用（良好的测试框架）</p>\n<p>能够与其它平台，系统方便集成（一个test case对应多个test Run）</p>\n</li>\n<li><p>缺陷库</p>\n<p>Bug的完整生命周期记录</p>\n</li>\n<li><p>结果库</p>\n<p>每次自动化测试的结果</p>\n<p>最小的单位不是test case，而是test run</p>\n</li>\n</ul>\n<p>质量体系，不仅用于预防问题，长远看还需要提供数据支持，需要辅助决策，辅助管理。</p>\n<h1 id=\"团队\"><a href=\"#团队\" class=\"headerlink\" title=\"团队\"></a>团队</h1><p>当一个团队可以很好的预防问题的发生时，可以称这样的团队为建设型的团队。</p>\n<p>传统的瀑布模型中开发完成开始测试是导致项目进度缓慢的一个重要原因。</p>\n<p>如何让开发与测试并行？测试始终伴随开发，甚至优先于开发。</p>\n<p>开发，测试并行的三个重要保障：需求文档，开发文档，测试文档</p>\n<h1 id=\"TDD\"><a href=\"#TDD\" class=\"headerlink\" title=\"TDD\"></a>TDD</h1><p><strong>文档评审</strong></p>\n<p>从执行过程上来看，当需求文档出来后，开发和测试需要同时整理对应文档，然后进入评审环节。</p>\n<p>需求作为开发，测试的输入项，要求需求文档不能出现偏差。</p>\n<p>从制度上可以做出一些规范化，例如：</p>\n<ul>\n<li>需求文档、开发文档、测试文档作为三个关键文档，任何一个都一定不能或缺</li>\n<li>三个关键文档都要有评审，三次的评审都要求产品、开发、测试负责的人员到场确认</li>\n<li>文档可以驳回，但确认后的文档不可更改</li>\n<li>任何一个文档出现滞后，都要记录，分析问题</li>\n</ul>\n<p>文档内容要细致，需求文档作为开发文档和测试文档输入，尤其重要。</p>\n<p>各个文档的基本标准：</p>\n<ul>\n<li>需求文档：明确各步骤输入输出</li>\n<li>测试文档：明确各个测试点，需要进行什么测试，是否要求自动化等信息，设计（复用）测试框架</li>\n<li>开发文档：提供设计架构，需要细致到开发阶段填充代码就可以了</li>\n</ul>\n<p>一个优秀文档的重要标准：评审打回次数。</p>\n<p><strong>开发，测试并行</strong></p>\n<p>三个文档评审结束后，开发和测试同时开始工作。</p>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><p><strong>关于需求分析</strong></p>\n<p>需求分析需要专业的人专门处理，需求分析的过程如同医生看病：</p>\n<p>医生不能问病人想吃什么药，想怎么治疗，而是需要找到病人病因</p>\n<p>产品不能表面的询问用户想要什么，而是要发现用户的真实需求</p>\n<p>需求分析过程展开：</p>\n<ol>\n<li><p>获取</p>\n<p>得到最原始的需求，这些需求可能是凌乱的，甚至是矛盾的，不能直接用来开发</p>\n</li>\n<li><p>分析</p>\n<p>剔除原始需求中的噪音，获取真实的需求，这个阶段产品应该基本确认需求</p>\n</li>\n<li><p>细化</p>\n<p>产出原型，与美术，设计确认沟通，明确每步的输入输出</p>\n</li>\n<li><p>固化</p>\n<p>与用户确认，得到最终版本的需求文档</p>\n</li>\n</ol>\n<p><strong>关于团队成员能力</strong></p>\n<ol>\n<li>不能迁就最低能力人员，要推动团队成长，进步</li>\n<li>开发与测试要互相促进，测试需要考虑开发设计的文档是否可以进行测试，有哪些改进，开发需要考虑代码的覆盖</li>\n<li>通过模板让人员能力可流动，可转化。总结高质量方法，模板，流程给团队复用，提高整体质量</li>\n</ol>\n<p><strong>关于测试</strong></p>\n<ul>\n<li>Bug分级</li>\n<li>不要首先搞UI测试</li>\n<li>尽量使用真实数据，边界数据</li>\n<li>避免对其它模块，代码的依赖</li>\n<li>发布时不一定就能做到所有测试都通过</li>\n<li>测试要可复用，粒度，范围要注意</li>\n</ul>\n"},{"title":"迪米特法则——合理的封装","date":"2016-10-22T10:55:36.000Z","_content":"\n## 背景\n\n以服务员，客户，钱包为载体，模拟一个付款过程，阐述不恰当的封装行为。\n\n说明合理封装的一般过程以及不合理封装所表现的一般形式，介绍迪米特法则相关的基本内容，遵循迪米特法则对问题代码进行重构。\n\n## 看似没有问题的问题\n\n先看一个简单代码，分别描述钱包、客户、服务员：\n\n```java\npublic class Wallet {\n    private double value;\n     public double getTotalMoney() {\n        return value;\n    }\n    public void setTotalMoney(double newValue) {\n        value = newValue;\n    }\n    public void addMoney(double deposit) {\n        value += deposit;\n    }\n    public void subtractMoney(double debit) {\n        value -= debit;\n    }\n\t// 省略其它字段，方法\n}\n\npublic class Customer {\n    private Wallet myWallet;\n\t// 省略其它字段，方法\n}\n\npublic class Paperboy {\n  private Customer myCustomer;\n  public void pay(double payment) {\n    Wallet theWallet = myCustomer.getWallet();\n    if (theWallet.getTotalMoney() > payment) {\n        theWallet.subtractMoney(payment);\n    } else {\n        //money not enough\n    }\n  }\n}\n```\n一眼看过去，没毛病。几个基本的简单类在Paperboy的pay方法中实现了简单的业务逻辑，但翻译成“人类语言”就有点问题了：\n\n业务的第一步造作：通过客户获取其钱包。\n\n等等这样真的好吗?现实生活中仿佛讲不通啊，程序设计中其实违反了迪米特法则。\n\n听到迪米特法则那一瞬间，我想到的是各种设计模式概念，尴尬的是就是想不起迪米特到底是个啥!\n\n## 迪米特法则\n\n迪米特法则（最小知识法则，强调专注性）：\n\n任何一个对象或者方法，它应该只能调用下列对象：\n\n- 该对象本身和对象的属性\n- 作为参数传进方法的对象\n- 在方法内创建的对象\n\n这下好像清晰多了，其实再通俗一点上面的代码就是违反了**封装**的原则。\n\n**合理的封装分为两步**：\n\n1. **分辨职责**\n   1. 依据：数据与行为应该封装在一起（信息专家模式）\n   2. 过程：职责操作哪些数据，数据在哪个（些）类，进而确定职责在哪个类\n2. 判别哪些是实现细节，哪些是可以**公开的接口**，以保证对**细节的合理隐藏**\n\n**不良封装造成的结果**：Feature Envy（依恋情结）\n\n**不良封装可能的代码样式**：\n\n```java\nobj1.obj1_fun().obj2_fun();\n```\n类似链式的方法调用，但方法返回的是不同对象，这时候的代码很有可能是不良封装，违反迪米特法则了。\n\n## 问题的解决\n\n上面代码良好的封装示例：\n\n```java\npublic class Customer {\n    private Wallet myWallet;\n\n    public void pay(float payment) {\n        Wallet theWallet = myWallet;\n        if (theWallet.getTotalMoney() > payment) {\n            theWallet.subtractMoney(payment);\n        } else {\n            //money not enough\n        }\n    }\n}\n\npublic class Paperboy {\n    private Customer myCustomer;\n\n    public void pay(float payment) {\n        myCustomer.pay(payment);\n    }\n\n}\n```\n","source":"_posts/迪米特法则——合理的封装.md","raw":"---\ntitle: 迪米特法则——合理的封装\ndate: 2016-10-22 18:55:36\ntags: \n  - Java\n  - 设计模式\ncategories: 设计模式\n---\n\n## 背景\n\n以服务员，客户，钱包为载体，模拟一个付款过程，阐述不恰当的封装行为。\n\n说明合理封装的一般过程以及不合理封装所表现的一般形式，介绍迪米特法则相关的基本内容，遵循迪米特法则对问题代码进行重构。\n\n## 看似没有问题的问题\n\n先看一个简单代码，分别描述钱包、客户、服务员：\n\n```java\npublic class Wallet {\n    private double value;\n     public double getTotalMoney() {\n        return value;\n    }\n    public void setTotalMoney(double newValue) {\n        value = newValue;\n    }\n    public void addMoney(double deposit) {\n        value += deposit;\n    }\n    public void subtractMoney(double debit) {\n        value -= debit;\n    }\n\t// 省略其它字段，方法\n}\n\npublic class Customer {\n    private Wallet myWallet;\n\t// 省略其它字段，方法\n}\n\npublic class Paperboy {\n  private Customer myCustomer;\n  public void pay(double payment) {\n    Wallet theWallet = myCustomer.getWallet();\n    if (theWallet.getTotalMoney() > payment) {\n        theWallet.subtractMoney(payment);\n    } else {\n        //money not enough\n    }\n  }\n}\n```\n一眼看过去，没毛病。几个基本的简单类在Paperboy的pay方法中实现了简单的业务逻辑，但翻译成“人类语言”就有点问题了：\n\n业务的第一步造作：通过客户获取其钱包。\n\n等等这样真的好吗?现实生活中仿佛讲不通啊，程序设计中其实违反了迪米特法则。\n\n听到迪米特法则那一瞬间，我想到的是各种设计模式概念，尴尬的是就是想不起迪米特到底是个啥!\n\n## 迪米特法则\n\n迪米特法则（最小知识法则，强调专注性）：\n\n任何一个对象或者方法，它应该只能调用下列对象：\n\n- 该对象本身和对象的属性\n- 作为参数传进方法的对象\n- 在方法内创建的对象\n\n这下好像清晰多了，其实再通俗一点上面的代码就是违反了**封装**的原则。\n\n**合理的封装分为两步**：\n\n1. **分辨职责**\n   1. 依据：数据与行为应该封装在一起（信息专家模式）\n   2. 过程：职责操作哪些数据，数据在哪个（些）类，进而确定职责在哪个类\n2. 判别哪些是实现细节，哪些是可以**公开的接口**，以保证对**细节的合理隐藏**\n\n**不良封装造成的结果**：Feature Envy（依恋情结）\n\n**不良封装可能的代码样式**：\n\n```java\nobj1.obj1_fun().obj2_fun();\n```\n类似链式的方法调用，但方法返回的是不同对象，这时候的代码很有可能是不良封装，违反迪米特法则了。\n\n## 问题的解决\n\n上面代码良好的封装示例：\n\n```java\npublic class Customer {\n    private Wallet myWallet;\n\n    public void pay(float payment) {\n        Wallet theWallet = myWallet;\n        if (theWallet.getTotalMoney() > payment) {\n            theWallet.subtractMoney(payment);\n        } else {\n            //money not enough\n        }\n    }\n}\n\npublic class Paperboy {\n    private Customer myCustomer;\n\n    public void pay(float payment) {\n        myCustomer.pay(payment);\n    }\n\n}\n```\n","slug":"迪米特法则——合理的封装","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gbc001jyi2eq44pbl5t","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>以服务员，客户，钱包为载体，模拟一个付款过程，阐述不恰当的封装行为。</p>\n<p>说明合理封装的一般过程以及不合理封装所表现的一般形式，介绍迪米特法则相关的基本内容，遵循迪米特法则对问题代码进行重构。</p>\n<h2 id=\"看似没有问题的问题\"><a href=\"#看似没有问题的问题\" class=\"headerlink\" title=\"看似没有问题的问题\"></a>看似没有问题的问题</h2><p>先看一个简单代码，分别描述钱包、客户、服务员：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wallet</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> value;</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTotalMoney</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTotalMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> newValue)</span> </span>&#123;</div><div class=\"line\">        value = newValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> deposit)</span> </span>&#123;</div><div class=\"line\">        value += deposit;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subtractMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> debit)</span> </span>&#123;</div><div class=\"line\">        value -= debit;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 省略其它字段，方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Wallet myWallet;</div><div class=\"line\">\t<span class=\"comment\">// 省略其它字段，方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Paperboy</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> Customer myCustomer;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">double</span> payment)</span> </span>&#123;</div><div class=\"line\">    Wallet theWallet = myCustomer.getWallet();</div><div class=\"line\">    <span class=\"keyword\">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</div><div class=\"line\">        theWallet.subtractMoney(payment);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//money not enough</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一眼看过去，没毛病。几个基本的简单类在Paperboy的pay方法中实现了简单的业务逻辑，但翻译成“人类语言”就有点问题了：</p>\n<p>业务的第一步造作：通过客户获取其钱包。</p>\n<p>等等这样真的好吗?现实生活中仿佛讲不通啊，程序设计中其实违反了迪米特法则。</p>\n<p>听到迪米特法则那一瞬间，我想到的是各种设计模式概念，尴尬的是就是想不起迪米特到底是个啥!</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>迪米特法则（最小知识法则，强调专注性）：</p>\n<p>任何一个对象或者方法，它应该只能调用下列对象：</p>\n<ul>\n<li>该对象本身和对象的属性</li>\n<li>作为参数传进方法的对象</li>\n<li>在方法内创建的对象</li>\n</ul>\n<p>这下好像清晰多了，其实再通俗一点上面的代码就是违反了<strong>封装</strong>的原则。</p>\n<p><strong>合理的封装分为两步</strong>：</p>\n<ol>\n<li><strong>分辨职责</strong><ol>\n<li>依据：数据与行为应该封装在一起（信息专家模式）</li>\n<li>过程：职责操作哪些数据，数据在哪个（些）类，进而确定职责在哪个类</li>\n</ol>\n</li>\n<li>判别哪些是实现细节，哪些是可以<strong>公开的接口</strong>，以保证对<strong>细节的合理隐藏</strong></li>\n</ol>\n<p><strong>不良封装造成的结果</strong>：Feature Envy（依恋情结）</p>\n<p><strong>不良封装可能的代码样式</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj1.obj1_fun().obj2_fun();</div></pre></td></tr></table></figure>\n<p>类似链式的方法调用，但方法返回的是不同对象，这时候的代码很有可能是不良封装，违反迪米特法则了。</p>\n<h2 id=\"问题的解决\"><a href=\"#问题的解决\" class=\"headerlink\" title=\"问题的解决\"></a>问题的解决</h2><p>上面代码良好的封装示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Wallet myWallet;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">float</span> payment)</span> </span>&#123;</div><div class=\"line\">        Wallet theWallet = myWallet;</div><div class=\"line\">        <span class=\"keyword\">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</div><div class=\"line\">            theWallet.subtractMoney(payment);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//money not enough</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Paperboy</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Customer myCustomer;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">float</span> payment)</span> </span>&#123;</div><div class=\"line\">        myCustomer.pay(payment);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>以服务员，客户，钱包为载体，模拟一个付款过程，阐述不恰当的封装行为。</p>\n<p>说明合理封装的一般过程以及不合理封装所表现的一般形式，介绍迪米特法则相关的基本内容，遵循迪米特法则对问题代码进行重构。</p>\n<h2 id=\"看似没有问题的问题\"><a href=\"#看似没有问题的问题\" class=\"headerlink\" title=\"看似没有问题的问题\"></a>看似没有问题的问题</h2><p>先看一个简单代码，分别描述钱包、客户、服务员：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wallet</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> value;</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTotalMoney</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTotalMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> newValue)</span> </span>&#123;</div><div class=\"line\">        value = newValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> deposit)</span> </span>&#123;</div><div class=\"line\">        value += deposit;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subtractMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> debit)</span> </span>&#123;</div><div class=\"line\">        value -= debit;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 省略其它字段，方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Wallet myWallet;</div><div class=\"line\">\t<span class=\"comment\">// 省略其它字段，方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Paperboy</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> Customer myCustomer;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">double</span> payment)</span> </span>&#123;</div><div class=\"line\">    Wallet theWallet = myCustomer.getWallet();</div><div class=\"line\">    <span class=\"keyword\">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</div><div class=\"line\">        theWallet.subtractMoney(payment);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//money not enough</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一眼看过去，没毛病。几个基本的简单类在Paperboy的pay方法中实现了简单的业务逻辑，但翻译成“人类语言”就有点问题了：</p>\n<p>业务的第一步造作：通过客户获取其钱包。</p>\n<p>等等这样真的好吗?现实生活中仿佛讲不通啊，程序设计中其实违反了迪米特法则。</p>\n<p>听到迪米特法则那一瞬间，我想到的是各种设计模式概念，尴尬的是就是想不起迪米特到底是个啥!</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>迪米特法则（最小知识法则，强调专注性）：</p>\n<p>任何一个对象或者方法，它应该只能调用下列对象：</p>\n<ul>\n<li>该对象本身和对象的属性</li>\n<li>作为参数传进方法的对象</li>\n<li>在方法内创建的对象</li>\n</ul>\n<p>这下好像清晰多了，其实再通俗一点上面的代码就是违反了<strong>封装</strong>的原则。</p>\n<p><strong>合理的封装分为两步</strong>：</p>\n<ol>\n<li><strong>分辨职责</strong><ol>\n<li>依据：数据与行为应该封装在一起（信息专家模式）</li>\n<li>过程：职责操作哪些数据，数据在哪个（些）类，进而确定职责在哪个类</li>\n</ol>\n</li>\n<li>判别哪些是实现细节，哪些是可以<strong>公开的接口</strong>，以保证对<strong>细节的合理隐藏</strong></li>\n</ol>\n<p><strong>不良封装造成的结果</strong>：Feature Envy（依恋情结）</p>\n<p><strong>不良封装可能的代码样式</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj1.obj1_fun().obj2_fun();</div></pre></td></tr></table></figure>\n<p>类似链式的方法调用，但方法返回的是不同对象，这时候的代码很有可能是不良封装，违反迪米特法则了。</p>\n<h2 id=\"问题的解决\"><a href=\"#问题的解决\" class=\"headerlink\" title=\"问题的解决\"></a>问题的解决</h2><p>上面代码良好的封装示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Wallet myWallet;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">float</span> payment)</span> </span>&#123;</div><div class=\"line\">        Wallet theWallet = myWallet;</div><div class=\"line\">        <span class=\"keyword\">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</div><div class=\"line\">            theWallet.subtractMoney(payment);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//money not enough</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Paperboy</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Customer myCustomer;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">float</span> payment)</span> </span>&#123;</div><div class=\"line\">        myCustomer.pay(payment);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"自下而上的开发实践","date":"2016-10-22T11:23:25.000Z","_content":"\n## 两种开发思路\n\n**自上而下**：设计先行，根据设计开发\n\n**自下而上**：开发先行，给予开发重构\n\n## 关注点分离\n\n类似于文章段落的划分，代码拆分的简单过程可以概括为：\n\n- 分行\n  - 方法真实逻辑与业务支撑逻辑的划分\n  - 基于模块层次的划分，而不是语句行数的划分\n- 注释\n  - 良好命名要胜过写大量的注释\n- 抽象提取方法\n  - 合理封装\n  - 参数内联\n  - 方法名、可访问性\n- 删除不必要的分行与注释\n\n## 共性与可变性分析\n\n软件工程的两个敌人：\n\n* 共性：开发成本、维护成本 \n* 可变性：维护成本\n\n共性的复用两种模式：\n\n- 继承\n  - 强耦合关系，父类的修改影响所有子类\n  - 单继承限制\n  - 多态\n  - 差异式编程\n  - 钩子方法\n- 组合\n  - 优先使用\n  - 依赖注入\n  - 优先组合接口而非实现\n    - 控制翻转\n\n## 接口\n\ncontext+role+collaborator\n\n好处：类型确定，但实现可变、不确定\n\n类与接口的关系类似于人与角色的关系：\n\n- 人可以有多个角色，类可以有多个接口\n- 人的某一个角色的确定是由环境决定的，类某一接口的确定是由上下文环境决定的\n\n接口设计应当遵循的原则：**接口隔离原则（SIP）**\n\n接口应该是干净的，单一的，细粒度的，而不是混合过多的方法，职责单一\n\n## 扩展式设计的一般过程：\n\n1. 分离职责各司其职：关注点分离\n   - 向上分离：继承\n   - 向外分离：组合\n2. 统一接口：\n   - 提炼接口，提供多态\n   - 面向接口编程\n3. 引用接口预留空白\n   - 依赖注入\n\n以一个事务为例子展示扩展式设计的一般过程：\n\n首先，有一个Service，在方法中业务逻辑与JDBC事务粘合在一起：\n\n\n```java\npublic class OrderService {\n    private DatabasePool dbPool;\n\n    public void subscribTrainings(List<Training> trainings, \n                                  Customer customer) throws SQLException {\n        // 初始化方法\n      \tConnection c = null;\n        PreparedStatement ps = null;\n        Statement s = null;\n        ResultSet rs = null;\n        boolean transactionState = false;\n      \n        try {\n          \t// 开启事务 \n            s = c.createStatement();\n            transactionState = c.getAutoCommit();\n            c.setAutoCommit(false);\n          \n          \t// 业务操作\n            for (Training training : trainings) {\n                addTrainingItem(customer, training);\n            }\n            addOrder(customer, trainings);\n            \n          \t// 提交事务\n          \tc.commit();\n        } catch (SQLException sqlx) {\n          \t// 回滚\n            c.rollback();\n          \n            throw sqlx;\n        } finally {\n          \t// 关闭操作\n            try {\n                c.setAutoCommit(transactionState);\n                dbPool.release(c);\n                if (s != null) s.close();\n                if (ps != null) ps.close();\n                if (rs != null) rs.close();\n            } catch (SQLException ignored) {\n            }\n        }\n    }\n\n    private void addOrder(Customer customer, List<Training> trainings) {\n\t\n    }\n\n    private void addTrainingItem(Customer customer, Training training) {\n\n    }\n}\n```\n\n第一步在原始代码上分段并添加注释后代码如上所示。对每段代码提取方法，向上抽象：\n\n```java\npublic class TransactionScope {\n    private DatabasePool dbPool;\n    private Connection connection;\n    private PreparedStatement preparedStatement;\n    private Statement statement;\n    private ResultSet resultSet;\n    private boolean transactionState;\n\n    public void using() throws SQLException {\n        setup();\n        try {\n            beginTransaction();\n            // 留白一个具体的业务的实现:\n            //      1. (模板方法)继承->钩子方法\n            //      2. (委派)传递一个方法(方法接口)\n            commitTransaction();\n        } catch (SQLException sqlx) {\n            rollbackTransaction();\n            throw sqlx;\n        } finally {\n            teardown();\n        }\n    }\n\n    private void rollbackTransaction() throws SQLException {\n        connection.rollback();\n    }\n\n    private void setup() {\n        connection = null;\n        preparedStatement = null;\n        statement = null;\n        resultSet = null;\n        transactionState = false;\n    }\n\n    private void teardown() {\n        try {\n            connection.setAutoCommit(transactionState);\n            dbPool.release(connection);\n            if (statement != null) statement.close();\n            if (preparedStatement != null) preparedStatement.close();\n            if (resultSet != null) resultSet.close();\n        } catch (SQLException ignored) {\n        }\n    }\n\n    private void commitTransaction() throws SQLException {\n        connection.commit();\n    }\n\n    private void beginTransaction() throws SQLException {\n        statement = connection.createStatement();\n        transactionState = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n    }\n}\n\npublic interface Command {\n    void execute();\n}\n\n```\n现在提炼出了一个本地事务的基本控制模板，实现了事务控制与业务逻辑控制基本分离。\n\n继续提炼事务控制类的接口，用于横向扩展继承使用：\n\n```java\npublic interface TransactionScope {\n    void using(Command command) throws SQLException;\n}\n\npublic class LocalTransactionScope implements TransactionScope {\n  \t@Override\n    public void using(Command action) throws SQLException {\n        setup();\n        try {\n            beginTransaction();\n            action.execute();  // 具体的业务逻辑\n            commitTransaction();\n        } catch (SQLException sqlx) {\n            rollbackTransaction();\n            throw sqlx;\n        } finally {\n            teardown();\n        }\n    }\n}\n\npublic class DistructedTransactionScope implements TransactionScope {\n    @Override\n    public void using(Command command) throws SQLException {\n      \n    }\n}\n```\n调用方通过接口留白，实现依赖注入：\n\n```java\npublic class OrderService {\n    private TransactionScope transactionScope;\n\n    public void setTransactionScope(TransactionScope transactionScope) {\n        this.transactionScope = transactionScope;\n    }\n\n    public void subscribTrainings(List<Training> trainings, \n                                  Customer customer) throws SQLException {\n        transactionScope.using(() -> {\n                for (Training training : trainings) {\n                    addTrainingItem(customer, training);\n                }\n                addOrder(customer, trainings);\n        });\n    }\n}\n```\n","source":"_posts/自下而上的开发实践.md","raw":"---\ntitle: 自下而上的开发实践\ndate: 2016-10-22 19:23:25\ntags:\n  - 设计模式\n  - Java\ncategories: 设计模式\n---\n\n## 两种开发思路\n\n**自上而下**：设计先行，根据设计开发\n\n**自下而上**：开发先行，给予开发重构\n\n## 关注点分离\n\n类似于文章段落的划分，代码拆分的简单过程可以概括为：\n\n- 分行\n  - 方法真实逻辑与业务支撑逻辑的划分\n  - 基于模块层次的划分，而不是语句行数的划分\n- 注释\n  - 良好命名要胜过写大量的注释\n- 抽象提取方法\n  - 合理封装\n  - 参数内联\n  - 方法名、可访问性\n- 删除不必要的分行与注释\n\n## 共性与可变性分析\n\n软件工程的两个敌人：\n\n* 共性：开发成本、维护成本 \n* 可变性：维护成本\n\n共性的复用两种模式：\n\n- 继承\n  - 强耦合关系，父类的修改影响所有子类\n  - 单继承限制\n  - 多态\n  - 差异式编程\n  - 钩子方法\n- 组合\n  - 优先使用\n  - 依赖注入\n  - 优先组合接口而非实现\n    - 控制翻转\n\n## 接口\n\ncontext+role+collaborator\n\n好处：类型确定，但实现可变、不确定\n\n类与接口的关系类似于人与角色的关系：\n\n- 人可以有多个角色，类可以有多个接口\n- 人的某一个角色的确定是由环境决定的，类某一接口的确定是由上下文环境决定的\n\n接口设计应当遵循的原则：**接口隔离原则（SIP）**\n\n接口应该是干净的，单一的，细粒度的，而不是混合过多的方法，职责单一\n\n## 扩展式设计的一般过程：\n\n1. 分离职责各司其职：关注点分离\n   - 向上分离：继承\n   - 向外分离：组合\n2. 统一接口：\n   - 提炼接口，提供多态\n   - 面向接口编程\n3. 引用接口预留空白\n   - 依赖注入\n\n以一个事务为例子展示扩展式设计的一般过程：\n\n首先，有一个Service，在方法中业务逻辑与JDBC事务粘合在一起：\n\n\n```java\npublic class OrderService {\n    private DatabasePool dbPool;\n\n    public void subscribTrainings(List<Training> trainings, \n                                  Customer customer) throws SQLException {\n        // 初始化方法\n      \tConnection c = null;\n        PreparedStatement ps = null;\n        Statement s = null;\n        ResultSet rs = null;\n        boolean transactionState = false;\n      \n        try {\n          \t// 开启事务 \n            s = c.createStatement();\n            transactionState = c.getAutoCommit();\n            c.setAutoCommit(false);\n          \n          \t// 业务操作\n            for (Training training : trainings) {\n                addTrainingItem(customer, training);\n            }\n            addOrder(customer, trainings);\n            \n          \t// 提交事务\n          \tc.commit();\n        } catch (SQLException sqlx) {\n          \t// 回滚\n            c.rollback();\n          \n            throw sqlx;\n        } finally {\n          \t// 关闭操作\n            try {\n                c.setAutoCommit(transactionState);\n                dbPool.release(c);\n                if (s != null) s.close();\n                if (ps != null) ps.close();\n                if (rs != null) rs.close();\n            } catch (SQLException ignored) {\n            }\n        }\n    }\n\n    private void addOrder(Customer customer, List<Training> trainings) {\n\t\n    }\n\n    private void addTrainingItem(Customer customer, Training training) {\n\n    }\n}\n```\n\n第一步在原始代码上分段并添加注释后代码如上所示。对每段代码提取方法，向上抽象：\n\n```java\npublic class TransactionScope {\n    private DatabasePool dbPool;\n    private Connection connection;\n    private PreparedStatement preparedStatement;\n    private Statement statement;\n    private ResultSet resultSet;\n    private boolean transactionState;\n\n    public void using() throws SQLException {\n        setup();\n        try {\n            beginTransaction();\n            // 留白一个具体的业务的实现:\n            //      1. (模板方法)继承->钩子方法\n            //      2. (委派)传递一个方法(方法接口)\n            commitTransaction();\n        } catch (SQLException sqlx) {\n            rollbackTransaction();\n            throw sqlx;\n        } finally {\n            teardown();\n        }\n    }\n\n    private void rollbackTransaction() throws SQLException {\n        connection.rollback();\n    }\n\n    private void setup() {\n        connection = null;\n        preparedStatement = null;\n        statement = null;\n        resultSet = null;\n        transactionState = false;\n    }\n\n    private void teardown() {\n        try {\n            connection.setAutoCommit(transactionState);\n            dbPool.release(connection);\n            if (statement != null) statement.close();\n            if (preparedStatement != null) preparedStatement.close();\n            if (resultSet != null) resultSet.close();\n        } catch (SQLException ignored) {\n        }\n    }\n\n    private void commitTransaction() throws SQLException {\n        connection.commit();\n    }\n\n    private void beginTransaction() throws SQLException {\n        statement = connection.createStatement();\n        transactionState = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n    }\n}\n\npublic interface Command {\n    void execute();\n}\n\n```\n现在提炼出了一个本地事务的基本控制模板，实现了事务控制与业务逻辑控制基本分离。\n\n继续提炼事务控制类的接口，用于横向扩展继承使用：\n\n```java\npublic interface TransactionScope {\n    void using(Command command) throws SQLException;\n}\n\npublic class LocalTransactionScope implements TransactionScope {\n  \t@Override\n    public void using(Command action) throws SQLException {\n        setup();\n        try {\n            beginTransaction();\n            action.execute();  // 具体的业务逻辑\n            commitTransaction();\n        } catch (SQLException sqlx) {\n            rollbackTransaction();\n            throw sqlx;\n        } finally {\n            teardown();\n        }\n    }\n}\n\npublic class DistructedTransactionScope implements TransactionScope {\n    @Override\n    public void using(Command command) throws SQLException {\n      \n    }\n}\n```\n调用方通过接口留白，实现依赖注入：\n\n```java\npublic class OrderService {\n    private TransactionScope transactionScope;\n\n    public void setTransactionScope(TransactionScope transactionScope) {\n        this.transactionScope = transactionScope;\n    }\n\n    public void subscribTrainings(List<Training> trainings, \n                                  Customer customer) throws SQLException {\n        transactionScope.using(() -> {\n                for (Training training : trainings) {\n                    addTrainingItem(customer, training);\n                }\n                addOrder(customer, trainings);\n        });\n    }\n}\n```\n","slug":"自下而上的开发实践","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj06y6gbf001nyi2ewgirians","content":"<h2 id=\"两种开发思路\"><a href=\"#两种开发思路\" class=\"headerlink\" title=\"两种开发思路\"></a>两种开发思路</h2><p><strong>自上而下</strong>：设计先行，根据设计开发</p>\n<p><strong>自下而上</strong>：开发先行，给予开发重构</p>\n<h2 id=\"关注点分离\"><a href=\"#关注点分离\" class=\"headerlink\" title=\"关注点分离\"></a>关注点分离</h2><p>类似于文章段落的划分，代码拆分的简单过程可以概括为：</p>\n<ul>\n<li>分行<ul>\n<li>方法真实逻辑与业务支撑逻辑的划分</li>\n<li>基于模块层次的划分，而不是语句行数的划分</li>\n</ul>\n</li>\n<li>注释<ul>\n<li>良好命名要胜过写大量的注释</li>\n</ul>\n</li>\n<li>抽象提取方法<ul>\n<li>合理封装</li>\n<li>参数内联</li>\n<li>方法名、可访问性</li>\n</ul>\n</li>\n<li>删除不必要的分行与注释</li>\n</ul>\n<h2 id=\"共性与可变性分析\"><a href=\"#共性与可变性分析\" class=\"headerlink\" title=\"共性与可变性分析\"></a>共性与可变性分析</h2><p>软件工程的两个敌人：</p>\n<ul>\n<li>共性：开发成本、维护成本 </li>\n<li>可变性：维护成本</li>\n</ul>\n<p>共性的复用两种模式：</p>\n<ul>\n<li>继承<ul>\n<li>强耦合关系，父类的修改影响所有子类</li>\n<li>单继承限制</li>\n<li>多态</li>\n<li>差异式编程</li>\n<li>钩子方法</li>\n</ul>\n</li>\n<li>组合<ul>\n<li>优先使用</li>\n<li>依赖注入</li>\n<li>优先组合接口而非实现<ul>\n<li>控制翻转</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>context+role+collaborator</p>\n<p>好处：类型确定，但实现可变、不确定</p>\n<p>类与接口的关系类似于人与角色的关系：</p>\n<ul>\n<li>人可以有多个角色，类可以有多个接口</li>\n<li>人的某一个角色的确定是由环境决定的，类某一接口的确定是由上下文环境决定的</li>\n</ul>\n<p>接口设计应当遵循的原则：<strong>接口隔离原则（SIP）</strong></p>\n<p>接口应该是干净的，单一的，细粒度的，而不是混合过多的方法，职责单一</p>\n<h2 id=\"扩展式设计的一般过程：\"><a href=\"#扩展式设计的一般过程：\" class=\"headerlink\" title=\"扩展式设计的一般过程：\"></a>扩展式设计的一般过程：</h2><ol>\n<li>分离职责各司其职：关注点分离<ul>\n<li>向上分离：继承</li>\n<li>向外分离：组合</li>\n</ul>\n</li>\n<li>统一接口：<ul>\n<li>提炼接口，提供多态</li>\n<li>面向接口编程</li>\n</ul>\n</li>\n<li>引用接口预留空白<ul>\n<li>依赖注入</li>\n</ul>\n</li>\n</ol>\n<p>以一个事务为例子展示扩展式设计的一般过程：</p>\n<p>首先，有一个Service，在方法中业务逻辑与JDBC事务粘合在一起：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> DatabasePool dbPool;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribTrainings</span><span class=\"params\">(List&lt;Training&gt; trainings, </span></span></div><div class=\"line\">                                  Customer customer) <span class=\"keyword\">throws</span> SQLException &#123;</div><div class=\"line\">        <span class=\"comment\">// 初始化方法</span></div><div class=\"line\">      \tConnection c = <span class=\"keyword\">null</span>;</div><div class=\"line\">        PreparedStatement ps = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Statement s = <span class=\"keyword\">null</span>;</div><div class=\"line\">        ResultSet rs = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> transactionState = <span class=\"keyword\">false</span>;</div><div class=\"line\">      </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 开启事务 </span></div><div class=\"line\">            s = c.createStatement();</div><div class=\"line\">            transactionState = c.getAutoCommit();</div><div class=\"line\">            c.setAutoCommit(<span class=\"keyword\">false</span>);</div><div class=\"line\">          </div><div class=\"line\">          \t<span class=\"comment\">// 业务操作</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (Training training : trainings) &#123;</div><div class=\"line\">                addTrainingItem(customer, training);</div><div class=\"line\">            &#125;</div><div class=\"line\">            addOrder(customer, trainings);</div><div class=\"line\">            </div><div class=\"line\">          \t<span class=\"comment\">// 提交事务</span></div><div class=\"line\">          \tc.commit();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 回滚</span></div><div class=\"line\">            c.rollback();</div><div class=\"line\">          </div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 关闭操作</span></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                c.setAutoCommit(transactionState);</div><div class=\"line\">                dbPool.release(c);</div><div class=\"line\">                <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>) s.close();</div><div class=\"line\">                <span class=\"keyword\">if</span> (ps != <span class=\"keyword\">null</span>) ps.close();</div><div class=\"line\">                <span class=\"keyword\">if</span> (rs != <span class=\"keyword\">null</span>) rs.close();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException ignored) &#123;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addOrder</span><span class=\"params\">(Customer customer, List&lt;Training&gt; trainings)</span> </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addTrainingItem</span><span class=\"params\">(Customer customer, Training training)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一步在原始代码上分段并添加注释后代码如上所示。对每段代码提取方法，向上抽象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> DatabasePool dbPool;</div><div class=\"line\">    <span class=\"keyword\">private</span> Connection connection;</div><div class=\"line\">    <span class=\"keyword\">private</span> PreparedStatement preparedStatement;</div><div class=\"line\">    <span class=\"keyword\">private</span> Statement statement;</div><div class=\"line\">    <span class=\"keyword\">private</span> ResultSet resultSet;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> transactionState;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        setup();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            beginTransaction();</div><div class=\"line\">            <span class=\"comment\">// 留白一个具体的业务的实现:</span></div><div class=\"line\">            <span class=\"comment\">//      1. (模板方法)继承-&gt;钩子方法</span></div><div class=\"line\">            <span class=\"comment\">//      2. (委派)传递一个方法(方法接口)</span></div><div class=\"line\">            commitTransaction();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">            rollbackTransaction();</div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            teardown();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rollbackTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        connection.rollback();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        connection = <span class=\"keyword\">null</span>;</div><div class=\"line\">        preparedStatement = <span class=\"keyword\">null</span>;</div><div class=\"line\">        statement = <span class=\"keyword\">null</span>;</div><div class=\"line\">        resultSet = <span class=\"keyword\">null</span>;</div><div class=\"line\">        transactionState = <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">teardown</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            connection.setAutoCommit(transactionState);</div><div class=\"line\">            dbPool.release(connection);</div><div class=\"line\">            <span class=\"keyword\">if</span> (statement != <span class=\"keyword\">null</span>) statement.close();</div><div class=\"line\">            <span class=\"keyword\">if</span> (preparedStatement != <span class=\"keyword\">null</span>) preparedStatement.close();</div><div class=\"line\">            <span class=\"keyword\">if</span> (resultSet != <span class=\"keyword\">null</span>) resultSet.close();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException ignored) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">commitTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        connection.commit();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">beginTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        statement = connection.createStatement();</div><div class=\"line\">        transactionState = connection.getAutoCommit();</div><div class=\"line\">        connection.setAutoCommit(<span class=\"keyword\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Command</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在提炼出了一个本地事务的基本控制模板，实现了事务控制与业务逻辑控制基本分离。</p>\n<p>继续提炼事务控制类的接口，用于横向扩展继承使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command command)</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalTransactionScope</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">  \t<span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command action)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        setup();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            beginTransaction();</div><div class=\"line\">            action.execute();  <span class=\"comment\">// 具体的业务逻辑</span></div><div class=\"line\">            commitTransaction();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">            rollbackTransaction();</div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            teardown();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DistructedTransactionScope</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command command)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">      </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用方通过接口留白，实现依赖注入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> TransactionScope transactionScope;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTransactionScope</span><span class=\"params\">(TransactionScope transactionScope)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.transactionScope = transactionScope;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribTrainings</span><span class=\"params\">(List&lt;Training&gt; trainings, </span></span></div><div class=\"line\">                                  Customer customer) <span class=\"keyword\">throws</span> SQLException &#123;</div><div class=\"line\">        transactionScope.using(() -&gt; &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (Training training : trainings) &#123;</div><div class=\"line\">                    addTrainingItem(customer, training);</div><div class=\"line\">                &#125;</div><div class=\"line\">                addOrder(customer, trainings);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"两种开发思路\"><a href=\"#两种开发思路\" class=\"headerlink\" title=\"两种开发思路\"></a>两种开发思路</h2><p><strong>自上而下</strong>：设计先行，根据设计开发</p>\n<p><strong>自下而上</strong>：开发先行，给予开发重构</p>\n<h2 id=\"关注点分离\"><a href=\"#关注点分离\" class=\"headerlink\" title=\"关注点分离\"></a>关注点分离</h2><p>类似于文章段落的划分，代码拆分的简单过程可以概括为：</p>\n<ul>\n<li>分行<ul>\n<li>方法真实逻辑与业务支撑逻辑的划分</li>\n<li>基于模块层次的划分，而不是语句行数的划分</li>\n</ul>\n</li>\n<li>注释<ul>\n<li>良好命名要胜过写大量的注释</li>\n</ul>\n</li>\n<li>抽象提取方法<ul>\n<li>合理封装</li>\n<li>参数内联</li>\n<li>方法名、可访问性</li>\n</ul>\n</li>\n<li>删除不必要的分行与注释</li>\n</ul>\n<h2 id=\"共性与可变性分析\"><a href=\"#共性与可变性分析\" class=\"headerlink\" title=\"共性与可变性分析\"></a>共性与可变性分析</h2><p>软件工程的两个敌人：</p>\n<ul>\n<li>共性：开发成本、维护成本 </li>\n<li>可变性：维护成本</li>\n</ul>\n<p>共性的复用两种模式：</p>\n<ul>\n<li>继承<ul>\n<li>强耦合关系，父类的修改影响所有子类</li>\n<li>单继承限制</li>\n<li>多态</li>\n<li>差异式编程</li>\n<li>钩子方法</li>\n</ul>\n</li>\n<li>组合<ul>\n<li>优先使用</li>\n<li>依赖注入</li>\n<li>优先组合接口而非实现<ul>\n<li>控制翻转</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>context+role+collaborator</p>\n<p>好处：类型确定，但实现可变、不确定</p>\n<p>类与接口的关系类似于人与角色的关系：</p>\n<ul>\n<li>人可以有多个角色，类可以有多个接口</li>\n<li>人的某一个角色的确定是由环境决定的，类某一接口的确定是由上下文环境决定的</li>\n</ul>\n<p>接口设计应当遵循的原则：<strong>接口隔离原则（SIP）</strong></p>\n<p>接口应该是干净的，单一的，细粒度的，而不是混合过多的方法，职责单一</p>\n<h2 id=\"扩展式设计的一般过程：\"><a href=\"#扩展式设计的一般过程：\" class=\"headerlink\" title=\"扩展式设计的一般过程：\"></a>扩展式设计的一般过程：</h2><ol>\n<li>分离职责各司其职：关注点分离<ul>\n<li>向上分离：继承</li>\n<li>向外分离：组合</li>\n</ul>\n</li>\n<li>统一接口：<ul>\n<li>提炼接口，提供多态</li>\n<li>面向接口编程</li>\n</ul>\n</li>\n<li>引用接口预留空白<ul>\n<li>依赖注入</li>\n</ul>\n</li>\n</ol>\n<p>以一个事务为例子展示扩展式设计的一般过程：</p>\n<p>首先，有一个Service，在方法中业务逻辑与JDBC事务粘合在一起：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> DatabasePool dbPool;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribTrainings</span><span class=\"params\">(List&lt;Training&gt; trainings, </div><div class=\"line\">                                  Customer customer)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 初始化方法</span></div><div class=\"line\">      \tConnection c = <span class=\"keyword\">null</span>;</div><div class=\"line\">        PreparedStatement ps = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Statement s = <span class=\"keyword\">null</span>;</div><div class=\"line\">        ResultSet rs = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> transactionState = <span class=\"keyword\">false</span>;</div><div class=\"line\">      </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 开启事务 </span></div><div class=\"line\">            s = c.createStatement();</div><div class=\"line\">            transactionState = c.getAutoCommit();</div><div class=\"line\">            c.setAutoCommit(<span class=\"keyword\">false</span>);</div><div class=\"line\">          </div><div class=\"line\">          \t<span class=\"comment\">// 业务操作</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (Training training : trainings) &#123;</div><div class=\"line\">                addTrainingItem(customer, training);</div><div class=\"line\">            &#125;</div><div class=\"line\">            addOrder(customer, trainings);</div><div class=\"line\">            </div><div class=\"line\">          \t<span class=\"comment\">// 提交事务</span></div><div class=\"line\">          \tc.commit();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 回滚</span></div><div class=\"line\">            c.rollback();</div><div class=\"line\">          </div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 关闭操作</span></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                c.setAutoCommit(transactionState);</div><div class=\"line\">                dbPool.release(c);</div><div class=\"line\">                <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>) s.close();</div><div class=\"line\">                <span class=\"keyword\">if</span> (ps != <span class=\"keyword\">null</span>) ps.close();</div><div class=\"line\">                <span class=\"keyword\">if</span> (rs != <span class=\"keyword\">null</span>) rs.close();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException ignored) &#123;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addOrder</span><span class=\"params\">(Customer customer, List&lt;Training&gt; trainings)</span> </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addTrainingItem</span><span class=\"params\">(Customer customer, Training training)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一步在原始代码上分段并添加注释后代码如上所示。对每段代码提取方法，向上抽象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> DatabasePool dbPool;</div><div class=\"line\">    <span class=\"keyword\">private</span> Connection connection;</div><div class=\"line\">    <span class=\"keyword\">private</span> PreparedStatement preparedStatement;</div><div class=\"line\">    <span class=\"keyword\">private</span> Statement statement;</div><div class=\"line\">    <span class=\"keyword\">private</span> ResultSet resultSet;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> transactionState;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        setup();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            beginTransaction();</div><div class=\"line\">            <span class=\"comment\">// 留白一个具体的业务的实现:</span></div><div class=\"line\">            <span class=\"comment\">//      1. (模板方法)继承-&gt;钩子方法</span></div><div class=\"line\">            <span class=\"comment\">//      2. (委派)传递一个方法(方法接口)</span></div><div class=\"line\">            commitTransaction();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">            rollbackTransaction();</div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            teardown();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rollbackTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        connection.rollback();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        connection = <span class=\"keyword\">null</span>;</div><div class=\"line\">        preparedStatement = <span class=\"keyword\">null</span>;</div><div class=\"line\">        statement = <span class=\"keyword\">null</span>;</div><div class=\"line\">        resultSet = <span class=\"keyword\">null</span>;</div><div class=\"line\">        transactionState = <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">teardown</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            connection.setAutoCommit(transactionState);</div><div class=\"line\">            dbPool.release(connection);</div><div class=\"line\">            <span class=\"keyword\">if</span> (statement != <span class=\"keyword\">null</span>) statement.close();</div><div class=\"line\">            <span class=\"keyword\">if</span> (preparedStatement != <span class=\"keyword\">null</span>) preparedStatement.close();</div><div class=\"line\">            <span class=\"keyword\">if</span> (resultSet != <span class=\"keyword\">null</span>) resultSet.close();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException ignored) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">commitTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        connection.commit();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">beginTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        statement = connection.createStatement();</div><div class=\"line\">        transactionState = connection.getAutoCommit();</div><div class=\"line\">        connection.setAutoCommit(<span class=\"keyword\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Command</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在提炼出了一个本地事务的基本控制模板，实现了事务控制与业务逻辑控制基本分离。</p>\n<p>继续提炼事务控制类的接口，用于横向扩展继承使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command command)</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalTransactionScope</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">  \t<span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command action)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        setup();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            beginTransaction();</div><div class=\"line\">            action.execute();  <span class=\"comment\">// 具体的业务逻辑</span></div><div class=\"line\">            commitTransaction();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">            rollbackTransaction();</div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            teardown();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DistructedTransactionScope</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command command)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">      </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用方通过接口留白，实现依赖注入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> TransactionScope transactionScope;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTransactionScope</span><span class=\"params\">(TransactionScope transactionScope)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.transactionScope = transactionScope;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribTrainings</span><span class=\"params\">(List&lt;Training&gt; trainings, </div><div class=\"line\">                                  Customer customer)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        transactionScope.using(() -&gt; &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (Training training : trainings) &#123;</div><div class=\"line\">                    addTrainingItem(customer, training);</div><div class=\"line\">                &#125;</div><div class=\"line\">                addOrder(customer, trainings);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj06y6g9m0000yi2e6c2uobh6","category_id":"cj06y6ga70005yi2e5sndwti1","_id":"cj06y6gal000gyi2erehecam7"},{"post_id":"cj06y6g9v0002yi2ex87qqnaz","category_id":"cj06y6gah000cyi2e7ddw76d4","_id":"cj06y6gas000qyi2eks0szjyo"},{"post_id":"cj06y6ga80006yi2e0w5fypne","category_id":"cj06y6gao000kyi2e7e5zf5at","_id":"cj06y6gax000wyi2ehmjxwl2y"},{"post_id":"cj06y6gav000tyi2e5jkvruge","category_id":"cj06y6gao000kyi2e7e5zf5at","_id":"cj06y6gaz0010yi2eo86sn9w4"},{"post_id":"cj06y6gad0008yi2eturkgjbm","category_id":"cj06y6gao000kyi2e7e5zf5at","_id":"cj06y6gb10013yi2e2qilexop"},{"post_id":"cj06y6gag000byi2e2yo5laad","category_id":"cj06y6gay000yyi2eck9uztl8","_id":"cj06y6gb30017yi2esu2c913w"},{"post_id":"cj06y6gai000eyi2ehp61jf13","category_id":"cj06y6gao000kyi2e7e5zf5at","_id":"cj06y6gb8001dyi2ehi8qr0nv"},{"post_id":"cj06y6gal000hyi2e1ol42g31","category_id":"cj06y6gb30018yi2ei7t5tcua","_id":"cj06y6gbd001lyi2epggeu7s2"},{"post_id":"cj06y6gap000myi2e0v8x6u7f","category_id":"cj06y6gb30018yi2ei7t5tcua","_id":"cj06y6gbj001pyi2e3rryk4x2"},{"post_id":"cj06y6gar000pyi2errvix1fn","category_id":"cj06y6gbi001oyi2ero1o88qt","_id":"cj06y6gbk001uyi2euo4ncep7"},{"post_id":"cj06y6gaw000vyi2e10usfl2h","category_id":"cj06y6gbj001ryi2ep633y6d1","_id":"cj06y6gbl001xyi2eou00lx42"},{"post_id":"cj06y6gay000zyi2erf9jwcun","category_id":"cj06y6gbi001oyi2ero1o88qt","_id":"cj06y6gbl0020yi2eh9alo17e"},{"post_id":"cj06y6gaz0011yi2ewwk3b3vq","category_id":"cj06y6gbl001zyi2egnv9qbe3","_id":"cj06y6gbn0025yi2el62x0jm8"},{"post_id":"cj06y6gb10015yi2e3zz20qxs","category_id":"cj06y6gbj001ryi2ep633y6d1","_id":"cj06y6gbp002ayi2eleghsksa"},{"post_id":"cj06y6gb20016yi2ekq1yrcq7","category_id":"cj06y6gbl001zyi2egnv9qbe3","_id":"cj06y6gbr002eyi2e0nq4eoou"},{"post_id":"cj06y6gb4001ayi2ezqez57zs","category_id":"cj06y6gbj001ryi2ep633y6d1","_id":"cj06y6gbs002iyi2ee47gcdj4"},{"post_id":"cj06y6gb6001cyi2ecr33dnn5","category_id":"cj06y6gbj001ryi2ep633y6d1","_id":"cj06y6gbu002myi2e0dra52ep"},{"post_id":"cj06y6gb9001gyi2eq9ybqad3","category_id":"cj06y6gbj001ryi2ep633y6d1","_id":"cj06y6gbv002pyi2ex9rn53jn"},{"post_id":"cj06y6gbc001jyi2eq44pbl5t","category_id":"cj06y6gbj001ryi2ep633y6d1","_id":"cj06y6gbx002syi2erwf59w6s"},{"post_id":"cj06y6gbf001nyi2ewgirians","category_id":"cj06y6gbj001ryi2ep633y6d1","_id":"cj06y6gbz002vyi2e6myrkrqh"}],"PostTag":[{"post_id":"cj06y6g9m0000yi2e6c2uobh6","tag_id":"cj06y6ga00004yi2e8coqaotl","_id":"cj06y6gao000lyi2e4mprhp6g"},{"post_id":"cj06y6g9m0000yi2e6c2uobh6","tag_id":"cj06y6gaf000ayi2epgr5305d","_id":"cj06y6gar000oyi2esywyble3"},{"post_id":"cj06y6g9v0002yi2ex87qqnaz","tag_id":"cj06y6gan000iyi2erakvi60e","_id":"cj06y6gaw000uyi2eodphi8yr"},{"post_id":"cj06y6ga80006yi2e0w5fypne","tag_id":"cj06y6gan000iyi2erakvi60e","_id":"cj06y6gb5001byi2eo7fdhkmn"},{"post_id":"cj06y6ga80006yi2e0w5fypne","tag_id":"cj06y6gax000xyi2ekliak8x5","_id":"cj06y6gb8001eyi2eluie54qy"},{"post_id":"cj06y6ga80006yi2e0w5fypne","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gbb001iyi2exmaulu09"},{"post_id":"cj06y6gad0008yi2eturkgjbm","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gbd001kyi2emh5v0nol"},{"post_id":"cj06y6gag000byi2e2yo5laad","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gbj001syi2ej1oulbbq"},{"post_id":"cj06y6gag000byi2e2yo5laad","tag_id":"cj06y6gbe001myi2e0ul851da","_id":"cj06y6gbk001tyi2e0wqs13r5"},{"post_id":"cj06y6gai000eyi2ehp61jf13","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gbm0023yi2e1w9hefeb"},{"post_id":"cj06y6gai000eyi2ehp61jf13","tag_id":"cj06y6gbk001vyi2ec07zd2jd","_id":"cj06y6gbm0024yi2eb7g47st2"},{"post_id":"cj06y6gai000eyi2ehp61jf13","tag_id":"cj06y6gbl001yyi2eogmzxr4q","_id":"cj06y6gbp0028yi2enhy323i8"},{"post_id":"cj06y6gal000hyi2e1ol42g31","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gbp0029yi2es6erzb1o"},{"post_id":"cj06y6gap000myi2e0v8x6u7f","tag_id":"cj06y6gbl001yyi2eogmzxr4q","_id":"cj06y6gbq002dyi2ezch5dapf"},{"post_id":"cj06y6gar000pyi2errvix1fn","tag_id":"cj06y6gbp002byi2e4qxm3gb8","_id":"cj06y6gbs002hyi2eurho2wdz"},{"post_id":"cj06y6gav000tyi2e5jkvruge","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gbu002lyi2e9wwmx6li"},{"post_id":"cj06y6gaw000vyi2e10usfl2h","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gby002uyi2ey82tmras"},{"post_id":"cj06y6gaw000vyi2e10usfl2h","tag_id":"cj06y6gbu002oyi2emrsgqczz","_id":"cj06y6gbz002wyi2e8yt2qgv8"},{"post_id":"cj06y6gaw000vyi2e10usfl2h","tag_id":"cj06y6gbl001yyi2eogmzxr4q","_id":"cj06y6gc0002yyi2eubggi85i"},{"post_id":"cj06y6gay000zyi2erf9jwcun","tag_id":"cj06y6gbp002byi2e4qxm3gb8","_id":"cj06y6gc0002zyi2er51fshp8"},{"post_id":"cj06y6gb10015yi2e3zz20qxs","tag_id":"cj06y6gbu002oyi2emrsgqczz","_id":"cj06y6gc10032yi2e2jmtvyrf"},{"post_id":"cj06y6gb10015yi2e3zz20qxs","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gc10033yi2ei45naraf"},{"post_id":"cj06y6gb4001ayi2ezqez57zs","tag_id":"cj06y6gbu002oyi2emrsgqczz","_id":"cj06y6gc20035yi2ecu5ho9if"},{"post_id":"cj06y6gb4001ayi2ezqez57zs","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gc20036yi2eqjrw3zh5"},{"post_id":"cj06y6gb6001cyi2ecr33dnn5","tag_id":"cj06y6gbu002oyi2emrsgqczz","_id":"cj06y6gc20038yi2ekwyn8yp4"},{"post_id":"cj06y6gb6001cyi2ecr33dnn5","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gc20039yi2e8s91udhj"},{"post_id":"cj06y6gb9001gyi2eq9ybqad3","tag_id":"cj06y6gbu002oyi2emrsgqczz","_id":"cj06y6gc3003byi2e9jexecbu"},{"post_id":"cj06y6gbc001jyi2eq44pbl5t","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gc3003dyi2eyatzdaok"},{"post_id":"cj06y6gbc001jyi2eq44pbl5t","tag_id":"cj06y6gbu002oyi2emrsgqczz","_id":"cj06y6gc3003eyi2eyst6z6nw"},{"post_id":"cj06y6gbf001nyi2ewgirians","tag_id":"cj06y6gbu002oyi2emrsgqczz","_id":"cj06y6gc4003fyi2egb8n6jo8"},{"post_id":"cj06y6gbf001nyi2ewgirians","tag_id":"cj06y6gb10012yi2eehs5jsum","_id":"cj06y6gc4003gyi2em11nntxe"}],"Tag":[{"name":"HTML","_id":"cj06y6ga00004yi2e8coqaotl"},{"name":"CSS","_id":"cj06y6gaf000ayi2epgr5305d"},{"name":"daily","_id":"cj06y6gan000iyi2erakvi60e"},{"name":"JVM","_id":"cj06y6gax000xyi2ekliak8x5"},{"name":"Java","_id":"cj06y6gb10012yi2eehs5jsum"},{"name":"Spring","_id":"cj06y6gbe001myi2e0ul851da"},{"name":"读书笔记","_id":"cj06y6gbk001vyi2ec07zd2jd"},{"name":"Functional","_id":"cj06y6gbl001yyi2eogmzxr4q"},{"name":"翻译","_id":"cj06y6gbp002byi2e4qxm3gb8"},{"name":"设计模式","_id":"cj06y6gbu002oyi2emrsgqczz"}]}}