{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"00d09eae4324f411e01562979a81eb9702aa0a16","modified":1483770026000},{"_id":"source/favicon.ico","hash":"bc4575713d5905501315801cc9d52d8fc2b43178","modified":1483770026000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1478882347000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1469886538000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1469886538000},{"_id":"themes/next/.javascript_ignore","hash":"de73037693881ad2626e2962e8c5ab243f7b24d0","modified":1478882434000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1469886538000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1469886538000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1469886538000},{"_id":"themes/next/_config.yml","hash":"a4208229d828723c2bb2256286c6501d3e6e6157","modified":1504432774000},{"_id":"themes/next/bower.json","hash":"023b5b945bc45c205129a18e26d304fb9caa15c7","modified":1478882459000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1469886538000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1469886538000},{"_id":"source/_posts/Docker结构.md","hash":"f8e1afe4b86589462ba4edafb756531537095538","modified":1512742089000},{"_id":"source/_posts/HTTPS小记.md","hash":"50bee3ed10eb6f2ffc8f3909206a046e99a5e392","modified":1483770026000},{"_id":"source/_posts/HTML与CSS小记.md","hash":"e2748c4330ecf4d48997079afa7c1d44df9b8fe5","modified":1483770026000},{"_id":"source/_posts/IoC容器的简单实现.md","hash":"d5bfad4dafbcb8fd754b49094d0c8e80247ef225","modified":1483770026000},{"_id":"source/_posts/JDK中的Future模式.md","hash":"223b4a4a37013a637f74b119adffbe2b2fe4c06c","modified":1491313176000},{"_id":"source/_posts/JVM故障发现排除.md","hash":"42560bc89945cf814af3e27738997891797b09d8","modified":1512739893000},{"_id":"source/_posts/JDK并发包——线程池.md","hash":"c9513adb79fe0fdfcd0fa159428791f10ec7b40b","modified":1492341386000},{"_id":"source/_posts/JVM知识拾遗.md","hash":"33a34506b80f40ca9f0aba7a2f23a3fa58477597","modified":1512740283000},{"_id":"source/_posts/JDK并发包——同步控制工具.md","hash":"8c3741c93d807c4149e2210271651df0c5c87e5d","modified":1491745830000},{"_id":"source/_posts/Java内存区域.md","hash":"238363279ad71ab1c5e915cff957a485dc62bc3a","modified":1483770026000},{"_id":"source/_posts/SpringBoot包文件执行分析.md","hash":"dfbeb835d4274b0873ff2c1197fd9dc0a98d8d09","modified":1497972132000},{"_id":"source/_posts/Lambda表达式.md","hash":"dc93257f9a6d698fdb0acaee496a9bdb0bb62125","modified":1484505759000},{"_id":"source/_posts/Java线程基本操作.md","hash":"fc6362c0c046b69f37aa9978916e248aa696d620","modified":1500135838000},{"_id":"source/_posts/Spring之AOP【一】.md","hash":"0bfeae9b214456dc0f874553b3f591951a42c27d","modified":1489948893000},{"_id":"source/_posts/Spring之ApplicationContext.md","hash":"1de11dd95ae12b2b1a2be555c76816ed8053acf4","modified":1489928363000},{"_id":"source/_posts/Spring之BeanFactory.md","hash":"08e467387c8f9a9787a85cca6e2cc98f12949c4b","modified":1489339414000},{"_id":"source/_posts/Spring之AOP【二】.md","hash":"6a9b3c37a8220f802f90fbdb4132aba3d670c8d8","modified":1490381121000},{"_id":"source/_posts/Spring之数据访问.md","hash":"1e04517743b37d035f5e95d8343125ff5482f9e2","modified":1492331363000},{"_id":"source/_posts/Spring事件驱动模型与观察者模式.md","hash":"f22ada987fb4848926fbb7d56b28b9e924eb1703","modified":1502724383000},{"_id":"source/_posts/Spring事务行为.md","hash":"bf582a04244bbcc8dd04d8f6ea67ae2cb73cbdc1","modified":1512739082000},{"_id":"source/_posts/《Java并发编程实战》读书笔记.md","hash":"033e79c32e98cf613523f359cc33e8fc129ed15d","modified":1483770026000},{"_id":"source/_posts/ThreadLocal小记.md","hash":"1ca1eaa05099e1f116f08e289ca3a2b1722ca85d","modified":1483770026000},{"_id":"source/_posts/《函数式编程思维》读书笔记.md","hash":"b3d9ce43d94f8650f1418d501b92a81ae7eb827e","modified":1483770026000},{"_id":"source/_posts/【MQ】可靠消息.md","hash":"4b6842096ea07a0ccaa8103ccce559a8ba6c0080","modified":1512741444000},{"_id":"source/_posts/【MQ】初始MQ.md","hash":"0761e2edf1e2948be6265273300ca73d85ca8f48","modified":1512741305000},{"_id":"source/_posts/【MQ】使用扩展.md","hash":"6f44538fecc86731571d25a31e15e08a4a62c29d","modified":1512741646000},{"_id":"source/_posts/【SpringBoot】Servlet容器.md","hash":"10342b18da12e29ee31a769471b215da59083a48","modified":1504186042000},{"_id":"source/_posts/【SpringBoot】SpringApplication实例创建.md","hash":"70ea343eaf8f7667cf8f82c222947e22f26e9d3c","modified":1499261068000},{"_id":"source/_posts/【Netty】IO模型.md","hash":"8576b74f655fa7264c8a6cc82d207e860268e364","modified":1500222287000},{"_id":"source/_posts/【MQ】镜像队列.md","hash":"e4f3be6f85e9b0b7307ecfcd484cda2b47ffc1ce","modified":1512741584000},{"_id":"source/_posts/【SpringBoot】容器启动.md","hash":"f6f408bf4e26f368ac9fb5081fc8f3c6ec8ae352","modified":1500380831000},{"_id":"source/_posts/【SpringBoot】条件注解.md","hash":"69cb1620dabdc77897908e159cb58e857624494f","modified":1512740806000},{"_id":"source/_posts/【SpringBoot】监听器篇.md","hash":"e1713e676ba6fd73e99cc36b37f974f49e08c731","modified":1499261241000},{"_id":"source/_posts/【SpringBoot】配置加载.md","hash":"55de5496e998724294ea00dbb3dcece459889648","modified":1505744147000},{"_id":"source/_posts/【翻译】《OSGI官方指南》首页.md","hash":"51ecc7fa86c8844dad4e67c413eb69bda13bffd0","modified":1485309962000},{"_id":"source/_posts/【重拾网络】DNS.md","hash":"77af4848dbf91dec8696ea8c867cdcf70f76dc29","modified":1500559630000},{"_id":"source/_posts/【Spring】容器刷新.md","hash":"0db0a068e50f00fc74e45114bf3ba2ca0c519a60","modified":1500136373000},{"_id":"source/_posts/【重拾网络】基本概念.md","hash":"7a271d7b5b6caf858d13a3e691f5d27c82dc3bf5","modified":1500477986000},{"_id":"source/_posts/【翻译】SpringData官方文档第四章.md","hash":"7130cb79dca8b3541df56af570155a483854d0b2","modified":1483772285000},{"_id":"source/_posts/二零一六年度总结.md","hash":"95729fd27a2466cd96aab8f752c8e3175c0003a9","modified":1483777385000},{"_id":"source/_posts/【重拾网络】应用层.md","hash":"e2a3a0e53ae2313d8ce6d16c771b6f6880ae86ec","modified":1500559497000},{"_id":"source/_posts/使用CI发布Hexo.md","hash":"7acbee16e173bd249b8e36e5985f5093d7029a04","modified":1483778295000},{"_id":"source/_posts/使用Builder模式改进多参数方法.md","hash":"a138468db27bb32713add236e8ada17aeb10ffe4","modified":1483770026000},{"_id":"source/_posts/从ReentrantLock看AQS.md","hash":"5508a6c25c7d2a24359bea2121ea9327a82cfb12","modified":1496849840000},{"_id":"source/_posts/从依赖实现到依赖行为.md","hash":"444e860fc19361494cd70cd193cd283a6123cffb","modified":1483770026000},{"_id":"source/_posts/命令模式.md","hash":"95ef2e7e2beafa5f8f145ea0ae040772749808da","modified":1484505135000},{"_id":"source/_posts/容器生态系统.md","hash":"1a821841e73a174639b2b9b3fcedddbe5503a97f","modified":1512742011000},{"_id":"source/_posts/单例背后的技术细节.md","hash":"6363095ffcd85cec66d1d4ac584debc6a8ed3089","modified":1512740635000},{"_id":"source/_posts/对象回收与引用类型.md","hash":"7c3e9bf0fa7500d3686e9a17613b45d3694f85a9","modified":1490192361000},{"_id":"source/_posts/类加载器在Tomcat中的应用.md","hash":"91ce7a7df92f40df8172921a847cad5dbf6b28b1","modified":1489415849000},{"_id":"source/_posts/聊聊JDK动态代理.md","hash":"f0fc8d859e049710235aeea75addc6352edd52a1","modified":1494608417000},{"_id":"source/_posts/浅谈测试驱动开发.md","hash":"22558c4bfe8778c65617cda05545a99d62417930","modified":1486303990000},{"_id":"source/_posts/自下而上的开发实践.md","hash":"f1af2467bbccbb5202e9369a463deb2300434f70","modified":1483770026000},{"_id":"source/_posts/迪米特法则——合理的封装.md","hash":"dfcd4c4e9d9df2ea50690e849fc2519ed8b37ad5","modified":1483770026000},{"_id":"source/_posts/责任链模式.md","hash":"1619ccd8af2f055b753cc0ff2fd1db73fa2ecf0f","modified":1484505464000},{"_id":"source/categories/index-10.md","hash":"bc0d0aa68925cfadae4e1e871f9b481582543978","modified":1512741832000},{"_id":"source/categories/index-1.md","hash":"32c65ffdc4b2b07d95bf52ca7331e2dfa8b84a60","modified":1483770026000},{"_id":"source/categories/index-2.md","hash":"01c6269ba8f66017829598c89ce35b0fcf041249","modified":1483770026000},{"_id":"source/categories/index-4.md","hash":"720625e0db913d633e142a4fbccdf771f903d6b2","modified":1483770026000},{"_id":"source/categories/index-5.md","hash":"63608e6e32d05787de75c02ebb9ea793206cd7a1","modified":1483771847000},{"_id":"source/categories/index-6.md","hash":"7e2fa2be8c7b32d85525e20edaab980d6e96dd7a","modified":1483771970000},{"_id":"source/categories/index-3.md","hash":"9c2ea31bdcb30eb37c89cf66f3e6a6c2648f72bc","modified":1483770026000},{"_id":"source/categories/index-7.md","hash":"18a1a3ef2bccd90d386992230e7c4f0579ba8992","modified":1489339142000},{"_id":"source/categories/index-8.md","hash":"f094f5997f33180e49e0db5004de03bfd7a0e70d","modified":1512739744000},{"_id":"source/categories/index-9.md","hash":"a7886548bc4983646c5f55fa2460f32af0b2ba37","modified":1512741093000},{"_id":"source/categories/index.md","hash":"265279f98f069e929ce7a682d3d80f30df999a43","modified":1483770026000},{"_id":"source/tags/index-11.md","hash":"8c1b03c2a7570e37d04be9372da0fd9a9b69facd","modified":1512741888000},{"_id":"source/tags/index-1.md","hash":"15f2af37c1cdc21f3dcc572d8017099646cdd617","modified":1483770026000},{"_id":"source/tags/index-2.md","hash":"cf3e574ba065f16e24d019b51eade2060d3c1c62","modified":1483770026000},{"_id":"source/tags/index-10.md","hash":"97eb7682de5f0554d65a9122d9ec92af49107995","modified":1512741216000},{"_id":"source/tags/index-3.md","hash":"2bcb7dc8521f2e013f0cd2f49d3b0f52917fa96c","modified":1483770026000},{"_id":"source/tags/index-4.md","hash":"751f69598690223422467db912b81e623d805a88","modified":1483770026000},{"_id":"source/tags/index-6.md","hash":"e9ed82135629d97b29dc691c27b58330b1474966","modified":1483770026000},{"_id":"source/tags/index-5.md","hash":"da17106467a5adc108e9fad7e0f04160a557a185","modified":1483770026000},{"_id":"source/tags/index-8.md","hash":"05dc9b8155df1ff9d8ce4eed213c97d765de5f17","modified":1489339058000},{"_id":"source/tags/index-7.md","hash":"3ce31588fb1b0fdb924984004402858d10aaa005","modified":1483772174000},{"_id":"source/tags/index-9.md","hash":"27cdaaac99a8484f4327bbd35b93ef452e366430","modified":1491313075000},{"_id":"source/tags/index.md","hash":"7b78e54ef8023d86641b636f341196330582d695","modified":1483770026000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1469886538000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1469886538000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1469886538000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1469886538000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1469886538000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1469886538000},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1469886538000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1469886538000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1469886538000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1469886538000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1469886538000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1469886538000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1469886538000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1469886538000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1469886538000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1469886538000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1469886538000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1469886538000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1469886538000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1469886538000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1469886538000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1469886538000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1469886538000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1469886538000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1469886538000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1469886538000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1469886538000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1469886538000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1469886538000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1469886538000},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1469886538000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1469886538000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1469886538000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1469886538000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1469886538000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1469886538000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1469886538000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1469886538000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1469886538000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1469886538000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1469886538000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1469886538000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1469886538000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1469886538000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1469886538000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1469886538000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1469886538000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1469886538000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1469886538000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1469886538000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1469886538000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1469886538000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1469886538000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1469886538000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1469886538000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1469886538000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469886538000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1469886538000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1469886538000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1469886538000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1469886538000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1469886538000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1469886538000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1469886538000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1469886538000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1469886538000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1469886538000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1469886538000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1469886538000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1469886538000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1469886538000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1469886538000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1469886538000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1469886538000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1469886538000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1469886538000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1469886538000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1469886538000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1469886538000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1469886538000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1469886538000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1469886538000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1469886538000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1469886538000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1469886538000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1469886538000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1469886538000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1469886538000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1469886538000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1469886538000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1469886538000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1469886538000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1469886538000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1469886538000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1469886538000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1469886538000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1469886538000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1469886538000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1469886538000},{"_id":"themes/next/source/images/avatar.png","hash":"9b1c328be2868cd82320037820b2a1b89be37a37","modified":1469888010000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1469886538000}],"Category":[{"name":"其它","_id":"cjaxzl2oq0005d82elvechmhw"},{"name":"容器","_id":"cjaxzl2p0000cd82egqwo8hmp"},{"name":"前端","_id":"cjaxzl2p7000ld82e7826zupe"},{"name":"Java","_id":"cjaxzl2pg000sd82e6us0l4m6"},{"name":"JVM","_id":"cjaxzl2pr0018d82e1kgv9z3j"},{"name":"Spring","_id":"cjaxzl2qd001zd82eqiicv14y"},{"name":"读书笔记","_id":"cjaxzl2rk003kd82en6z4y726"},{"name":"MQ","_id":"cjaxzl2ru0040d82eei99mcqs"},{"name":"Netty","_id":"cjaxzl2sk004nd82e0b0vkops"},{"name":"翻译","_id":"cjaxzl2sx0056d82eq1u7990u"},{"name":"网络","_id":"cjaxzl2t4005ed82e3adqayw0"},{"name":"随笔","_id":"cjaxzl2t8005pd82eb6ld9afp"},{"name":"设计模式","_id":"cjaxzl2tb0064d82epyvzmnp8"}],"Data":[],"Page":[{"title":"容器","date":"2017-12-08T14:02:57.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-10.md","raw":"---\ntitle: 容器\ndate: 2017-12-08 22:02:57\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-12-08T14:03:52.000Z","path":"categories/index-10.html","layout":"page","_id":"cjaxzl2oe0001d82ebssehcvz","content":"","excerpt":"","more":""},{"title":"前端","date":"2016-07-31T10:50:48.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-1.md","raw":"---\ntitle: 前端\ndate: 2016-07-31 18:50:48\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"categories/index-1.html","layout":"page","_id":"cjaxzl2ok0003d82ejxameq1r","content":"","excerpt":"","more":""},{"title":"读书笔记","date":"2016-08-27T14:15:37.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-2.md","raw":"---\ntitle: 读书笔记\ndate: 2016-08-27 22:15:37\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"categories/index-2.html","layout":"page","_id":"cjaxzl2ot0007d82e6i4zb2br","content":"","excerpt":"","more":""},{"title":"其它","date":"2016-10-24T16:01:14.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-4.md","raw":"---\ntitle: 其它\ndate: 2016-10-25 00:01:14\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"categories/index-4.html","layout":"page","_id":"cjaxzl2ox0009d82eggwf8a6b","content":"","excerpt":"","more":""},{"title":"翻译","date":"2017-01-07T06:49:10.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-5.md","raw":"---\ntitle: 翻译\ndate: 2017-01-07 14:49:10\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:50:47.000Z","path":"categories/index-5.html","layout":"page","_id":"cjaxzl2p0000dd82e7s39dh0b","content":"","excerpt":"","more":""},{"title":"随笔","date":"2017-01-07T06:51:27.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-6.md","raw":"---\ntitle: 随笔\ndate: 2017-01-07 14:51:27\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:52:50.000Z","path":"categories/index-6.html","layout":"page","_id":"cjaxzl2p3000gd82e2ggc9bfn","content":"","excerpt":"","more":""},{"title":"设计模式","date":"2016-10-22T11:06:15.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-3.md","raw":"---\ntitle: 设计模式\ndate: 2016-10-22 19:06:15\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"categories/index-3.html","layout":"page","_id":"cjaxzl2p6000kd82eqjvdw4ye","content":"","excerpt":"","more":""},{"title":"Spring","date":"2017-03-12T17:17:54.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-7.md","raw":"---\ntitle: Spring\ndate: 2017-03-13 01:17:54\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-03-12T17:19:02.000Z","path":"categories/index-7.html","layout":"page","_id":"cjaxzl2pb000nd82e8i6jrnf8","content":"","excerpt":"","more":""},{"title":"JVM","date":"2017-12-08T13:25:54.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-8.md","raw":"---\ntitle: JVM\ndate: 2017-12-08 21:25:54\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-12-08T13:29:04.000Z","path":"categories/index-8.html","layout":"page","_id":"cjaxzl2pf000qd82eaes6bixk","content":"","excerpt":"","more":""},{"title":"MQ","date":"2017-12-08T13:49:26.000Z","type":"categories","comments":0,"_content":"","source":"categories/index-9.md","raw":"---\ntitle: MQ\ndate: 2017-12-08 21:49:26\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-12-08T13:51:33.000Z","path":"categories/index-9.html","layout":"page","_id":"cjaxzl2pj000vd82eqpl7cdvz","content":"","excerpt":"","more":""},{"title":"Java","date":"2016-07-30T14:47:23.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: Java\ndate: 2016-07-30 22:47:23\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"categories/index.html","layout":"page","_id":"cjaxzl2pl000yd82e847w2eaj","content":"","excerpt":"","more":""},{"title":"容器","date":"2017-12-08T14:04:07.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-11.md","raw":"---\ntitle: 容器\ndate: 2017-12-08 22:04:07\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-12-08T14:04:48.000Z","path":"tags/index-11.html","layout":"page","_id":"cjaxzl2yx008ad82eg5k20487","content":"","excerpt":"","more":""},{"title":"HTML","date":"2016-07-31T11:10:04.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-1.md","raw":"---\ntitle: HTML\ndate: 2016-07-31 19:10:04\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-1.html","layout":"page","_id":"cjaxzl2yy008bd82egpiny9oe","content":"","excerpt":"","more":""},{"title":"CSS","date":"2016-07-31T11:18:55.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-2.md","raw":"---\ntitle: CSS\ndate: 2016-07-31 19:18:55\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-2.html","layout":"page","_id":"cjaxzl2z0008cd82ek7gz5zzq","content":"","excerpt":"","more":""},{"title":"MQ","date":"2017-12-08T13:52:45.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-10.md","raw":"---\ntitle: MQ\ndate: 2017-12-08 21:52:45\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-12-08T13:53:36.000Z","path":"tags/index-10.html","layout":"page","_id":"cjaxzl2z1008dd82e9aqm627o","content":"","excerpt":"","more":""},{"title":"JVM","date":"2016-08-14T15:09:22.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-3.md","raw":"---\ntitle: JVM\ndate: 2016-08-14 23:09:22\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-3.html","layout":"page","_id":"cjaxzl2z2008ed82eizd6byhy","content":"","excerpt":"","more":""},{"title":"Java","date":"2016-08-14T15:14:08.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-4.md","raw":"---\ntitle: Java\ndate: 2016-08-14 23:14:08\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-4.html","layout":"page","_id":"cjaxzl2z2008fd82e5teisg0n","content":"","excerpt":"","more":""},{"title":"设计模式","date":"2016-10-22T11:12:06.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-6.md","raw":"---\ntitle: 设计模式\ndate: 2016-10-22 19:12:06\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-6.html","layout":"page","_id":"cjaxzl2z3008gd82ej03hqebw","content":"","excerpt":"","more":""},{"title":"Functional","date":"2016-08-27T14:01:31.000Z","_content":"","source":"tags/index-5.md","raw":"---\ntitle: Functional\ndate: 2016-08-27 22:01:31\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index-5.html","comments":1,"layout":"page","_id":"cjaxzl2z3008hd82e5pz822zz","content":"","excerpt":"","more":""},{"title":"Spring","date":"2017-03-12T17:16:16.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-8.md","raw":"---\ntitle: Spring\ndate: 2017-03-13 01:16:16\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-03-12T17:17:38.000Z","path":"tags/index-8.html","layout":"page","_id":"cjaxzl2z4008id82e1fx8ypqe","content":"","excerpt":"","more":""},{"title":"翻译","date":"2017-01-07T06:55:01.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-7.md","raw":"---\ntitle: 翻译\ndate: 2017-01-07 14:55:01\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:56:14.000Z","path":"tags/index-7.html","layout":"page","_id":"cjaxzl2z4008jd82e8etvelk5","content":"","excerpt":"","more":""},{"title":"并发","date":"2017-04-04T13:36:27.000Z","type":"tags","comments":0,"_content":"","source":"tags/index-9.md","raw":"---\ntitle: 并发\ndate: 2017-04-04 21:36:27\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-04-04T13:37:55.000Z","path":"tags/index-9.html","layout":"page","_id":"cjaxzl2z5008kd82e8dwkvut9","content":"","excerpt":"","more":""},{"title":"daily","date":"2016-07-30T14:27:10.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: daily\ndate: 2016-07-30 22:27:10\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-07T06:20:26.000Z","path":"tags/index.html","layout":"page","_id":"cjaxzl2z5008ld82exy1o5i0m","content":"","excerpt":"","more":""}],"Post":[{"title":"HTTPS小记","date":"2016-10-24T15:58:06.000Z","_content":"\n## 背景\n\n最近好像跟HTTPS较上劲了，前几天的职级答辩问到了相关问题，最近维护的系统升级也碰到相关问题。\n\n自己对HTTPS了解的并不多，今天简单了解了一下，在此做个记录。\n\n首先有几个基本概念，TCP/IP协议，HTTP一些，对称/非对称加密，证书，公钥/私钥。\n\nTCP/TP：\n\n- 传输层协议，主要解决数据如何在网络中传输\n\nHTTP：\n\n- 应用层协议，主要解决如何包装数据，依赖TCP/IP协议\n\n对称加密：\n\n- 加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来\n\n非对称加密：\n\n- 加密和解密过程使用了不同的密钥。分为公钥和私钥，它们可以互相解密。\n- 公钥加密，私钥解密\n- 私钥数字签名，公钥验证\n\n证书：\n\n- 我理解主要是两个作用：验证证书持有者身份、提供证书持有者公钥\n\n## 为什么用HTTPS\n\n因为HTTP不安全。\n\n1. HTTP使用的是明文传输，容易被窃取\n2. 无法验证报文完整性，可能被篡改\n3. 无法验证通信双方的身份\n\n为了对HTTP提供安全保障，就依赖：\n\n### SSL与TLS\n\nSSL（Secure Socket Layer，安全套接字层）\n\nTLS（Transport Layer Security，传输层安全协议）\n\nTLS可以理解为SSL的增强版。\n\nHTTP直接与TCP通信，而在HTTPS中首先与SSL通信，SSL再与TCP通信。我觉得可以理解成HTTPS = HTTP + SSL。\n\n不论HTTP还是HTTPS，所有的通信、加解密都是最终都是建立在TCP/IP之上的。\n\n## 加密思路\n\n1. 客户端向服务器端索要并验证公钥；\n2. 双方协商生成\"对话密钥\"；\n3. 双方采用\"对话密钥\"进行加密通信；\n\n在通信过程中其实双方使用的还是对称的加密算法，但是为了让这个对称的加密算法足够安全。首先使用非对称的算法来获取对话密钥，之后再用对话密钥来对通信的内容加密解密。\n\n所以关键问题就变成了：\n\n## 对话密钥的创建\n\n我没有仔细阅读相关协议，在网上查了一些资料，下面的内容是根据自己的理解写的。\n\n简单描述一次对话密钥的获取过程：\n\n> C：我想跟服务器A说悄悄话，我支持1,2,3版本的协议。我先跟你说个秘密X。\n>\n> S：我是服务器A。我们用3版本的协议说话吧，我也给你说个秘密Y。我再给你个公钥，使用它加密后的信息就只有我能听懂了。\n>\n> C：让我先看看你是不是服务器A。（确认是服务器A）那我再给你说个秘密Z，这次用你给我的公钥对Z加密，确保其他人都不知道。以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要跟你确认的就这些。\n>\n> S：好的，以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要确认的也就这些内容。网上把上面四个步骤描述\n\n网上把上述的四个步骤描述为：\n\n- 客户端发出请求\n  - 支持的协议版本，比如TLS 1.0版\n  - 一个随机数\n  - 支持的加密方法，比如RSA公钥加密\n  - 支持的压缩方法\n- 服务器回应\n  - 协议的版本\n  - 加密的算法\n  - 生成随机数\n  - 服务器证书\n- 客户端回应\n  - 对服务器下发的证书进行验证\n  - 再次产生一个随机数（第三个随机数）\n  - 使用服务器证书中的公钥进行加密\n  - 发送编码改变的消息\n  - 发送整个前面所有消息的hash值\n  - 根据三个随机数生成对话密钥\n- 服务器最终回应\n  - 使用私钥解密接收到第三个随机数\n  - 验证数据完整性\n  - 使用跟客户端同样的方式生成对话密钥\n  - 告知客户端已经切换到协商过的加密套件状态\n  - 服务端发送消息验证加解密是否成功\n\n如果服务器需要对客户端的身份进行认证，那么在第一次服务器回应中可以向客户端索取证书。客户端提供证书后，服务器通过验证客户端证书，从而验证客户端的身份。\n","source":"_posts/HTTPS小记.md","raw":"---\ntitle: HTTPS小记\ndate: 2016-10-24 23:58:06\ntags: daily\ncategories: 其它\n---\n\n## 背景\n\n最近好像跟HTTPS较上劲了，前几天的职级答辩问到了相关问题，最近维护的系统升级也碰到相关问题。\n\n自己对HTTPS了解的并不多，今天简单了解了一下，在此做个记录。\n\n首先有几个基本概念，TCP/IP协议，HTTP一些，对称/非对称加密，证书，公钥/私钥。\n\nTCP/TP：\n\n- 传输层协议，主要解决数据如何在网络中传输\n\nHTTP：\n\n- 应用层协议，主要解决如何包装数据，依赖TCP/IP协议\n\n对称加密：\n\n- 加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来\n\n非对称加密：\n\n- 加密和解密过程使用了不同的密钥。分为公钥和私钥，它们可以互相解密。\n- 公钥加密，私钥解密\n- 私钥数字签名，公钥验证\n\n证书：\n\n- 我理解主要是两个作用：验证证书持有者身份、提供证书持有者公钥\n\n## 为什么用HTTPS\n\n因为HTTP不安全。\n\n1. HTTP使用的是明文传输，容易被窃取\n2. 无法验证报文完整性，可能被篡改\n3. 无法验证通信双方的身份\n\n为了对HTTP提供安全保障，就依赖：\n\n### SSL与TLS\n\nSSL（Secure Socket Layer，安全套接字层）\n\nTLS（Transport Layer Security，传输层安全协议）\n\nTLS可以理解为SSL的增强版。\n\nHTTP直接与TCP通信，而在HTTPS中首先与SSL通信，SSL再与TCP通信。我觉得可以理解成HTTPS = HTTP + SSL。\n\n不论HTTP还是HTTPS，所有的通信、加解密都是最终都是建立在TCP/IP之上的。\n\n## 加密思路\n\n1. 客户端向服务器端索要并验证公钥；\n2. 双方协商生成\"对话密钥\"；\n3. 双方采用\"对话密钥\"进行加密通信；\n\n在通信过程中其实双方使用的还是对称的加密算法，但是为了让这个对称的加密算法足够安全。首先使用非对称的算法来获取对话密钥，之后再用对话密钥来对通信的内容加密解密。\n\n所以关键问题就变成了：\n\n## 对话密钥的创建\n\n我没有仔细阅读相关协议，在网上查了一些资料，下面的内容是根据自己的理解写的。\n\n简单描述一次对话密钥的获取过程：\n\n> C：我想跟服务器A说悄悄话，我支持1,2,3版本的协议。我先跟你说个秘密X。\n>\n> S：我是服务器A。我们用3版本的协议说话吧，我也给你说个秘密Y。我再给你个公钥，使用它加密后的信息就只有我能听懂了。\n>\n> C：让我先看看你是不是服务器A。（确认是服务器A）那我再给你说个秘密Z，这次用你给我的公钥对Z加密，确保其他人都不知道。以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要跟你确认的就这些。\n>\n> S：好的，以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要确认的也就这些内容。网上把上面四个步骤描述\n\n网上把上述的四个步骤描述为：\n\n- 客户端发出请求\n  - 支持的协议版本，比如TLS 1.0版\n  - 一个随机数\n  - 支持的加密方法，比如RSA公钥加密\n  - 支持的压缩方法\n- 服务器回应\n  - 协议的版本\n  - 加密的算法\n  - 生成随机数\n  - 服务器证书\n- 客户端回应\n  - 对服务器下发的证书进行验证\n  - 再次产生一个随机数（第三个随机数）\n  - 使用服务器证书中的公钥进行加密\n  - 发送编码改变的消息\n  - 发送整个前面所有消息的hash值\n  - 根据三个随机数生成对话密钥\n- 服务器最终回应\n  - 使用私钥解密接收到第三个随机数\n  - 验证数据完整性\n  - 使用跟客户端同样的方式生成对话密钥\n  - 告知客户端已经切换到协商过的加密套件状态\n  - 服务端发送消息验证加解密是否成功\n\n如果服务器需要对客户端的身份进行认证，那么在第一次服务器回应中可以向客户端索取证书。客户端提供证书后，服务器通过验证客户端证书，从而验证客户端的身份。\n","slug":"HTTPS小记","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2o90000d82eucrbnpf5","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近好像跟HTTPS较上劲了，前几天的职级答辩问到了相关问题，最近维护的系统升级也碰到相关问题。</p>\n<p>自己对HTTPS了解的并不多，今天简单了解了一下，在此做个记录。</p>\n<p>首先有几个基本概念，TCP/IP协议，HTTP一些，对称/非对称加密，证书，公钥/私钥。</p>\n<p>TCP/TP：</p>\n<ul>\n<li>传输层协议，主要解决数据如何在网络中传输</li>\n</ul>\n<p>HTTP：</p>\n<ul>\n<li>应用层协议，主要解决如何包装数据，依赖TCP/IP协议</li>\n</ul>\n<p>对称加密：</p>\n<ul>\n<li>加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来</li>\n</ul>\n<p>非对称加密：</p>\n<ul>\n<li>加密和解密过程使用了不同的密钥。分为公钥和私钥，它们可以互相解密。</li>\n<li>公钥加密，私钥解密</li>\n<li>私钥数字签名，公钥验证</li>\n</ul>\n<p>证书：</p>\n<ul>\n<li>我理解主要是两个作用：验证证书持有者身份、提供证书持有者公钥</li>\n</ul>\n<h2 id=\"为什么用HTTPS\"><a href=\"#为什么用HTTPS\" class=\"headerlink\" title=\"为什么用HTTPS\"></a>为什么用HTTPS</h2><p>因为HTTP不安全。</p>\n<ol>\n<li>HTTP使用的是明文传输，容易被窃取</li>\n<li>无法验证报文完整性，可能被篡改</li>\n<li>无法验证通信双方的身份</li>\n</ol>\n<p>为了对HTTP提供安全保障，就依赖：</p>\n<h3 id=\"SSL与TLS\"><a href=\"#SSL与TLS\" class=\"headerlink\" title=\"SSL与TLS\"></a>SSL与TLS</h3><p>SSL（Secure Socket Layer，安全套接字层）</p>\n<p>TLS（Transport Layer Security，传输层安全协议）</p>\n<p>TLS可以理解为SSL的增强版。</p>\n<p>HTTP直接与TCP通信，而在HTTPS中首先与SSL通信，SSL再与TCP通信。我觉得可以理解成HTTPS = HTTP + SSL。</p>\n<p>不论HTTP还是HTTPS，所有的通信、加解密都是最终都是建立在TCP/IP之上的。</p>\n<h2 id=\"加密思路\"><a href=\"#加密思路\" class=\"headerlink\" title=\"加密思路\"></a>加密思路</h2><ol>\n<li>客户端向服务器端索要并验证公钥；</li>\n<li>双方协商生成”对话密钥”；</li>\n<li>双方采用”对话密钥”进行加密通信；</li>\n</ol>\n<p>在通信过程中其实双方使用的还是对称的加密算法，但是为了让这个对称的加密算法足够安全。首先使用非对称的算法来获取对话密钥，之后再用对话密钥来对通信的内容加密解密。</p>\n<p>所以关键问题就变成了：</p>\n<h2 id=\"对话密钥的创建\"><a href=\"#对话密钥的创建\" class=\"headerlink\" title=\"对话密钥的创建\"></a>对话密钥的创建</h2><p>我没有仔细阅读相关协议，在网上查了一些资料，下面的内容是根据自己的理解写的。</p>\n<p>简单描述一次对话密钥的获取过程：</p>\n<blockquote>\n<p>C：我想跟服务器A说悄悄话，我支持1,2,3版本的协议。我先跟你说个秘密X。</p>\n<p>S：我是服务器A。我们用3版本的协议说话吧，我也给你说个秘密Y。我再给你个公钥，使用它加密后的信息就只有我能听懂了。</p>\n<p>C：让我先看看你是不是服务器A。（确认是服务器A）那我再给你说个秘密Z，这次用你给我的公钥对Z加密，确保其他人都不知道。以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要跟你确认的就这些。</p>\n<p>S：好的，以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要确认的也就这些内容。网上把上面四个步骤描述</p>\n</blockquote>\n<p>网上把上述的四个步骤描述为：</p>\n<ul>\n<li>客户端发出请求<ul>\n<li>支持的协议版本，比如TLS 1.0版</li>\n<li>一个随机数</li>\n<li>支持的加密方法，比如RSA公钥加密</li>\n<li>支持的压缩方法</li>\n</ul>\n</li>\n<li>服务器回应<ul>\n<li>协议的版本</li>\n<li>加密的算法</li>\n<li>生成随机数</li>\n<li>服务器证书</li>\n</ul>\n</li>\n<li>客户端回应<ul>\n<li>对服务器下发的证书进行验证</li>\n<li>再次产生一个随机数（第三个随机数）</li>\n<li>使用服务器证书中的公钥进行加密</li>\n<li>发送编码改变的消息</li>\n<li>发送整个前面所有消息的hash值</li>\n<li>根据三个随机数生成对话密钥</li>\n</ul>\n</li>\n<li>服务器最终回应<ul>\n<li>使用私钥解密接收到第三个随机数</li>\n<li>验证数据完整性</li>\n<li>使用跟客户端同样的方式生成对话密钥</li>\n<li>告知客户端已经切换到协商过的加密套件状态</li>\n<li>服务端发送消息验证加解密是否成功</li>\n</ul>\n</li>\n</ul>\n<p>如果服务器需要对客户端的身份进行认证，那么在第一次服务器回应中可以向客户端索取证书。客户端提供证书后，服务器通过验证客户端证书，从而验证客户端的身份。</p>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近好像跟HTTPS较上劲了，前几天的职级答辩问到了相关问题，最近维护的系统升级也碰到相关问题。</p>\n<p>自己对HTTPS了解的并不多，今天简单了解了一下，在此做个记录。</p>\n<p>首先有几个基本概念，TCP/IP协议，HTTP一些，对称/非对称加密，证书，公钥/私钥。</p>\n<p>TCP/TP：</p>\n<ul>\n<li>传输层协议，主要解决数据如何在网络中传输</li>\n</ul>\n<p>HTTP：</p>\n<ul>\n<li>应用层协议，主要解决如何包装数据，依赖TCP/IP协议</li>\n</ul>\n<p>对称加密：</p>\n<ul>\n<li>加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来</li>\n</ul>\n<p>非对称加密：</p>\n<ul>\n<li>加密和解密过程使用了不同的密钥。分为公钥和私钥，它们可以互相解密。</li>\n<li>公钥加密，私钥解密</li>\n<li>私钥数字签名，公钥验证</li>\n</ul>\n<p>证书：</p>\n<ul>\n<li>我理解主要是两个作用：验证证书持有者身份、提供证书持有者公钥</li>\n</ul>\n<h2 id=\"为什么用HTTPS\"><a href=\"#为什么用HTTPS\" class=\"headerlink\" title=\"为什么用HTTPS\"></a>为什么用HTTPS</h2><p>因为HTTP不安全。</p>\n<ol>\n<li>HTTP使用的是明文传输，容易被窃取</li>\n<li>无法验证报文完整性，可能被篡改</li>\n<li>无法验证通信双方的身份</li>\n</ol>\n<p>为了对HTTP提供安全保障，就依赖：</p>\n<h3 id=\"SSL与TLS\"><a href=\"#SSL与TLS\" class=\"headerlink\" title=\"SSL与TLS\"></a>SSL与TLS</h3><p>SSL（Secure Socket Layer，安全套接字层）</p>\n<p>TLS（Transport Layer Security，传输层安全协议）</p>\n<p>TLS可以理解为SSL的增强版。</p>\n<p>HTTP直接与TCP通信，而在HTTPS中首先与SSL通信，SSL再与TCP通信。我觉得可以理解成HTTPS = HTTP + SSL。</p>\n<p>不论HTTP还是HTTPS，所有的通信、加解密都是最终都是建立在TCP/IP之上的。</p>\n<h2 id=\"加密思路\"><a href=\"#加密思路\" class=\"headerlink\" title=\"加密思路\"></a>加密思路</h2><ol>\n<li>客户端向服务器端索要并验证公钥；</li>\n<li>双方协商生成”对话密钥”；</li>\n<li>双方采用”对话密钥”进行加密通信；</li>\n</ol>\n<p>在通信过程中其实双方使用的还是对称的加密算法，但是为了让这个对称的加密算法足够安全。首先使用非对称的算法来获取对话密钥，之后再用对话密钥来对通信的内容加密解密。</p>\n<p>所以关键问题就变成了：</p>\n<h2 id=\"对话密钥的创建\"><a href=\"#对话密钥的创建\" class=\"headerlink\" title=\"对话密钥的创建\"></a>对话密钥的创建</h2><p>我没有仔细阅读相关协议，在网上查了一些资料，下面的内容是根据自己的理解写的。</p>\n<p>简单描述一次对话密钥的获取过程：</p>\n<blockquote>\n<p>C：我想跟服务器A说悄悄话，我支持1,2,3版本的协议。我先跟你说个秘密X。</p>\n<p>S：我是服务器A。我们用3版本的协议说话吧，我也给你说个秘密Y。我再给你个公钥，使用它加密后的信息就只有我能听懂了。</p>\n<p>C：让我先看看你是不是服务器A。（确认是服务器A）那我再给你说个秘密Z，这次用你给我的公钥对Z加密，确保其他人都不知道。以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要跟你确认的就这些。</p>\n<p>S：好的，以后我们用X,Y,Z这三个秘密来验证彼此的消息。我要确认的也就这些内容。网上把上面四个步骤描述</p>\n</blockquote>\n<p>网上把上述的四个步骤描述为：</p>\n<ul>\n<li>客户端发出请求<ul>\n<li>支持的协议版本，比如TLS 1.0版</li>\n<li>一个随机数</li>\n<li>支持的加密方法，比如RSA公钥加密</li>\n<li>支持的压缩方法</li>\n</ul>\n</li>\n<li>服务器回应<ul>\n<li>协议的版本</li>\n<li>加密的算法</li>\n<li>生成随机数</li>\n<li>服务器证书</li>\n</ul>\n</li>\n<li>客户端回应<ul>\n<li>对服务器下发的证书进行验证</li>\n<li>再次产生一个随机数（第三个随机数）</li>\n<li>使用服务器证书中的公钥进行加密</li>\n<li>发送编码改变的消息</li>\n<li>发送整个前面所有消息的hash值</li>\n<li>根据三个随机数生成对话密钥</li>\n</ul>\n</li>\n<li>服务器最终回应<ul>\n<li>使用私钥解密接收到第三个随机数</li>\n<li>验证数据完整性</li>\n<li>使用跟客户端同样的方式生成对话密钥</li>\n<li>告知客户端已经切换到协商过的加密套件状态</li>\n<li>服务端发送消息验证加解密是否成功</li>\n</ul>\n</li>\n</ul>\n<p>如果服务器需要对客户端的身份进行认证，那么在第一次服务器回应中可以向客户端索取证书。客户端提供证书后，服务器通过验证客户端证书，从而验证客户端的身份。</p>\n"},{"title":"Docker结构","date":"2017-12-08T14:07:19.000Z","tagsi":"容器","_content":"\n## 容器介绍\n\n### 容器与虚拟机\n\n- 容器：应用程序；依赖\n- 虚拟机：应用程序；依赖；操作系统\n\n![docker_vm.jpg](https://ooo.0o0.ooo/2017/06/21/594a1480eb090.jpg)\n\n### 容器解决的问题\n\n简化打包、部署，使应用具备了超强的可移植能力\n\n对于现在多服务的应用往往依赖多个组件（例如：MQ,DB,Cache等），整个开发周期又需要部署多个环境（开发，测试，正式等），这就为运维带来极大的不便：\n\n![c3786681cc644e6d8a6204cdffc49aa3_th.jpeg](https://ooo.0o0.ooo/2017/06/21/594a17934f0dd.jpeg)\n\n上面的图有两个变量：\n\n1. 应用组件\n2. 服务器环境\n\n容器能做的就是就是为应用组件提供一个基于容器的标准化环境，让容器可以运行在几乎所有操作系统上\n\n![54e8e6a8d2ec4b2d8acba239d323dfb9_th.jpeg](https://ooo.0o0.ooo/2017/06/21/594a19569b110.jpeg)\n\n好处：\n\n- 隔离：容器环境与宿主环境隔离\n- 重用：同一个组件只需要创建一次运行环境就可以在其他机器上运行\n- 一致：只需要配置好标准的 runtime 环境，服务器就可以运行任何容器\n\n## Docker组成\n\n核心组件：\n\n1. Docker 客户端 - Client\n2. Docker 服务器 - Docker daemon\n3. Docker 镜像 - Image\n4. Registry\n5. Docker 容器 - Container\n\n![docker_architecture.jpg](https://ooo.0o0.ooo/2017/06/21/594a29f4c365c.jpg)\n\n## Docker启动过程\n\n上篇文章最后提到了Docker的安装并运行了httpd：`sudo docker run -d -p 80:80 httpd`\n\n结合Docker的组成，说明一下在容器启动过程这些组件是怎么协作的：\n\n1. docker client调用docker daemon请求启动一个容器\n2. docker daemon会向host请求创建容器\n3. host创建一个空的容器\n4. docker daemon检查本机docker镜像文件（如果没有，则到Registry下载）\n5. 将镜像文件加载到容器中\n","source":"_posts/Docker结构.md","raw":"---\ntitle: Docker结构\ndate: 2017-12-08 22:07:19\ntagsi: 容器\ncategories: 容器\n---\n\n## 容器介绍\n\n### 容器与虚拟机\n\n- 容器：应用程序；依赖\n- 虚拟机：应用程序；依赖；操作系统\n\n![docker_vm.jpg](https://ooo.0o0.ooo/2017/06/21/594a1480eb090.jpg)\n\n### 容器解决的问题\n\n简化打包、部署，使应用具备了超强的可移植能力\n\n对于现在多服务的应用往往依赖多个组件（例如：MQ,DB,Cache等），整个开发周期又需要部署多个环境（开发，测试，正式等），这就为运维带来极大的不便：\n\n![c3786681cc644e6d8a6204cdffc49aa3_th.jpeg](https://ooo.0o0.ooo/2017/06/21/594a17934f0dd.jpeg)\n\n上面的图有两个变量：\n\n1. 应用组件\n2. 服务器环境\n\n容器能做的就是就是为应用组件提供一个基于容器的标准化环境，让容器可以运行在几乎所有操作系统上\n\n![54e8e6a8d2ec4b2d8acba239d323dfb9_th.jpeg](https://ooo.0o0.ooo/2017/06/21/594a19569b110.jpeg)\n\n好处：\n\n- 隔离：容器环境与宿主环境隔离\n- 重用：同一个组件只需要创建一次运行环境就可以在其他机器上运行\n- 一致：只需要配置好标准的 runtime 环境，服务器就可以运行任何容器\n\n## Docker组成\n\n核心组件：\n\n1. Docker 客户端 - Client\n2. Docker 服务器 - Docker daemon\n3. Docker 镜像 - Image\n4. Registry\n5. Docker 容器 - Container\n\n![docker_architecture.jpg](https://ooo.0o0.ooo/2017/06/21/594a29f4c365c.jpg)\n\n## Docker启动过程\n\n上篇文章最后提到了Docker的安装并运行了httpd：`sudo docker run -d -p 80:80 httpd`\n\n结合Docker的组成，说明一下在容器启动过程这些组件是怎么协作的：\n\n1. docker client调用docker daemon请求启动一个容器\n2. docker daemon会向host请求创建容器\n3. host创建一个空的容器\n4. docker daemon检查本机docker镜像文件（如果没有，则到Registry下载）\n5. 将镜像文件加载到容器中\n","slug":"Docker结构","published":1,"updated":"2017-12-08T14:08:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2oh0002d82epkykm5oq","content":"<h2 id=\"容器介绍\"><a href=\"#容器介绍\" class=\"headerlink\" title=\"容器介绍\"></a>容器介绍</h2><h3 id=\"容器与虚拟机\"><a href=\"#容器与虚拟机\" class=\"headerlink\" title=\"容器与虚拟机\"></a>容器与虚拟机</h3><ul>\n<li>容器：应用程序；依赖</li>\n<li>虚拟机：应用程序；依赖；操作系统</li>\n</ul>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/21/594a1480eb090.jpg\" alt=\"docker_vm.jpg\"></p>\n<h3 id=\"容器解决的问题\"><a href=\"#容器解决的问题\" class=\"headerlink\" title=\"容器解决的问题\"></a>容器解决的问题</h3><p>简化打包、部署，使应用具备了超强的可移植能力</p>\n<p>对于现在多服务的应用往往依赖多个组件（例如：MQ,DB,Cache等），整个开发周期又需要部署多个环境（开发，测试，正式等），这就为运维带来极大的不便：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/21/594a17934f0dd.jpeg\" alt=\"c3786681cc644e6d8a6204cdffc49aa3_th.jpeg\"></p>\n<p>上面的图有两个变量：</p>\n<ol>\n<li>应用组件</li>\n<li>服务器环境</li>\n</ol>\n<p>容器能做的就是就是为应用组件提供一个基于容器的标准化环境，让容器可以运行在几乎所有操作系统上</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/21/594a19569b110.jpeg\" alt=\"54e8e6a8d2ec4b2d8acba239d323dfb9_th.jpeg\"></p>\n<p>好处：</p>\n<ul>\n<li>隔离：容器环境与宿主环境隔离</li>\n<li>重用：同一个组件只需要创建一次运行环境就可以在其他机器上运行</li>\n<li>一致：只需要配置好标准的 runtime 环境，服务器就可以运行任何容器</li>\n</ul>\n<h2 id=\"Docker组成\"><a href=\"#Docker组成\" class=\"headerlink\" title=\"Docker组成\"></a>Docker组成</h2><p>核心组件：</p>\n<ol>\n<li>Docker 客户端 - Client</li>\n<li>Docker 服务器 - Docker daemon</li>\n<li>Docker 镜像 - Image</li>\n<li>Registry</li>\n<li>Docker 容器 - Container</li>\n</ol>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/21/594a29f4c365c.jpg\" alt=\"docker_architecture.jpg\"></p>\n<h2 id=\"Docker启动过程\"><a href=\"#Docker启动过程\" class=\"headerlink\" title=\"Docker启动过程\"></a>Docker启动过程</h2><p>上篇文章最后提到了Docker的安装并运行了httpd：<code>sudo docker run -d -p 80:80 httpd</code></p>\n<p>结合Docker的组成，说明一下在容器启动过程这些组件是怎么协作的：</p>\n<ol>\n<li>docker client调用docker daemon请求启动一个容器</li>\n<li>docker daemon会向host请求创建容器</li>\n<li>host创建一个空的容器</li>\n<li>docker daemon检查本机docker镜像文件（如果没有，则到Registry下载）</li>\n<li>将镜像文件加载到容器中</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"容器介绍\"><a href=\"#容器介绍\" class=\"headerlink\" title=\"容器介绍\"></a>容器介绍</h2><h3 id=\"容器与虚拟机\"><a href=\"#容器与虚拟机\" class=\"headerlink\" title=\"容器与虚拟机\"></a>容器与虚拟机</h3><ul>\n<li>容器：应用程序；依赖</li>\n<li>虚拟机：应用程序；依赖；操作系统</li>\n</ul>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/21/594a1480eb090.jpg\" alt=\"docker_vm.jpg\"></p>\n<h3 id=\"容器解决的问题\"><a href=\"#容器解决的问题\" class=\"headerlink\" title=\"容器解决的问题\"></a>容器解决的问题</h3><p>简化打包、部署，使应用具备了超强的可移植能力</p>\n<p>对于现在多服务的应用往往依赖多个组件（例如：MQ,DB,Cache等），整个开发周期又需要部署多个环境（开发，测试，正式等），这就为运维带来极大的不便：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/21/594a17934f0dd.jpeg\" alt=\"c3786681cc644e6d8a6204cdffc49aa3_th.jpeg\"></p>\n<p>上面的图有两个变量：</p>\n<ol>\n<li>应用组件</li>\n<li>服务器环境</li>\n</ol>\n<p>容器能做的就是就是为应用组件提供一个基于容器的标准化环境，让容器可以运行在几乎所有操作系统上</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/21/594a19569b110.jpeg\" alt=\"54e8e6a8d2ec4b2d8acba239d323dfb9_th.jpeg\"></p>\n<p>好处：</p>\n<ul>\n<li>隔离：容器环境与宿主环境隔离</li>\n<li>重用：同一个组件只需要创建一次运行环境就可以在其他机器上运行</li>\n<li>一致：只需要配置好标准的 runtime 环境，服务器就可以运行任何容器</li>\n</ul>\n<h2 id=\"Docker组成\"><a href=\"#Docker组成\" class=\"headerlink\" title=\"Docker组成\"></a>Docker组成</h2><p>核心组件：</p>\n<ol>\n<li>Docker 客户端 - Client</li>\n<li>Docker 服务器 - Docker daemon</li>\n<li>Docker 镜像 - Image</li>\n<li>Registry</li>\n<li>Docker 容器 - Container</li>\n</ol>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/21/594a29f4c365c.jpg\" alt=\"docker_architecture.jpg\"></p>\n<h2 id=\"Docker启动过程\"><a href=\"#Docker启动过程\" class=\"headerlink\" title=\"Docker启动过程\"></a>Docker启动过程</h2><p>上篇文章最后提到了Docker的安装并运行了httpd：<code>sudo docker run -d -p 80:80 httpd</code></p>\n<p>结合Docker的组成，说明一下在容器启动过程这些组件是怎么协作的：</p>\n<ol>\n<li>docker client调用docker daemon请求启动一个容器</li>\n<li>docker daemon会向host请求创建容器</li>\n<li>host创建一个空的容器</li>\n<li>docker daemon检查本机docker镜像文件（如果没有，则到Registry下载）</li>\n<li>将镜像文件加载到容器中</li>\n</ol>\n"},{"title":"HTML与CSS小记","date":"2016-07-31T10:54:52.000Z","_content":"\n![jjj](https://ooo.0o0.ooo/2016/07/31/579dd779d1389.png)","source":"_posts/HTML与CSS小记.md","raw":"---\ntitle: HTML与CSS小记\ndate: 2016-07-31 18:54:52\ntags: \n  - HTML\n  - CSS\ncategories: 前端\n\n---\n\n![jjj](https://ooo.0o0.ooo/2016/07/31/579dd779d1389.png)","slug":"HTML与CSS小记","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2or0006d82e2nvgx6jb","content":"<p><img src=\"https://ooo.0o0.ooo/2016/07/31/579dd779d1389.png\" alt=\"jjj\"></p>\n","excerpt":"","more":"<p><img src=\"https://ooo.0o0.ooo/2016/07/31/579dd779d1389.png\" alt=\"jjj\"></p>\n"},{"title":"IoC容器的简单实现","date":"2016-11-10T15:44:15.000Z","_content":"\n记录临摹一个IoC容器的过程，使用对象容器进行控制反转，将对象间依赖关系的管理交给容器。\n\n代码在[这里](https://github.com/zhanghTK/HelloIoC)，API参照了Spring IoC部分，实现的具体过程参照了[tiny-spring](https://github.com/code4craft/tiny-spring)和[ioc-sample](https://github.com/kevinlynx/ioc-sample)。先看看如何使用：\n\n# 像Spring一样用\n\n```xml\n<beans>\n    <bean name=\"helloWorldOutputService\"\n          class=\"tk.zhangh.ioc.beans.HelloWorldOutputServiceImpl\">\n        <property name=\"name\" value=\"helloWorld\"/>\n        <property name=\"outputService\" ref=\"outputService\"/>\n    </bean>\n</beans>\n```\n\n```java\n@Test\npublic void register_get_bean_by_ClassPathXmlApplicationContextTest() throws Exception {\n    ApplicationContext applicationContext = new\n      ClassPathXmlApplicationContext(\"ioc.xml\");\n    HelloWorldService helloWorldService = (HelloWorldService)\n      applicationContext.getBean(\"helloWorldOutputService\");\n    helloWorldService.sayHello();\n}\n```\n\n---\n\n整个开发过程是这样的：\n\n# 自下而上\n\n大体的开发步骤以及思路参照了[tiny-spring](https://github.com/code4craft/tiny-spring)，实现步骤可以简述为：\n\n## 1.全手动式的Bean容器\n\n做容器的最重要的就是存取，针对bean容器就是bean信息的保存（注册）和bean实例的获取。\n\n- bean信息注册\n\n  bean的基本信息包括：bean的名称、bean实例、bean的Class信息，bean的属性信息，把这些基本信息封装成了`BeanDefinition`。\n\n  以`key(beanName)=>value(BeanDefinition)`的键值对就可以完成注册的功能\n\n- bean实例获取\n\n  从bean信息到bean实例中间还有一条鸿沟：怎么实例化bean。\n\n  为了方便实现，在初始化`BeanDefinition`实例的时候也对bean进行了初始化。\n\n\n站在客户端角度，怎么注册bean并不重要，因此bean容器接口只声明获取bena的方法。\n\n在`BeanDefinition`中实例化bean带来一个严重问题：bean实例的创建不受容器控制的。\n\n## 2. 定制Bean的实例化过程\n\n针对上面的问题，`AbstractBeanFactory`抽象出实例化bean方法，并在`AutowireCapableBeanFactory`提供基板实现。在`BeanDefinition`中并不需要再实例化了（代码实现到这一步时没有修改,bug）。\n\n新的`AutowireCapableBeanFactory`已经可以做到：\n\n1. 注册保存`BeanDefinition`\n2. 在注册时实例化bean\n3. 提供bean实例的获取\n\n现在，bean的实例化是受控于容器的。\n\n但是初始化的时机不够灵活，整个生命周期只有在注册时刻有唯一一次初始化。\n\n这样会影响bean实例属性的初始化，先看基本属性：\n\n## 3. 支持基本属性依赖\n\n对基本属性支持比较简单，整个过程完全由容器控制：\n\n1. 根据`BeanDefinition`获取bean相关的属性信息\n2. 创建对应的属性对象\n3. 使用反射注入属性\n\n在bean实例构造完成后就对属性注入，但是现有的方案并不能支持bean属性的注入：\n\n1. 属性bean从哪里来\n2. bean属性本身依赖其他bean呢？如果存在循环依赖呢？\n\n## 4. 使用资源文件配置\n\n解决bean属性问题前，先完成支持资源文件的管理。\n\n1. 创建资源文件表示类，以及资源加载类\n2. 创建信息读取接口，抽象类，以及具体的XML配置读取策略类\n\n添加对资源文件配置支持后，整个bean容器的过程为：\n\n1. 读取加载配置文件信息\n2. 创建beanfactory\n3. 注册保存bean信息\n   1. 创建bean实例\n   2. 设置bean实例的属性\n\n支持资源文件配置后原来需要硬编码的bean信息可以以配置文件的形式展示。\n\n但是，bean的实例构造时机、属性注入的时机没有改变，所以依赖存在对bean属性的支持问题。\n\n## 5. 支持bean属性依赖\n\n前面碰到的两个问题：\n\n1. 属性bean从哪里来\n2. bean属性本身依赖其他bean呢？如果存在循环依赖呢？\n\n属性bean也是bean，所以应该从工厂获取，循环依赖问题在Spring里是通过延迟实例化解决。\n\n所以问题变成了怎么调整bean实例构造时机，让这个过程延迟，发生在所有bean注册完成后。\n\n调整：在注册时只保存`BeanDefinition`，不对bena进行实例化。\n\n所有bean的实例化延迟到第一次获取bean实例时再进行：\n\n1. 先创建bean实例\n2. 遍历所有属性，基本属性直接注入，如果是其他bean引用重复以上过程。\n\n## 6. 进一步简化\n\n回头看现在的客户端使用：\n\n1. 加载资源\n2. 解析资源\n3. 创建beanFactory\n4. 注册bean\n5. 获取bean\n\n前四步实际是beanFactory的生命周期内容，客户端不关心这些细节，只要提供配置文件就可以。\n\n所以使用`ApplicationContext`接口对外暴露获取bean的方法。\n\nbean加载，解析，存取功能分别委托给：`BeanDefinitionReader`， `AbstractBeanFactory`。\n\n整个Bean容器生命周期细节都可以封装起来，对外提供简单调用。\n\n\n\n至此，一个简单的IoC容器就完成了\n\n---\n\n# 自上而下\n\n俯视这个IoC容器，基本的生命周期活动包括了：\n\n1. 资源加载\n2. 资源解析\n3. bean factory创建\n4. bean注册\n5. 创建bean实例\n6. bean获取\n\n所有的步骤都是以接口或抽象方法的形式提供或者是多态留白，具体的实现都交由子类实现。\n\n|       步骤       |                   抽象方法                   |\n| :------------: | :--------------------------------------: |\n|      资源加载      |        Resources.getInputStream()        |\n|      资源解析      | BeanDefinitionReader.loadBeanDefinitions(String) |\n| bean factory创建 |      this.beanFactory = beanFactory      |\n|     bean注册     | AbstractBeanFactory.registerBeanDefinition(String, BeanDefinition) |\n|    bean实例化     | AbstractBeanFactory.doCreateBean(BeanDefinition) |\n|     bean获取     |       BeanFactory.getBean(String)        |\n\n各个模块的耦合以接口留白的形式而非具体实现类为扩展带来了极大的灵活。\n\n在实现的时候并没有考虑这些，但实现完成后发现接口带来的灵活极大的方便了修改和扩展。\n","source":"_posts/IoC容器的简单实现.md","raw":"---\ntitle: IoC容器的简单实现\ndate: 2016-11-10 23:44:15\ntags:\n  - Java\ncategories: Java\n\n---\n\n记录临摹一个IoC容器的过程，使用对象容器进行控制反转，将对象间依赖关系的管理交给容器。\n\n代码在[这里](https://github.com/zhanghTK/HelloIoC)，API参照了Spring IoC部分，实现的具体过程参照了[tiny-spring](https://github.com/code4craft/tiny-spring)和[ioc-sample](https://github.com/kevinlynx/ioc-sample)。先看看如何使用：\n\n# 像Spring一样用\n\n```xml\n<beans>\n    <bean name=\"helloWorldOutputService\"\n          class=\"tk.zhangh.ioc.beans.HelloWorldOutputServiceImpl\">\n        <property name=\"name\" value=\"helloWorld\"/>\n        <property name=\"outputService\" ref=\"outputService\"/>\n    </bean>\n</beans>\n```\n\n```java\n@Test\npublic void register_get_bean_by_ClassPathXmlApplicationContextTest() throws Exception {\n    ApplicationContext applicationContext = new\n      ClassPathXmlApplicationContext(\"ioc.xml\");\n    HelloWorldService helloWorldService = (HelloWorldService)\n      applicationContext.getBean(\"helloWorldOutputService\");\n    helloWorldService.sayHello();\n}\n```\n\n---\n\n整个开发过程是这样的：\n\n# 自下而上\n\n大体的开发步骤以及思路参照了[tiny-spring](https://github.com/code4craft/tiny-spring)，实现步骤可以简述为：\n\n## 1.全手动式的Bean容器\n\n做容器的最重要的就是存取，针对bean容器就是bean信息的保存（注册）和bean实例的获取。\n\n- bean信息注册\n\n  bean的基本信息包括：bean的名称、bean实例、bean的Class信息，bean的属性信息，把这些基本信息封装成了`BeanDefinition`。\n\n  以`key(beanName)=>value(BeanDefinition)`的键值对就可以完成注册的功能\n\n- bean实例获取\n\n  从bean信息到bean实例中间还有一条鸿沟：怎么实例化bean。\n\n  为了方便实现，在初始化`BeanDefinition`实例的时候也对bean进行了初始化。\n\n\n站在客户端角度，怎么注册bean并不重要，因此bean容器接口只声明获取bena的方法。\n\n在`BeanDefinition`中实例化bean带来一个严重问题：bean实例的创建不受容器控制的。\n\n## 2. 定制Bean的实例化过程\n\n针对上面的问题，`AbstractBeanFactory`抽象出实例化bean方法，并在`AutowireCapableBeanFactory`提供基板实现。在`BeanDefinition`中并不需要再实例化了（代码实现到这一步时没有修改,bug）。\n\n新的`AutowireCapableBeanFactory`已经可以做到：\n\n1. 注册保存`BeanDefinition`\n2. 在注册时实例化bean\n3. 提供bean实例的获取\n\n现在，bean的实例化是受控于容器的。\n\n但是初始化的时机不够灵活，整个生命周期只有在注册时刻有唯一一次初始化。\n\n这样会影响bean实例属性的初始化，先看基本属性：\n\n## 3. 支持基本属性依赖\n\n对基本属性支持比较简单，整个过程完全由容器控制：\n\n1. 根据`BeanDefinition`获取bean相关的属性信息\n2. 创建对应的属性对象\n3. 使用反射注入属性\n\n在bean实例构造完成后就对属性注入，但是现有的方案并不能支持bean属性的注入：\n\n1. 属性bean从哪里来\n2. bean属性本身依赖其他bean呢？如果存在循环依赖呢？\n\n## 4. 使用资源文件配置\n\n解决bean属性问题前，先完成支持资源文件的管理。\n\n1. 创建资源文件表示类，以及资源加载类\n2. 创建信息读取接口，抽象类，以及具体的XML配置读取策略类\n\n添加对资源文件配置支持后，整个bean容器的过程为：\n\n1. 读取加载配置文件信息\n2. 创建beanfactory\n3. 注册保存bean信息\n   1. 创建bean实例\n   2. 设置bean实例的属性\n\n支持资源文件配置后原来需要硬编码的bean信息可以以配置文件的形式展示。\n\n但是，bean的实例构造时机、属性注入的时机没有改变，所以依赖存在对bean属性的支持问题。\n\n## 5. 支持bean属性依赖\n\n前面碰到的两个问题：\n\n1. 属性bean从哪里来\n2. bean属性本身依赖其他bean呢？如果存在循环依赖呢？\n\n属性bean也是bean，所以应该从工厂获取，循环依赖问题在Spring里是通过延迟实例化解决。\n\n所以问题变成了怎么调整bean实例构造时机，让这个过程延迟，发生在所有bean注册完成后。\n\n调整：在注册时只保存`BeanDefinition`，不对bena进行实例化。\n\n所有bean的实例化延迟到第一次获取bean实例时再进行：\n\n1. 先创建bean实例\n2. 遍历所有属性，基本属性直接注入，如果是其他bean引用重复以上过程。\n\n## 6. 进一步简化\n\n回头看现在的客户端使用：\n\n1. 加载资源\n2. 解析资源\n3. 创建beanFactory\n4. 注册bean\n5. 获取bean\n\n前四步实际是beanFactory的生命周期内容，客户端不关心这些细节，只要提供配置文件就可以。\n\n所以使用`ApplicationContext`接口对外暴露获取bean的方法。\n\nbean加载，解析，存取功能分别委托给：`BeanDefinitionReader`， `AbstractBeanFactory`。\n\n整个Bean容器生命周期细节都可以封装起来，对外提供简单调用。\n\n\n\n至此，一个简单的IoC容器就完成了\n\n---\n\n# 自上而下\n\n俯视这个IoC容器，基本的生命周期活动包括了：\n\n1. 资源加载\n2. 资源解析\n3. bean factory创建\n4. bean注册\n5. 创建bean实例\n6. bean获取\n\n所有的步骤都是以接口或抽象方法的形式提供或者是多态留白，具体的实现都交由子类实现。\n\n|       步骤       |                   抽象方法                   |\n| :------------: | :--------------------------------------: |\n|      资源加载      |        Resources.getInputStream()        |\n|      资源解析      | BeanDefinitionReader.loadBeanDefinitions(String) |\n| bean factory创建 |      this.beanFactory = beanFactory      |\n|     bean注册     | AbstractBeanFactory.registerBeanDefinition(String, BeanDefinition) |\n|    bean实例化     | AbstractBeanFactory.doCreateBean(BeanDefinition) |\n|     bean获取     |       BeanFactory.getBean(String)        |\n\n各个模块的耦合以接口留白的形式而非具体实现类为扩展带来了极大的灵活。\n\n在实现的时候并没有考虑这些，但实现完成后发现接口带来的灵活极大的方便了修改和扩展。\n","slug":"IoC容器的简单实现","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2ov0008d82ek8y4dijm","content":"<p>记录临摹一个IoC容器的过程，使用对象容器进行控制反转，将对象间依赖关系的管理交给容器。</p>\n<p>代码在<a href=\"https://github.com/zhanghTK/HelloIoC\" target=\"_blank\" rel=\"external\">这里</a>，API参照了Spring IoC部分，实现的具体过程参照了<a href=\"https://github.com/code4craft/tiny-spring\" target=\"_blank\" rel=\"external\">tiny-spring</a>和<a href=\"https://github.com/kevinlynx/ioc-sample\" target=\"_blank\" rel=\"external\">ioc-sample</a>。先看看如何使用：</p>\n<h1 id=\"像Spring一样用\"><a href=\"#像Spring一样用\" class=\"headerlink\" title=\"像Spring一样用\"></a>像Spring一样用</h1><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"helloWorldOutputService\"</span></span></div><div class=\"line\">          <span class=\"attr\">class</span>=<span class=\"string\">\"tk.zhangh.ioc.beans.HelloWorldOutputServiceImpl\"</span>&gt;</div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"helloWorld\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"outputService\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"outputService\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register_get_bean_by_ClassPathXmlApplicationContextTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    ApplicationContext applicationContext = <span class=\"keyword\">new</span></div><div class=\"line\">      ClassPathXmlApplicationContext(<span class=\"string\">\"ioc.xml\"</span>);</div><div class=\"line\">    HelloWorldService helloWorldService = (HelloWorldService)</div><div class=\"line\">      applicationContext.getBean(<span class=\"string\">\"helloWorldOutputService\"</span>);</div><div class=\"line\">    helloWorldService.sayHello();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>整个开发过程是这样的：</p>\n<h1 id=\"自下而上\"><a href=\"#自下而上\" class=\"headerlink\" title=\"自下而上\"></a>自下而上</h1><p>大体的开发步骤以及思路参照了<a href=\"https://github.com/code4craft/tiny-spring\" target=\"_blank\" rel=\"external\">tiny-spring</a>，实现步骤可以简述为：</p>\n<h2 id=\"1-全手动式的Bean容器\"><a href=\"#1-全手动式的Bean容器\" class=\"headerlink\" title=\"1.全手动式的Bean容器\"></a>1.全手动式的Bean容器</h2><p>做容器的最重要的就是存取，针对bean容器就是bean信息的保存（注册）和bean实例的获取。</p>\n<ul>\n<li><p>bean信息注册</p>\n<p>bean的基本信息包括：bean的名称、bean实例、bean的Class信息，bean的属性信息，把这些基本信息封装成了<code>BeanDefinition</code>。</p>\n<p>以<code>key(beanName)=&gt;value(BeanDefinition)</code>的键值对就可以完成注册的功能</p>\n</li>\n<li><p>bean实例获取</p>\n<p>从bean信息到bean实例中间还有一条鸿沟：怎么实例化bean。</p>\n<p>为了方便实现，在初始化<code>BeanDefinition</code>实例的时候也对bean进行了初始化。</p>\n</li>\n</ul>\n<p>站在客户端角度，怎么注册bean并不重要，因此bean容器接口只声明获取bena的方法。</p>\n<p>在<code>BeanDefinition</code>中实例化bean带来一个严重问题：bean实例的创建不受容器控制的。</p>\n<h2 id=\"2-定制Bean的实例化过程\"><a href=\"#2-定制Bean的实例化过程\" class=\"headerlink\" title=\"2. 定制Bean的实例化过程\"></a>2. 定制Bean的实例化过程</h2><p>针对上面的问题，<code>AbstractBeanFactory</code>抽象出实例化bean方法，并在<code>AutowireCapableBeanFactory</code>提供基板实现。在<code>BeanDefinition</code>中并不需要再实例化了（代码实现到这一步时没有修改,bug）。</p>\n<p>新的<code>AutowireCapableBeanFactory</code>已经可以做到：</p>\n<ol>\n<li>注册保存<code>BeanDefinition</code></li>\n<li>在注册时实例化bean</li>\n<li>提供bean实例的获取</li>\n</ol>\n<p>现在，bean的实例化是受控于容器的。</p>\n<p>但是初始化的时机不够灵活，整个生命周期只有在注册时刻有唯一一次初始化。</p>\n<p>这样会影响bean实例属性的初始化，先看基本属性：</p>\n<h2 id=\"3-支持基本属性依赖\"><a href=\"#3-支持基本属性依赖\" class=\"headerlink\" title=\"3. 支持基本属性依赖\"></a>3. 支持基本属性依赖</h2><p>对基本属性支持比较简单，整个过程完全由容器控制：</p>\n<ol>\n<li>根据<code>BeanDefinition</code>获取bean相关的属性信息</li>\n<li>创建对应的属性对象</li>\n<li>使用反射注入属性</li>\n</ol>\n<p>在bean实例构造完成后就对属性注入，但是现有的方案并不能支持bean属性的注入：</p>\n<ol>\n<li>属性bean从哪里来</li>\n<li>bean属性本身依赖其他bean呢？如果存在循环依赖呢？</li>\n</ol>\n<h2 id=\"4-使用资源文件配置\"><a href=\"#4-使用资源文件配置\" class=\"headerlink\" title=\"4. 使用资源文件配置\"></a>4. 使用资源文件配置</h2><p>解决bean属性问题前，先完成支持资源文件的管理。</p>\n<ol>\n<li>创建资源文件表示类，以及资源加载类</li>\n<li>创建信息读取接口，抽象类，以及具体的XML配置读取策略类</li>\n</ol>\n<p>添加对资源文件配置支持后，整个bean容器的过程为：</p>\n<ol>\n<li>读取加载配置文件信息</li>\n<li>创建beanfactory</li>\n<li>注册保存bean信息<ol>\n<li>创建bean实例</li>\n<li>设置bean实例的属性</li>\n</ol>\n</li>\n</ol>\n<p>支持资源文件配置后原来需要硬编码的bean信息可以以配置文件的形式展示。</p>\n<p>但是，bean的实例构造时机、属性注入的时机没有改变，所以依赖存在对bean属性的支持问题。</p>\n<h2 id=\"5-支持bean属性依赖\"><a href=\"#5-支持bean属性依赖\" class=\"headerlink\" title=\"5. 支持bean属性依赖\"></a>5. 支持bean属性依赖</h2><p>前面碰到的两个问题：</p>\n<ol>\n<li>属性bean从哪里来</li>\n<li>bean属性本身依赖其他bean呢？如果存在循环依赖呢？</li>\n</ol>\n<p>属性bean也是bean，所以应该从工厂获取，循环依赖问题在Spring里是通过延迟实例化解决。</p>\n<p>所以问题变成了怎么调整bean实例构造时机，让这个过程延迟，发生在所有bean注册完成后。</p>\n<p>调整：在注册时只保存<code>BeanDefinition</code>，不对bena进行实例化。</p>\n<p>所有bean的实例化延迟到第一次获取bean实例时再进行：</p>\n<ol>\n<li>先创建bean实例</li>\n<li>遍历所有属性，基本属性直接注入，如果是其他bean引用重复以上过程。</li>\n</ol>\n<h2 id=\"6-进一步简化\"><a href=\"#6-进一步简化\" class=\"headerlink\" title=\"6. 进一步简化\"></a>6. 进一步简化</h2><p>回头看现在的客户端使用：</p>\n<ol>\n<li>加载资源</li>\n<li>解析资源</li>\n<li>创建beanFactory</li>\n<li>注册bean</li>\n<li>获取bean</li>\n</ol>\n<p>前四步实际是beanFactory的生命周期内容，客户端不关心这些细节，只要提供配置文件就可以。</p>\n<p>所以使用<code>ApplicationContext</code>接口对外暴露获取bean的方法。</p>\n<p>bean加载，解析，存取功能分别委托给：<code>BeanDefinitionReader</code>， <code>AbstractBeanFactory</code>。</p>\n<p>整个Bean容器生命周期细节都可以封装起来，对外提供简单调用。</p>\n<p>至此，一个简单的IoC容器就完成了</p>\n<hr>\n<h1 id=\"自上而下\"><a href=\"#自上而下\" class=\"headerlink\" title=\"自上而下\"></a>自上而下</h1><p>俯视这个IoC容器，基本的生命周期活动包括了：</p>\n<ol>\n<li>资源加载</li>\n<li>资源解析</li>\n<li>bean factory创建</li>\n<li>bean注册</li>\n<li>创建bean实例</li>\n<li>bean获取</li>\n</ol>\n<p>所有的步骤都是以接口或抽象方法的形式提供或者是多态留白，具体的实现都交由子类实现。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">步骤</th>\n<th style=\"text-align:center\">抽象方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">资源加载</td>\n<td style=\"text-align:center\">Resources.getInputStream()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">资源解析</td>\n<td style=\"text-align:center\">BeanDefinitionReader.loadBeanDefinitions(String)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean factory创建</td>\n<td style=\"text-align:center\">this.beanFactory = beanFactory</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean注册</td>\n<td style=\"text-align:center\">AbstractBeanFactory.registerBeanDefinition(String, BeanDefinition)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean实例化</td>\n<td style=\"text-align:center\">AbstractBeanFactory.doCreateBean(BeanDefinition)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean获取</td>\n<td style=\"text-align:center\">BeanFactory.getBean(String)</td>\n</tr>\n</tbody>\n</table>\n<p>各个模块的耦合以接口留白的形式而非具体实现类为扩展带来了极大的灵活。</p>\n<p>在实现的时候并没有考虑这些，但实现完成后发现接口带来的灵活极大的方便了修改和扩展。</p>\n","excerpt":"","more":"<p>记录临摹一个IoC容器的过程，使用对象容器进行控制反转，将对象间依赖关系的管理交给容器。</p>\n<p>代码在<a href=\"https://github.com/zhanghTK/HelloIoC\">这里</a>，API参照了Spring IoC部分，实现的具体过程参照了<a href=\"https://github.com/code4craft/tiny-spring\">tiny-spring</a>和<a href=\"https://github.com/kevinlynx/ioc-sample\">ioc-sample</a>。先看看如何使用：</p>\n<h1 id=\"像Spring一样用\"><a href=\"#像Spring一样用\" class=\"headerlink\" title=\"像Spring一样用\"></a>像Spring一样用</h1><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"helloWorldOutputService\"</span></div><div class=\"line\">          <span class=\"attr\">class</span>=<span class=\"string\">\"tk.zhangh.ioc.beans.HelloWorldOutputServiceImpl\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"helloWorld\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"outputService\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"outputService\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register_get_bean_by_ClassPathXmlApplicationContextTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    ApplicationContext applicationContext = <span class=\"keyword\">new</span></div><div class=\"line\">      ClassPathXmlApplicationContext(<span class=\"string\">\"ioc.xml\"</span>);</div><div class=\"line\">    HelloWorldService helloWorldService = (HelloWorldService)</div><div class=\"line\">      applicationContext.getBean(<span class=\"string\">\"helloWorldOutputService\"</span>);</div><div class=\"line\">    helloWorldService.sayHello();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>整个开发过程是这样的：</p>\n<h1 id=\"自下而上\"><a href=\"#自下而上\" class=\"headerlink\" title=\"自下而上\"></a>自下而上</h1><p>大体的开发步骤以及思路参照了<a href=\"https://github.com/code4craft/tiny-spring\">tiny-spring</a>，实现步骤可以简述为：</p>\n<h2 id=\"1-全手动式的Bean容器\"><a href=\"#1-全手动式的Bean容器\" class=\"headerlink\" title=\"1.全手动式的Bean容器\"></a>1.全手动式的Bean容器</h2><p>做容器的最重要的就是存取，针对bean容器就是bean信息的保存（注册）和bean实例的获取。</p>\n<ul>\n<li><p>bean信息注册</p>\n<p>bean的基本信息包括：bean的名称、bean实例、bean的Class信息，bean的属性信息，把这些基本信息封装成了<code>BeanDefinition</code>。</p>\n<p>以<code>key(beanName)=&gt;value(BeanDefinition)</code>的键值对就可以完成注册的功能</p>\n</li>\n<li><p>bean实例获取</p>\n<p>从bean信息到bean实例中间还有一条鸿沟：怎么实例化bean。</p>\n<p>为了方便实现，在初始化<code>BeanDefinition</code>实例的时候也对bean进行了初始化。</p>\n</li>\n</ul>\n<p>站在客户端角度，怎么注册bean并不重要，因此bean容器接口只声明获取bena的方法。</p>\n<p>在<code>BeanDefinition</code>中实例化bean带来一个严重问题：bean实例的创建不受容器控制的。</p>\n<h2 id=\"2-定制Bean的实例化过程\"><a href=\"#2-定制Bean的实例化过程\" class=\"headerlink\" title=\"2. 定制Bean的实例化过程\"></a>2. 定制Bean的实例化过程</h2><p>针对上面的问题，<code>AbstractBeanFactory</code>抽象出实例化bean方法，并在<code>AutowireCapableBeanFactory</code>提供基板实现。在<code>BeanDefinition</code>中并不需要再实例化了（代码实现到这一步时没有修改,bug）。</p>\n<p>新的<code>AutowireCapableBeanFactory</code>已经可以做到：</p>\n<ol>\n<li>注册保存<code>BeanDefinition</code></li>\n<li>在注册时实例化bean</li>\n<li>提供bean实例的获取</li>\n</ol>\n<p>现在，bean的实例化是受控于容器的。</p>\n<p>但是初始化的时机不够灵活，整个生命周期只有在注册时刻有唯一一次初始化。</p>\n<p>这样会影响bean实例属性的初始化，先看基本属性：</p>\n<h2 id=\"3-支持基本属性依赖\"><a href=\"#3-支持基本属性依赖\" class=\"headerlink\" title=\"3. 支持基本属性依赖\"></a>3. 支持基本属性依赖</h2><p>对基本属性支持比较简单，整个过程完全由容器控制：</p>\n<ol>\n<li>根据<code>BeanDefinition</code>获取bean相关的属性信息</li>\n<li>创建对应的属性对象</li>\n<li>使用反射注入属性</li>\n</ol>\n<p>在bean实例构造完成后就对属性注入，但是现有的方案并不能支持bean属性的注入：</p>\n<ol>\n<li>属性bean从哪里来</li>\n<li>bean属性本身依赖其他bean呢？如果存在循环依赖呢？</li>\n</ol>\n<h2 id=\"4-使用资源文件配置\"><a href=\"#4-使用资源文件配置\" class=\"headerlink\" title=\"4. 使用资源文件配置\"></a>4. 使用资源文件配置</h2><p>解决bean属性问题前，先完成支持资源文件的管理。</p>\n<ol>\n<li>创建资源文件表示类，以及资源加载类</li>\n<li>创建信息读取接口，抽象类，以及具体的XML配置读取策略类</li>\n</ol>\n<p>添加对资源文件配置支持后，整个bean容器的过程为：</p>\n<ol>\n<li>读取加载配置文件信息</li>\n<li>创建beanfactory</li>\n<li>注册保存bean信息<ol>\n<li>创建bean实例</li>\n<li>设置bean实例的属性</li>\n</ol>\n</li>\n</ol>\n<p>支持资源文件配置后原来需要硬编码的bean信息可以以配置文件的形式展示。</p>\n<p>但是，bean的实例构造时机、属性注入的时机没有改变，所以依赖存在对bean属性的支持问题。</p>\n<h2 id=\"5-支持bean属性依赖\"><a href=\"#5-支持bean属性依赖\" class=\"headerlink\" title=\"5. 支持bean属性依赖\"></a>5. 支持bean属性依赖</h2><p>前面碰到的两个问题：</p>\n<ol>\n<li>属性bean从哪里来</li>\n<li>bean属性本身依赖其他bean呢？如果存在循环依赖呢？</li>\n</ol>\n<p>属性bean也是bean，所以应该从工厂获取，循环依赖问题在Spring里是通过延迟实例化解决。</p>\n<p>所以问题变成了怎么调整bean实例构造时机，让这个过程延迟，发生在所有bean注册完成后。</p>\n<p>调整：在注册时只保存<code>BeanDefinition</code>，不对bena进行实例化。</p>\n<p>所有bean的实例化延迟到第一次获取bean实例时再进行：</p>\n<ol>\n<li>先创建bean实例</li>\n<li>遍历所有属性，基本属性直接注入，如果是其他bean引用重复以上过程。</li>\n</ol>\n<h2 id=\"6-进一步简化\"><a href=\"#6-进一步简化\" class=\"headerlink\" title=\"6. 进一步简化\"></a>6. 进一步简化</h2><p>回头看现在的客户端使用：</p>\n<ol>\n<li>加载资源</li>\n<li>解析资源</li>\n<li>创建beanFactory</li>\n<li>注册bean</li>\n<li>获取bean</li>\n</ol>\n<p>前四步实际是beanFactory的生命周期内容，客户端不关心这些细节，只要提供配置文件就可以。</p>\n<p>所以使用<code>ApplicationContext</code>接口对外暴露获取bean的方法。</p>\n<p>bean加载，解析，存取功能分别委托给：<code>BeanDefinitionReader</code>， <code>AbstractBeanFactory</code>。</p>\n<p>整个Bean容器生命周期细节都可以封装起来，对外提供简单调用。</p>\n<p>至此，一个简单的IoC容器就完成了</p>\n<hr>\n<h1 id=\"自上而下\"><a href=\"#自上而下\" class=\"headerlink\" title=\"自上而下\"></a>自上而下</h1><p>俯视这个IoC容器，基本的生命周期活动包括了：</p>\n<ol>\n<li>资源加载</li>\n<li>资源解析</li>\n<li>bean factory创建</li>\n<li>bean注册</li>\n<li>创建bean实例</li>\n<li>bean获取</li>\n</ol>\n<p>所有的步骤都是以接口或抽象方法的形式提供或者是多态留白，具体的实现都交由子类实现。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">步骤</th>\n<th style=\"text-align:center\">抽象方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">资源加载</td>\n<td style=\"text-align:center\">Resources.getInputStream()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">资源解析</td>\n<td style=\"text-align:center\">BeanDefinitionReader.loadBeanDefinitions(String)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean factory创建</td>\n<td style=\"text-align:center\">this.beanFactory = beanFactory</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean注册</td>\n<td style=\"text-align:center\">AbstractBeanFactory.registerBeanDefinition(String, BeanDefinition)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean实例化</td>\n<td style=\"text-align:center\">AbstractBeanFactory.doCreateBean(BeanDefinition)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bean获取</td>\n<td style=\"text-align:center\">BeanFactory.getBean(String)</td>\n</tr>\n</tbody>\n</table>\n<p>各个模块的耦合以接口留白的形式而非具体实现类为扩展带来了极大的灵活。</p>\n<p>在实现的时候并没有考虑这些，但实现完成后发现接口带来的灵活极大的方便了修改和扩展。</p>\n"},{"title":"JDK中的Future模式","date":"2017-04-04T13:33:48.000Z","_content":"\n## Future模式\n\nFuture模式：一个耗时的任务开始后立即返回客户端凭证，而不是要求客户端持续等待，客户端随时可以使用凭证获取任务结果\n\n日常生活中类似的场景非常常见，比如你去维修电脑，把电脑交给售后拿好凭证你就可以走了，而不是守在售后等电脑。\n\nFuture模式的典型类图：\n\n![Future模式.png](https://ooo.0o0.ooo/2017/03/30/58dcc547c217d.png)\n\n- Task：任务接口\n- FutureTask：客户端凭证，实际任务委托给ResultTask\n- ResultTask：实际的任务处理\n- Client：创建FutureTask包装ResultTask，开启新线程处理ResultData，返回FutureTask\n\n如果任务没有执行完毕将持续阻塞，直到任务结束。具体实现可以使用wait/notifyAll方法以自己作为monitor阻塞自己。\n\n## JDK的支持\n\nJDK中提供了Future的支持，在Future模式之前先看看基本的支持。\n\n先从线程池部分看起，线程池的继承结构如下：\n\n- Executor接口中只定义了`void execute(Runnable command);`\n\n- ExecutorService接口进一步扩展了Executor，添加了如`shutdown`，`isShutdown`等方法，需要注意的是ExecutorService添加了三个重载的`submit`方法：\n\n  - ` <T> Future<T> submit(Callable<T> task);`\n  - `<T> Future<T> submit(Runnable task, T result);`\n  - `Future<?> submit(Runnable task);`\n\n  自此，线程池与Future和Callable/Runnable产生了难分难解的缘分。\n\n  继续ExecutorService实现之前先看看submit方法的返回值Future：\n\n- Future接口内只定义了几个简单方法，获取任务状态及结果。\n\n- AbstractExecutorService实现了ExecutorService，对三个submit方法的实现核心调用都是一致的：\n\n  ```java\n  RunnableFuture<T> ftask = newTaskFor(task, result);\n  execute(ftask);\n  return ftask;\n  ```\n\n\n关于线程池与Runnable与Callable的关系就到这里，下面是Runnable/Callable与RunnableFuture的关系了：\n\n- RunnableFuture接口定义：\n\n  `public interface RunnableFuture<V> extends Runnable, Future<V>`\n\n  所以RunnableFuture有两个身份：\n\n  1. Runnable，可以作为一个线程使用\n  2. Future，可以获取运行结果和线程状态\n\n  但是作为Runnable有什么好返回的呢？看一下具体的实现：FutureTask\n\n- FutureTask有接收Runnable的构造：\n\n  ```java\n  public FutureTask(Runnable runnable, V result) {\n    this.callable = Executors.callable(runnable, result);\n    this.state = NEW;       // ensure visibility of callable\n  }\n  ```\n\n- 再看`Executors.callable`：\n\n  ```java\n  public static <T> Callable<T> callable(Runnable task, T result) {\n    if (task == null)\n      throw new NullPointerException();\n    return new RunnableAdapter<T>(task, result);\n  }\n  ```\n\n- 继续看RunnableAdapter\n\n  ```java\n  static final class RunnableAdapter<T> implements Callable<T> {\n    final Runnable task;\n    final T result;\n    RunnableAdapter(Runnable task, T result) {\n      this.task = task;\n      this.result = result;\n    }\n    public T call() {\n      task.run();\n      return result;\n    }\n  }\n  ```\n\n\n\n我理解可以简单的概括为以下几点：\n\n- Runnable只是单纯的启动线程\n- Future只是单纯的获取线程状态\n- RunnableFuture勾画了Runnable和Future统一的蓝图\n- FutureTask最终完成了大一统\n- 线程池既可以接收Runnable又可以接收Callable，但最终处理的都是Callable\n\n## JDK的Future模式\n\n![JDK的Future.png](https://ooo.0o0.ooo/2017/03/30/58dccdfa7fc8d.png)\n","source":"_posts/JDK中的Future模式.md","raw":"---\ntitle: JDK中的Future模式\ndate: 2017-04-04 21:33:48\ntags:\n  - Java\n  - 并发\ncategories: Java\n---\n\n## Future模式\n\nFuture模式：一个耗时的任务开始后立即返回客户端凭证，而不是要求客户端持续等待，客户端随时可以使用凭证获取任务结果\n\n日常生活中类似的场景非常常见，比如你去维修电脑，把电脑交给售后拿好凭证你就可以走了，而不是守在售后等电脑。\n\nFuture模式的典型类图：\n\n![Future模式.png](https://ooo.0o0.ooo/2017/03/30/58dcc547c217d.png)\n\n- Task：任务接口\n- FutureTask：客户端凭证，实际任务委托给ResultTask\n- ResultTask：实际的任务处理\n- Client：创建FutureTask包装ResultTask，开启新线程处理ResultData，返回FutureTask\n\n如果任务没有执行完毕将持续阻塞，直到任务结束。具体实现可以使用wait/notifyAll方法以自己作为monitor阻塞自己。\n\n## JDK的支持\n\nJDK中提供了Future的支持，在Future模式之前先看看基本的支持。\n\n先从线程池部分看起，线程池的继承结构如下：\n\n- Executor接口中只定义了`void execute(Runnable command);`\n\n- ExecutorService接口进一步扩展了Executor，添加了如`shutdown`，`isShutdown`等方法，需要注意的是ExecutorService添加了三个重载的`submit`方法：\n\n  - ` <T> Future<T> submit(Callable<T> task);`\n  - `<T> Future<T> submit(Runnable task, T result);`\n  - `Future<?> submit(Runnable task);`\n\n  自此，线程池与Future和Callable/Runnable产生了难分难解的缘分。\n\n  继续ExecutorService实现之前先看看submit方法的返回值Future：\n\n- Future接口内只定义了几个简单方法，获取任务状态及结果。\n\n- AbstractExecutorService实现了ExecutorService，对三个submit方法的实现核心调用都是一致的：\n\n  ```java\n  RunnableFuture<T> ftask = newTaskFor(task, result);\n  execute(ftask);\n  return ftask;\n  ```\n\n\n关于线程池与Runnable与Callable的关系就到这里，下面是Runnable/Callable与RunnableFuture的关系了：\n\n- RunnableFuture接口定义：\n\n  `public interface RunnableFuture<V> extends Runnable, Future<V>`\n\n  所以RunnableFuture有两个身份：\n\n  1. Runnable，可以作为一个线程使用\n  2. Future，可以获取运行结果和线程状态\n\n  但是作为Runnable有什么好返回的呢？看一下具体的实现：FutureTask\n\n- FutureTask有接收Runnable的构造：\n\n  ```java\n  public FutureTask(Runnable runnable, V result) {\n    this.callable = Executors.callable(runnable, result);\n    this.state = NEW;       // ensure visibility of callable\n  }\n  ```\n\n- 再看`Executors.callable`：\n\n  ```java\n  public static <T> Callable<T> callable(Runnable task, T result) {\n    if (task == null)\n      throw new NullPointerException();\n    return new RunnableAdapter<T>(task, result);\n  }\n  ```\n\n- 继续看RunnableAdapter\n\n  ```java\n  static final class RunnableAdapter<T> implements Callable<T> {\n    final Runnable task;\n    final T result;\n    RunnableAdapter(Runnable task, T result) {\n      this.task = task;\n      this.result = result;\n    }\n    public T call() {\n      task.run();\n      return result;\n    }\n  }\n  ```\n\n\n\n我理解可以简单的概括为以下几点：\n\n- Runnable只是单纯的启动线程\n- Future只是单纯的获取线程状态\n- RunnableFuture勾画了Runnable和Future统一的蓝图\n- FutureTask最终完成了大一统\n- 线程池既可以接收Runnable又可以接收Callable，但最终处理的都是Callable\n\n## JDK的Future模式\n\n![JDK的Future.png](https://ooo.0o0.ooo/2017/03/30/58dccdfa7fc8d.png)\n","slug":"JDK中的Future模式","published":1,"updated":"2017-04-04T13:39:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2oy000bd82ez9ccysie","content":"<h2 id=\"Future模式\"><a href=\"#Future模式\" class=\"headerlink\" title=\"Future模式\"></a>Future模式</h2><p>Future模式：一个耗时的任务开始后立即返回客户端凭证，而不是要求客户端持续等待，客户端随时可以使用凭证获取任务结果</p>\n<p>日常生活中类似的场景非常常见，比如你去维修电脑，把电脑交给售后拿好凭证你就可以走了，而不是守在售后等电脑。</p>\n<p>Future模式的典型类图：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/30/58dcc547c217d.png\" alt=\"Future模式.png\"></p>\n<ul>\n<li>Task：任务接口</li>\n<li>FutureTask：客户端凭证，实际任务委托给ResultTask</li>\n<li>ResultTask：实际的任务处理</li>\n<li>Client：创建FutureTask包装ResultTask，开启新线程处理ResultData，返回FutureTask</li>\n</ul>\n<p>如果任务没有执行完毕将持续阻塞，直到任务结束。具体实现可以使用wait/notifyAll方法以自己作为monitor阻塞自己。</p>\n<h2 id=\"JDK的支持\"><a href=\"#JDK的支持\" class=\"headerlink\" title=\"JDK的支持\"></a>JDK的支持</h2><p>JDK中提供了Future的支持，在Future模式之前先看看基本的支持。</p>\n<p>先从线程池部分看起，线程池的继承结构如下：</p>\n<ul>\n<li><p>Executor接口中只定义了<code>void execute(Runnable command);</code></p>\n</li>\n<li><p>ExecutorService接口进一步扩展了Executor，添加了如<code>shutdown</code>，<code>isShutdown</code>等方法，需要注意的是ExecutorService添加了三个重载的<code>submit</code>方法：</p>\n<ul>\n<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</code></li>\n<li><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</code></li>\n<li><code>Future&lt;?&gt; submit(Runnable task);</code></li>\n</ul>\n<p>自此，线程池与Future和Callable/Runnable产生了难分难解的缘分。</p>\n<p>继续ExecutorService实现之前先看看submit方法的返回值Future：</p>\n</li>\n<li><p>Future接口内只定义了几个简单方法，获取任务状态及结果。</p>\n</li>\n<li><p>AbstractExecutorService实现了ExecutorService，对三个submit方法的实现核心调用都是一致的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</div><div class=\"line\">execute(ftask);</div><div class=\"line\"><span class=\"keyword\">return</span> ftask;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>关于线程池与Runnable与Callable的关系就到这里，下面是Runnable/Callable与RunnableFuture的关系了：</p>\n<ul>\n<li><p>RunnableFuture接口定义：</p>\n<p><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</code></p>\n<p>所以RunnableFuture有两个身份：</p>\n<ol>\n<li>Runnable，可以作为一个线程使用</li>\n<li>Future，可以获取运行结果和线程状态</li>\n</ol>\n<p>但是作为Runnable有什么好返回的呢？看一下具体的实现：FutureTask</p>\n</li>\n<li><p>FutureTask有接收Runnable的构造：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable runnable, V result)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.callable = Executors.callable(runnable, result);</div><div class=\"line\">  <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>再看<code>Executors.callable</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Callable&lt;T&gt; <span class=\"title\">callable</span><span class=\"params\">(Runnable task, T result)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>)</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RunnableAdapter&lt;T&gt;(task, result);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>继续看RunnableAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunnableAdapter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">final</span> Runnable task;</div><div class=\"line\">  <span class=\"keyword\">final</span> T result;</div><div class=\"line\">  RunnableAdapter(Runnable task, T result) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.task = task;</div><div class=\"line\">    <span class=\"keyword\">this</span>.result = result;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    task.run();</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我理解可以简单的概括为以下几点：</p>\n<ul>\n<li>Runnable只是单纯的启动线程</li>\n<li>Future只是单纯的获取线程状态</li>\n<li>RunnableFuture勾画了Runnable和Future统一的蓝图</li>\n<li>FutureTask最终完成了大一统</li>\n<li>线程池既可以接收Runnable又可以接收Callable，但最终处理的都是Callable</li>\n</ul>\n<h2 id=\"JDK的Future模式\"><a href=\"#JDK的Future模式\" class=\"headerlink\" title=\"JDK的Future模式\"></a>JDK的Future模式</h2><p><img src=\"https://ooo.0o0.ooo/2017/03/30/58dccdfa7fc8d.png\" alt=\"JDK的Future.png\"></p>\n","excerpt":"","more":"<h2 id=\"Future模式\"><a href=\"#Future模式\" class=\"headerlink\" title=\"Future模式\"></a>Future模式</h2><p>Future模式：一个耗时的任务开始后立即返回客户端凭证，而不是要求客户端持续等待，客户端随时可以使用凭证获取任务结果</p>\n<p>日常生活中类似的场景非常常见，比如你去维修电脑，把电脑交给售后拿好凭证你就可以走了，而不是守在售后等电脑。</p>\n<p>Future模式的典型类图：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/30/58dcc547c217d.png\" alt=\"Future模式.png\"></p>\n<ul>\n<li>Task：任务接口</li>\n<li>FutureTask：客户端凭证，实际任务委托给ResultTask</li>\n<li>ResultTask：实际的任务处理</li>\n<li>Client：创建FutureTask包装ResultTask，开启新线程处理ResultData，返回FutureTask</li>\n</ul>\n<p>如果任务没有执行完毕将持续阻塞，直到任务结束。具体实现可以使用wait/notifyAll方法以自己作为monitor阻塞自己。</p>\n<h2 id=\"JDK的支持\"><a href=\"#JDK的支持\" class=\"headerlink\" title=\"JDK的支持\"></a>JDK的支持</h2><p>JDK中提供了Future的支持，在Future模式之前先看看基本的支持。</p>\n<p>先从线程池部分看起，线程池的继承结构如下：</p>\n<ul>\n<li><p>Executor接口中只定义了<code>void execute(Runnable command);</code></p>\n</li>\n<li><p>ExecutorService接口进一步扩展了Executor，添加了如<code>shutdown</code>，<code>isShutdown</code>等方法，需要注意的是ExecutorService添加了三个重载的<code>submit</code>方法：</p>\n<ul>\n<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</code></li>\n<li><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</code></li>\n<li><code>Future&lt;?&gt; submit(Runnable task);</code></li>\n</ul>\n<p>自此，线程池与Future和Callable/Runnable产生了难分难解的缘分。</p>\n<p>继续ExecutorService实现之前先看看submit方法的返回值Future：</p>\n</li>\n<li><p>Future接口内只定义了几个简单方法，获取任务状态及结果。</p>\n</li>\n<li><p>AbstractExecutorService实现了ExecutorService，对三个submit方法的实现核心调用都是一致的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</div><div class=\"line\">execute(ftask);</div><div class=\"line\"><span class=\"keyword\">return</span> ftask;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>关于线程池与Runnable与Callable的关系就到这里，下面是Runnable/Callable与RunnableFuture的关系了：</p>\n<ul>\n<li><p>RunnableFuture接口定义：</p>\n<p><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</code></p>\n<p>所以RunnableFuture有两个身份：</p>\n<ol>\n<li>Runnable，可以作为一个线程使用</li>\n<li>Future，可以获取运行结果和线程状态</li>\n</ol>\n<p>但是作为Runnable有什么好返回的呢？看一下具体的实现：FutureTask</p>\n</li>\n<li><p>FutureTask有接收Runnable的构造：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable runnable, V result)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.callable = Executors.callable(runnable, result);</div><div class=\"line\">  <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>再看<code>Executors.callable</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Callable&lt;T&gt; <span class=\"title\">callable</span><span class=\"params\">(Runnable task, T result)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>)</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RunnableAdapter&lt;T&gt;(task, result);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>继续看RunnableAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunnableAdapter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">final</span> Runnable task;</div><div class=\"line\">  <span class=\"keyword\">final</span> T result;</div><div class=\"line\">  RunnableAdapter(Runnable task, T result) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.task = task;</div><div class=\"line\">    <span class=\"keyword\">this</span>.result = result;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    task.run();</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我理解可以简单的概括为以下几点：</p>\n<ul>\n<li>Runnable只是单纯的启动线程</li>\n<li>Future只是单纯的获取线程状态</li>\n<li>RunnableFuture勾画了Runnable和Future统一的蓝图</li>\n<li>FutureTask最终完成了大一统</li>\n<li>线程池既可以接收Runnable又可以接收Callable，但最终处理的都是Callable</li>\n</ul>\n<h2 id=\"JDK的Future模式\"><a href=\"#JDK的Future模式\" class=\"headerlink\" title=\"JDK的Future模式\"></a>JDK的Future模式</h2><p><img src=\"https://ooo.0o0.ooo/2017/03/30/58dccdfa7fc8d.png\" alt=\"JDK的Future.png\"></p>\n"},{"title":"JVM故障发现排除","date":"2017-12-08T13:20:40.000Z","_content":"\n最近做了服务器迁移之后，系统运行过程中出现了几次发现不稳定的情况。这次的经历又回想起之前几次碰到类似的问题，类似的问题往往需要能快速排查定位、处理。但相关类似问题又不是经常能够碰到，每次出现问题都是手忙脚乱的查资料，今天根据《深入理解 Java 虚拟机》和自己简单的经验做一下总结，方便日后使用。\n\n## 工具\n\n目前可用的 JVM 监控工具还是蛮多的，这里只列出实际操作中我使用的几个。其中有命令行工具也有第可视化工具，从使用的便捷性上讲，可视化的工具无疑是更好的。但生产环境处于安全，性能的考虑往往不开放远程连接，这时还是得用命令行工具处理。\n\n### 命令行工具\n\n- jps：JVM 进程状况工具，主要作用是查看 LVMID，-v 参数可以输出 JMV 启动参数\n\n- jstat：JVM 统计信息监控工具，主要是查看 GC 相关信息：\n\n  - -gc：监视 Java 堆状况\n  - -gccapacity：监视 Java 堆状况，最大，最小空间\n  - -gcutil：监视 Java 堆状况，已使用百分比\n\n  输出列含义见文末\n\n- jinfo：Java 配置信息工具，查看设置 JVM 启动参数\n\n  - 查看：-flag < name >：输出指定名称参数值，作为 jps -v 补充\n  - 设置：\n    - -flag [+|-] < name >：设置指定 JVM 参数的布尔值\n    - -flag < name > = < value >：设置指定 JVM 参数的值\n\n- jmap：Java 内存映像工具，主要参数：\n\n  - -dump：生成快照，例如：-dump:format=b,file=< filename.bin > < pid >\n  - -heap：显示 Java 堆详细信息\n  - -histo：像是堆中对象统计信息\n  - -permstat：以 ClassLoader 为统计口径显示永久代内存状况\n\n- jstack：Java 堆栈跟踪工具，用于生成 JVM 当前线程快照，-l 参数显示关于加锁信息，-F 参数强制 dump\n\n### 可视化工具\n\n- VisualVM：多合一故障处理工具，这个几乎涵盖了我用到上面命令行的所有功能\n- MemoryAnalyzerTool：用于分析 dump 堆文件，对比 VisualVM 功能单一，但是提供了报表功能可以协助分析问题\n\n## 问题排查一般思路\n\n目前我在实际开发过程中碰到的 JVM 问题主要可以分类两类：内存溢出和系统运行缓慢\n\n### 内存溢出\n\n这种场景是影响最恶劣，但也是最容易排查的。通常的错误就能告诉说明溢出区域：\n\n- outOfMemoryError ：年老代内存不足\n- outOfMemoryError:PermGen Space：永久代内存不足\n- outOfMemoryError:GC overhead limit exceed：垃圾回收时间占用系统运行时间的98%或以上\n\n生产环境碰到这类情况为了确保系统可用，可以先使用 jstat 查看 Java 堆的空间使用情况确定到底是哪部分溢出，其最大可用空间是多少，然后直接扩大该区域空间即可。重启时建议加上 -XX:+HeapDumpOnOutMemoryError 作为启动参数，在下次溢出可以获得快照文件。\n\n上面的做法作为临时解决方案可以解决一般性的问题，但没有系统的快照无法深入分析问题产生的原因，如果想分析问题根源需要在重启前使用 jmap 生成快照。获得快照文件后可以在本地使用可视化工具分析。使用 MemoryAnalyzer 打开快照文件就能获得一个分析报表，里面列出了可能出现泄露的地方。目前我碰到的内存溢出问题一般从这个分析报表里面就可以确定了，如果不能确定就需要根据加载的类，类的实例，引用关系进一步分析了。\n\n我目前碰到的都是 Java 堆的溢出，以上的思路基本可以解决。但除此还有其他的内存溢出需要注意：\n\n- Direct Memory\n- 线程堆栈：StackOverflowError，OutOfMemoryError：unable to create new native thread\n- Socket 缓冲区：IOException：Too many open files\n\n### 系统运行缓慢\n\n系统运行缓慢可能出现的原因就比较多了，通常就是找到导致系统缓慢的具体代码段，然后修复。一般化的解决思路是从系统到应用，从应用到线程。\n\n具体来说：首先使用系统监控工具（例如 top，vmstat）查看当前系统运行状况，确认哪个应用的资源占用过大，是否是 Java 应用的问题；其次使用 jps 获得具体应用的 LVMID，根据 LVMID 查看应用的具体运行状况，如线程情况，系统信息等。还可以根据系统工具 pidstat 进一步查看线程的运行信息来辅助确定问题。以上基本就可以确定问题。\n\n### 本地应用\n\n如果是本地应用或者可以远程访问的应用排查起来就更方便了，直接使用 VisualVM 连接上去，从系统到线程的一切信息都了如指掌，还可以直接运行 GC，dump 快照等。\n\n---\n\n- 关于工具使用的一些参考：\n\n  [JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解](https://my.oschina.net/feichexia/blog/196575)\n\n  [MAT - Memory Analyzer Tool 使用进阶](http://www.lightskystreet.com/2015/09/01/mat_usage/)\n\n- jstat 输出列含义：\n\n  S0C：年轻代中第一个survivor的容量 (字节) \n\n  S1C：年轻代中第二个survivor的容量 (字节) \n\n  S0U：年轻代中第一个survivor目前已使用空间 (字节) \n\n  S1U：年轻代中第二个survivor目前已使用空间 (字节) \n\n  EC：年轻代中Eden的容量 (字节) \n\n  EU：年轻代中Eden目前已使用空间 (字节) \n\n  OC：Old代的容量 (字节) \n\n  OU：Old代目前已使用空间 (字节) \n\n  PC：Perm(持久代)的容量 (字节) \n\n  PU：Perm(持久代)目前已使用空间 (字节) \n\n  YGC：从应用程序启动到采样时年轻代中gc次数 \n\n  YGCT：从应用程序启动到采样时年轻代中gc所用时间(s) \n\n  FGC：从应用程序启动到采样时old代(全gc)gc次数 \n\n  FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s) \n\n  GCT：从应用程序启动到采样时gc用的总时间(s) \n\n  NGCMN：年轻代中初始化(最小)的大小 (字节) \n\n  NGCMX：年轻代的最大容量 (字节) \n\n  NGC：年轻代中当前的容量 (字节) \n\n  OGCMN：old代中初始化(最小)的大小 (字节) \n\n  OGCMX：old代的最大容量 (字节) \n\n  OGC：old代当前新生成的容量 (字节) \n\n  PGCMN：perm代中初始化(最小)的大小 (字节) \n\n  PGCMX：perm代的最大容量 (字节) \n\n  PGC：perm代当前新生成的容量 (字节) \n\n  S0：年轻代中第一个survivor已使用的占当前容量百分比 \n\n  S1：年轻代中第二个survivor已使用的占当前容量百分比 \n\n  E：年轻代中Eden已使用的占当前容量百分比 \n\n  O：old代已使用的占当前容量百分比 \n\n  P：perm代已使用的占当前容量百分比 \n\n  S0CMX：年轻代中第一个survivor的最大容量 (字节) \n\n  S1CMX ：年轻代中第二个survivor的最大容量 (字节) \n\n  ECMX：年轻代中Eden的最大容量 (字节) \n\n  DSS：当前需要survivor的容量 (字节)（Eden区已满） \n\n  TT： 持有次数限制 \n\n  MTT ： 最大持有次数限制 \n  \n  \n  ---\n  20171208 补充\n  \n  目前系统接入了 APM（Application Performance Management） 对整个系统的运行进行监控。监控内容包括但不限 JVM 相关内容，非常值得参考。\n  [APM 传送问](https://github.com/naver/pinpoint)\n\n\n","source":"_posts/JVM故障发现排除.md","raw":"---\ntitle: JVM故障发现排除\ndate: 2017-12-08 21:20:40\ntags:\n  - Java\n  - JVM\ncategories: JVM\n---\n\n最近做了服务器迁移之后，系统运行过程中出现了几次发现不稳定的情况。这次的经历又回想起之前几次碰到类似的问题，类似的问题往往需要能快速排查定位、处理。但相关类似问题又不是经常能够碰到，每次出现问题都是手忙脚乱的查资料，今天根据《深入理解 Java 虚拟机》和自己简单的经验做一下总结，方便日后使用。\n\n## 工具\n\n目前可用的 JVM 监控工具还是蛮多的，这里只列出实际操作中我使用的几个。其中有命令行工具也有第可视化工具，从使用的便捷性上讲，可视化的工具无疑是更好的。但生产环境处于安全，性能的考虑往往不开放远程连接，这时还是得用命令行工具处理。\n\n### 命令行工具\n\n- jps：JVM 进程状况工具，主要作用是查看 LVMID，-v 参数可以输出 JMV 启动参数\n\n- jstat：JVM 统计信息监控工具，主要是查看 GC 相关信息：\n\n  - -gc：监视 Java 堆状况\n  - -gccapacity：监视 Java 堆状况，最大，最小空间\n  - -gcutil：监视 Java 堆状况，已使用百分比\n\n  输出列含义见文末\n\n- jinfo：Java 配置信息工具，查看设置 JVM 启动参数\n\n  - 查看：-flag < name >：输出指定名称参数值，作为 jps -v 补充\n  - 设置：\n    - -flag [+|-] < name >：设置指定 JVM 参数的布尔值\n    - -flag < name > = < value >：设置指定 JVM 参数的值\n\n- jmap：Java 内存映像工具，主要参数：\n\n  - -dump：生成快照，例如：-dump:format=b,file=< filename.bin > < pid >\n  - -heap：显示 Java 堆详细信息\n  - -histo：像是堆中对象统计信息\n  - -permstat：以 ClassLoader 为统计口径显示永久代内存状况\n\n- jstack：Java 堆栈跟踪工具，用于生成 JVM 当前线程快照，-l 参数显示关于加锁信息，-F 参数强制 dump\n\n### 可视化工具\n\n- VisualVM：多合一故障处理工具，这个几乎涵盖了我用到上面命令行的所有功能\n- MemoryAnalyzerTool：用于分析 dump 堆文件，对比 VisualVM 功能单一，但是提供了报表功能可以协助分析问题\n\n## 问题排查一般思路\n\n目前我在实际开发过程中碰到的 JVM 问题主要可以分类两类：内存溢出和系统运行缓慢\n\n### 内存溢出\n\n这种场景是影响最恶劣，但也是最容易排查的。通常的错误就能告诉说明溢出区域：\n\n- outOfMemoryError ：年老代内存不足\n- outOfMemoryError:PermGen Space：永久代内存不足\n- outOfMemoryError:GC overhead limit exceed：垃圾回收时间占用系统运行时间的98%或以上\n\n生产环境碰到这类情况为了确保系统可用，可以先使用 jstat 查看 Java 堆的空间使用情况确定到底是哪部分溢出，其最大可用空间是多少，然后直接扩大该区域空间即可。重启时建议加上 -XX:+HeapDumpOnOutMemoryError 作为启动参数，在下次溢出可以获得快照文件。\n\n上面的做法作为临时解决方案可以解决一般性的问题，但没有系统的快照无法深入分析问题产生的原因，如果想分析问题根源需要在重启前使用 jmap 生成快照。获得快照文件后可以在本地使用可视化工具分析。使用 MemoryAnalyzer 打开快照文件就能获得一个分析报表，里面列出了可能出现泄露的地方。目前我碰到的内存溢出问题一般从这个分析报表里面就可以确定了，如果不能确定就需要根据加载的类，类的实例，引用关系进一步分析了。\n\n我目前碰到的都是 Java 堆的溢出，以上的思路基本可以解决。但除此还有其他的内存溢出需要注意：\n\n- Direct Memory\n- 线程堆栈：StackOverflowError，OutOfMemoryError：unable to create new native thread\n- Socket 缓冲区：IOException：Too many open files\n\n### 系统运行缓慢\n\n系统运行缓慢可能出现的原因就比较多了，通常就是找到导致系统缓慢的具体代码段，然后修复。一般化的解决思路是从系统到应用，从应用到线程。\n\n具体来说：首先使用系统监控工具（例如 top，vmstat）查看当前系统运行状况，确认哪个应用的资源占用过大，是否是 Java 应用的问题；其次使用 jps 获得具体应用的 LVMID，根据 LVMID 查看应用的具体运行状况，如线程情况，系统信息等。还可以根据系统工具 pidstat 进一步查看线程的运行信息来辅助确定问题。以上基本就可以确定问题。\n\n### 本地应用\n\n如果是本地应用或者可以远程访问的应用排查起来就更方便了，直接使用 VisualVM 连接上去，从系统到线程的一切信息都了如指掌，还可以直接运行 GC，dump 快照等。\n\n---\n\n- 关于工具使用的一些参考：\n\n  [JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解](https://my.oschina.net/feichexia/blog/196575)\n\n  [MAT - Memory Analyzer Tool 使用进阶](http://www.lightskystreet.com/2015/09/01/mat_usage/)\n\n- jstat 输出列含义：\n\n  S0C：年轻代中第一个survivor的容量 (字节) \n\n  S1C：年轻代中第二个survivor的容量 (字节) \n\n  S0U：年轻代中第一个survivor目前已使用空间 (字节) \n\n  S1U：年轻代中第二个survivor目前已使用空间 (字节) \n\n  EC：年轻代中Eden的容量 (字节) \n\n  EU：年轻代中Eden目前已使用空间 (字节) \n\n  OC：Old代的容量 (字节) \n\n  OU：Old代目前已使用空间 (字节) \n\n  PC：Perm(持久代)的容量 (字节) \n\n  PU：Perm(持久代)目前已使用空间 (字节) \n\n  YGC：从应用程序启动到采样时年轻代中gc次数 \n\n  YGCT：从应用程序启动到采样时年轻代中gc所用时间(s) \n\n  FGC：从应用程序启动到采样时old代(全gc)gc次数 \n\n  FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s) \n\n  GCT：从应用程序启动到采样时gc用的总时间(s) \n\n  NGCMN：年轻代中初始化(最小)的大小 (字节) \n\n  NGCMX：年轻代的最大容量 (字节) \n\n  NGC：年轻代中当前的容量 (字节) \n\n  OGCMN：old代中初始化(最小)的大小 (字节) \n\n  OGCMX：old代的最大容量 (字节) \n\n  OGC：old代当前新生成的容量 (字节) \n\n  PGCMN：perm代中初始化(最小)的大小 (字节) \n\n  PGCMX：perm代的最大容量 (字节) \n\n  PGC：perm代当前新生成的容量 (字节) \n\n  S0：年轻代中第一个survivor已使用的占当前容量百分比 \n\n  S1：年轻代中第二个survivor已使用的占当前容量百分比 \n\n  E：年轻代中Eden已使用的占当前容量百分比 \n\n  O：old代已使用的占当前容量百分比 \n\n  P：perm代已使用的占当前容量百分比 \n\n  S0CMX：年轻代中第一个survivor的最大容量 (字节) \n\n  S1CMX ：年轻代中第二个survivor的最大容量 (字节) \n\n  ECMX：年轻代中Eden的最大容量 (字节) \n\n  DSS：当前需要survivor的容量 (字节)（Eden区已满） \n\n  TT： 持有次数限制 \n\n  MTT ： 最大持有次数限制 \n  \n  \n  ---\n  20171208 补充\n  \n  目前系统接入了 APM（Application Performance Management） 对整个系统的运行进行监控。监控内容包括但不限 JVM 相关内容，非常值得参考。\n  [APM 传送问](https://github.com/naver/pinpoint)\n\n\n","slug":"JVM故障发现排除","published":1,"updated":"2017-12-08T13:31:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2p2000fd82ehhut72jc","content":"<p>最近做了服务器迁移之后，系统运行过程中出现了几次发现不稳定的情况。这次的经历又回想起之前几次碰到类似的问题，类似的问题往往需要能快速排查定位、处理。但相关类似问题又不是经常能够碰到，每次出现问题都是手忙脚乱的查资料，今天根据《深入理解 Java 虚拟机》和自己简单的经验做一下总结，方便日后使用。</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>目前可用的 JVM 监控工具还是蛮多的，这里只列出实际操作中我使用的几个。其中有命令行工具也有第可视化工具，从使用的便捷性上讲，可视化的工具无疑是更好的。但生产环境处于安全，性能的考虑往往不开放远程连接，这时还是得用命令行工具处理。</p>\n<h3 id=\"命令行工具\"><a href=\"#命令行工具\" class=\"headerlink\" title=\"命令行工具\"></a>命令行工具</h3><ul>\n<li><p>jps：JVM 进程状况工具，主要作用是查看 LVMID，-v 参数可以输出 JMV 启动参数</p>\n</li>\n<li><p>jstat：JVM 统计信息监控工具，主要是查看 GC 相关信息：</p>\n<ul>\n<li>-gc：监视 Java 堆状况</li>\n<li>-gccapacity：监视 Java 堆状况，最大，最小空间</li>\n<li>-gcutil：监视 Java 堆状况，已使用百分比</li>\n</ul>\n<p>输出列含义见文末</p>\n</li>\n<li><p>jinfo：Java 配置信息工具，查看设置 JVM 启动参数</p>\n<ul>\n<li>查看：-flag &lt; name &gt;：输出指定名称参数值，作为 jps -v 补充</li>\n<li>设置：<ul>\n<li>-flag [+|-] &lt; name &gt;：设置指定 JVM 参数的布尔值</li>\n<li>-flag &lt; name &gt; = &lt; value &gt;：设置指定 JVM 参数的值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>jmap：Java 内存映像工具，主要参数：</p>\n<ul>\n<li>-dump：生成快照，例如：-dump:format=b,file=&lt; filename.bin &gt; &lt; pid &gt;</li>\n<li>-heap：显示 Java 堆详细信息</li>\n<li>-histo：像是堆中对象统计信息</li>\n<li>-permstat：以 ClassLoader 为统计口径显示永久代内存状况</li>\n</ul>\n</li>\n<li><p>jstack：Java 堆栈跟踪工具，用于生成 JVM 当前线程快照，-l 参数显示关于加锁信息，-F 参数强制 dump</p>\n</li>\n</ul>\n<h3 id=\"可视化工具\"><a href=\"#可视化工具\" class=\"headerlink\" title=\"可视化工具\"></a>可视化工具</h3><ul>\n<li>VisualVM：多合一故障处理工具，这个几乎涵盖了我用到上面命令行的所有功能</li>\n<li>MemoryAnalyzerTool：用于分析 dump 堆文件，对比 VisualVM 功能单一，但是提供了报表功能可以协助分析问题</li>\n</ul>\n<h2 id=\"问题排查一般思路\"><a href=\"#问题排查一般思路\" class=\"headerlink\" title=\"问题排查一般思路\"></a>问题排查一般思路</h2><p>目前我在实际开发过程中碰到的 JVM 问题主要可以分类两类：内存溢出和系统运行缓慢</p>\n<h3 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h3><p>这种场景是影响最恶劣，但也是最容易排查的。通常的错误就能告诉说明溢出区域：</p>\n<ul>\n<li>outOfMemoryError ：年老代内存不足</li>\n<li>outOfMemoryError:PermGen Space：永久代内存不足</li>\n<li>outOfMemoryError:GC overhead limit exceed：垃圾回收时间占用系统运行时间的98%或以上</li>\n</ul>\n<p>生产环境碰到这类情况为了确保系统可用，可以先使用 jstat 查看 Java 堆的空间使用情况确定到底是哪部分溢出，其最大可用空间是多少，然后直接扩大该区域空间即可。重启时建议加上 -XX:+HeapDumpOnOutMemoryError 作为启动参数，在下次溢出可以获得快照文件。</p>\n<p>上面的做法作为临时解决方案可以解决一般性的问题，但没有系统的快照无法深入分析问题产生的原因，如果想分析问题根源需要在重启前使用 jmap 生成快照。获得快照文件后可以在本地使用可视化工具分析。使用 MemoryAnalyzer 打开快照文件就能获得一个分析报表，里面列出了可能出现泄露的地方。目前我碰到的内存溢出问题一般从这个分析报表里面就可以确定了，如果不能确定就需要根据加载的类，类的实例，引用关系进一步分析了。</p>\n<p>我目前碰到的都是 Java 堆的溢出，以上的思路基本可以解决。但除此还有其他的内存溢出需要注意：</p>\n<ul>\n<li>Direct Memory</li>\n<li>线程堆栈：StackOverflowError，OutOfMemoryError：unable to create new native thread</li>\n<li>Socket 缓冲区：IOException：Too many open files</li>\n</ul>\n<h3 id=\"系统运行缓慢\"><a href=\"#系统运行缓慢\" class=\"headerlink\" title=\"系统运行缓慢\"></a>系统运行缓慢</h3><p>系统运行缓慢可能出现的原因就比较多了，通常就是找到导致系统缓慢的具体代码段，然后修复。一般化的解决思路是从系统到应用，从应用到线程。</p>\n<p>具体来说：首先使用系统监控工具（例如 top，vmstat）查看当前系统运行状况，确认哪个应用的资源占用过大，是否是 Java 应用的问题；其次使用 jps 获得具体应用的 LVMID，根据 LVMID 查看应用的具体运行状况，如线程情况，系统信息等。还可以根据系统工具 pidstat 进一步查看线程的运行信息来辅助确定问题。以上基本就可以确定问题。</p>\n<h3 id=\"本地应用\"><a href=\"#本地应用\" class=\"headerlink\" title=\"本地应用\"></a>本地应用</h3><p>如果是本地应用或者可以远程访问的应用排查起来就更方便了，直接使用 VisualVM 连接上去，从系统到线程的一切信息都了如指掌，还可以直接运行 GC，dump 快照等。</p>\n<hr>\n<ul>\n<li><p>关于工具使用的一些参考：</p>\n<p><a href=\"https://my.oschina.net/feichexia/blog/196575\" target=\"_blank\" rel=\"external\">JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解</a></p>\n<p><a href=\"http://www.lightskystreet.com/2015/09/01/mat_usage/\" target=\"_blank\" rel=\"external\">MAT - Memory Analyzer Tool 使用进阶</a></p>\n</li>\n<li><p>jstat 输出列含义：</p>\n<p>S0C：年轻代中第一个survivor的容量 (字节) </p>\n<p>S1C：年轻代中第二个survivor的容量 (字节) </p>\n<p>S0U：年轻代中第一个survivor目前已使用空间 (字节) </p>\n<p>S1U：年轻代中第二个survivor目前已使用空间 (字节) </p>\n<p>EC：年轻代中Eden的容量 (字节) </p>\n<p>EU：年轻代中Eden目前已使用空间 (字节) </p>\n<p>OC：Old代的容量 (字节) </p>\n<p>OU：Old代目前已使用空间 (字节) </p>\n<p>PC：Perm(持久代)的容量 (字节) </p>\n<p>PU：Perm(持久代)目前已使用空间 (字节) </p>\n<p>YGC：从应用程序启动到采样时年轻代中gc次数 </p>\n<p>YGCT：从应用程序启动到采样时年轻代中gc所用时间(s) </p>\n<p>FGC：从应用程序启动到采样时old代(全gc)gc次数 </p>\n<p>FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s) </p>\n<p>GCT：从应用程序启动到采样时gc用的总时间(s) </p>\n<p>NGCMN：年轻代中初始化(最小)的大小 (字节) </p>\n<p>NGCMX：年轻代的最大容量 (字节) </p>\n<p>NGC：年轻代中当前的容量 (字节) </p>\n<p>OGCMN：old代中初始化(最小)的大小 (字节) </p>\n<p>OGCMX：old代的最大容量 (字节) </p>\n<p>OGC：old代当前新生成的容量 (字节) </p>\n<p>PGCMN：perm代中初始化(最小)的大小 (字节) </p>\n<p>PGCMX：perm代的最大容量 (字节) </p>\n<p>PGC：perm代当前新生成的容量 (字节) </p>\n<p>S0：年轻代中第一个survivor已使用的占当前容量百分比 </p>\n<p>S1：年轻代中第二个survivor已使用的占当前容量百分比 </p>\n<p>E：年轻代中Eden已使用的占当前容量百分比 </p>\n<p>O：old代已使用的占当前容量百分比 </p>\n<p>P：perm代已使用的占当前容量百分比 </p>\n<p>S0CMX：年轻代中第一个survivor的最大容量 (字节) </p>\n<p>S1CMX ：年轻代中第二个survivor的最大容量 (字节) </p>\n<p>ECMX：年轻代中Eden的最大容量 (字节) </p>\n<p>DSS：当前需要survivor的容量 (字节)（Eden区已满） </p>\n<p>TT： 持有次数限制 </p>\n<p>MTT ： 最大持有次数限制 </p>\n</li>\n</ul>\n<hr>\n<p>  20171208 补充</p>\n<p>  目前系统接入了 APM（Application Performance Management） 对整个系统的运行进行监控。监控内容包括但不限 JVM 相关内容，非常值得参考。<br>  <a href=\"https://github.com/naver/pinpoint\" target=\"_blank\" rel=\"external\">APM 传送问</a></p>\n","excerpt":"","more":"<p>最近做了服务器迁移之后，系统运行过程中出现了几次发现不稳定的情况。这次的经历又回想起之前几次碰到类似的问题，类似的问题往往需要能快速排查定位、处理。但相关类似问题又不是经常能够碰到，每次出现问题都是手忙脚乱的查资料，今天根据《深入理解 Java 虚拟机》和自己简单的经验做一下总结，方便日后使用。</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>目前可用的 JVM 监控工具还是蛮多的，这里只列出实际操作中我使用的几个。其中有命令行工具也有第可视化工具，从使用的便捷性上讲，可视化的工具无疑是更好的。但生产环境处于安全，性能的考虑往往不开放远程连接，这时还是得用命令行工具处理。</p>\n<h3 id=\"命令行工具\"><a href=\"#命令行工具\" class=\"headerlink\" title=\"命令行工具\"></a>命令行工具</h3><ul>\n<li><p>jps：JVM 进程状况工具，主要作用是查看 LVMID，-v 参数可以输出 JMV 启动参数</p>\n</li>\n<li><p>jstat：JVM 统计信息监控工具，主要是查看 GC 相关信息：</p>\n<ul>\n<li>-gc：监视 Java 堆状况</li>\n<li>-gccapacity：监视 Java 堆状况，最大，最小空间</li>\n<li>-gcutil：监视 Java 堆状况，已使用百分比</li>\n</ul>\n<p>输出列含义见文末</p>\n</li>\n<li><p>jinfo：Java 配置信息工具，查看设置 JVM 启动参数</p>\n<ul>\n<li>查看：-flag &lt; name &gt;：输出指定名称参数值，作为 jps -v 补充</li>\n<li>设置：<ul>\n<li>-flag [+|-] &lt; name &gt;：设置指定 JVM 参数的布尔值</li>\n<li>-flag &lt; name &gt; = &lt; value &gt;：设置指定 JVM 参数的值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>jmap：Java 内存映像工具，主要参数：</p>\n<ul>\n<li>-dump：生成快照，例如：-dump:format=b,file=&lt; filename.bin &gt; &lt; pid &gt;</li>\n<li>-heap：显示 Java 堆详细信息</li>\n<li>-histo：像是堆中对象统计信息</li>\n<li>-permstat：以 ClassLoader 为统计口径显示永久代内存状况</li>\n</ul>\n</li>\n<li><p>jstack：Java 堆栈跟踪工具，用于生成 JVM 当前线程快照，-l 参数显示关于加锁信息，-F 参数强制 dump</p>\n</li>\n</ul>\n<h3 id=\"可视化工具\"><a href=\"#可视化工具\" class=\"headerlink\" title=\"可视化工具\"></a>可视化工具</h3><ul>\n<li>VisualVM：多合一故障处理工具，这个几乎涵盖了我用到上面命令行的所有功能</li>\n<li>MemoryAnalyzerTool：用于分析 dump 堆文件，对比 VisualVM 功能单一，但是提供了报表功能可以协助分析问题</li>\n</ul>\n<h2 id=\"问题排查一般思路\"><a href=\"#问题排查一般思路\" class=\"headerlink\" title=\"问题排查一般思路\"></a>问题排查一般思路</h2><p>目前我在实际开发过程中碰到的 JVM 问题主要可以分类两类：内存溢出和系统运行缓慢</p>\n<h3 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h3><p>这种场景是影响最恶劣，但也是最容易排查的。通常的错误就能告诉说明溢出区域：</p>\n<ul>\n<li>outOfMemoryError ：年老代内存不足</li>\n<li>outOfMemoryError:PermGen Space：永久代内存不足</li>\n<li>outOfMemoryError:GC overhead limit exceed：垃圾回收时间占用系统运行时间的98%或以上</li>\n</ul>\n<p>生产环境碰到这类情况为了确保系统可用，可以先使用 jstat 查看 Java 堆的空间使用情况确定到底是哪部分溢出，其最大可用空间是多少，然后直接扩大该区域空间即可。重启时建议加上 -XX:+HeapDumpOnOutMemoryError 作为启动参数，在下次溢出可以获得快照文件。</p>\n<p>上面的做法作为临时解决方案可以解决一般性的问题，但没有系统的快照无法深入分析问题产生的原因，如果想分析问题根源需要在重启前使用 jmap 生成快照。获得快照文件后可以在本地使用可视化工具分析。使用 MemoryAnalyzer 打开快照文件就能获得一个分析报表，里面列出了可能出现泄露的地方。目前我碰到的内存溢出问题一般从这个分析报表里面就可以确定了，如果不能确定就需要根据加载的类，类的实例，引用关系进一步分析了。</p>\n<p>我目前碰到的都是 Java 堆的溢出，以上的思路基本可以解决。但除此还有其他的内存溢出需要注意：</p>\n<ul>\n<li>Direct Memory</li>\n<li>线程堆栈：StackOverflowError，OutOfMemoryError：unable to create new native thread</li>\n<li>Socket 缓冲区：IOException：Too many open files</li>\n</ul>\n<h3 id=\"系统运行缓慢\"><a href=\"#系统运行缓慢\" class=\"headerlink\" title=\"系统运行缓慢\"></a>系统运行缓慢</h3><p>系统运行缓慢可能出现的原因就比较多了，通常就是找到导致系统缓慢的具体代码段，然后修复。一般化的解决思路是从系统到应用，从应用到线程。</p>\n<p>具体来说：首先使用系统监控工具（例如 top，vmstat）查看当前系统运行状况，确认哪个应用的资源占用过大，是否是 Java 应用的问题；其次使用 jps 获得具体应用的 LVMID，根据 LVMID 查看应用的具体运行状况，如线程情况，系统信息等。还可以根据系统工具 pidstat 进一步查看线程的运行信息来辅助确定问题。以上基本就可以确定问题。</p>\n<h3 id=\"本地应用\"><a href=\"#本地应用\" class=\"headerlink\" title=\"本地应用\"></a>本地应用</h3><p>如果是本地应用或者可以远程访问的应用排查起来就更方便了，直接使用 VisualVM 连接上去，从系统到线程的一切信息都了如指掌，还可以直接运行 GC，dump 快照等。</p>\n<hr>\n<ul>\n<li><p>关于工具使用的一些参考：</p>\n<p><a href=\"https://my.oschina.net/feichexia/blog/196575\">JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解</a></p>\n<p><a href=\"http://www.lightskystreet.com/2015/09/01/mat_usage/\">MAT - Memory Analyzer Tool 使用进阶</a></p>\n</li>\n<li><p>jstat 输出列含义：</p>\n<p>S0C：年轻代中第一个survivor的容量 (字节) </p>\n<p>S1C：年轻代中第二个survivor的容量 (字节) </p>\n<p>S0U：年轻代中第一个survivor目前已使用空间 (字节) </p>\n<p>S1U：年轻代中第二个survivor目前已使用空间 (字节) </p>\n<p>EC：年轻代中Eden的容量 (字节) </p>\n<p>EU：年轻代中Eden目前已使用空间 (字节) </p>\n<p>OC：Old代的容量 (字节) </p>\n<p>OU：Old代目前已使用空间 (字节) </p>\n<p>PC：Perm(持久代)的容量 (字节) </p>\n<p>PU：Perm(持久代)目前已使用空间 (字节) </p>\n<p>YGC：从应用程序启动到采样时年轻代中gc次数 </p>\n<p>YGCT：从应用程序启动到采样时年轻代中gc所用时间(s) </p>\n<p>FGC：从应用程序启动到采样时old代(全gc)gc次数 </p>\n<p>FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s) </p>\n<p>GCT：从应用程序启动到采样时gc用的总时间(s) </p>\n<p>NGCMN：年轻代中初始化(最小)的大小 (字节) </p>\n<p>NGCMX：年轻代的最大容量 (字节) </p>\n<p>NGC：年轻代中当前的容量 (字节) </p>\n<p>OGCMN：old代中初始化(最小)的大小 (字节) </p>\n<p>OGCMX：old代的最大容量 (字节) </p>\n<p>OGC：old代当前新生成的容量 (字节) </p>\n<p>PGCMN：perm代中初始化(最小)的大小 (字节) </p>\n<p>PGCMX：perm代的最大容量 (字节) </p>\n<p>PGC：perm代当前新生成的容量 (字节) </p>\n<p>S0：年轻代中第一个survivor已使用的占当前容量百分比 </p>\n<p>S1：年轻代中第二个survivor已使用的占当前容量百分比 </p>\n<p>E：年轻代中Eden已使用的占当前容量百分比 </p>\n<p>O：old代已使用的占当前容量百分比 </p>\n<p>P：perm代已使用的占当前容量百分比 </p>\n<p>S0CMX：年轻代中第一个survivor的最大容量 (字节) </p>\n<p>S1CMX ：年轻代中第二个survivor的最大容量 (字节) </p>\n<p>ECMX：年轻代中Eden的最大容量 (字节) </p>\n<p>DSS：当前需要survivor的容量 (字节)（Eden区已满） </p>\n<p>TT： 持有次数限制 </p>\n<p>MTT ： 最大持有次数限制 </p>\n</li>\n</ul>\n<hr>\n<p>  20171208 补充</p>\n<p>  目前系统接入了 APM（Application Performance Management） 对整个系统的运行进行监控。监控内容包括但不限 JVM 相关内容，非常值得参考。<br>  <a href=\"https://github.com/naver/pinpoint\">APM 传送问</a></p>\n"},{"title":"JDK并发包——线程池","date":"2017-04-16T11:05:56.000Z","_content":"\n## JDK的支持\n\n![Executor.png](https://ooo.0o0.ooo/2017/04/10/58eb4e010f8ef.png)\n\n以上为JDK线程池的核心类,\n\n日常线程池的使用可以以ExecutorService为通用的接口，由Executors生产特定的线程池实现\n\nExecutors提供各种工具方法的支持和基本线程池实现包括：\n\n- newFixedThreadPool\n- newSingleThreadExecutor\n- newCachedThreadPool\n- newSingleThreadScheduledExecutor\n- newScheduledThreadPool\n\nScheduledExecutorService与其他几个线程池不同，提供了三个特殊方法：\n\n- schedule：在给定时间调度一次任务\n- scheduleAtFixedRate：以任务开始时间为起点，按给定频率调度任务\n- scheduleWithFixedDelay：以任务结束时间为起点，按给定频率调度任务\n\n注意：\n\n1. 如果周期太短，那么任务会在上个任务结束后立即调用\n2. 如果任务抛出异常，那么后续所有执行都会被中断\n\n## 线程池实现\n\nThreadPoolExecutor最重要的构造方法：\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory\n                              RejectedExecutionHandler handler);\n```\n\nExecutors提供的不同线程实现就是根据不同参数定制的，有两个参数需要注意：\n\n1. workQueue：被提交但未执行的任务队列\n\n   可以直接使用的几种BlockingQueue：\n\n   - SynchronousQueue：直接提交队列\n   - ArrayBlockingQueue：有界队列\n   - LinkedBlockingQueue：无界队列\n   - PriorityBlockingQueue：优先级队列\n\n   ![ThreadPoolExecutor任务调度逻辑.png](https://ooo.0o0.ooo/2017/04/10/58eb6684c2895.png)\n\n2. handler：拒绝策略，包括：\n\n   - AbortPolicy\n   - CallerRunsPolicy\n   - DiscardOledestPolicy\n   - DiscardPolicy\n   - 实现RejectedExecutionHandler接口自定义\n\n## 线程池基本使用\n\n### 切面扩展\n\n- beforeExecute()\n- afterExecute()\n- terminated()\n\n### 线程池与异常\n\n在线程池中执行线程有两种方法：\n\n- submit\n- execute\n\n两者除了是否有返回值之外，在异常的处理方式上也存在区别。\n\nsubmit是ExecutorService中引入的方法，在AbstractorService中各个重载的submit方法最终都会以`return execute(new FutureTask)`的形式执行。\n\n所以submit线程最终是由线程池调用FutureTask的run方法执行，execute的run方法是由线程调用FutureTask的run方法执行。\n\n看一下FutureTask的源码：\n\n```java\npublic void run() {\n  ...\n  try {\n    Callable<V> c = callable;\n    if (c != null && state == NEW) {\n      V result;\n      boolean ran;\n      try {\n        result = c.call();\n        ran = true;\n      } catch (Throwable ex) {\n        result = null;\n        ran = false;\n        setException(ex);\n      }\n      if (ran)\n        set(result);\n    }\n  } finally {\n  ...\n  }\n}\n\nprotected void setException(Throwable t) {\n  if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n    outcome = t;\n    UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n    finishCompletion();\n    }\n}\n\npublic V get() throws InterruptedException, ExecutionException {\n  int s = state;\n  if (s <= COMPLETING)\n    s = awaitDone(false, 0L);\n  return report(s);\n}\n\nprivate V report(int s) throws ExecutionException {\n  Object x = outcome;\n  if (s == NORMAL)\n    return (V)x;\n  if (s >= CANCELLED)\n    throw new CancellationException();\n  throw new ExecutionException((Throwable)x);\n}\n```\n\n除非你手动get，否则你是得不到任何异常的。使用execute则没有这个问题。\n\n可以重新实现线程池以获取更详细的异常堆栈信息。\n\n### 线程数量\n\n公式：Nthread = Ncpu * Ucpu * （1+ W/C），各字段含义：\n\nNthreads：线程数量\n\nNcpu：CPU的数量，Runtime.getRuntime().availableProcessors()\n\nUcpu：CPU使用率，范围在[0,1]\n\nW/C：等待时间与计算时间的比率\n\n## Fork/Join线程池\n\nFork/Join是分治思想的线程池框架。\n\n核心接口和实现包括：\n\n1. ForkJoinPool：专门为ForkJoin框架提供的线程池\n2. ForkJoinTask：抽象的计算任务\n   1. RecursiveTask：有返回值得具体任务\n   2. RecursiveAction：无返回值的具体任务\n\n使用ForkJoin线程池的优点：\n\n1. 避免大量的开启，回收线程，线程的开启和回收都依赖线程池\n2. 某线程任务处理后可以从其他线程获取任务处理（双端队列，工作密取）\n","source":"_posts/JDK并发包——线程池.md","raw":"---\ntitle: JDK并发包——线程池\ndate: 2017-04-16 19:05:56\ntags:\n  - Java\n  - 并发\ncategories: Java\n---\n\n## JDK的支持\n\n![Executor.png](https://ooo.0o0.ooo/2017/04/10/58eb4e010f8ef.png)\n\n以上为JDK线程池的核心类,\n\n日常线程池的使用可以以ExecutorService为通用的接口，由Executors生产特定的线程池实现\n\nExecutors提供各种工具方法的支持和基本线程池实现包括：\n\n- newFixedThreadPool\n- newSingleThreadExecutor\n- newCachedThreadPool\n- newSingleThreadScheduledExecutor\n- newScheduledThreadPool\n\nScheduledExecutorService与其他几个线程池不同，提供了三个特殊方法：\n\n- schedule：在给定时间调度一次任务\n- scheduleAtFixedRate：以任务开始时间为起点，按给定频率调度任务\n- scheduleWithFixedDelay：以任务结束时间为起点，按给定频率调度任务\n\n注意：\n\n1. 如果周期太短，那么任务会在上个任务结束后立即调用\n2. 如果任务抛出异常，那么后续所有执行都会被中断\n\n## 线程池实现\n\nThreadPoolExecutor最重要的构造方法：\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory\n                              RejectedExecutionHandler handler);\n```\n\nExecutors提供的不同线程实现就是根据不同参数定制的，有两个参数需要注意：\n\n1. workQueue：被提交但未执行的任务队列\n\n   可以直接使用的几种BlockingQueue：\n\n   - SynchronousQueue：直接提交队列\n   - ArrayBlockingQueue：有界队列\n   - LinkedBlockingQueue：无界队列\n   - PriorityBlockingQueue：优先级队列\n\n   ![ThreadPoolExecutor任务调度逻辑.png](https://ooo.0o0.ooo/2017/04/10/58eb6684c2895.png)\n\n2. handler：拒绝策略，包括：\n\n   - AbortPolicy\n   - CallerRunsPolicy\n   - DiscardOledestPolicy\n   - DiscardPolicy\n   - 实现RejectedExecutionHandler接口自定义\n\n## 线程池基本使用\n\n### 切面扩展\n\n- beforeExecute()\n- afterExecute()\n- terminated()\n\n### 线程池与异常\n\n在线程池中执行线程有两种方法：\n\n- submit\n- execute\n\n两者除了是否有返回值之外，在异常的处理方式上也存在区别。\n\nsubmit是ExecutorService中引入的方法，在AbstractorService中各个重载的submit方法最终都会以`return execute(new FutureTask)`的形式执行。\n\n所以submit线程最终是由线程池调用FutureTask的run方法执行，execute的run方法是由线程调用FutureTask的run方法执行。\n\n看一下FutureTask的源码：\n\n```java\npublic void run() {\n  ...\n  try {\n    Callable<V> c = callable;\n    if (c != null && state == NEW) {\n      V result;\n      boolean ran;\n      try {\n        result = c.call();\n        ran = true;\n      } catch (Throwable ex) {\n        result = null;\n        ran = false;\n        setException(ex);\n      }\n      if (ran)\n        set(result);\n    }\n  } finally {\n  ...\n  }\n}\n\nprotected void setException(Throwable t) {\n  if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n    outcome = t;\n    UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n    finishCompletion();\n    }\n}\n\npublic V get() throws InterruptedException, ExecutionException {\n  int s = state;\n  if (s <= COMPLETING)\n    s = awaitDone(false, 0L);\n  return report(s);\n}\n\nprivate V report(int s) throws ExecutionException {\n  Object x = outcome;\n  if (s == NORMAL)\n    return (V)x;\n  if (s >= CANCELLED)\n    throw new CancellationException();\n  throw new ExecutionException((Throwable)x);\n}\n```\n\n除非你手动get，否则你是得不到任何异常的。使用execute则没有这个问题。\n\n可以重新实现线程池以获取更详细的异常堆栈信息。\n\n### 线程数量\n\n公式：Nthread = Ncpu * Ucpu * （1+ W/C），各字段含义：\n\nNthreads：线程数量\n\nNcpu：CPU的数量，Runtime.getRuntime().availableProcessors()\n\nUcpu：CPU使用率，范围在[0,1]\n\nW/C：等待时间与计算时间的比率\n\n## Fork/Join线程池\n\nFork/Join是分治思想的线程池框架。\n\n核心接口和实现包括：\n\n1. ForkJoinPool：专门为ForkJoin框架提供的线程池\n2. ForkJoinTask：抽象的计算任务\n   1. RecursiveTask：有返回值得具体任务\n   2. RecursiveAction：无返回值的具体任务\n\n使用ForkJoin线程池的优点：\n\n1. 避免大量的开启，回收线程，线程的开启和回收都依赖线程池\n2. 某线程任务处理后可以从其他线程获取任务处理（双端队列，工作密取）\n","slug":"JDK并发包——线程池","published":1,"updated":"2017-04-16T11:16:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2p4000id82ewpn1xrcb","content":"<h2 id=\"JDK的支持\"><a href=\"#JDK的支持\" class=\"headerlink\" title=\"JDK的支持\"></a>JDK的支持</h2><p><img src=\"https://ooo.0o0.ooo/2017/04/10/58eb4e010f8ef.png\" alt=\"Executor.png\"></p>\n<p>以上为JDK线程池的核心类,</p>\n<p>日常线程池的使用可以以ExecutorService为通用的接口，由Executors生产特定的线程池实现</p>\n<p>Executors提供各种工具方法的支持和基本线程池实现包括：</p>\n<ul>\n<li>newFixedThreadPool</li>\n<li>newSingleThreadExecutor</li>\n<li>newCachedThreadPool</li>\n<li>newSingleThreadScheduledExecutor</li>\n<li>newScheduledThreadPool</li>\n</ul>\n<p>ScheduledExecutorService与其他几个线程池不同，提供了三个特殊方法：</p>\n<ul>\n<li>schedule：在给定时间调度一次任务</li>\n<li>scheduleAtFixedRate：以任务开始时间为起点，按给定频率调度任务</li>\n<li>scheduleWithFixedDelay：以任务结束时间为起点，按给定频率调度任务</li>\n</ul>\n<p>注意：</p>\n<ol>\n<li>如果周期太短，那么任务会在上个任务结束后立即调用</li>\n<li>如果任务抛出异常，那么后续所有执行都会被中断</li>\n</ol>\n<h2 id=\"线程池实现\"><a href=\"#线程池实现\" class=\"headerlink\" title=\"线程池实现\"></a>线程池实现</h2><p>ThreadPoolExecutor最重要的构造方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ThreadPoolExecutor(int corePoolSize,</div><div class=\"line\">                              int maximumPoolSize,</div><div class=\"line\">                              long keepAliveTime,</div><div class=\"line\">                              TimeUnit unit,</div><div class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class=\"line\">                              ThreadFactory threadFactory</div><div class=\"line\">                              RejectedExecutionHandler handler);</div></pre></td></tr></table></figure>\n<p>Executors提供的不同线程实现就是根据不同参数定制的，有两个参数需要注意：</p>\n<ol>\n<li><p>workQueue：被提交但未执行的任务队列</p>\n<p>可以直接使用的几种BlockingQueue：</p>\n<ul>\n<li>SynchronousQueue：直接提交队列</li>\n<li>ArrayBlockingQueue：有界队列</li>\n<li>LinkedBlockingQueue：无界队列</li>\n<li>PriorityBlockingQueue：优先级队列</li>\n</ul>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/10/58eb6684c2895.png\" alt=\"ThreadPoolExecutor任务调度逻辑.png\"></p>\n</li>\n<li><p>handler：拒绝策略，包括：</p>\n<ul>\n<li>AbortPolicy</li>\n<li>CallerRunsPolicy</li>\n<li>DiscardOledestPolicy</li>\n<li>DiscardPolicy</li>\n<li>实现RejectedExecutionHandler接口自定义</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"线程池基本使用\"><a href=\"#线程池基本使用\" class=\"headerlink\" title=\"线程池基本使用\"></a>线程池基本使用</h2><h3 id=\"切面扩展\"><a href=\"#切面扩展\" class=\"headerlink\" title=\"切面扩展\"></a>切面扩展</h3><ul>\n<li>beforeExecute()</li>\n<li>afterExecute()</li>\n<li>terminated()</li>\n</ul>\n<h3 id=\"线程池与异常\"><a href=\"#线程池与异常\" class=\"headerlink\" title=\"线程池与异常\"></a>线程池与异常</h3><p>在线程池中执行线程有两种方法：</p>\n<ul>\n<li>submit</li>\n<li>execute</li>\n</ul>\n<p>两者除了是否有返回值之外，在异常的处理方式上也存在区别。</p>\n<p>submit是ExecutorService中引入的方法，在AbstractorService中各个重载的submit方法最终都会以<code>return execute(new FutureTask)</code>的形式执行。</p>\n<p>所以submit线程最终是由线程池调用FutureTask的run方法执行，execute的run方法是由线程调用FutureTask的run方法执行。</p>\n<p>看一下FutureTask的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    Callable&lt;V&gt; c = callable;</div><div class=\"line\">    <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123;</div><div class=\"line\">      V result;</div><div class=\"line\">      <span class=\"keyword\">boolean</span> ran;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        result = c.call();</div><div class=\"line\">        ran = <span class=\"keyword\">true</span>;</div><div class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">        result = <span class=\"keyword\">null</span>;</div><div class=\"line\">        ran = <span class=\"keyword\">false</span>;</div><div class=\"line\">        setException(ex);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (ran)</div><div class=\"line\">        set(result);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setException</span><span class=\"params\">(Throwable t)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW, COMPLETING)) &#123;</div><div class=\"line\">    outcome = t;</div><div class=\"line\">    UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, EXCEPTIONAL); <span class=\"comment\">// final state</span></div><div class=\"line\">    finishCompletion();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> s = state;</div><div class=\"line\">  <span class=\"keyword\">if</span> (s &lt;= COMPLETING)</div><div class=\"line\">    s = awaitDone(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> report(s);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">report</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> <span class=\"keyword\">throws</span> ExecutionException </span>&#123;</div><div class=\"line\">  Object x = outcome;</div><div class=\"line\">  <span class=\"keyword\">if</span> (s == NORMAL)</div><div class=\"line\">    <span class=\"keyword\">return</span> (V)x;</div><div class=\"line\">  <span class=\"keyword\">if</span> (s &gt;= CANCELLED)</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ExecutionException((Throwable)x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除非你手动get，否则你是得不到任何异常的。使用execute则没有这个问题。</p>\n<p>可以重新实现线程池以获取更详细的异常堆栈信息。</p>\n<h3 id=\"线程数量\"><a href=\"#线程数量\" class=\"headerlink\" title=\"线程数量\"></a>线程数量</h3><p>公式：Nthread = Ncpu <em> Ucpu </em> （1+ W/C），各字段含义：</p>\n<p>Nthreads：线程数量</p>\n<p>Ncpu：CPU的数量，Runtime.getRuntime().availableProcessors()</p>\n<p>Ucpu：CPU使用率，范围在[0,1]</p>\n<p>W/C：等待时间与计算时间的比率</p>\n<h2 id=\"Fork-Join线程池\"><a href=\"#Fork-Join线程池\" class=\"headerlink\" title=\"Fork/Join线程池\"></a>Fork/Join线程池</h2><p>Fork/Join是分治思想的线程池框架。</p>\n<p>核心接口和实现包括：</p>\n<ol>\n<li>ForkJoinPool：专门为ForkJoin框架提供的线程池</li>\n<li>ForkJoinTask：抽象的计算任务<ol>\n<li>RecursiveTask：有返回值得具体任务</li>\n<li>RecursiveAction：无返回值的具体任务</li>\n</ol>\n</li>\n</ol>\n<p>使用ForkJoin线程池的优点：</p>\n<ol>\n<li>避免大量的开启，回收线程，线程的开启和回收都依赖线程池</li>\n<li>某线程任务处理后可以从其他线程获取任务处理（双端队列，工作密取）</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"JDK的支持\"><a href=\"#JDK的支持\" class=\"headerlink\" title=\"JDK的支持\"></a>JDK的支持</h2><p><img src=\"https://ooo.0o0.ooo/2017/04/10/58eb4e010f8ef.png\" alt=\"Executor.png\"></p>\n<p>以上为JDK线程池的核心类,</p>\n<p>日常线程池的使用可以以ExecutorService为通用的接口，由Executors生产特定的线程池实现</p>\n<p>Executors提供各种工具方法的支持和基本线程池实现包括：</p>\n<ul>\n<li>newFixedThreadPool</li>\n<li>newSingleThreadExecutor</li>\n<li>newCachedThreadPool</li>\n<li>newSingleThreadScheduledExecutor</li>\n<li>newScheduledThreadPool</li>\n</ul>\n<p>ScheduledExecutorService与其他几个线程池不同，提供了三个特殊方法：</p>\n<ul>\n<li>schedule：在给定时间调度一次任务</li>\n<li>scheduleAtFixedRate：以任务开始时间为起点，按给定频率调度任务</li>\n<li>scheduleWithFixedDelay：以任务结束时间为起点，按给定频率调度任务</li>\n</ul>\n<p>注意：</p>\n<ol>\n<li>如果周期太短，那么任务会在上个任务结束后立即调用</li>\n<li>如果任务抛出异常，那么后续所有执行都会被中断</li>\n</ol>\n<h2 id=\"线程池实现\"><a href=\"#线程池实现\" class=\"headerlink\" title=\"线程池实现\"></a>线程池实现</h2><p>ThreadPoolExecutor最重要的构造方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ThreadPoolExecutor(int corePoolSize,</div><div class=\"line\">                              int maximumPoolSize,</div><div class=\"line\">                              long keepAliveTime,</div><div class=\"line\">                              TimeUnit unit,</div><div class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class=\"line\">                              ThreadFactory threadFactory</div><div class=\"line\">                              RejectedExecutionHandler handler);</div></pre></td></tr></table></figure>\n<p>Executors提供的不同线程实现就是根据不同参数定制的，有两个参数需要注意：</p>\n<ol>\n<li><p>workQueue：被提交但未执行的任务队列</p>\n<p>可以直接使用的几种BlockingQueue：</p>\n<ul>\n<li>SynchronousQueue：直接提交队列</li>\n<li>ArrayBlockingQueue：有界队列</li>\n<li>LinkedBlockingQueue：无界队列</li>\n<li>PriorityBlockingQueue：优先级队列</li>\n</ul>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/10/58eb6684c2895.png\" alt=\"ThreadPoolExecutor任务调度逻辑.png\"></p>\n</li>\n<li><p>handler：拒绝策略，包括：</p>\n<ul>\n<li>AbortPolicy</li>\n<li>CallerRunsPolicy</li>\n<li>DiscardOledestPolicy</li>\n<li>DiscardPolicy</li>\n<li>实现RejectedExecutionHandler接口自定义</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"线程池基本使用\"><a href=\"#线程池基本使用\" class=\"headerlink\" title=\"线程池基本使用\"></a>线程池基本使用</h2><h3 id=\"切面扩展\"><a href=\"#切面扩展\" class=\"headerlink\" title=\"切面扩展\"></a>切面扩展</h3><ul>\n<li>beforeExecute()</li>\n<li>afterExecute()</li>\n<li>terminated()</li>\n</ul>\n<h3 id=\"线程池与异常\"><a href=\"#线程池与异常\" class=\"headerlink\" title=\"线程池与异常\"></a>线程池与异常</h3><p>在线程池中执行线程有两种方法：</p>\n<ul>\n<li>submit</li>\n<li>execute</li>\n</ul>\n<p>两者除了是否有返回值之外，在异常的处理方式上也存在区别。</p>\n<p>submit是ExecutorService中引入的方法，在AbstractorService中各个重载的submit方法最终都会以<code>return execute(new FutureTask)</code>的形式执行。</p>\n<p>所以submit线程最终是由线程池调用FutureTask的run方法执行，execute的run方法是由线程调用FutureTask的run方法执行。</p>\n<p>看一下FutureTask的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    Callable&lt;V&gt; c = callable;</div><div class=\"line\">    <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123;</div><div class=\"line\">      V result;</div><div class=\"line\">      <span class=\"keyword\">boolean</span> ran;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        result = c.call();</div><div class=\"line\">        ran = <span class=\"keyword\">true</span>;</div><div class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">        result = <span class=\"keyword\">null</span>;</div><div class=\"line\">        ran = <span class=\"keyword\">false</span>;</div><div class=\"line\">        setException(ex);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (ran)</div><div class=\"line\">        set(result);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setException</span><span class=\"params\">(Throwable t)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW, COMPLETING)) &#123;</div><div class=\"line\">    outcome = t;</div><div class=\"line\">    UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, EXCEPTIONAL); <span class=\"comment\">// final state</span></div><div class=\"line\">    finishCompletion();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> s = state;</div><div class=\"line\">  <span class=\"keyword\">if</span> (s &lt;= COMPLETING)</div><div class=\"line\">    s = awaitDone(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> report(s);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">report</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> <span class=\"keyword\">throws</span> ExecutionException </span>&#123;</div><div class=\"line\">  Object x = outcome;</div><div class=\"line\">  <span class=\"keyword\">if</span> (s == NORMAL)</div><div class=\"line\">    <span class=\"keyword\">return</span> (V)x;</div><div class=\"line\">  <span class=\"keyword\">if</span> (s &gt;= CANCELLED)</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ExecutionException((Throwable)x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除非你手动get，否则你是得不到任何异常的。使用execute则没有这个问题。</p>\n<p>可以重新实现线程池以获取更详细的异常堆栈信息。</p>\n<h3 id=\"线程数量\"><a href=\"#线程数量\" class=\"headerlink\" title=\"线程数量\"></a>线程数量</h3><p>公式：Nthread = Ncpu <em> Ucpu </em> （1+ W/C），各字段含义：</p>\n<p>Nthreads：线程数量</p>\n<p>Ncpu：CPU的数量，Runtime.getRuntime().availableProcessors()</p>\n<p>Ucpu：CPU使用率，范围在[0,1]</p>\n<p>W/C：等待时间与计算时间的比率</p>\n<h2 id=\"Fork-Join线程池\"><a href=\"#Fork-Join线程池\" class=\"headerlink\" title=\"Fork/Join线程池\"></a>Fork/Join线程池</h2><p>Fork/Join是分治思想的线程池框架。</p>\n<p>核心接口和实现包括：</p>\n<ol>\n<li>ForkJoinPool：专门为ForkJoin框架提供的线程池</li>\n<li>ForkJoinTask：抽象的计算任务<ol>\n<li>RecursiveTask：有返回值得具体任务</li>\n<li>RecursiveAction：无返回值的具体任务</li>\n</ol>\n</li>\n</ol>\n<p>使用ForkJoin线程池的优点：</p>\n<ol>\n<li>避免大量的开启，回收线程，线程的开启和回收都依赖线程池</li>\n<li>某线程任务处理后可以从其他线程获取任务处理（双端队列，工作密取）</li>\n</ol>\n"},{"title":"JVM知识拾遗","date":"2017-12-08T13:36:30.000Z","_content":"\n## 运行时数据区域\n\n谈论到运行时数据区可能有非常多词在脑海中闪现：堆、栈、新生代、老年代、永久区、方法区等等。上面这些概念确实都位于运行时数据区，但从 JVM 功能实现的角度没有这么多概念，例如老年代，新生代都是从垃圾收集的角度去分析。单纯从 JVM 功能实现角度可以用下图概括：\n\n![运行时数据区](https://camo.githubusercontent.com/8799029281fbeed32ea53e95df7c82042a3dff21/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031372f30372f30322f353935383832373332333737312e706e67)\n\n### 线程私有区域\n\n- 程序计数器\n\n  当先线程所执行的字节码的行号执行器\n\n- Java 虚拟机栈\n\n  与线程一致的声明周期。由若干个栈帧组成，每个栈帧对应一个方法。栈帧存储局部变量表、操作数栈等信息\n\n### 线程共享区域\n\n- Java堆\n\n  Java 堆主要用于存放对象实例，所有线程共享的内存区域统称为 Java 堆，但其内部又划分为若干个逻辑区域。从功能的角度上看 Java 堆存放对象实例，可以分为新生代、老年代。\n\n\n- 方法区\n\n  Java 堆的一个逻辑区域，但功能上与 Java 堆有明显的区别。主要是存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。内部重要区域：运行时常量池。\n\n  在方法区这部分有几个混淆的概念：方法区，永久代，元空间：\n\n  - 方法区：JVM 规范中定义的区域\n  - 永久代：HotSpot 在 JDK1.8 之前对方法区的实现，使用 Java 堆内存\n  - 元空间；HotSpot 在 JDK1.8 开始对方法区的实现，该区域使用本地内存\n\n《深入理解 Java 虚拟机》一书在第 2 章从内存溢出的角度详细的说明了运行时数据区域（甚至包括了非虚拟机运行时数据区域），个人感觉区域之间层次描述稍弱，内容也较多，从 JVM 运行模型的角度上面的概括更容易理解。\n\n## 内存分配与回收\n\n单纯从 JVM 功能实现的角度考虑，对象内存的分配和回收就是对堆空间的操作。但为了高效的自动回收内存，一般把 Java 堆分为新生代和老年代，二者在对象内存分配和回收策略上有所区别。区别的根本原因是为了内存回收，所以先从内存回收策略看起——垃圾收集算法。\n\n### 垃圾收集算法\n\n- 标记-清除\n  - 最基本的垃圾收集算法\n  - 效率不高；内存碎片\n- 复制算法\n  - 适合“朝生夕死”的对象，新生代收集算法\n  - 由三部分组成：两个小块 Survivor 和一个大块 Eden，HotSpot 默认比例8:1:1，每次使用一个 Survivor 和一个 Eden\n  - 当 Survivor 空间不足时依赖其他内存进行担保\n- 标记-整理\n  - 适合存活率高对象\n  - 标记-清除-整理\n\n### 内存分配\n\n内存分配没有绝对的准则，采用不同的垃圾收集器，JVM 实现，JVM 参数可能得到不同的分配策略。但有几条普遍策略：\n\n- 对象优先在  Eden 分配\n- 大对象直接进入老年代\n- 长期存活的对象将进入老年代\n- 动态对象年龄判定：如果在 Survivor 中间中相同年龄所有对象大小的综合大于 Survovor 空间一半，年龄大于等于该年龄的对象直接晋升老年代\n- 空间分配担保\n\n### 垃圾收集器\n\n先放一张垃圾收集器的组合\n\n![GC.png](https://ooo.0o0.ooo/2017/09/19/59c0ee65ee2a4.png)\n\n#### 新生代收集器\n\n##### Serial\n\n![Serial.jpg](https://i.loli.net/2017/09/19/59c1060eed6f0.jpg)\n\n单线程垃圾收集器，进行垃圾收集的时候需要暂停其他的线程\n\n##### ParNew\n\n![PaeNew.jpg](https://i.loli.net/2017/09/19/59c10658676f9.jpg)\n\nSerial收集器的多线程版本，许多运行在Server模式下的虚拟机中首选的新生代收集器，可以与CMS收集器配合工作\n\n##### Parallel Scavenge\n\n并行的多线程收集器，更关注可控制的吞吐量。吞吐量越大，垃圾收集的时间越短。目前没有使用过。\n\n#### 老年代收集器\n\n##### Serial Old\n\nSerial收集器的老年代版本，也是一个单线程收集器，采用“标记-整理算法”进行回收。其运行过程与Serial收集器一样。\n\n用途：\n\n- 与Parallel Scavenge收集器搭配使用\n- 作为CMS收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用\n\n##### Parallel Old\n\n![Parallel Old.jpg](https://i.loli.net/2017/09/19/59c106f16c0e9.jpg)\n\nParallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法进行垃圾回收。与 Parallel Scavenge 收集器配合使用，“吞吐量优先”收集器是这个组合的特点，在注重吞吐量和CPU资源敏感的场合，都可以使用这个组合。\n\n##### CMS\n\n![1505822517(1).jpg](https://i.loli.net/2017/09/19/59c1075791807.jpg)\n\n为获取最短回收停顿时间而生的老年代垃圾收集器（标记-清除算法）。整个执行过程分为 4 个步骤：\n\n- 初始标记：仅标记 GC Roots 直接可达的对象，需要 STW\n- 并发标记：GC Roots Tracing，并行\n- 重新标记：修正上一步执行中变动的标记记录\n- 并发清除：并行\n\n缺点：对 CPU 资源敏感，无法有效处理浮动垃圾，无法有效处理内存碎片\n\n目前我在项目中使用最多的垃圾收集器，从 GC 日志来看，STW 时间确实少，以最近一次本地 GC 日志说明：85% 的 GC 时间持续一秒内，但最大的 STW 时间只有 160 ms，平均 STW 时间 135 ms。\n\n##### G1 收集器\n\n目前这个收集器完全没有使用过。从描述上看是神一般的存在。大致思想是将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region（化整为零）。\n\n![1505823191(1).jpg](https://i.loli.net/2017/09/19/59c109faa5c94.jpg)\n\n---\n\n以上收集器虽然多，但还是有规律可以总结的：\n\n- Serial：是最原始的新生代收集器\n- Parnew：多线程版本的 Serial 新生代收集器\n- Parallel Scavenge：吞吐量优先新生代收集器\n- Serial Old：最原始的老年代收集器，万能备胎\n- Parallel Scavenge：吞吐量优先老年代收集器\n- CMS：多线程版本的老年代收集器\n\n## 备忘录\n\n### 虚拟机参数小结\n\n| 参数                         | 描述                        |\n| -------------------------- | ------------------------- |\n| -Xms                       | 初始堆大小                     |\n| -Xmx                       | 最大堆大小                     |\n| -Xmn                       | 新生代大小                     |\n| -Xss                       | 每个线程的堆栈大小                 |\n| -XX:NewRatio               | 新生代和老年代的比例                |\n| -XX:SurvivorRatio          | 新生代 Eden 区和 Survivor区域的比例 |\n| -XX:PermSize               | 永久代的初始大小                  |\n| -XX:MaxPermSize            | 永久代的最大值                   |\n| –XX:MetaspaceSize          | 元空间的初始大小                  |\n| -XX:MaxMetaspaceSize       | 元空间的最大值                   |\n| -XX:MaxTenuringThreshold   | 超过设置年龄的新生代直接晋升老年代         |\n| -XX:PretenureSizeThreshold | 超过设置大小的新生代直接晋升老年代         |\n| -XX:+PrintGC               | 每次 GC 时打印相关信息             |\n| -XX:+PrintGC Details       | 每次 GC 时打印详细信息             |\n| -XX:+PrintGCTimeStamps     | 打印每次 GC 的时间戳              |\n| -Xloggc                    | 是将每次GC事件的相关情况记录到文件中       |\n\n### 垃圾收集器参数总结\n\n| 参数                                 | 描述                                       |\n| ---------------------------------- | ---------------------------------------- |\n| -XX:+UseSerialGC                   | 使用 Serial + Serial Old 收集器组合             |\n| -XX:+UseParNewGC                   | 使用 ParNew + Serial Old 收集器组合             |\n| -XX:+UseConcMarkSweepGC            | 使用 ParNew + CMS + Serial Old 收集器组合       |\n| -XX:+UseParallelGC                 | 使用 Parallel Scavenge + Serial Old 收集器组合  |\n| -XX:+UseParallelOldGC              | 使用 Parallel Scavenge + Parallel Old 收集器组合 |\n| -XX:ParallelGCThreads              | 设置并行 GC 时进行内存回收的线程数                      |\n| -XX:GCTimeRatio                    | Parallel Scavenge 中 GC 时间占比，默认 99，即允许 1% 的 GC 时间。 |\n| -XX:MaxGCPauseMillis               | 设置 GC 的最大停顿时间，只对 Parallel Scavenge 有效    |\n| -XX:CMSInitiatingOccupancyFraction | 设置 CMS 收集器在老年代空间被使用多少后触发垃圾收集             |\n| -XX:+UseCMSCompactAtFullCollection | 设置 CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理          |\n| -XX:+CMSFullGCBeforeCompaction     | 设置 CMS 收集器在完成若干次垃圾收集后是进行一次内存碎片整理         |\n\n### 启动参数的选择\n\n启动参数大体指定三部分：设置收集器相关配置、设置内存分配相关配置，其他。\n\n对于收集器，目前我我基本上都使用 ParNew（新生代）+ CMS（老年代）+ Serial Old（老年代备用）组合。可能需要指定的参数还有：-XX:ParallelGCThreads，-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSCompactAtFullCollection，-XX:+CMSFullGCBeforeCompaction。但目前实际上我都没有特殊指定（设置过线程数，但发现效果并不理想）。\n\n对于内存分配，这个就要结合项目和环境的具体信息配置了。\n\n其他部分就包括：对 GC 过程、类加载卸载等信息的输出，异常 Dump 等信息。\n\n完成以上配置后，还需要根据系统运行状况，GC 日志的情况进一步调整参数。对 GC 日志的分析可以使用 [gceasy](http://gceasy.io/index.jsp) 分析，系统运行状况可以参考后面的文章《JVM 故障发现和排查》。\n\n---\n\n参考：\n\n- 《深入理解 Java 虚拟机》\n- [Java永久代去哪儿了](http://www.infoq.com/cn/articles/Java-PERMGEN-Removed)\n- [Java8内存模型—永久代(PermGen)和元空间(Metaspace)](http://www.cnblogs.com/paddix/p/5309550.html)\n","source":"_posts/JVM知识拾遗.md","raw":"---\ntitle: JVM知识拾遗\ndate: 2017-12-08 21:36:30\ntags:\n  - Java\n  - JVM\ncategories: JVM\n---\n\n## 运行时数据区域\n\n谈论到运行时数据区可能有非常多词在脑海中闪现：堆、栈、新生代、老年代、永久区、方法区等等。上面这些概念确实都位于运行时数据区，但从 JVM 功能实现的角度没有这么多概念，例如老年代，新生代都是从垃圾收集的角度去分析。单纯从 JVM 功能实现角度可以用下图概括：\n\n![运行时数据区](https://camo.githubusercontent.com/8799029281fbeed32ea53e95df7c82042a3dff21/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031372f30372f30322f353935383832373332333737312e706e67)\n\n### 线程私有区域\n\n- 程序计数器\n\n  当先线程所执行的字节码的行号执行器\n\n- Java 虚拟机栈\n\n  与线程一致的声明周期。由若干个栈帧组成，每个栈帧对应一个方法。栈帧存储局部变量表、操作数栈等信息\n\n### 线程共享区域\n\n- Java堆\n\n  Java 堆主要用于存放对象实例，所有线程共享的内存区域统称为 Java 堆，但其内部又划分为若干个逻辑区域。从功能的角度上看 Java 堆存放对象实例，可以分为新生代、老年代。\n\n\n- 方法区\n\n  Java 堆的一个逻辑区域，但功能上与 Java 堆有明显的区别。主要是存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。内部重要区域：运行时常量池。\n\n  在方法区这部分有几个混淆的概念：方法区，永久代，元空间：\n\n  - 方法区：JVM 规范中定义的区域\n  - 永久代：HotSpot 在 JDK1.8 之前对方法区的实现，使用 Java 堆内存\n  - 元空间；HotSpot 在 JDK1.8 开始对方法区的实现，该区域使用本地内存\n\n《深入理解 Java 虚拟机》一书在第 2 章从内存溢出的角度详细的说明了运行时数据区域（甚至包括了非虚拟机运行时数据区域），个人感觉区域之间层次描述稍弱，内容也较多，从 JVM 运行模型的角度上面的概括更容易理解。\n\n## 内存分配与回收\n\n单纯从 JVM 功能实现的角度考虑，对象内存的分配和回收就是对堆空间的操作。但为了高效的自动回收内存，一般把 Java 堆分为新生代和老年代，二者在对象内存分配和回收策略上有所区别。区别的根本原因是为了内存回收，所以先从内存回收策略看起——垃圾收集算法。\n\n### 垃圾收集算法\n\n- 标记-清除\n  - 最基本的垃圾收集算法\n  - 效率不高；内存碎片\n- 复制算法\n  - 适合“朝生夕死”的对象，新生代收集算法\n  - 由三部分组成：两个小块 Survivor 和一个大块 Eden，HotSpot 默认比例8:1:1，每次使用一个 Survivor 和一个 Eden\n  - 当 Survivor 空间不足时依赖其他内存进行担保\n- 标记-整理\n  - 适合存活率高对象\n  - 标记-清除-整理\n\n### 内存分配\n\n内存分配没有绝对的准则，采用不同的垃圾收集器，JVM 实现，JVM 参数可能得到不同的分配策略。但有几条普遍策略：\n\n- 对象优先在  Eden 分配\n- 大对象直接进入老年代\n- 长期存活的对象将进入老年代\n- 动态对象年龄判定：如果在 Survivor 中间中相同年龄所有对象大小的综合大于 Survovor 空间一半，年龄大于等于该年龄的对象直接晋升老年代\n- 空间分配担保\n\n### 垃圾收集器\n\n先放一张垃圾收集器的组合\n\n![GC.png](https://ooo.0o0.ooo/2017/09/19/59c0ee65ee2a4.png)\n\n#### 新生代收集器\n\n##### Serial\n\n![Serial.jpg](https://i.loli.net/2017/09/19/59c1060eed6f0.jpg)\n\n单线程垃圾收集器，进行垃圾收集的时候需要暂停其他的线程\n\n##### ParNew\n\n![PaeNew.jpg](https://i.loli.net/2017/09/19/59c10658676f9.jpg)\n\nSerial收集器的多线程版本，许多运行在Server模式下的虚拟机中首选的新生代收集器，可以与CMS收集器配合工作\n\n##### Parallel Scavenge\n\n并行的多线程收集器，更关注可控制的吞吐量。吞吐量越大，垃圾收集的时间越短。目前没有使用过。\n\n#### 老年代收集器\n\n##### Serial Old\n\nSerial收集器的老年代版本，也是一个单线程收集器，采用“标记-整理算法”进行回收。其运行过程与Serial收集器一样。\n\n用途：\n\n- 与Parallel Scavenge收集器搭配使用\n- 作为CMS收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用\n\n##### Parallel Old\n\n![Parallel Old.jpg](https://i.loli.net/2017/09/19/59c106f16c0e9.jpg)\n\nParallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法进行垃圾回收。与 Parallel Scavenge 收集器配合使用，“吞吐量优先”收集器是这个组合的特点，在注重吞吐量和CPU资源敏感的场合，都可以使用这个组合。\n\n##### CMS\n\n![1505822517(1).jpg](https://i.loli.net/2017/09/19/59c1075791807.jpg)\n\n为获取最短回收停顿时间而生的老年代垃圾收集器（标记-清除算法）。整个执行过程分为 4 个步骤：\n\n- 初始标记：仅标记 GC Roots 直接可达的对象，需要 STW\n- 并发标记：GC Roots Tracing，并行\n- 重新标记：修正上一步执行中变动的标记记录\n- 并发清除：并行\n\n缺点：对 CPU 资源敏感，无法有效处理浮动垃圾，无法有效处理内存碎片\n\n目前我在项目中使用最多的垃圾收集器，从 GC 日志来看，STW 时间确实少，以最近一次本地 GC 日志说明：85% 的 GC 时间持续一秒内，但最大的 STW 时间只有 160 ms，平均 STW 时间 135 ms。\n\n##### G1 收集器\n\n目前这个收集器完全没有使用过。从描述上看是神一般的存在。大致思想是将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region（化整为零）。\n\n![1505823191(1).jpg](https://i.loli.net/2017/09/19/59c109faa5c94.jpg)\n\n---\n\n以上收集器虽然多，但还是有规律可以总结的：\n\n- Serial：是最原始的新生代收集器\n- Parnew：多线程版本的 Serial 新生代收集器\n- Parallel Scavenge：吞吐量优先新生代收集器\n- Serial Old：最原始的老年代收集器，万能备胎\n- Parallel Scavenge：吞吐量优先老年代收集器\n- CMS：多线程版本的老年代收集器\n\n## 备忘录\n\n### 虚拟机参数小结\n\n| 参数                         | 描述                        |\n| -------------------------- | ------------------------- |\n| -Xms                       | 初始堆大小                     |\n| -Xmx                       | 最大堆大小                     |\n| -Xmn                       | 新生代大小                     |\n| -Xss                       | 每个线程的堆栈大小                 |\n| -XX:NewRatio               | 新生代和老年代的比例                |\n| -XX:SurvivorRatio          | 新生代 Eden 区和 Survivor区域的比例 |\n| -XX:PermSize               | 永久代的初始大小                  |\n| -XX:MaxPermSize            | 永久代的最大值                   |\n| –XX:MetaspaceSize          | 元空间的初始大小                  |\n| -XX:MaxMetaspaceSize       | 元空间的最大值                   |\n| -XX:MaxTenuringThreshold   | 超过设置年龄的新生代直接晋升老年代         |\n| -XX:PretenureSizeThreshold | 超过设置大小的新生代直接晋升老年代         |\n| -XX:+PrintGC               | 每次 GC 时打印相关信息             |\n| -XX:+PrintGC Details       | 每次 GC 时打印详细信息             |\n| -XX:+PrintGCTimeStamps     | 打印每次 GC 的时间戳              |\n| -Xloggc                    | 是将每次GC事件的相关情况记录到文件中       |\n\n### 垃圾收集器参数总结\n\n| 参数                                 | 描述                                       |\n| ---------------------------------- | ---------------------------------------- |\n| -XX:+UseSerialGC                   | 使用 Serial + Serial Old 收集器组合             |\n| -XX:+UseParNewGC                   | 使用 ParNew + Serial Old 收集器组合             |\n| -XX:+UseConcMarkSweepGC            | 使用 ParNew + CMS + Serial Old 收集器组合       |\n| -XX:+UseParallelGC                 | 使用 Parallel Scavenge + Serial Old 收集器组合  |\n| -XX:+UseParallelOldGC              | 使用 Parallel Scavenge + Parallel Old 收集器组合 |\n| -XX:ParallelGCThreads              | 设置并行 GC 时进行内存回收的线程数                      |\n| -XX:GCTimeRatio                    | Parallel Scavenge 中 GC 时间占比，默认 99，即允许 1% 的 GC 时间。 |\n| -XX:MaxGCPauseMillis               | 设置 GC 的最大停顿时间，只对 Parallel Scavenge 有效    |\n| -XX:CMSInitiatingOccupancyFraction | 设置 CMS 收集器在老年代空间被使用多少后触发垃圾收集             |\n| -XX:+UseCMSCompactAtFullCollection | 设置 CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理          |\n| -XX:+CMSFullGCBeforeCompaction     | 设置 CMS 收集器在完成若干次垃圾收集后是进行一次内存碎片整理         |\n\n### 启动参数的选择\n\n启动参数大体指定三部分：设置收集器相关配置、设置内存分配相关配置，其他。\n\n对于收集器，目前我我基本上都使用 ParNew（新生代）+ CMS（老年代）+ Serial Old（老年代备用）组合。可能需要指定的参数还有：-XX:ParallelGCThreads，-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSCompactAtFullCollection，-XX:+CMSFullGCBeforeCompaction。但目前实际上我都没有特殊指定（设置过线程数，但发现效果并不理想）。\n\n对于内存分配，这个就要结合项目和环境的具体信息配置了。\n\n其他部分就包括：对 GC 过程、类加载卸载等信息的输出，异常 Dump 等信息。\n\n完成以上配置后，还需要根据系统运行状况，GC 日志的情况进一步调整参数。对 GC 日志的分析可以使用 [gceasy](http://gceasy.io/index.jsp) 分析，系统运行状况可以参考后面的文章《JVM 故障发现和排查》。\n\n---\n\n参考：\n\n- 《深入理解 Java 虚拟机》\n- [Java永久代去哪儿了](http://www.infoq.com/cn/articles/Java-PERMGEN-Removed)\n- [Java8内存模型—永久代(PermGen)和元空间(Metaspace)](http://www.cnblogs.com/paddix/p/5309550.html)\n","slug":"JVM知识拾遗","published":1,"updated":"2017-12-08T13:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2p9000md82e0o2w7ybk","content":"<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><p>谈论到运行时数据区可能有非常多词在脑海中闪现：堆、栈、新生代、老年代、永久区、方法区等等。上面这些概念确实都位于运行时数据区，但从 JVM 功能实现的角度没有这么多概念，例如老年代，新生代都是从垃圾收集的角度去分析。单纯从 JVM 功能实现角度可以用下图概括：</p>\n<p><img src=\"https://camo.githubusercontent.com/8799029281fbeed32ea53e95df7c82042a3dff21/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031372f30372f30322f353935383832373332333737312e706e67\" alt=\"运行时数据区\"></p>\n<h3 id=\"线程私有区域\"><a href=\"#线程私有区域\" class=\"headerlink\" title=\"线程私有区域\"></a>线程私有区域</h3><ul>\n<li><p>程序计数器</p>\n<p>当先线程所执行的字节码的行号执行器</p>\n</li>\n<li><p>Java 虚拟机栈</p>\n<p>与线程一致的声明周期。由若干个栈帧组成，每个栈帧对应一个方法。栈帧存储局部变量表、操作数栈等信息</p>\n</li>\n</ul>\n<h3 id=\"线程共享区域\"><a href=\"#线程共享区域\" class=\"headerlink\" title=\"线程共享区域\"></a>线程共享区域</h3><ul>\n<li><p>Java堆</p>\n<p>Java 堆主要用于存放对象实例，所有线程共享的内存区域统称为 Java 堆，但其内部又划分为若干个逻辑区域。从功能的角度上看 Java 堆存放对象实例，可以分为新生代、老年代。</p>\n</li>\n</ul>\n<ul>\n<li><p>方法区</p>\n<p>Java 堆的一个逻辑区域，但功能上与 Java 堆有明显的区别。主要是存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。内部重要区域：运行时常量池。</p>\n<p>在方法区这部分有几个混淆的概念：方法区，永久代，元空间：</p>\n<ul>\n<li>方法区：JVM 规范中定义的区域</li>\n<li>永久代：HotSpot 在 JDK1.8 之前对方法区的实现，使用 Java 堆内存</li>\n<li>元空间；HotSpot 在 JDK1.8 开始对方法区的实现，该区域使用本地内存</li>\n</ul>\n</li>\n</ul>\n<p>《深入理解 Java 虚拟机》一书在第 2 章从内存溢出的角度详细的说明了运行时数据区域（甚至包括了非虚拟机运行时数据区域），个人感觉区域之间层次描述稍弱，内容也较多，从 JVM 运行模型的角度上面的概括更容易理解。</p>\n<h2 id=\"内存分配与回收\"><a href=\"#内存分配与回收\" class=\"headerlink\" title=\"内存分配与回收\"></a>内存分配与回收</h2><p>单纯从 JVM 功能实现的角度考虑，对象内存的分配和回收就是对堆空间的操作。但为了高效的自动回收内存，一般把 Java 堆分为新生代和老年代，二者在对象内存分配和回收策略上有所区别。区别的根本原因是为了内存回收，所以先从内存回收策略看起——垃圾收集算法。</p>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><ul>\n<li>标记-清除<ul>\n<li>最基本的垃圾收集算法</li>\n<li>效率不高；内存碎片</li>\n</ul>\n</li>\n<li>复制算法<ul>\n<li>适合“朝生夕死”的对象，新生代收集算法</li>\n<li>由三部分组成：两个小块 Survivor 和一个大块 Eden，HotSpot 默认比例8:1:1，每次使用一个 Survivor 和一个 Eden</li>\n<li>当 Survivor 空间不足时依赖其他内存进行担保</li>\n</ul>\n</li>\n<li>标记-整理<ul>\n<li>适合存活率高对象</li>\n<li>标记-清除-整理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><p>内存分配没有绝对的准则，采用不同的垃圾收集器，JVM 实现，JVM 参数可能得到不同的分配策略。但有几条普遍策略：</p>\n<ul>\n<li>对象优先在  Eden 分配</li>\n<li>大对象直接进入老年代</li>\n<li>长期存活的对象将进入老年代</li>\n<li>动态对象年龄判定：如果在 Survivor 中间中相同年龄所有对象大小的综合大于 Survovor 空间一半，年龄大于等于该年龄的对象直接晋升老年代</li>\n<li>空间分配担保</li>\n</ul>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p>先放一张垃圾收集器的组合</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/09/19/59c0ee65ee2a4.png\" alt=\"GC.png\"></p>\n<h4 id=\"新生代收集器\"><a href=\"#新生代收集器\" class=\"headerlink\" title=\"新生代收集器\"></a>新生代收集器</h4><h5 id=\"Serial\"><a href=\"#Serial\" class=\"headerlink\" title=\"Serial\"></a>Serial</h5><p><img src=\"https://i.loli.net/2017/09/19/59c1060eed6f0.jpg\" alt=\"Serial.jpg\"></p>\n<p>单线程垃圾收集器，进行垃圾收集的时候需要暂停其他的线程</p>\n<h5 id=\"ParNew\"><a href=\"#ParNew\" class=\"headerlink\" title=\"ParNew\"></a>ParNew</h5><p><img src=\"https://i.loli.net/2017/09/19/59c10658676f9.jpg\" alt=\"PaeNew.jpg\"></p>\n<p>Serial收集器的多线程版本，许多运行在Server模式下的虚拟机中首选的新生代收集器，可以与CMS收集器配合工作</p>\n<h5 id=\"Parallel-Scavenge\"><a href=\"#Parallel-Scavenge\" class=\"headerlink\" title=\"Parallel Scavenge\"></a>Parallel Scavenge</h5><p>并行的多线程收集器，更关注可控制的吞吐量。吞吐量越大，垃圾收集的时间越短。目前没有使用过。</p>\n<h4 id=\"老年代收集器\"><a href=\"#老年代收集器\" class=\"headerlink\" title=\"老年代收集器\"></a>老年代收集器</h4><h5 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h5><p>Serial收集器的老年代版本，也是一个单线程收集器，采用“标记-整理算法”进行回收。其运行过程与Serial收集器一样。</p>\n<p>用途：</p>\n<ul>\n<li>与Parallel Scavenge收集器搭配使用</li>\n<li>作为CMS收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用</li>\n</ul>\n<h5 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h5><p><img src=\"https://i.loli.net/2017/09/19/59c106f16c0e9.jpg\" alt=\"Parallel Old.jpg\"></p>\n<p>Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法进行垃圾回收。与 Parallel Scavenge 收集器配合使用，“吞吐量优先”收集器是这个组合的特点，在注重吞吐量和CPU资源敏感的场合，都可以使用这个组合。</p>\n<h5 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h5><p><img src=\"https://i.loli.net/2017/09/19/59c1075791807.jpg\" alt=\"1505822517(1).jpg\"></p>\n<p>为获取最短回收停顿时间而生的老年代垃圾收集器（标记-清除算法）。整个执行过程分为 4 个步骤：</p>\n<ul>\n<li>初始标记：仅标记 GC Roots 直接可达的对象，需要 STW</li>\n<li>并发标记：GC Roots Tracing，并行</li>\n<li>重新标记：修正上一步执行中变动的标记记录</li>\n<li>并发清除：并行</li>\n</ul>\n<p>缺点：对 CPU 资源敏感，无法有效处理浮动垃圾，无法有效处理内存碎片</p>\n<p>目前我在项目中使用最多的垃圾收集器，从 GC 日志来看，STW 时间确实少，以最近一次本地 GC 日志说明：85% 的 GC 时间持续一秒内，但最大的 STW 时间只有 160 ms，平均 STW 时间 135 ms。</p>\n<h5 id=\"G1-收集器\"><a href=\"#G1-收集器\" class=\"headerlink\" title=\"G1 收集器\"></a>G1 收集器</h5><p>目前这个收集器完全没有使用过。从描述上看是神一般的存在。大致思想是将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region（化整为零）。</p>\n<p><img src=\"https://i.loli.net/2017/09/19/59c109faa5c94.jpg\" alt=\"1505823191(1).jpg\"></p>\n<hr>\n<p>以上收集器虽然多，但还是有规律可以总结的：</p>\n<ul>\n<li>Serial：是最原始的新生代收集器</li>\n<li>Parnew：多线程版本的 Serial 新生代收集器</li>\n<li>Parallel Scavenge：吞吐量优先新生代收集器</li>\n<li>Serial Old：最原始的老年代收集器，万能备胎</li>\n<li>Parallel Scavenge：吞吐量优先老年代收集器</li>\n<li>CMS：多线程版本的老年代收集器</li>\n</ul>\n<h2 id=\"备忘录\"><a href=\"#备忘录\" class=\"headerlink\" title=\"备忘录\"></a>备忘录</h2><h3 id=\"虚拟机参数小结\"><a href=\"#虚拟机参数小结\" class=\"headerlink\" title=\"虚拟机参数小结\"></a>虚拟机参数小结</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-Xms</td>\n<td>初始堆大小</td>\n</tr>\n<tr>\n<td>-Xmx</td>\n<td>最大堆大小</td>\n</tr>\n<tr>\n<td>-Xmn</td>\n<td>新生代大小</td>\n</tr>\n<tr>\n<td>-Xss</td>\n<td>每个线程的堆栈大小</td>\n</tr>\n<tr>\n<td>-XX:NewRatio</td>\n<td>新生代和老年代的比例</td>\n</tr>\n<tr>\n<td>-XX:SurvivorRatio</td>\n<td>新生代 Eden 区和 Survivor区域的比例</td>\n</tr>\n<tr>\n<td>-XX:PermSize</td>\n<td>永久代的初始大小</td>\n</tr>\n<tr>\n<td>-XX:MaxPermSize</td>\n<td>永久代的最大值</td>\n</tr>\n<tr>\n<td>–XX:MetaspaceSize</td>\n<td>元空间的初始大小</td>\n</tr>\n<tr>\n<td>-XX:MaxMetaspaceSize</td>\n<td>元空间的最大值</td>\n</tr>\n<tr>\n<td>-XX:MaxTenuringThreshold</td>\n<td>超过设置年龄的新生代直接晋升老年代</td>\n</tr>\n<tr>\n<td>-XX:PretenureSizeThreshold</td>\n<td>超过设置大小的新生代直接晋升老年代</td>\n</tr>\n<tr>\n<td>-XX:+PrintGC</td>\n<td>每次 GC 时打印相关信息</td>\n</tr>\n<tr>\n<td>-XX:+PrintGC Details</td>\n<td>每次 GC 时打印详细信息</td>\n</tr>\n<tr>\n<td>-XX:+PrintGCTimeStamps</td>\n<td>打印每次 GC 的时间戳</td>\n</tr>\n<tr>\n<td>-Xloggc</td>\n<td>是将每次GC事件的相关情况记录到文件中</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"垃圾收集器参数总结\"><a href=\"#垃圾收集器参数总结\" class=\"headerlink\" title=\"垃圾收集器参数总结\"></a>垃圾收集器参数总结</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-XX:+UseSerialGC</td>\n<td>使用 Serial + Serial Old 收集器组合</td>\n</tr>\n<tr>\n<td>-XX:+UseParNewGC</td>\n<td>使用 ParNew + Serial Old 收集器组合</td>\n</tr>\n<tr>\n<td>-XX:+UseConcMarkSweepGC</td>\n<td>使用 ParNew + CMS + Serial Old 收集器组合</td>\n</tr>\n<tr>\n<td>-XX:+UseParallelGC</td>\n<td>使用 Parallel Scavenge + Serial Old 收集器组合</td>\n</tr>\n<tr>\n<td>-XX:+UseParallelOldGC</td>\n<td>使用 Parallel Scavenge + Parallel Old 收集器组合</td>\n</tr>\n<tr>\n<td>-XX:ParallelGCThreads</td>\n<td>设置并行 GC 时进行内存回收的线程数</td>\n</tr>\n<tr>\n<td>-XX:GCTimeRatio</td>\n<td>Parallel Scavenge 中 GC 时间占比，默认 99，即允许 1% 的 GC 时间。</td>\n</tr>\n<tr>\n<td>-XX:MaxGCPauseMillis</td>\n<td>设置 GC 的最大停顿时间，只对 Parallel Scavenge 有效</td>\n</tr>\n<tr>\n<td>-XX:CMSInitiatingOccupancyFraction</td>\n<td>设置 CMS 收集器在老年代空间被使用多少后触发垃圾收集</td>\n</tr>\n<tr>\n<td>-XX:+UseCMSCompactAtFullCollection</td>\n<td>设置 CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理</td>\n</tr>\n<tr>\n<td>-XX:+CMSFullGCBeforeCompaction</td>\n<td>设置 CMS 收集器在完成若干次垃圾收集后是进行一次内存碎片整理</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"启动参数的选择\"><a href=\"#启动参数的选择\" class=\"headerlink\" title=\"启动参数的选择\"></a>启动参数的选择</h3><p>启动参数大体指定三部分：设置收集器相关配置、设置内存分配相关配置，其他。</p>\n<p>对于收集器，目前我我基本上都使用 ParNew（新生代）+ CMS（老年代）+ Serial Old（老年代备用）组合。可能需要指定的参数还有：-XX:ParallelGCThreads，-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSCompactAtFullCollection，-XX:+CMSFullGCBeforeCompaction。但目前实际上我都没有特殊指定（设置过线程数，但发现效果并不理想）。</p>\n<p>对于内存分配，这个就要结合项目和环境的具体信息配置了。</p>\n<p>其他部分就包括：对 GC 过程、类加载卸载等信息的输出，异常 Dump 等信息。</p>\n<p>完成以上配置后，还需要根据系统运行状况，GC 日志的情况进一步调整参数。对 GC 日志的分析可以使用 <a href=\"http://gceasy.io/index.jsp\" target=\"_blank\" rel=\"external\">gceasy</a> 分析，系统运行状况可以参考后面的文章《JVM 故障发现和排查》。</p>\n<hr>\n<p>参考：</p>\n<ul>\n<li>《深入理解 Java 虚拟机》</li>\n<li><a href=\"http://www.infoq.com/cn/articles/Java-PERMGEN-Removed\" target=\"_blank\" rel=\"external\">Java永久代去哪儿了</a></li>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5309550.html\" target=\"_blank\" rel=\"external\">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><p>谈论到运行时数据区可能有非常多词在脑海中闪现：堆、栈、新生代、老年代、永久区、方法区等等。上面这些概念确实都位于运行时数据区，但从 JVM 功能实现的角度没有这么多概念，例如老年代，新生代都是从垃圾收集的角度去分析。单纯从 JVM 功能实现角度可以用下图概括：</p>\n<p><img src=\"https://camo.githubusercontent.com/8799029281fbeed32ea53e95df7c82042a3dff21/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031372f30372f30322f353935383832373332333737312e706e67\" alt=\"运行时数据区\"></p>\n<h3 id=\"线程私有区域\"><a href=\"#线程私有区域\" class=\"headerlink\" title=\"线程私有区域\"></a>线程私有区域</h3><ul>\n<li><p>程序计数器</p>\n<p>当先线程所执行的字节码的行号执行器</p>\n</li>\n<li><p>Java 虚拟机栈</p>\n<p>与线程一致的声明周期。由若干个栈帧组成，每个栈帧对应一个方法。栈帧存储局部变量表、操作数栈等信息</p>\n</li>\n</ul>\n<h3 id=\"线程共享区域\"><a href=\"#线程共享区域\" class=\"headerlink\" title=\"线程共享区域\"></a>线程共享区域</h3><ul>\n<li><p>Java堆</p>\n<p>Java 堆主要用于存放对象实例，所有线程共享的内存区域统称为 Java 堆，但其内部又划分为若干个逻辑区域。从功能的角度上看 Java 堆存放对象实例，可以分为新生代、老年代。</p>\n</li>\n</ul>\n<ul>\n<li><p>方法区</p>\n<p>Java 堆的一个逻辑区域，但功能上与 Java 堆有明显的区别。主要是存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。内部重要区域：运行时常量池。</p>\n<p>在方法区这部分有几个混淆的概念：方法区，永久代，元空间：</p>\n<ul>\n<li>方法区：JVM 规范中定义的区域</li>\n<li>永久代：HotSpot 在 JDK1.8 之前对方法区的实现，使用 Java 堆内存</li>\n<li>元空间；HotSpot 在 JDK1.8 开始对方法区的实现，该区域使用本地内存</li>\n</ul>\n</li>\n</ul>\n<p>《深入理解 Java 虚拟机》一书在第 2 章从内存溢出的角度详细的说明了运行时数据区域（甚至包括了非虚拟机运行时数据区域），个人感觉区域之间层次描述稍弱，内容也较多，从 JVM 运行模型的角度上面的概括更容易理解。</p>\n<h2 id=\"内存分配与回收\"><a href=\"#内存分配与回收\" class=\"headerlink\" title=\"内存分配与回收\"></a>内存分配与回收</h2><p>单纯从 JVM 功能实现的角度考虑，对象内存的分配和回收就是对堆空间的操作。但为了高效的自动回收内存，一般把 Java 堆分为新生代和老年代，二者在对象内存分配和回收策略上有所区别。区别的根本原因是为了内存回收，所以先从内存回收策略看起——垃圾收集算法。</p>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><ul>\n<li>标记-清除<ul>\n<li>最基本的垃圾收集算法</li>\n<li>效率不高；内存碎片</li>\n</ul>\n</li>\n<li>复制算法<ul>\n<li>适合“朝生夕死”的对象，新生代收集算法</li>\n<li>由三部分组成：两个小块 Survivor 和一个大块 Eden，HotSpot 默认比例8:1:1，每次使用一个 Survivor 和一个 Eden</li>\n<li>当 Survivor 空间不足时依赖其他内存进行担保</li>\n</ul>\n</li>\n<li>标记-整理<ul>\n<li>适合存活率高对象</li>\n<li>标记-清除-整理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><p>内存分配没有绝对的准则，采用不同的垃圾收集器，JVM 实现，JVM 参数可能得到不同的分配策略。但有几条普遍策略：</p>\n<ul>\n<li>对象优先在  Eden 分配</li>\n<li>大对象直接进入老年代</li>\n<li>长期存活的对象将进入老年代</li>\n<li>动态对象年龄判定：如果在 Survivor 中间中相同年龄所有对象大小的综合大于 Survovor 空间一半，年龄大于等于该年龄的对象直接晋升老年代</li>\n<li>空间分配担保</li>\n</ul>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p>先放一张垃圾收集器的组合</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/09/19/59c0ee65ee2a4.png\" alt=\"GC.png\"></p>\n<h4 id=\"新生代收集器\"><a href=\"#新生代收集器\" class=\"headerlink\" title=\"新生代收集器\"></a>新生代收集器</h4><h5 id=\"Serial\"><a href=\"#Serial\" class=\"headerlink\" title=\"Serial\"></a>Serial</h5><p><img src=\"https://i.loli.net/2017/09/19/59c1060eed6f0.jpg\" alt=\"Serial.jpg\"></p>\n<p>单线程垃圾收集器，进行垃圾收集的时候需要暂停其他的线程</p>\n<h5 id=\"ParNew\"><a href=\"#ParNew\" class=\"headerlink\" title=\"ParNew\"></a>ParNew</h5><p><img src=\"https://i.loli.net/2017/09/19/59c10658676f9.jpg\" alt=\"PaeNew.jpg\"></p>\n<p>Serial收集器的多线程版本，许多运行在Server模式下的虚拟机中首选的新生代收集器，可以与CMS收集器配合工作</p>\n<h5 id=\"Parallel-Scavenge\"><a href=\"#Parallel-Scavenge\" class=\"headerlink\" title=\"Parallel Scavenge\"></a>Parallel Scavenge</h5><p>并行的多线程收集器，更关注可控制的吞吐量。吞吐量越大，垃圾收集的时间越短。目前没有使用过。</p>\n<h4 id=\"老年代收集器\"><a href=\"#老年代收集器\" class=\"headerlink\" title=\"老年代收集器\"></a>老年代收集器</h4><h5 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h5><p>Serial收集器的老年代版本，也是一个单线程收集器，采用“标记-整理算法”进行回收。其运行过程与Serial收集器一样。</p>\n<p>用途：</p>\n<ul>\n<li>与Parallel Scavenge收集器搭配使用</li>\n<li>作为CMS收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用</li>\n</ul>\n<h5 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h5><p><img src=\"https://i.loli.net/2017/09/19/59c106f16c0e9.jpg\" alt=\"Parallel Old.jpg\"></p>\n<p>Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法进行垃圾回收。与 Parallel Scavenge 收集器配合使用，“吞吐量优先”收集器是这个组合的特点，在注重吞吐量和CPU资源敏感的场合，都可以使用这个组合。</p>\n<h5 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h5><p><img src=\"https://i.loli.net/2017/09/19/59c1075791807.jpg\" alt=\"1505822517(1).jpg\"></p>\n<p>为获取最短回收停顿时间而生的老年代垃圾收集器（标记-清除算法）。整个执行过程分为 4 个步骤：</p>\n<ul>\n<li>初始标记：仅标记 GC Roots 直接可达的对象，需要 STW</li>\n<li>并发标记：GC Roots Tracing，并行</li>\n<li>重新标记：修正上一步执行中变动的标记记录</li>\n<li>并发清除：并行</li>\n</ul>\n<p>缺点：对 CPU 资源敏感，无法有效处理浮动垃圾，无法有效处理内存碎片</p>\n<p>目前我在项目中使用最多的垃圾收集器，从 GC 日志来看，STW 时间确实少，以最近一次本地 GC 日志说明：85% 的 GC 时间持续一秒内，但最大的 STW 时间只有 160 ms，平均 STW 时间 135 ms。</p>\n<h5 id=\"G1-收集器\"><a href=\"#G1-收集器\" class=\"headerlink\" title=\"G1 收集器\"></a>G1 收集器</h5><p>目前这个收集器完全没有使用过。从描述上看是神一般的存在。大致思想是将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region（化整为零）。</p>\n<p><img src=\"https://i.loli.net/2017/09/19/59c109faa5c94.jpg\" alt=\"1505823191(1).jpg\"></p>\n<hr>\n<p>以上收集器虽然多，但还是有规律可以总结的：</p>\n<ul>\n<li>Serial：是最原始的新生代收集器</li>\n<li>Parnew：多线程版本的 Serial 新生代收集器</li>\n<li>Parallel Scavenge：吞吐量优先新生代收集器</li>\n<li>Serial Old：最原始的老年代收集器，万能备胎</li>\n<li>Parallel Scavenge：吞吐量优先老年代收集器</li>\n<li>CMS：多线程版本的老年代收集器</li>\n</ul>\n<h2 id=\"备忘录\"><a href=\"#备忘录\" class=\"headerlink\" title=\"备忘录\"></a>备忘录</h2><h3 id=\"虚拟机参数小结\"><a href=\"#虚拟机参数小结\" class=\"headerlink\" title=\"虚拟机参数小结\"></a>虚拟机参数小结</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-Xms</td>\n<td>初始堆大小</td>\n</tr>\n<tr>\n<td>-Xmx</td>\n<td>最大堆大小</td>\n</tr>\n<tr>\n<td>-Xmn</td>\n<td>新生代大小</td>\n</tr>\n<tr>\n<td>-Xss</td>\n<td>每个线程的堆栈大小</td>\n</tr>\n<tr>\n<td>-XX:NewRatio</td>\n<td>新生代和老年代的比例</td>\n</tr>\n<tr>\n<td>-XX:SurvivorRatio</td>\n<td>新生代 Eden 区和 Survivor区域的比例</td>\n</tr>\n<tr>\n<td>-XX:PermSize</td>\n<td>永久代的初始大小</td>\n</tr>\n<tr>\n<td>-XX:MaxPermSize</td>\n<td>永久代的最大值</td>\n</tr>\n<tr>\n<td>–XX:MetaspaceSize</td>\n<td>元空间的初始大小</td>\n</tr>\n<tr>\n<td>-XX:MaxMetaspaceSize</td>\n<td>元空间的最大值</td>\n</tr>\n<tr>\n<td>-XX:MaxTenuringThreshold</td>\n<td>超过设置年龄的新生代直接晋升老年代</td>\n</tr>\n<tr>\n<td>-XX:PretenureSizeThreshold</td>\n<td>超过设置大小的新生代直接晋升老年代</td>\n</tr>\n<tr>\n<td>-XX:+PrintGC</td>\n<td>每次 GC 时打印相关信息</td>\n</tr>\n<tr>\n<td>-XX:+PrintGC Details</td>\n<td>每次 GC 时打印详细信息</td>\n</tr>\n<tr>\n<td>-XX:+PrintGCTimeStamps</td>\n<td>打印每次 GC 的时间戳</td>\n</tr>\n<tr>\n<td>-Xloggc</td>\n<td>是将每次GC事件的相关情况记录到文件中</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"垃圾收集器参数总结\"><a href=\"#垃圾收集器参数总结\" class=\"headerlink\" title=\"垃圾收集器参数总结\"></a>垃圾收集器参数总结</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-XX:+UseSerialGC</td>\n<td>使用 Serial + Serial Old 收集器组合</td>\n</tr>\n<tr>\n<td>-XX:+UseParNewGC</td>\n<td>使用 ParNew + Serial Old 收集器组合</td>\n</tr>\n<tr>\n<td>-XX:+UseConcMarkSweepGC</td>\n<td>使用 ParNew + CMS + Serial Old 收集器组合</td>\n</tr>\n<tr>\n<td>-XX:+UseParallelGC</td>\n<td>使用 Parallel Scavenge + Serial Old 收集器组合</td>\n</tr>\n<tr>\n<td>-XX:+UseParallelOldGC</td>\n<td>使用 Parallel Scavenge + Parallel Old 收集器组合</td>\n</tr>\n<tr>\n<td>-XX:ParallelGCThreads</td>\n<td>设置并行 GC 时进行内存回收的线程数</td>\n</tr>\n<tr>\n<td>-XX:GCTimeRatio</td>\n<td>Parallel Scavenge 中 GC 时间占比，默认 99，即允许 1% 的 GC 时间。</td>\n</tr>\n<tr>\n<td>-XX:MaxGCPauseMillis</td>\n<td>设置 GC 的最大停顿时间，只对 Parallel Scavenge 有效</td>\n</tr>\n<tr>\n<td>-XX:CMSInitiatingOccupancyFraction</td>\n<td>设置 CMS 收集器在老年代空间被使用多少后触发垃圾收集</td>\n</tr>\n<tr>\n<td>-XX:+UseCMSCompactAtFullCollection</td>\n<td>设置 CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理</td>\n</tr>\n<tr>\n<td>-XX:+CMSFullGCBeforeCompaction</td>\n<td>设置 CMS 收集器在完成若干次垃圾收集后是进行一次内存碎片整理</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"启动参数的选择\"><a href=\"#启动参数的选择\" class=\"headerlink\" title=\"启动参数的选择\"></a>启动参数的选择</h3><p>启动参数大体指定三部分：设置收集器相关配置、设置内存分配相关配置，其他。</p>\n<p>对于收集器，目前我我基本上都使用 ParNew（新生代）+ CMS（老年代）+ Serial Old（老年代备用）组合。可能需要指定的参数还有：-XX:ParallelGCThreads，-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSCompactAtFullCollection，-XX:+CMSFullGCBeforeCompaction。但目前实际上我都没有特殊指定（设置过线程数，但发现效果并不理想）。</p>\n<p>对于内存分配，这个就要结合项目和环境的具体信息配置了。</p>\n<p>其他部分就包括：对 GC 过程、类加载卸载等信息的输出，异常 Dump 等信息。</p>\n<p>完成以上配置后，还需要根据系统运行状况，GC 日志的情况进一步调整参数。对 GC 日志的分析可以使用 <a href=\"http://gceasy.io/index.jsp\">gceasy</a> 分析，系统运行状况可以参考后面的文章《JVM 故障发现和排查》。</p>\n<hr>\n<p>参考：</p>\n<ul>\n<li>《深入理解 Java 虚拟机》</li>\n<li><a href=\"http://www.infoq.com/cn/articles/Java-PERMGEN-Removed\">Java永久代去哪儿了</a></li>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5309550.html\">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></li>\n</ul>\n"},{"title":"JDK并发包——同步控制工具","date":"2017-04-09T13:46:11.000Z","_content":"\n为了弥补Java原生并发的各种不足，在并发包中提供了格式各样的工具，这篇先看看关于同步控制并法包的支持。\n\n## 可重入锁——ReentrantLock\n\nJava原生提供的synchronized主要有以下几个缺点：\n\n- JDK5之前的synchronized的性能较差\n- synchronized本身无法响应中断、无法限时等待、无法确保同步线程之间的公平性\n\n可重入锁既是为了解决以上问题提出的。\n\n但是关于这个可重入的名字我觉得还是比较让人疑惑，synchronized本身也是支持一个线程的重入的。\n\n对于原生synchronized的缺陷，ReentrantLock提供了如下几个重要的方法以改善：\n\n- lockInterruptibly()：获得锁，但优先响应中断\n- tryLock()：尝试获得锁，成功返回true，失败立即返false，不等待\n- tryLock(long time, TimeUnit unit)：在给定时间内尝试获得锁\n- unlock()：释放锁\n- ReentrantLock(boolean fair)：确保同步线程之间的访问公平\n\n除此还提供了最基本的lock()方法：获得，如果锁被占用则等待。\n\nReentrantLock使用过程中需要注意的是无论何种方式获取锁，每次获取锁之后都要手动调用unlock方法释放锁。\n\n## wait/notify的替身——Condition\n\nCondition与ReentrantLock的关系如同synchronized与wait/notify方法的关系。\n\n为了配合ReentrantLock，Condition本身提供了与wait方法类似的await，与notif方法类似的singal，除此还补充了不响应中断的awaitUninterruptibly方法。\n\n关于Condition的使用：\n\n- 通过ReentrantLock实例的工厂方法获取Condition。\n\n\n- 调用await时必须持有线程的相关ReentrantLock，await调用后线程会释放锁，当再次被唤醒时重新持有锁\n- 调用signal时也必须持有线程的相关ReentrantLock，但是调用结束后需要手动释放锁，否则被唤醒线程无法获取锁\n\n## 宽容的临界区——Semaphore\n\n可以简单的理解信号量（Semaphore）是可以多个线程同时访问的临界区资源。\n\n在构造Semapho时必须制定多个线程的具体数量，还可以指定是否是否公平访问，对象的其它主要方法有：\n\n- acquire()\n- acquireUninterruptibly()\n- tryAcquire()\n- tryAcquire(long timeout, TimeUnit unit)\n- release()\n\n方法的含义如同方法名，没有发现使用特别的地方。\n\n需要注意的是申请的信号量使用完毕后，需要release以避免资源越来越少。\n\n## 读写锁——ReentrantReadWriteLock\n\n说来惭愧，到目前为止在实际项目中并发包的各种工具我貌似只使用过读写锁。\n\n通常锁都是严格串行的，读写锁提供读写分离锁，对多个读操作不进行阻塞，以此来改善性能。\n\n具体使用中读锁和写锁需要从同一个ReentrantReadWriteLock对象获取：\n\n```java\nReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\nLock readLock = readWriteLock.readLock();\nLock writeLock = readWriteLock.writeLock();\n```\n\n针对读操作使用读锁，针对写操作使用写锁。\n\n## 倒计数器与循环栅栏\n\n倒计数器：CountDownLatch\n\n循环栅栏：CyclicBarrier\n\n这两个工具具体用法不好解释，我以一个场景考试举例，这个场景有如下特点：\n\n- 参加考试的人员是一定的\n- 使用一个线程表示一个参考人员\n- 不限时，考试结束的唯一标志是所有人员交卷\n\n使用倒计数器实现时：\n\n- CountDownLatch定义多少人参加考试\n- 每次有人交卷CountDownLatch就减少一，交卷后人员自由离开考场\n- 当CountDownLatch减少到0时表示考试结束\n\n使用循环栅栏实现时：\n\n- CyclicBarrier定义多少人参加考试，宣布考试结束\n- 每次有人交卷CyclicBarrier就减少一，但是交卷后人员不能离开考场\n- 当CyclicBarrier减少到0时表示考试结束，所有人统一离场，宣布考试结束\n- 当一场考试结束，下一场考试立即准备完毕\n\n可以看出CyclicBarrier还是更强大一些的。\n\n相较于CountDownLatch，CyclicBarrier可以定义完成事件，可以重复使用，控制线程的阻塞。\n\n---\n\n以上并发工具的使用示例都可以在[Joolkit](https://github.com/zhanghTK/Joolkit/tree/master/concurrent/src/test/java/tk/zhangh/java/concurrent/thread)中找到。\n","source":"_posts/JDK并发包——同步控制工具.md","raw":"---\ntitle: JDK并发包——同步控制工具\ndate: 2017-04-09 21:46:11\ntags:\n  - Java\n  - 并发\ncategories: Java\n---\n\n为了弥补Java原生并发的各种不足，在并发包中提供了格式各样的工具，这篇先看看关于同步控制并法包的支持。\n\n## 可重入锁——ReentrantLock\n\nJava原生提供的synchronized主要有以下几个缺点：\n\n- JDK5之前的synchronized的性能较差\n- synchronized本身无法响应中断、无法限时等待、无法确保同步线程之间的公平性\n\n可重入锁既是为了解决以上问题提出的。\n\n但是关于这个可重入的名字我觉得还是比较让人疑惑，synchronized本身也是支持一个线程的重入的。\n\n对于原生synchronized的缺陷，ReentrantLock提供了如下几个重要的方法以改善：\n\n- lockInterruptibly()：获得锁，但优先响应中断\n- tryLock()：尝试获得锁，成功返回true，失败立即返false，不等待\n- tryLock(long time, TimeUnit unit)：在给定时间内尝试获得锁\n- unlock()：释放锁\n- ReentrantLock(boolean fair)：确保同步线程之间的访问公平\n\n除此还提供了最基本的lock()方法：获得，如果锁被占用则等待。\n\nReentrantLock使用过程中需要注意的是无论何种方式获取锁，每次获取锁之后都要手动调用unlock方法释放锁。\n\n## wait/notify的替身——Condition\n\nCondition与ReentrantLock的关系如同synchronized与wait/notify方法的关系。\n\n为了配合ReentrantLock，Condition本身提供了与wait方法类似的await，与notif方法类似的singal，除此还补充了不响应中断的awaitUninterruptibly方法。\n\n关于Condition的使用：\n\n- 通过ReentrantLock实例的工厂方法获取Condition。\n\n\n- 调用await时必须持有线程的相关ReentrantLock，await调用后线程会释放锁，当再次被唤醒时重新持有锁\n- 调用signal时也必须持有线程的相关ReentrantLock，但是调用结束后需要手动释放锁，否则被唤醒线程无法获取锁\n\n## 宽容的临界区——Semaphore\n\n可以简单的理解信号量（Semaphore）是可以多个线程同时访问的临界区资源。\n\n在构造Semapho时必须制定多个线程的具体数量，还可以指定是否是否公平访问，对象的其它主要方法有：\n\n- acquire()\n- acquireUninterruptibly()\n- tryAcquire()\n- tryAcquire(long timeout, TimeUnit unit)\n- release()\n\n方法的含义如同方法名，没有发现使用特别的地方。\n\n需要注意的是申请的信号量使用完毕后，需要release以避免资源越来越少。\n\n## 读写锁——ReentrantReadWriteLock\n\n说来惭愧，到目前为止在实际项目中并发包的各种工具我貌似只使用过读写锁。\n\n通常锁都是严格串行的，读写锁提供读写分离锁，对多个读操作不进行阻塞，以此来改善性能。\n\n具体使用中读锁和写锁需要从同一个ReentrantReadWriteLock对象获取：\n\n```java\nReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\nLock readLock = readWriteLock.readLock();\nLock writeLock = readWriteLock.writeLock();\n```\n\n针对读操作使用读锁，针对写操作使用写锁。\n\n## 倒计数器与循环栅栏\n\n倒计数器：CountDownLatch\n\n循环栅栏：CyclicBarrier\n\n这两个工具具体用法不好解释，我以一个场景考试举例，这个场景有如下特点：\n\n- 参加考试的人员是一定的\n- 使用一个线程表示一个参考人员\n- 不限时，考试结束的唯一标志是所有人员交卷\n\n使用倒计数器实现时：\n\n- CountDownLatch定义多少人参加考试\n- 每次有人交卷CountDownLatch就减少一，交卷后人员自由离开考场\n- 当CountDownLatch减少到0时表示考试结束\n\n使用循环栅栏实现时：\n\n- CyclicBarrier定义多少人参加考试，宣布考试结束\n- 每次有人交卷CyclicBarrier就减少一，但是交卷后人员不能离开考场\n- 当CyclicBarrier减少到0时表示考试结束，所有人统一离场，宣布考试结束\n- 当一场考试结束，下一场考试立即准备完毕\n\n可以看出CyclicBarrier还是更强大一些的。\n\n相较于CountDownLatch，CyclicBarrier可以定义完成事件，可以重复使用，控制线程的阻塞。\n\n---\n\n以上并发工具的使用示例都可以在[Joolkit](https://github.com/zhanghTK/Joolkit/tree/master/concurrent/src/test/java/tk/zhangh/java/concurrent/thread)中找到。\n","slug":"JDK并发包——同步控制工具","published":1,"updated":"2017-04-09T13:50:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2pd000od82epd518p2e","content":"<p>为了弥补Java原生并发的各种不足，在并发包中提供了格式各样的工具，这篇先看看关于同步控制并法包的支持。</p>\n<h2 id=\"可重入锁——ReentrantLock\"><a href=\"#可重入锁——ReentrantLock\" class=\"headerlink\" title=\"可重入锁——ReentrantLock\"></a>可重入锁——ReentrantLock</h2><p>Java原生提供的synchronized主要有以下几个缺点：</p>\n<ul>\n<li>JDK5之前的synchronized的性能较差</li>\n<li>synchronized本身无法响应中断、无法限时等待、无法确保同步线程之间的公平性</li>\n</ul>\n<p>可重入锁既是为了解决以上问题提出的。</p>\n<p>但是关于这个可重入的名字我觉得还是比较让人疑惑，synchronized本身也是支持一个线程的重入的。</p>\n<p>对于原生synchronized的缺陷，ReentrantLock提供了如下几个重要的方法以改善：</p>\n<ul>\n<li>lockInterruptibly()：获得锁，但优先响应中断</li>\n<li>tryLock()：尝试获得锁，成功返回true，失败立即返false，不等待</li>\n<li>tryLock(long time, TimeUnit unit)：在给定时间内尝试获得锁</li>\n<li>unlock()：释放锁</li>\n<li>ReentrantLock(boolean fair)：确保同步线程之间的访问公平</li>\n</ul>\n<p>除此还提供了最基本的lock()方法：获得，如果锁被占用则等待。</p>\n<p>ReentrantLock使用过程中需要注意的是无论何种方式获取锁，每次获取锁之后都要手动调用unlock方法释放锁。</p>\n<h2 id=\"wait-notify的替身——Condition\"><a href=\"#wait-notify的替身——Condition\" class=\"headerlink\" title=\"wait/notify的替身——Condition\"></a>wait/notify的替身——Condition</h2><p>Condition与ReentrantLock的关系如同synchronized与wait/notify方法的关系。</p>\n<p>为了配合ReentrantLock，Condition本身提供了与wait方法类似的await，与notif方法类似的singal，除此还补充了不响应中断的awaitUninterruptibly方法。</p>\n<p>关于Condition的使用：</p>\n<ul>\n<li>通过ReentrantLock实例的工厂方法获取Condition。</li>\n</ul>\n<ul>\n<li>调用await时必须持有线程的相关ReentrantLock，await调用后线程会释放锁，当再次被唤醒时重新持有锁</li>\n<li>调用signal时也必须持有线程的相关ReentrantLock，但是调用结束后需要手动释放锁，否则被唤醒线程无法获取锁</li>\n</ul>\n<h2 id=\"宽容的临界区——Semaphore\"><a href=\"#宽容的临界区——Semaphore\" class=\"headerlink\" title=\"宽容的临界区——Semaphore\"></a>宽容的临界区——Semaphore</h2><p>可以简单的理解信号量（Semaphore）是可以多个线程同时访问的临界区资源。</p>\n<p>在构造Semapho时必须制定多个线程的具体数量，还可以指定是否是否公平访问，对象的其它主要方法有：</p>\n<ul>\n<li>acquire()</li>\n<li>acquireUninterruptibly()</li>\n<li>tryAcquire()</li>\n<li>tryAcquire(long timeout, TimeUnit unit)</li>\n<li>release()</li>\n</ul>\n<p>方法的含义如同方法名，没有发现使用特别的地方。</p>\n<p>需要注意的是申请的信号量使用完毕后，需要release以避免资源越来越少。</p>\n<h2 id=\"读写锁——ReentrantReadWriteLock\"><a href=\"#读写锁——ReentrantReadWriteLock\" class=\"headerlink\" title=\"读写锁——ReentrantReadWriteLock\"></a>读写锁——ReentrantReadWriteLock</h2><p>说来惭愧，到目前为止在实际项目中并发包的各种工具我貌似只使用过读写锁。</p>\n<p>通常锁都是严格串行的，读写锁提供读写分离锁，对多个读操作不进行阻塞，以此来改善性能。</p>\n<p>具体使用中读锁和写锁需要从同一个ReentrantReadWriteLock对象获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReentrantReadWriteLock readWriteLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</div><div class=\"line\">Lock readLock = readWriteLock.readLock();</div><div class=\"line\">Lock writeLock = readWriteLock.writeLock();</div></pre></td></tr></table></figure>\n<p>针对读操作使用读锁，针对写操作使用写锁。</p>\n<h2 id=\"倒计数器与循环栅栏\"><a href=\"#倒计数器与循环栅栏\" class=\"headerlink\" title=\"倒计数器与循环栅栏\"></a>倒计数器与循环栅栏</h2><p>倒计数器：CountDownLatch</p>\n<p>循环栅栏：CyclicBarrier</p>\n<p>这两个工具具体用法不好解释，我以一个场景考试举例，这个场景有如下特点：</p>\n<ul>\n<li>参加考试的人员是一定的</li>\n<li>使用一个线程表示一个参考人员</li>\n<li>不限时，考试结束的唯一标志是所有人员交卷</li>\n</ul>\n<p>使用倒计数器实现时：</p>\n<ul>\n<li>CountDownLatch定义多少人参加考试</li>\n<li>每次有人交卷CountDownLatch就减少一，交卷后人员自由离开考场</li>\n<li>当CountDownLatch减少到0时表示考试结束</li>\n</ul>\n<p>使用循环栅栏实现时：</p>\n<ul>\n<li>CyclicBarrier定义多少人参加考试，宣布考试结束</li>\n<li>每次有人交卷CyclicBarrier就减少一，但是交卷后人员不能离开考场</li>\n<li>当CyclicBarrier减少到0时表示考试结束，所有人统一离场，宣布考试结束</li>\n<li>当一场考试结束，下一场考试立即准备完毕</li>\n</ul>\n<p>可以看出CyclicBarrier还是更强大一些的。</p>\n<p>相较于CountDownLatch，CyclicBarrier可以定义完成事件，可以重复使用，控制线程的阻塞。</p>\n<hr>\n<p>以上并发工具的使用示例都可以在<a href=\"https://github.com/zhanghTK/Joolkit/tree/master/concurrent/src/test/java/tk/zhangh/java/concurrent/thread\" target=\"_blank\" rel=\"external\">Joolkit</a>中找到。</p>\n","excerpt":"","more":"<p>为了弥补Java原生并发的各种不足，在并发包中提供了格式各样的工具，这篇先看看关于同步控制并法包的支持。</p>\n<h2 id=\"可重入锁——ReentrantLock\"><a href=\"#可重入锁——ReentrantLock\" class=\"headerlink\" title=\"可重入锁——ReentrantLock\"></a>可重入锁——ReentrantLock</h2><p>Java原生提供的synchronized主要有以下几个缺点：</p>\n<ul>\n<li>JDK5之前的synchronized的性能较差</li>\n<li>synchronized本身无法响应中断、无法限时等待、无法确保同步线程之间的公平性</li>\n</ul>\n<p>可重入锁既是为了解决以上问题提出的。</p>\n<p>但是关于这个可重入的名字我觉得还是比较让人疑惑，synchronized本身也是支持一个线程的重入的。</p>\n<p>对于原生synchronized的缺陷，ReentrantLock提供了如下几个重要的方法以改善：</p>\n<ul>\n<li>lockInterruptibly()：获得锁，但优先响应中断</li>\n<li>tryLock()：尝试获得锁，成功返回true，失败立即返false，不等待</li>\n<li>tryLock(long time, TimeUnit unit)：在给定时间内尝试获得锁</li>\n<li>unlock()：释放锁</li>\n<li>ReentrantLock(boolean fair)：确保同步线程之间的访问公平</li>\n</ul>\n<p>除此还提供了最基本的lock()方法：获得，如果锁被占用则等待。</p>\n<p>ReentrantLock使用过程中需要注意的是无论何种方式获取锁，每次获取锁之后都要手动调用unlock方法释放锁。</p>\n<h2 id=\"wait-notify的替身——Condition\"><a href=\"#wait-notify的替身——Condition\" class=\"headerlink\" title=\"wait/notify的替身——Condition\"></a>wait/notify的替身——Condition</h2><p>Condition与ReentrantLock的关系如同synchronized与wait/notify方法的关系。</p>\n<p>为了配合ReentrantLock，Condition本身提供了与wait方法类似的await，与notif方法类似的singal，除此还补充了不响应中断的awaitUninterruptibly方法。</p>\n<p>关于Condition的使用：</p>\n<ul>\n<li>通过ReentrantLock实例的工厂方法获取Condition。</li>\n</ul>\n<ul>\n<li>调用await时必须持有线程的相关ReentrantLock，await调用后线程会释放锁，当再次被唤醒时重新持有锁</li>\n<li>调用signal时也必须持有线程的相关ReentrantLock，但是调用结束后需要手动释放锁，否则被唤醒线程无法获取锁</li>\n</ul>\n<h2 id=\"宽容的临界区——Semaphore\"><a href=\"#宽容的临界区——Semaphore\" class=\"headerlink\" title=\"宽容的临界区——Semaphore\"></a>宽容的临界区——Semaphore</h2><p>可以简单的理解信号量（Semaphore）是可以多个线程同时访问的临界区资源。</p>\n<p>在构造Semapho时必须制定多个线程的具体数量，还可以指定是否是否公平访问，对象的其它主要方法有：</p>\n<ul>\n<li>acquire()</li>\n<li>acquireUninterruptibly()</li>\n<li>tryAcquire()</li>\n<li>tryAcquire(long timeout, TimeUnit unit)</li>\n<li>release()</li>\n</ul>\n<p>方法的含义如同方法名，没有发现使用特别的地方。</p>\n<p>需要注意的是申请的信号量使用完毕后，需要release以避免资源越来越少。</p>\n<h2 id=\"读写锁——ReentrantReadWriteLock\"><a href=\"#读写锁——ReentrantReadWriteLock\" class=\"headerlink\" title=\"读写锁——ReentrantReadWriteLock\"></a>读写锁——ReentrantReadWriteLock</h2><p>说来惭愧，到目前为止在实际项目中并发包的各种工具我貌似只使用过读写锁。</p>\n<p>通常锁都是严格串行的，读写锁提供读写分离锁，对多个读操作不进行阻塞，以此来改善性能。</p>\n<p>具体使用中读锁和写锁需要从同一个ReentrantReadWriteLock对象获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReentrantReadWriteLock readWriteLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</div><div class=\"line\">Lock readLock = readWriteLock.readLock();</div><div class=\"line\">Lock writeLock = readWriteLock.writeLock();</div></pre></td></tr></table></figure>\n<p>针对读操作使用读锁，针对写操作使用写锁。</p>\n<h2 id=\"倒计数器与循环栅栏\"><a href=\"#倒计数器与循环栅栏\" class=\"headerlink\" title=\"倒计数器与循环栅栏\"></a>倒计数器与循环栅栏</h2><p>倒计数器：CountDownLatch</p>\n<p>循环栅栏：CyclicBarrier</p>\n<p>这两个工具具体用法不好解释，我以一个场景考试举例，这个场景有如下特点：</p>\n<ul>\n<li>参加考试的人员是一定的</li>\n<li>使用一个线程表示一个参考人员</li>\n<li>不限时，考试结束的唯一标志是所有人员交卷</li>\n</ul>\n<p>使用倒计数器实现时：</p>\n<ul>\n<li>CountDownLatch定义多少人参加考试</li>\n<li>每次有人交卷CountDownLatch就减少一，交卷后人员自由离开考场</li>\n<li>当CountDownLatch减少到0时表示考试结束</li>\n</ul>\n<p>使用循环栅栏实现时：</p>\n<ul>\n<li>CyclicBarrier定义多少人参加考试，宣布考试结束</li>\n<li>每次有人交卷CyclicBarrier就减少一，但是交卷后人员不能离开考场</li>\n<li>当CyclicBarrier减少到0时表示考试结束，所有人统一离场，宣布考试结束</li>\n<li>当一场考试结束，下一场考试立即准备完毕</li>\n</ul>\n<p>可以看出CyclicBarrier还是更强大一些的。</p>\n<p>相较于CountDownLatch，CyclicBarrier可以定义完成事件，可以重复使用，控制线程的阻塞。</p>\n<hr>\n<p>以上并发工具的使用示例都可以在<a href=\"https://github.com/zhanghTK/Joolkit/tree/master/concurrent/src/test/java/tk/zhangh/java/concurrent/thread\">Joolkit</a>中找到。</p>\n"},{"title":"Java内存区域","date":"2016-08-14T15:02:39.000Z","_content":"\n![Java内存区域.png](https://ooo.0o0.ooo/2016/08/14/57b08be587b3a.png)\n","source":"_posts/Java内存区域.md","raw":"---\ntitle: Java内存区域\ndate: 2016-08-14 23:02:39\ntags:\n  - daily\n  - JVM\n  - Java\ncategories: Java\n\n---\n\n![Java内存区域.png](https://ooo.0o0.ooo/2016/08/14/57b08be587b3a.png)\n","slug":"Java内存区域","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2ph000td82e6ha278m0","content":"<p><img src=\"https://ooo.0o0.ooo/2016/08/14/57b08be587b3a.png\" alt=\"Java内存区域.png\"></p>\n","excerpt":"","more":"<p><img src=\"https://ooo.0o0.ooo/2016/08/14/57b08be587b3a.png\" alt=\"Java内存区域.png\"></p>\n"},{"title":"SpringBoot包文件执行分析","date":"2017-06-20T15:20:45.000Z","_content":"Spring Boot的一大特性是可以直接打包，并且这个Jar是可以直接启动的，不需要额外配置Servlet容器。\n\n这一特性极大的简化了配置，运维的工作。之前碰到这个问题也没有深究，今天记一下，以备后看。\n\n（最终本文未完成Servlet容器启动的说明，只记录了Jar包的启动）\n\n## 项目结构\n\n期初以为Spring Boot的启动入口就是应用中由`@SpringBootApplication`注解的`Main`方法，还在想到底是怎么把容器集成进去的。事先在网上查了一下，启动是从打包后Jar包中的 MANIFEST.MF 文件入手的。\n\n首先看一下一个空的Spring Boot应用打包后的结构：\n\n```\n├── BOOT-INF\n│   ├── classes\n│   │   ├── application.properties\n│   │   └── com\n│   │       └── example\n│   │           └── demo\n│   │               └── DemoApplication.class\n│   └── lib\n│       ├── classmate-1.3.3.jar\n│       ├── ...\n├── META-INF\n│   ├── MANIFEST.MF\n│   └── maven\n│       └── com.example\n│           └── demo\n│               ├── pom.properties\n│               └── pom.xml\n└── org\n    └── springframework\n        └── boot\n            └── loader\n                ├── JarLauncher.class\n                ├── ...\n```\n\n整个结构从结构和命名就能大体猜到含义，与网上看到的结构有些差异，但整体大同小异。\n\n回到刚才提及的 MANIFEST.MF，其内容如下：\n\n```properties\nManifest-Version: 1.0\nImplementation-Title: demo\nImplementation-Version: 0.0.1-SNAPSHOT\nArchiver-Version: Plexus Archiver\nBuilt-By: user\nImplementation-Vendor-Id: com.example\nSpring-Boot-Version: 1.5.4.RELEASE\nImplementation-Vendor: Pivotal Software, Inc.\nMain-Class: org.springframework.boot.loader.JarLauncher\nStart-Class: com.example.demo.DemoApplication\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nCreated-By: Apache Maven 3.3.9\nBuild-Jdk: 1.8.0_91\nImplementation-URL: http://projects.spring.io/spring-boot/demo/\n```\n\n里面有构建的各项基本信息，其中的Main-Class指定了`JarLauncher`，`Start-Class`指定了应用中的入口。\n\n看来`JarLauncher`才是项目的启动入口。除了Launcher外，Spring还提供了另一个重要的支持：Archive，先看看Archive。\n\n## Archive\n\n`Archive`是资源的抽象接口，定义了基本的资源获取抽象方法，可以用来表示Jar，文件目录等各种资源。\n\n其子类`JarFileArchive`表示Jar包文件的抽象，内部包含一个`JarFile`对应一个Jar包，在创建`JarFile`实例时会解析Jar包的内部结构。\n\n在资源解析过程中获取的URL可能存在多个`!/`作为资源分隔符分隔符，这是Spring在Jar协议基础上扩展出的，默认使用`org.springframework.boot.loader.jar.Handler`作为URL处理器。\n\n资源解析较为繁琐，且与启动逻辑关系不紧密，这里不做多记录。\n\n## Launcher\n\nLauncher作为启动器的抽象，提供了多个具体实现：`ExecutableArchiveLauncher`,`JarLauncher`,`WarLauncher`以及`PropertiesLauncher` ，其中`ExecutableArchiveLauncher`是个抽象实现，作为`JarLauncher`和`WarLauncher`的父类。\n\n`JarLauncher`是Jar包的启动类，下面详细看看启动过程实现：\n\n```java\npublic static void main(String[] args) {\n    new JarLauncher().launch(args);\n}\n```\n\n直接调用父类`Launcher`的实现：\n\n```java\nprotected void launch(String[] args) {\n  try {\n    // 设置上文提及的URL处理器\n    JarFile.registerUrlProtocolHandler();\n    // 获取classpath下的JarFileArchive，根据这些JarFileArchive创建类加载器\n    ClassLoader classLoader = createClassLoader(getClassPathArchives());\n    // 获得上文提及的start-class，调用重载launch方法\n    launch(args, getMainClass(), classLoader);\n  }\n  catch (Exception ex) {\n    ex.printStackTrace();\n    System.exit(1);\n  }\n}\n\nprotected void launch(String[] args, String mainClass, ClassLoader classLoader) \n  \t\t\t\t\t\tthrows Exception {\n    // 反射创建一个MainMethodRunner\n\tRunnable runner = createMainMethodRunner(mainClass, args, classLoader);\n    // 创建线程，启动\n\tThread runnerThread = new Thread(runner);\n\trunnerThread.setContextClassLoader(classLoader);\n\trunnerThread.setName(Thread.currentThread().getName());\n\trunnerThread.start();\n}\n\n```\n\n这里的ClassLoader是Spring自定义了类加载器`LaunchedURLClassLoader`，该类继承自`URLClassLoader`，加载逻辑：\n\n```java\n@Override\nprotected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n  synchronized (LaunchedURLClassLoader.LOCK_PROVIDER.getLock(this, name)) {\n    Class<?> loadedClass = findLoadedClass(name);\n    if (loadedClass == null) {\n      Handler.setUseFastConnectionExceptions(true);\n      try {\n        loadedClass = doLoadClass(name);\n      }\n      finally {\n        Handler.setUseFastConnectionExceptions(false);\n      }\n    }\n    if (resolve) {\n      resolveClass(loadedClass);\n    }\n    return loadedClass;\n  }\n}\n\nprivate Class<?> doLoadClass(String name) throws ClassNotFoundException {\n  // 尝试根类加载器加载\n  try {\n    if (this.rootClassLoader != null) {\n      return this.rootClassLoader.loadClass(name);\n    }\n  }\n  catch (Exception ex) {\n  }\n  \n  // 尝试父类的findClass\n  try {\n    findPackage(name);\n    Class<?> cls = findClass(name);\n\treturn cls;\n  }\n  catch (Exception ex) {\n  }\n\n  // 尝试父类的加载（双亲委派）\n  return super.loadClass(name, false);\n}\n\n// 设置根加载器为Extension ClassLoader\npublic LaunchedURLClassLoader(URL[] urls, ClassLoader parent) {\n  super(urls, parent);\n  this.rootClassLoader = findRootClassLoader(parent);\n}\n\nprivate ClassLoader findRootClassLoader(ClassLoader classLoader) {\n  while (classLoader != null) {\n    if (classLoader.getParent() == null) {\n      return classLoader;\n    }\n    classLoader = classLoader.getParent();\n  }\n  return null;\n}\n```\n\n简而言之破坏了双亲委派，如果没有加载过使用`doLoadClass`方法加载，内部加载逻辑：\n\n1. 尝试根类加载器加载(Extension ClassLoader)\n2. 尝试父类的findClass\n3. 尝试父类的加载（双亲委派）\n\n最后详细看一下`MainMethodRunner`的`run`方法，启动的其它逻辑都这这里了：\n\n```java\n@Override\npublic void run() {\n  try {\n    // 获取应用入口\n    Class<?> mainClass = Thread.currentThread().getContextClassLoader()\n      .loadClass(this.mainClassName);\n    Method mainMethod = mainClass.getDeclaredMethod(\"main\", String[].class);\n    if (mainMethod == null) {\n        throw new IllegalStateException(this.mainClassName\n\t\t\t\t\t\t+ \" does not have a main method\");\n    }\n    // 调用main方法\n    mainMethod.invoke(null, new Object[] { this.args });\n  } catch (Exception ex) {\n    ex.printStackTrace();\n\tSystem.exit(1);\n  }\n}\n```\n\n总结一下：\n\n1. 项目启动从`JarLauncher`开始\n2. 设置Url处理器，加载需要的各种资源\n3. 相关资源的加载使用了自定义的类加载器\n4. 开启新线程调用应用入口\n\n整个实现过程也没有用到什么特别的东西，主要还是反射，类加载器，线程的东西，额外还扩展了Jar协议。\n\n但是并没有看到关于Servlet容器的内容，看来容器的启动和Jar的执行是分开的。\n","source":"_posts/SpringBoot包文件执行分析.md","raw":"---\ntitle: SpringBoot包文件执行分析\ndate: 2017-06-20 23:20:45\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\nSpring Boot的一大特性是可以直接打包，并且这个Jar是可以直接启动的，不需要额外配置Servlet容器。\n\n这一特性极大的简化了配置，运维的工作。之前碰到这个问题也没有深究，今天记一下，以备后看。\n\n（最终本文未完成Servlet容器启动的说明，只记录了Jar包的启动）\n\n## 项目结构\n\n期初以为Spring Boot的启动入口就是应用中由`@SpringBootApplication`注解的`Main`方法，还在想到底是怎么把容器集成进去的。事先在网上查了一下，启动是从打包后Jar包中的 MANIFEST.MF 文件入手的。\n\n首先看一下一个空的Spring Boot应用打包后的结构：\n\n```\n├── BOOT-INF\n│   ├── classes\n│   │   ├── application.properties\n│   │   └── com\n│   │       └── example\n│   │           └── demo\n│   │               └── DemoApplication.class\n│   └── lib\n│       ├── classmate-1.3.3.jar\n│       ├── ...\n├── META-INF\n│   ├── MANIFEST.MF\n│   └── maven\n│       └── com.example\n│           └── demo\n│               ├── pom.properties\n│               └── pom.xml\n└── org\n    └── springframework\n        └── boot\n            └── loader\n                ├── JarLauncher.class\n                ├── ...\n```\n\n整个结构从结构和命名就能大体猜到含义，与网上看到的结构有些差异，但整体大同小异。\n\n回到刚才提及的 MANIFEST.MF，其内容如下：\n\n```properties\nManifest-Version: 1.0\nImplementation-Title: demo\nImplementation-Version: 0.0.1-SNAPSHOT\nArchiver-Version: Plexus Archiver\nBuilt-By: user\nImplementation-Vendor-Id: com.example\nSpring-Boot-Version: 1.5.4.RELEASE\nImplementation-Vendor: Pivotal Software, Inc.\nMain-Class: org.springframework.boot.loader.JarLauncher\nStart-Class: com.example.demo.DemoApplication\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nCreated-By: Apache Maven 3.3.9\nBuild-Jdk: 1.8.0_91\nImplementation-URL: http://projects.spring.io/spring-boot/demo/\n```\n\n里面有构建的各项基本信息，其中的Main-Class指定了`JarLauncher`，`Start-Class`指定了应用中的入口。\n\n看来`JarLauncher`才是项目的启动入口。除了Launcher外，Spring还提供了另一个重要的支持：Archive，先看看Archive。\n\n## Archive\n\n`Archive`是资源的抽象接口，定义了基本的资源获取抽象方法，可以用来表示Jar，文件目录等各种资源。\n\n其子类`JarFileArchive`表示Jar包文件的抽象，内部包含一个`JarFile`对应一个Jar包，在创建`JarFile`实例时会解析Jar包的内部结构。\n\n在资源解析过程中获取的URL可能存在多个`!/`作为资源分隔符分隔符，这是Spring在Jar协议基础上扩展出的，默认使用`org.springframework.boot.loader.jar.Handler`作为URL处理器。\n\n资源解析较为繁琐，且与启动逻辑关系不紧密，这里不做多记录。\n\n## Launcher\n\nLauncher作为启动器的抽象，提供了多个具体实现：`ExecutableArchiveLauncher`,`JarLauncher`,`WarLauncher`以及`PropertiesLauncher` ，其中`ExecutableArchiveLauncher`是个抽象实现，作为`JarLauncher`和`WarLauncher`的父类。\n\n`JarLauncher`是Jar包的启动类，下面详细看看启动过程实现：\n\n```java\npublic static void main(String[] args) {\n    new JarLauncher().launch(args);\n}\n```\n\n直接调用父类`Launcher`的实现：\n\n```java\nprotected void launch(String[] args) {\n  try {\n    // 设置上文提及的URL处理器\n    JarFile.registerUrlProtocolHandler();\n    // 获取classpath下的JarFileArchive，根据这些JarFileArchive创建类加载器\n    ClassLoader classLoader = createClassLoader(getClassPathArchives());\n    // 获得上文提及的start-class，调用重载launch方法\n    launch(args, getMainClass(), classLoader);\n  }\n  catch (Exception ex) {\n    ex.printStackTrace();\n    System.exit(1);\n  }\n}\n\nprotected void launch(String[] args, String mainClass, ClassLoader classLoader) \n  \t\t\t\t\t\tthrows Exception {\n    // 反射创建一个MainMethodRunner\n\tRunnable runner = createMainMethodRunner(mainClass, args, classLoader);\n    // 创建线程，启动\n\tThread runnerThread = new Thread(runner);\n\trunnerThread.setContextClassLoader(classLoader);\n\trunnerThread.setName(Thread.currentThread().getName());\n\trunnerThread.start();\n}\n\n```\n\n这里的ClassLoader是Spring自定义了类加载器`LaunchedURLClassLoader`，该类继承自`URLClassLoader`，加载逻辑：\n\n```java\n@Override\nprotected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n  synchronized (LaunchedURLClassLoader.LOCK_PROVIDER.getLock(this, name)) {\n    Class<?> loadedClass = findLoadedClass(name);\n    if (loadedClass == null) {\n      Handler.setUseFastConnectionExceptions(true);\n      try {\n        loadedClass = doLoadClass(name);\n      }\n      finally {\n        Handler.setUseFastConnectionExceptions(false);\n      }\n    }\n    if (resolve) {\n      resolveClass(loadedClass);\n    }\n    return loadedClass;\n  }\n}\n\nprivate Class<?> doLoadClass(String name) throws ClassNotFoundException {\n  // 尝试根类加载器加载\n  try {\n    if (this.rootClassLoader != null) {\n      return this.rootClassLoader.loadClass(name);\n    }\n  }\n  catch (Exception ex) {\n  }\n  \n  // 尝试父类的findClass\n  try {\n    findPackage(name);\n    Class<?> cls = findClass(name);\n\treturn cls;\n  }\n  catch (Exception ex) {\n  }\n\n  // 尝试父类的加载（双亲委派）\n  return super.loadClass(name, false);\n}\n\n// 设置根加载器为Extension ClassLoader\npublic LaunchedURLClassLoader(URL[] urls, ClassLoader parent) {\n  super(urls, parent);\n  this.rootClassLoader = findRootClassLoader(parent);\n}\n\nprivate ClassLoader findRootClassLoader(ClassLoader classLoader) {\n  while (classLoader != null) {\n    if (classLoader.getParent() == null) {\n      return classLoader;\n    }\n    classLoader = classLoader.getParent();\n  }\n  return null;\n}\n```\n\n简而言之破坏了双亲委派，如果没有加载过使用`doLoadClass`方法加载，内部加载逻辑：\n\n1. 尝试根类加载器加载(Extension ClassLoader)\n2. 尝试父类的findClass\n3. 尝试父类的加载（双亲委派）\n\n最后详细看一下`MainMethodRunner`的`run`方法，启动的其它逻辑都这这里了：\n\n```java\n@Override\npublic void run() {\n  try {\n    // 获取应用入口\n    Class<?> mainClass = Thread.currentThread().getContextClassLoader()\n      .loadClass(this.mainClassName);\n    Method mainMethod = mainClass.getDeclaredMethod(\"main\", String[].class);\n    if (mainMethod == null) {\n        throw new IllegalStateException(this.mainClassName\n\t\t\t\t\t\t+ \" does not have a main method\");\n    }\n    // 调用main方法\n    mainMethod.invoke(null, new Object[] { this.args });\n  } catch (Exception ex) {\n    ex.printStackTrace();\n\tSystem.exit(1);\n  }\n}\n```\n\n总结一下：\n\n1. 项目启动从`JarLauncher`开始\n2. 设置Url处理器，加载需要的各种资源\n3. 相关资源的加载使用了自定义的类加载器\n4. 开启新线程调用应用入口\n\n整个实现过程也没有用到什么特别的东西，主要还是反射，类加载器，线程的东西，额外还扩展了Jar协议。\n\n但是并没有看到关于Servlet容器的内容，看来容器的启动和Jar的执行是分开的。\n","slug":"SpringBoot包文件执行分析","published":1,"updated":"2017-06-20T15:22:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2pk000wd82eswhuy6sr","content":"<p>Spring Boot的一大特性是可以直接打包，并且这个Jar是可以直接启动的，不需要额外配置Servlet容器。</p>\n<p>这一特性极大的简化了配置，运维的工作。之前碰到这个问题也没有深究，今天记一下，以备后看。</p>\n<p>（最终本文未完成Servlet容器启动的说明，只记录了Jar包的启动）</p>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>期初以为Spring Boot的启动入口就是应用中由<code>@SpringBootApplication</code>注解的<code>Main</code>方法，还在想到底是怎么把容器集成进去的。事先在网上查了一下，启动是从打包后Jar包中的 MANIFEST.MF 文件入手的。</p>\n<p>首先看一下一个空的Spring Boot应用打包后的结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── BOOT-INF</div><div class=\"line\">│   ├── classes</div><div class=\"line\">│   │   ├── application.properties</div><div class=\"line\">│   │   └── com</div><div class=\"line\">│   │       └── example</div><div class=\"line\">│   │           └── demo</div><div class=\"line\">│   │               └── DemoApplication.class</div><div class=\"line\">│   └── lib</div><div class=\"line\">│       ├── classmate-1.3.3.jar</div><div class=\"line\">│       ├── ...</div><div class=\"line\">├── META-INF</div><div class=\"line\">│   ├── MANIFEST.MF</div><div class=\"line\">│   └── maven</div><div class=\"line\">│       └── com.example</div><div class=\"line\">│           └── demo</div><div class=\"line\">│               ├── pom.properties</div><div class=\"line\">│               └── pom.xml</div><div class=\"line\">└── org</div><div class=\"line\">    └── springframework</div><div class=\"line\">        └── boot</div><div class=\"line\">            └── loader</div><div class=\"line\">                ├── JarLauncher.class</div><div class=\"line\">                ├── ...</div></pre></td></tr></table></figure>\n<p>整个结构从结构和命名就能大体猜到含义，与网上看到的结构有些差异，但整体大同小异。</p>\n<p>回到刚才提及的 MANIFEST.MF，其内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Manifest-Version: 1.0</div><div class=\"line\">Implementation-Title: demo</div><div class=\"line\">Implementation-Version: 0.0.1-SNAPSHOT</div><div class=\"line\">Archiver-Version: Plexus Archiver</div><div class=\"line\">Built-By: user</div><div class=\"line\">Implementation-Vendor-Id: com.example</div><div class=\"line\">Spring-Boot-Version: 1.5.4.RELEASE</div><div class=\"line\">Implementation-Vendor: Pivotal Software, Inc.</div><div class=\"line\">Main-Class: org.springframework.boot.loader.JarLauncher</div><div class=\"line\">Start-Class: com.example.demo.DemoApplication</div><div class=\"line\">Spring-Boot-Classes: BOOT-INF/classes/</div><div class=\"line\">Spring-Boot-Lib: BOOT-INF/lib/</div><div class=\"line\">Created-By: Apache Maven 3.3.9</div><div class=\"line\">Build-Jdk: 1.8.0_91</div><div class=\"line\">Implementation-URL: http://projects.spring.io/spring-boot/demo/</div></pre></td></tr></table></figure>\n<p>里面有构建的各项基本信息，其中的Main-Class指定了<code>JarLauncher</code>，<code>Start-Class</code>指定了应用中的入口。</p>\n<p>看来<code>JarLauncher</code>才是项目的启动入口。除了Launcher外，Spring还提供了另一个重要的支持：Archive，先看看Archive。</p>\n<h2 id=\"Archive\"><a href=\"#Archive\" class=\"headerlink\" title=\"Archive\"></a>Archive</h2><p><code>Archive</code>是资源的抽象接口，定义了基本的资源获取抽象方法，可以用来表示Jar，文件目录等各种资源。</p>\n<p>其子类<code>JarFileArchive</code>表示Jar包文件的抽象，内部包含一个<code>JarFile</code>对应一个Jar包，在创建<code>JarFile</code>实例时会解析Jar包的内部结构。</p>\n<p>在资源解析过程中获取的URL可能存在多个<code>!/</code>作为资源分隔符分隔符，这是Spring在Jar协议基础上扩展出的，默认使用<code>org.springframework.boot.loader.jar.Handler</code>作为URL处理器。</p>\n<p>资源解析较为繁琐，且与启动逻辑关系不紧密，这里不做多记录。</p>\n<h2 id=\"Launcher\"><a href=\"#Launcher\" class=\"headerlink\" title=\"Launcher\"></a>Launcher</h2><p>Launcher作为启动器的抽象，提供了多个具体实现：<code>ExecutableArchiveLauncher</code>,<code>JarLauncher</code>,<code>WarLauncher</code>以及<code>PropertiesLauncher</code> ，其中<code>ExecutableArchiveLauncher</code>是个抽象实现，作为<code>JarLauncher</code>和<code>WarLauncher</code>的父类。</p>\n<p><code>JarLauncher</code>是Jar包的启动类，下面详细看看启动过程实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">new</span> JarLauncher().launch(args);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>直接调用父类<code>Launcher</code>的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">launch</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 设置上文提及的URL处理器</span></div><div class=\"line\">    JarFile.registerUrlProtocolHandler();</div><div class=\"line\">    <span class=\"comment\">// 获取classpath下的JarFileArchive，根据这些JarFileArchive创建类加载器</span></div><div class=\"line\">    ClassLoader classLoader = createClassLoader(getClassPathArchives());</div><div class=\"line\">    <span class=\"comment\">// 获得上文提及的start-class，调用重载launch方法</span></div><div class=\"line\">    launch(args, getMainClass(), classLoader);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">    ex.printStackTrace();</div><div class=\"line\">    System.exit(<span class=\"number\">1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">launch</span><span class=\"params\">(String[] args, String mainClass, ClassLoader classLoader)</span> </span></div><div class=\"line\">  \t\t\t\t\t\t<span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">    <span class=\"comment\">// 反射创建一个MainMethodRunner</span></div><div class=\"line\">\tRunnable runner = createMainMethodRunner(mainClass, args, classLoader);</div><div class=\"line\">    <span class=\"comment\">// 创建线程，启动</span></div><div class=\"line\">\tThread runnerThread = <span class=\"keyword\">new</span> Thread(runner);</div><div class=\"line\">\trunnerThread.setContextClassLoader(classLoader);</div><div class=\"line\">\trunnerThread.setName(Thread.currentThread().getName());</div><div class=\"line\">\trunnerThread.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的ClassLoader是Spring自定义了类加载器<code>LaunchedURLClassLoader</code>，该类继承自<code>URLClassLoader</code>，加载逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</div><div class=\"line\">  <span class=\"keyword\">synchronized</span> (LaunchedURLClassLoader.LOCK_PROVIDER.getLock(<span class=\"keyword\">this</span>, name)) &#123;</div><div class=\"line\">    Class&lt;?&gt; loadedClass = findLoadedClass(name);</div><div class=\"line\">    <span class=\"keyword\">if</span> (loadedClass == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      Handler.setUseFastConnectionExceptions(<span class=\"keyword\">true</span>);</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        loadedClass = doLoadClass(name);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        Handler.setUseFastConnectionExceptions(<span class=\"keyword\">false</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (resolve) &#123;</div><div class=\"line\">      resolveClass(loadedClass);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> loadedClass;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; doLoadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</div><div class=\"line\">  <span class=\"comment\">// 尝试根类加载器加载</span></div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.rootClassLoader != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.rootClassLoader.loadClass(name);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 尝试父类的findClass</span></div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    findPackage(name);</div><div class=\"line\">    Class&lt;?&gt; cls = findClass(name);</div><div class=\"line\">\t<span class=\"keyword\">return</span> cls;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 尝试父类的加载（双亲委派）</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.loadClass(name, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置根加载器为Extension ClassLoader</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LaunchedURLClassLoader</span><span class=\"params\">(URL[] urls, ClassLoader parent)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">super</span>(urls, parent);</div><div class=\"line\">  <span class=\"keyword\">this</span>.rootClassLoader = findRootClassLoader(parent);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ClassLoader <span class=\"title\">findRootClassLoader</span><span class=\"params\">(ClassLoader classLoader)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">while</span> (classLoader != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (classLoader.getParent() == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> classLoader;</div><div class=\"line\">    &#125;</div><div class=\"line\">    classLoader = classLoader.getParent();</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>简而言之破坏了双亲委派，如果没有加载过使用<code>doLoadClass</code>方法加载，内部加载逻辑：</p>\n<ol>\n<li>尝试根类加载器加载(Extension ClassLoader)</li>\n<li>尝试父类的findClass</li>\n<li>尝试父类的加载（双亲委派）</li>\n</ol>\n<p>最后详细看一下<code>MainMethodRunner</code>的<code>run</code>方法，启动的其它逻辑都这这里了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 获取应用入口</span></div><div class=\"line\">    Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</div><div class=\"line\">      .loadClass(<span class=\"keyword\">this</span>.mainClassName);</div><div class=\"line\">    Method mainMethod = mainClass.getDeclaredMethod(<span class=\"string\">\"main\"</span>, String[].class);</div><div class=\"line\">    <span class=\"keyword\">if</span> (mainMethod == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"keyword\">this</span>.mainClassName</div><div class=\"line\">\t\t\t\t\t\t+ <span class=\"string\">\" does not have a main method\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 调用main方法</span></div><div class=\"line\">    mainMethod.invoke(<span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[] &#123; <span class=\"keyword\">this</span>.args &#125;);</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">    ex.printStackTrace();</div><div class=\"line\">\tSystem.exit(<span class=\"number\">1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总结一下：</p>\n<ol>\n<li>项目启动从<code>JarLauncher</code>开始</li>\n<li>设置Url处理器，加载需要的各种资源</li>\n<li>相关资源的加载使用了自定义的类加载器</li>\n<li>开启新线程调用应用入口</li>\n</ol>\n<p>整个实现过程也没有用到什么特别的东西，主要还是反射，类加载器，线程的东西，额外还扩展了Jar协议。</p>\n<p>但是并没有看到关于Servlet容器的内容，看来容器的启动和Jar的执行是分开的。</p>\n","excerpt":"","more":"<p>Spring Boot的一大特性是可以直接打包，并且这个Jar是可以直接启动的，不需要额外配置Servlet容器。</p>\n<p>这一特性极大的简化了配置，运维的工作。之前碰到这个问题也没有深究，今天记一下，以备后看。</p>\n<p>（最终本文未完成Servlet容器启动的说明，只记录了Jar包的启动）</p>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>期初以为Spring Boot的启动入口就是应用中由<code>@SpringBootApplication</code>注解的<code>Main</code>方法，还在想到底是怎么把容器集成进去的。事先在网上查了一下，启动是从打包后Jar包中的 MANIFEST.MF 文件入手的。</p>\n<p>首先看一下一个空的Spring Boot应用打包后的结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── BOOT-INF</div><div class=\"line\">│   ├── classes</div><div class=\"line\">│   │   ├── application.properties</div><div class=\"line\">│   │   └── com</div><div class=\"line\">│   │       └── example</div><div class=\"line\">│   │           └── demo</div><div class=\"line\">│   │               └── DemoApplication.class</div><div class=\"line\">│   └── lib</div><div class=\"line\">│       ├── classmate-1.3.3.jar</div><div class=\"line\">│       ├── ...</div><div class=\"line\">├── META-INF</div><div class=\"line\">│   ├── MANIFEST.MF</div><div class=\"line\">│   └── maven</div><div class=\"line\">│       └── com.example</div><div class=\"line\">│           └── demo</div><div class=\"line\">│               ├── pom.properties</div><div class=\"line\">│               └── pom.xml</div><div class=\"line\">└── org</div><div class=\"line\">    └── springframework</div><div class=\"line\">        └── boot</div><div class=\"line\">            └── loader</div><div class=\"line\">                ├── JarLauncher.class</div><div class=\"line\">                ├── ...</div></pre></td></tr></table></figure>\n<p>整个结构从结构和命名就能大体猜到含义，与网上看到的结构有些差异，但整体大同小异。</p>\n<p>回到刚才提及的 MANIFEST.MF，其内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Manifest-Version: 1.0</div><div class=\"line\">Implementation-Title: demo</div><div class=\"line\">Implementation-Version: 0.0.1-SNAPSHOT</div><div class=\"line\">Archiver-Version: Plexus Archiver</div><div class=\"line\">Built-By: user</div><div class=\"line\">Implementation-Vendor-Id: com.example</div><div class=\"line\">Spring-Boot-Version: 1.5.4.RELEASE</div><div class=\"line\">Implementation-Vendor: Pivotal Software, Inc.</div><div class=\"line\">Main-Class: org.springframework.boot.loader.JarLauncher</div><div class=\"line\">Start-Class: com.example.demo.DemoApplication</div><div class=\"line\">Spring-Boot-Classes: BOOT-INF/classes/</div><div class=\"line\">Spring-Boot-Lib: BOOT-INF/lib/</div><div class=\"line\">Created-By: Apache Maven 3.3.9</div><div class=\"line\">Build-Jdk: 1.8.0_91</div><div class=\"line\">Implementation-URL: http://projects.spring.io/spring-boot/demo/</div></pre></td></tr></table></figure>\n<p>里面有构建的各项基本信息，其中的Main-Class指定了<code>JarLauncher</code>，<code>Start-Class</code>指定了应用中的入口。</p>\n<p>看来<code>JarLauncher</code>才是项目的启动入口。除了Launcher外，Spring还提供了另一个重要的支持：Archive，先看看Archive。</p>\n<h2 id=\"Archive\"><a href=\"#Archive\" class=\"headerlink\" title=\"Archive\"></a>Archive</h2><p><code>Archive</code>是资源的抽象接口，定义了基本的资源获取抽象方法，可以用来表示Jar，文件目录等各种资源。</p>\n<p>其子类<code>JarFileArchive</code>表示Jar包文件的抽象，内部包含一个<code>JarFile</code>对应一个Jar包，在创建<code>JarFile</code>实例时会解析Jar包的内部结构。</p>\n<p>在资源解析过程中获取的URL可能存在多个<code>!/</code>作为资源分隔符分隔符，这是Spring在Jar协议基础上扩展出的，默认使用<code>org.springframework.boot.loader.jar.Handler</code>作为URL处理器。</p>\n<p>资源解析较为繁琐，且与启动逻辑关系不紧密，这里不做多记录。</p>\n<h2 id=\"Launcher\"><a href=\"#Launcher\" class=\"headerlink\" title=\"Launcher\"></a>Launcher</h2><p>Launcher作为启动器的抽象，提供了多个具体实现：<code>ExecutableArchiveLauncher</code>,<code>JarLauncher</code>,<code>WarLauncher</code>以及<code>PropertiesLauncher</code> ，其中<code>ExecutableArchiveLauncher</code>是个抽象实现，作为<code>JarLauncher</code>和<code>WarLauncher</code>的父类。</p>\n<p><code>JarLauncher</code>是Jar包的启动类，下面详细看看启动过程实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">new</span> JarLauncher().launch(args);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>直接调用父类<code>Launcher</code>的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">launch</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 设置上文提及的URL处理器</span></div><div class=\"line\">    JarFile.registerUrlProtocolHandler();</div><div class=\"line\">    <span class=\"comment\">// 获取classpath下的JarFileArchive，根据这些JarFileArchive创建类加载器</span></div><div class=\"line\">    ClassLoader classLoader = createClassLoader(getClassPathArchives());</div><div class=\"line\">    <span class=\"comment\">// 获得上文提及的start-class，调用重载launch方法</span></div><div class=\"line\">    launch(args, getMainClass(), classLoader);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">    ex.printStackTrace();</div><div class=\"line\">    System.exit(<span class=\"number\">1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">launch</span><span class=\"params\">(String[] args, String mainClass, ClassLoader classLoader)</span> </div><div class=\"line\">  \t\t\t\t\t\t<span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 反射创建一个MainMethodRunner</span></div><div class=\"line\">\tRunnable runner = createMainMethodRunner(mainClass, args, classLoader);</div><div class=\"line\">    <span class=\"comment\">// 创建线程，启动</span></div><div class=\"line\">\tThread runnerThread = <span class=\"keyword\">new</span> Thread(runner);</div><div class=\"line\">\trunnerThread.setContextClassLoader(classLoader);</div><div class=\"line\">\trunnerThread.setName(Thread.currentThread().getName());</div><div class=\"line\">\trunnerThread.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的ClassLoader是Spring自定义了类加载器<code>LaunchedURLClassLoader</code>，该类继承自<code>URLClassLoader</code>，加载逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</div><div class=\"line\">  <span class=\"keyword\">synchronized</span> (LaunchedURLClassLoader.LOCK_PROVIDER.getLock(<span class=\"keyword\">this</span>, name)) &#123;</div><div class=\"line\">    Class&lt;?&gt; loadedClass = findLoadedClass(name);</div><div class=\"line\">    <span class=\"keyword\">if</span> (loadedClass == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      Handler.setUseFastConnectionExceptions(<span class=\"keyword\">true</span>);</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        loadedClass = doLoadClass(name);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        Handler.setUseFastConnectionExceptions(<span class=\"keyword\">false</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (resolve) &#123;</div><div class=\"line\">      resolveClass(loadedClass);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> loadedClass;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; doLoadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</div><div class=\"line\">  <span class=\"comment\">// 尝试根类加载器加载</span></div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.rootClassLoader != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.rootClassLoader.loadClass(name);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 尝试父类的findClass</span></div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    findPackage(name);</div><div class=\"line\">    Class&lt;?&gt; cls = findClass(name);</div><div class=\"line\">\t<span class=\"keyword\">return</span> cls;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 尝试父类的加载（双亲委派）</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.loadClass(name, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置根加载器为Extension ClassLoader</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LaunchedURLClassLoader</span><span class=\"params\">(URL[] urls, ClassLoader parent)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">super</span>(urls, parent);</div><div class=\"line\">  <span class=\"keyword\">this</span>.rootClassLoader = findRootClassLoader(parent);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ClassLoader <span class=\"title\">findRootClassLoader</span><span class=\"params\">(ClassLoader classLoader)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">while</span> (classLoader != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (classLoader.getParent() == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> classLoader;</div><div class=\"line\">    &#125;</div><div class=\"line\">    classLoader = classLoader.getParent();</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>简而言之破坏了双亲委派，如果没有加载过使用<code>doLoadClass</code>方法加载，内部加载逻辑：</p>\n<ol>\n<li>尝试根类加载器加载(Extension ClassLoader)</li>\n<li>尝试父类的findClass</li>\n<li>尝试父类的加载（双亲委派）</li>\n</ol>\n<p>最后详细看一下<code>MainMethodRunner</code>的<code>run</code>方法，启动的其它逻辑都这这里了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 获取应用入口</span></div><div class=\"line\">    Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</div><div class=\"line\">      .loadClass(<span class=\"keyword\">this</span>.mainClassName);</div><div class=\"line\">    Method mainMethod = mainClass.getDeclaredMethod(<span class=\"string\">\"main\"</span>, String[].class);</div><div class=\"line\">    <span class=\"keyword\">if</span> (mainMethod == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"keyword\">this</span>.mainClassName</div><div class=\"line\">\t\t\t\t\t\t+ <span class=\"string\">\" does not have a main method\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 调用main方法</span></div><div class=\"line\">    mainMethod.invoke(<span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[] &#123; <span class=\"keyword\">this</span>.args &#125;);</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">    ex.printStackTrace();</div><div class=\"line\">\tSystem.exit(<span class=\"number\">1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总结一下：</p>\n<ol>\n<li>项目启动从<code>JarLauncher</code>开始</li>\n<li>设置Url处理器，加载需要的各种资源</li>\n<li>相关资源的加载使用了自定义的类加载器</li>\n<li>开启新线程调用应用入口</li>\n</ol>\n<p>整个实现过程也没有用到什么特别的东西，主要还是反射，类加载器，线程的东西，额外还扩展了Jar协议。</p>\n<p>但是并没有看到关于Servlet容器的内容，看来容器的启动和Jar的执行是分开的。</p>\n"},{"title":"Lambda表达式","date":"2017-01-15T18:39:56.000Z","_content":"\n# Lambda表达式\n\n**Lambda表达式**:一段可以传递的代码\n\nJava8之前不能单纯的传递代码,必须先创建对象,以对象为载体,通过传递对象达到传递代码的目的.\n\n为了简化传递代码，在Java8中引入了对lambda表达式的支持。\n\nLambda表达式中代码的传递是以函数为载体的，一个函数最基本的构成为：\n\n- 函数声明：\n  - 返回值\n  - 函数名\n  - 参数列表\n- 函数体\n\n返回值可以根据函数体的执行结果确定，如果函数只调用一次，那么函数名也可以省略（匿名）。\n\n一个函数就可以概括成参数和函数体（即就是表达式）。\n\n所以Lambda表达式的语法为：`(参数列表声明)->{表达式}`\n\n# 函数式接口\n\n**函数式接口**：只包含一个抽象方法的接口\n\nJava8中lambda表达式能做的唯一一件事：转换函数式接口\n\n如果一个方法的参数为函数式接口的对象，可以使用Lamdba表达式来替代创建函数式接口的对象。\n\n例如：\n\n`Comparator`接口只有`int compare(T o1, T o2);`这一个抽象方法，所以是一个函数式接口。\n\n`Arrays.sort(T[] a, Comparator<? super T> c)`接收`Comparator`的对象，而`c.compare()`函数体内包含实际执行的代码.\n\nJava8之前：\n\n调用`Arrays.sort(T[] a, Comparator<? super T> c)`之前必须先创建`Comparator`接口实例对象。\n\nJava8中lambda表达式对开发人员可以简单理解为：\n\n传入一个lambda表达式，系统会自动创建`Comparator`对象，调用该对象的`compare()`方法时会执行lambda表达式中的代码。\n\n实际的编译，运行过程并不是上面描述的这样，但我们可以简单的这么理解。\n\n实际上lambda表达式依赖了JDK7引入的`invokedynamic`指令，在多数情况下，lambda都拥有比内部类更好的性能。\n\n# 方法引用\n\nLambda表达式的本质是传递函数，如果现有的函数完全能达到我们的需求，我们就可以直接传递函数，这就是方法引用。\n\n方法引用的基本语法：`类/对象::方法`，可能存在的对应关系有：\n\n- 对象：：实例方法\n- 类：：静态方法\n- 类：：实例方法\n\n第三种情况最为特殊，表达的意思是第一个参数作为方法调用的对象。\n\n关于重载方法的问题，根据参数类型自动匹配。\n\n可以作为对象的不仅有普通对象，还有`this`和`super`两个隐含对象。\n\n对构造器则使用`类::new`的形式调用，根据上下文类型信息会比配构造器。\n\n# 变量作用域\n\nlambda表达式不同于函数的地方：\n\n函数是独立的，而lambda包含上下文，lambda可以引用定义它的上下文变量（闭包）。\n\nJava8之前为了实现对上下文的引用，使用的是内部类访问外部的final局部变量，Java8中放宽了这条规则，不要求变量必须使用final声明了，但是仍然要求不改变变量，编译器会对做部分此检查。\n\n如果变量是一个实例变量，编译器无法检查不变性，但是不建议这么使用。\n\nlambda表达式的作用域与嵌套它的上下文环境一样。\n\n在lambda表达式中使用`this`指向的是创建该lambda表达式的方法的对象，这也间接可以说明lambda表达式不是由内部类实现的。\n\n# 默认方法\n\nJava8中允许接口中定义并实现方法，这样的方法称为默认方法。\n\n- 优点：方便的扩展接口方法\n\n  例如为`Collectoin`接口添加一个`forEach`方法，如果没有默认方法的支持，我们需要为每个子类增加对应的实现，这是灾难式的，但默认方法只需要在一个接口中添加就可以了。\n\n- 缺点：方法冲突\n\n  在继承体系中，继承的接口与接口，或接口与类可能实现了相同的方法，造成冲突。\n\n  Java8的规则：\n\n  - 接口与接口的方法冲突：不管有没有接口实现了方法，子类中一律必须重新实现\n  - 接口与类的方法冲突：子类默认继承类的实现方法（类优先）\n\nJava8允许在接口中定义方法可以将原本工具类中的静态方法定义到接口中，避免了接口和工具类的分离。\n\n同时将原本高层的工具类中的方法分散到各个子接口中，可以更清楚的使用类型。\n\n例如：原本定在`Collections`中的`nCopies`方法现在定义在`List`中，写法更加清晰：\n\n之前：`Collections.nCopies(10, \"Hello\");`\n\n现在：`List.nCopies(10, \"Hello\");`\n\n\n","source":"_posts/Lambda表达式.md","raw":"---\ntitle: Lambda表达式\ndate: 2017-01-16 02:39:56\ntags:\n - Java\n - 读书笔记\n - Functional\ncategory: Java\n---\n\n# Lambda表达式\n\n**Lambda表达式**:一段可以传递的代码\n\nJava8之前不能单纯的传递代码,必须先创建对象,以对象为载体,通过传递对象达到传递代码的目的.\n\n为了简化传递代码，在Java8中引入了对lambda表达式的支持。\n\nLambda表达式中代码的传递是以函数为载体的，一个函数最基本的构成为：\n\n- 函数声明：\n  - 返回值\n  - 函数名\n  - 参数列表\n- 函数体\n\n返回值可以根据函数体的执行结果确定，如果函数只调用一次，那么函数名也可以省略（匿名）。\n\n一个函数就可以概括成参数和函数体（即就是表达式）。\n\n所以Lambda表达式的语法为：`(参数列表声明)->{表达式}`\n\n# 函数式接口\n\n**函数式接口**：只包含一个抽象方法的接口\n\nJava8中lambda表达式能做的唯一一件事：转换函数式接口\n\n如果一个方法的参数为函数式接口的对象，可以使用Lamdba表达式来替代创建函数式接口的对象。\n\n例如：\n\n`Comparator`接口只有`int compare(T o1, T o2);`这一个抽象方法，所以是一个函数式接口。\n\n`Arrays.sort(T[] a, Comparator<? super T> c)`接收`Comparator`的对象，而`c.compare()`函数体内包含实际执行的代码.\n\nJava8之前：\n\n调用`Arrays.sort(T[] a, Comparator<? super T> c)`之前必须先创建`Comparator`接口实例对象。\n\nJava8中lambda表达式对开发人员可以简单理解为：\n\n传入一个lambda表达式，系统会自动创建`Comparator`对象，调用该对象的`compare()`方法时会执行lambda表达式中的代码。\n\n实际的编译，运行过程并不是上面描述的这样，但我们可以简单的这么理解。\n\n实际上lambda表达式依赖了JDK7引入的`invokedynamic`指令，在多数情况下，lambda都拥有比内部类更好的性能。\n\n# 方法引用\n\nLambda表达式的本质是传递函数，如果现有的函数完全能达到我们的需求，我们就可以直接传递函数，这就是方法引用。\n\n方法引用的基本语法：`类/对象::方法`，可能存在的对应关系有：\n\n- 对象：：实例方法\n- 类：：静态方法\n- 类：：实例方法\n\n第三种情况最为特殊，表达的意思是第一个参数作为方法调用的对象。\n\n关于重载方法的问题，根据参数类型自动匹配。\n\n可以作为对象的不仅有普通对象，还有`this`和`super`两个隐含对象。\n\n对构造器则使用`类::new`的形式调用，根据上下文类型信息会比配构造器。\n\n# 变量作用域\n\nlambda表达式不同于函数的地方：\n\n函数是独立的，而lambda包含上下文，lambda可以引用定义它的上下文变量（闭包）。\n\nJava8之前为了实现对上下文的引用，使用的是内部类访问外部的final局部变量，Java8中放宽了这条规则，不要求变量必须使用final声明了，但是仍然要求不改变变量，编译器会对做部分此检查。\n\n如果变量是一个实例变量，编译器无法检查不变性，但是不建议这么使用。\n\nlambda表达式的作用域与嵌套它的上下文环境一样。\n\n在lambda表达式中使用`this`指向的是创建该lambda表达式的方法的对象，这也间接可以说明lambda表达式不是由内部类实现的。\n\n# 默认方法\n\nJava8中允许接口中定义并实现方法，这样的方法称为默认方法。\n\n- 优点：方便的扩展接口方法\n\n  例如为`Collectoin`接口添加一个`forEach`方法，如果没有默认方法的支持，我们需要为每个子类增加对应的实现，这是灾难式的，但默认方法只需要在一个接口中添加就可以了。\n\n- 缺点：方法冲突\n\n  在继承体系中，继承的接口与接口，或接口与类可能实现了相同的方法，造成冲突。\n\n  Java8的规则：\n\n  - 接口与接口的方法冲突：不管有没有接口实现了方法，子类中一律必须重新实现\n  - 接口与类的方法冲突：子类默认继承类的实现方法（类优先）\n\nJava8允许在接口中定义方法可以将原本工具类中的静态方法定义到接口中，避免了接口和工具类的分离。\n\n同时将原本高层的工具类中的方法分散到各个子接口中，可以更清楚的使用类型。\n\n例如：原本定在`Collections`中的`nCopies`方法现在定义在`List`中，写法更加清晰：\n\n之前：`Collections.nCopies(10, \"Hello\");`\n\n现在：`List.nCopies(10, \"Hello\");`\n\n\n","slug":"Lambda表达式","published":1,"updated":"2017-01-15T18:42:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2pn0012d82e1xjqrg0d","content":"<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><p><strong>Lambda表达式</strong>:一段可以传递的代码</p>\n<p>Java8之前不能单纯的传递代码,必须先创建对象,以对象为载体,通过传递对象达到传递代码的目的.</p>\n<p>为了简化传递代码，在Java8中引入了对lambda表达式的支持。</p>\n<p>Lambda表达式中代码的传递是以函数为载体的，一个函数最基本的构成为：</p>\n<ul>\n<li>函数声明：<ul>\n<li>返回值</li>\n<li>函数名</li>\n<li>参数列表</li>\n</ul>\n</li>\n<li>函数体</li>\n</ul>\n<p>返回值可以根据函数体的执行结果确定，如果函数只调用一次，那么函数名也可以省略（匿名）。</p>\n<p>一个函数就可以概括成参数和函数体（即就是表达式）。</p>\n<p>所以Lambda表达式的语法为：<code>(参数列表声明)-&gt;{表达式}</code></p>\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><p><strong>函数式接口</strong>：只包含一个抽象方法的接口</p>\n<p>Java8中lambda表达式能做的唯一一件事：转换函数式接口</p>\n<p>如果一个方法的参数为函数式接口的对象，可以使用Lamdba表达式来替代创建函数式接口的对象。</p>\n<p>例如：</p>\n<p><code>Comparator</code>接口只有<code>int compare(T o1, T o2);</code>这一个抽象方法，所以是一个函数式接口。</p>\n<p><code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>接收<code>Comparator</code>的对象，而<code>c.compare()</code>函数体内包含实际执行的代码.</p>\n<p>Java8之前：</p>\n<p>调用<code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>之前必须先创建<code>Comparator</code>接口实例对象。</p>\n<p>Java8中lambda表达式对开发人员可以简单理解为：</p>\n<p>传入一个lambda表达式，系统会自动创建<code>Comparator</code>对象，调用该对象的<code>compare()</code>方法时会执行lambda表达式中的代码。</p>\n<p>实际的编译，运行过程并不是上面描述的这样，但我们可以简单的这么理解。</p>\n<p>实际上lambda表达式依赖了JDK7引入的<code>invokedynamic</code>指令，在多数情况下，lambda都拥有比内部类更好的性能。</p>\n<h1 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h1><p>Lambda表达式的本质是传递函数，如果现有的函数完全能达到我们的需求，我们就可以直接传递函数，这就是方法引用。</p>\n<p>方法引用的基本语法：<code>类/对象::方法</code>，可能存在的对应关系有：</p>\n<ul>\n<li>对象：：实例方法</li>\n<li>类：：静态方法</li>\n<li>类：：实例方法</li>\n</ul>\n<p>第三种情况最为特殊，表达的意思是第一个参数作为方法调用的对象。</p>\n<p>关于重载方法的问题，根据参数类型自动匹配。</p>\n<p>可以作为对象的不仅有普通对象，还有<code>this</code>和<code>super</code>两个隐含对象。</p>\n<p>对构造器则使用<code>类::new</code>的形式调用，根据上下文类型信息会比配构造器。</p>\n<h1 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h1><p>lambda表达式不同于函数的地方：</p>\n<p>函数是独立的，而lambda包含上下文，lambda可以引用定义它的上下文变量（闭包）。</p>\n<p>Java8之前为了实现对上下文的引用，使用的是内部类访问外部的final局部变量，Java8中放宽了这条规则，不要求变量必须使用final声明了，但是仍然要求不改变变量，编译器会对做部分此检查。</p>\n<p>如果变量是一个实例变量，编译器无法检查不变性，但是不建议这么使用。</p>\n<p>lambda表达式的作用域与嵌套它的上下文环境一样。</p>\n<p>在lambda表达式中使用<code>this</code>指向的是创建该lambda表达式的方法的对象，这也间接可以说明lambda表达式不是由内部类实现的。</p>\n<h1 id=\"默认方法\"><a href=\"#默认方法\" class=\"headerlink\" title=\"默认方法\"></a>默认方法</h1><p>Java8中允许接口中定义并实现方法，这样的方法称为默认方法。</p>\n<ul>\n<li><p>优点：方便的扩展接口方法</p>\n<p>例如为<code>Collectoin</code>接口添加一个<code>forEach</code>方法，如果没有默认方法的支持，我们需要为每个子类增加对应的实现，这是灾难式的，但默认方法只需要在一个接口中添加就可以了。</p>\n</li>\n<li><p>缺点：方法冲突</p>\n<p>在继承体系中，继承的接口与接口，或接口与类可能实现了相同的方法，造成冲突。</p>\n<p>Java8的规则：</p>\n<ul>\n<li>接口与接口的方法冲突：不管有没有接口实现了方法，子类中一律必须重新实现</li>\n<li>接口与类的方法冲突：子类默认继承类的实现方法（类优先）</li>\n</ul>\n</li>\n</ul>\n<p>Java8允许在接口中定义方法可以将原本工具类中的静态方法定义到接口中，避免了接口和工具类的分离。</p>\n<p>同时将原本高层的工具类中的方法分散到各个子接口中，可以更清楚的使用类型。</p>\n<p>例如：原本定在<code>Collections</code>中的<code>nCopies</code>方法现在定义在<code>List</code>中，写法更加清晰：</p>\n<p>之前：<code>Collections.nCopies(10, &quot;Hello&quot;);</code></p>\n<p>现在：<code>List.nCopies(10, &quot;Hello&quot;);</code></p>\n","excerpt":"","more":"<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><p><strong>Lambda表达式</strong>:一段可以传递的代码</p>\n<p>Java8之前不能单纯的传递代码,必须先创建对象,以对象为载体,通过传递对象达到传递代码的目的.</p>\n<p>为了简化传递代码，在Java8中引入了对lambda表达式的支持。</p>\n<p>Lambda表达式中代码的传递是以函数为载体的，一个函数最基本的构成为：</p>\n<ul>\n<li>函数声明：<ul>\n<li>返回值</li>\n<li>函数名</li>\n<li>参数列表</li>\n</ul>\n</li>\n<li>函数体</li>\n</ul>\n<p>返回值可以根据函数体的执行结果确定，如果函数只调用一次，那么函数名也可以省略（匿名）。</p>\n<p>一个函数就可以概括成参数和函数体（即就是表达式）。</p>\n<p>所以Lambda表达式的语法为：<code>(参数列表声明)-&gt;{表达式}</code></p>\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><p><strong>函数式接口</strong>：只包含一个抽象方法的接口</p>\n<p>Java8中lambda表达式能做的唯一一件事：转换函数式接口</p>\n<p>如果一个方法的参数为函数式接口的对象，可以使用Lamdba表达式来替代创建函数式接口的对象。</p>\n<p>例如：</p>\n<p><code>Comparator</code>接口只有<code>int compare(T o1, T o2);</code>这一个抽象方法，所以是一个函数式接口。</p>\n<p><code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>接收<code>Comparator</code>的对象，而<code>c.compare()</code>函数体内包含实际执行的代码.</p>\n<p>Java8之前：</p>\n<p>调用<code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>之前必须先创建<code>Comparator</code>接口实例对象。</p>\n<p>Java8中lambda表达式对开发人员可以简单理解为：</p>\n<p>传入一个lambda表达式，系统会自动创建<code>Comparator</code>对象，调用该对象的<code>compare()</code>方法时会执行lambda表达式中的代码。</p>\n<p>实际的编译，运行过程并不是上面描述的这样，但我们可以简单的这么理解。</p>\n<p>实际上lambda表达式依赖了JDK7引入的<code>invokedynamic</code>指令，在多数情况下，lambda都拥有比内部类更好的性能。</p>\n<h1 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h1><p>Lambda表达式的本质是传递函数，如果现有的函数完全能达到我们的需求，我们就可以直接传递函数，这就是方法引用。</p>\n<p>方法引用的基本语法：<code>类/对象::方法</code>，可能存在的对应关系有：</p>\n<ul>\n<li>对象：：实例方法</li>\n<li>类：：静态方法</li>\n<li>类：：实例方法</li>\n</ul>\n<p>第三种情况最为特殊，表达的意思是第一个参数作为方法调用的对象。</p>\n<p>关于重载方法的问题，根据参数类型自动匹配。</p>\n<p>可以作为对象的不仅有普通对象，还有<code>this</code>和<code>super</code>两个隐含对象。</p>\n<p>对构造器则使用<code>类::new</code>的形式调用，根据上下文类型信息会比配构造器。</p>\n<h1 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h1><p>lambda表达式不同于函数的地方：</p>\n<p>函数是独立的，而lambda包含上下文，lambda可以引用定义它的上下文变量（闭包）。</p>\n<p>Java8之前为了实现对上下文的引用，使用的是内部类访问外部的final局部变量，Java8中放宽了这条规则，不要求变量必须使用final声明了，但是仍然要求不改变变量，编译器会对做部分此检查。</p>\n<p>如果变量是一个实例变量，编译器无法检查不变性，但是不建议这么使用。</p>\n<p>lambda表达式的作用域与嵌套它的上下文环境一样。</p>\n<p>在lambda表达式中使用<code>this</code>指向的是创建该lambda表达式的方法的对象，这也间接可以说明lambda表达式不是由内部类实现的。</p>\n<h1 id=\"默认方法\"><a href=\"#默认方法\" class=\"headerlink\" title=\"默认方法\"></a>默认方法</h1><p>Java8中允许接口中定义并实现方法，这样的方法称为默认方法。</p>\n<ul>\n<li><p>优点：方便的扩展接口方法</p>\n<p>例如为<code>Collectoin</code>接口添加一个<code>forEach</code>方法，如果没有默认方法的支持，我们需要为每个子类增加对应的实现，这是灾难式的，但默认方法只需要在一个接口中添加就可以了。</p>\n</li>\n<li><p>缺点：方法冲突</p>\n<p>在继承体系中，继承的接口与接口，或接口与类可能实现了相同的方法，造成冲突。</p>\n<p>Java8的规则：</p>\n<ul>\n<li>接口与接口的方法冲突：不管有没有接口实现了方法，子类中一律必须重新实现</li>\n<li>接口与类的方法冲突：子类默认继承类的实现方法（类优先）</li>\n</ul>\n</li>\n</ul>\n<p>Java8允许在接口中定义方法可以将原本工具类中的静态方法定义到接口中，避免了接口和工具类的分离。</p>\n<p>同时将原本高层的工具类中的方法分散到各个子接口中，可以更清楚的使用类型。</p>\n<p>例如：原本定在<code>Collections</code>中的<code>nCopies</code>方法现在定义在<code>List</code>中，写法更加清晰：</p>\n<p>之前：<code>Collections.nCopies(10, &quot;Hello&quot;);</code></p>\n<p>现在：<code>List.nCopies(10, &quot;Hello&quot;);</code></p>\n"},{"title":"Java线程基本操作","date":"2017-03-28T16:03:51.000Z","_content":"\n## 线程状态\n\nJava中线程的定义与操作系统线程状态并不是一一对应的关系。\n\nJava在`java.lang.Thread.State`中给出了关于线程状态的描述：\n\n![线程状态.png](https://ooo.0o0.ooo/2017/03/24/58d507cd6f253.png)\n\n## Thread定义的基本方法\n\n- 新建\n\n  - start：用于启动线程\n\n  - run：普通方法,直接调用run方法将不会开启新的线程，依旧是在原有线程上顺序执行\n\n- 终止\n\n  - stop：不推荐使用，释放所有的锁，如果锁内的代码没有执行完毕，会出现不一致\n  - 会抛出ThreadDeath Error\n\n- 中断\n\n  - 给线程一个标记，让线程自己响应中断，具体怎么响应甚至于是否响应由被中断线程自己决定\n\n  - 与中断相关的方法包括：\n\n    | 方法                                     | 说明                        |\n    | :------------------------------------- | ------------------------- |\n    | `public void interrupt()`              | 中断线程， 将中断状态设置为true        |\n    | ` public boolean isInterrupted()`      | 测试线程是否已经中断。线程中断状态不受该方法的影响 |\n    | ` public static boolean interrupted()` | 测试当前线程是否已经中断，并清除中断状态      |\n\n  - 中断的处理\n\n    - 中断与异常\n\n      InterruptedException往往是阻塞的方法响应中断的方式，吞掉该异常将导致上层无法响应中断；\n\n      具体处理方式可以上抛，或者重设中断状态，但不建议吞掉；\n\n- sleep\n\n  - 休眠线程，使线程进入TIMED_WAITING状态\n  - 线程休眠期间不会释放锁\n  - 休眠期间可以响应中断，会抛出InterruptedException\n\n\n- 挂起与恢复\n\n  - suspend/resume，不推荐使用\n\n  - 缺陷：\n\n    - 挂起操作不会释放锁，如果加锁放生在suspend之前，没有其他线程可以访问锁，直到resume，容易造成死锁\n    - 如果resume先于suspend执行，线程无法结束会持续处于RUNNABLE状态，like this：\n\n    ```java\n    public class BadSuspend {\n        private static final Object lock = new Object();\n\n        public static class ChangeObjectThread extends Thread {\n            public ChangeObjectThread(String name) {\n                super.setName(name);\n            }\n\n            @Override\n            public void run() {\n                synchronized (lock) {\n                    System.out.println(\"in \" + getName());\n                    Thread.currentThread().suspend();\n                }\n            }\n        }\n\n        public static void main(String[] args) throws InterruptedException {\n            ChangeObjectThread thread1 = new ChangeObjectThread(\"thread1\");\n            thread1.start();\n            // 确保thread1一定执行\n            TimeUnit.MILLISECONDS.sleep(100);\n            ChangeObjectThread thread2 = new ChangeObjectThread(\"thread2\");\n            thread2.start();\n            thread1.resume();\n            thread2.resume();\n            thread1.join();\n            thread2.join();\n        }\n    }\n    ```\n\n    运行代码后，程序始终没有结束，查看线程详细信息，发现thread1线程已不存在，thread2卡在suspend方法并且状态仍然是RUNNABLE的，like this：\n\n    ![BadSuspend.jpg](https://ooo.0o0.ooo/2017/03/24/58d511f21c11c.jpg)\n\n- Join/Yeild\n\n  - yeild表示：别说我欺负你，我把机会让出来，我们一起抢\n  - join表示：我就是欺负你，你等着，我先来\n  - join的具体的实现参照后面的Object.wait方法介绍\n\n  守护线程\n\n  - 当只有守护线程时，JVM会自动退出\n  - `thread.setDaemon(true);`\n\n- 线程优先级：thread.setPriority(Thread.MAX_PRIORITY);\n\n- 同步：synchronized\n\n  - 加锁对象：对象锁\n  - 加锁实例方法：加锁在方法所在对象实例，如果多个线程加在多个实例上并没有什么卵用\n  - 加锁静态方法：加锁在方法所在Class对象上\n\n## Object中的线程相关方法\n\nObject.wait()/Object.notify()\n\n- 先看JDK中对两个方法的描述：\n\n  - wait()：\n\n    Causes the current thread to wait until another thread invokes the java.lang.Object.notify() method or the java.lang.Object.notifyAll() method for this object.\n\n  - notify()：\n\n    Wakes up a single thread that is waiting on this object's monitor.\n\n- 简言之，就是通过一个（monitor）对象，让线程停下来或是动起来\n\n- 这两个方法在操作之前都一定要取得monitor对象的锁\n\n- wait方法执行后线程会释放持有的锁，直到被他线程notify monitor时重新持有锁\n\n- wait的典型使用场景：Thread.join\n\n  join方法内部的关键实现：\n\n  ```java\n  public final synchronized void join(long millis) {\n    if (millis == 0) {\n      while (isAlive()) {\n        wait(0);\n      }\n    } else {\n      while (isAlive()) {\n        long delay = millis - now;\n        if (delay <= 0) {\n          break;\n        }\n        wait(delay);\n        now = System.currentTimeMillis() - base;\n      }\n    }\n  }\n  ```\n\n- 两点需要注意的：\n\n  - join最终的实现依赖：wait(delay);\n  - 加锁位置：public final synchronized void join(long millis)，相当于synchronized(this)\n\n  以一个例子说明：\n\n  ```java\n  public class JoinDemo {\n      private volatile static long count = 0;\n\n      public static void main(String[] args) throws InterruptedException {\n          Thread thread = new Thread(() -> {\n              while (++count < 1_000_000_000) {\n              }\n          });\n          thread.start();\n          thread.join();\n          System.out.println(count);\n      }\n  }\n  ```\n\n  Main线程中执行thread.join，在join(int)方法中锁加在了thread对象上，内部的wait()是在thread对象上执行的。也就是说对于Main线程而言，thread线程是它的monitor。\n\n  在join方法执行后Main线程处于WAITING状态，直到有人对它的monitor（thread 线程）执行notify操作，这一步是在thread线程执行完毕由JVM操作的。\n\n  可以说thread既当爹又当妈，既要让当前线程停下来，又要自己跑起来。在thread执行完毕后重新对自己notify，让Main线程跑起来。\n","source":"_posts/Java线程基本操作.md","raw":"---\ntitle: Java线程基本操作\ndate: 2017-03-29 00:03:51\ntags:\n  - Java\ncategories:\n  - Java\n---\n\n## 线程状态\n\nJava中线程的定义与操作系统线程状态并不是一一对应的关系。\n\nJava在`java.lang.Thread.State`中给出了关于线程状态的描述：\n\n![线程状态.png](https://ooo.0o0.ooo/2017/03/24/58d507cd6f253.png)\n\n## Thread定义的基本方法\n\n- 新建\n\n  - start：用于启动线程\n\n  - run：普通方法,直接调用run方法将不会开启新的线程，依旧是在原有线程上顺序执行\n\n- 终止\n\n  - stop：不推荐使用，释放所有的锁，如果锁内的代码没有执行完毕，会出现不一致\n  - 会抛出ThreadDeath Error\n\n- 中断\n\n  - 给线程一个标记，让线程自己响应中断，具体怎么响应甚至于是否响应由被中断线程自己决定\n\n  - 与中断相关的方法包括：\n\n    | 方法                                     | 说明                        |\n    | :------------------------------------- | ------------------------- |\n    | `public void interrupt()`              | 中断线程， 将中断状态设置为true        |\n    | ` public boolean isInterrupted()`      | 测试线程是否已经中断。线程中断状态不受该方法的影响 |\n    | ` public static boolean interrupted()` | 测试当前线程是否已经中断，并清除中断状态      |\n\n  - 中断的处理\n\n    - 中断与异常\n\n      InterruptedException往往是阻塞的方法响应中断的方式，吞掉该异常将导致上层无法响应中断；\n\n      具体处理方式可以上抛，或者重设中断状态，但不建议吞掉；\n\n- sleep\n\n  - 休眠线程，使线程进入TIMED_WAITING状态\n  - 线程休眠期间不会释放锁\n  - 休眠期间可以响应中断，会抛出InterruptedException\n\n\n- 挂起与恢复\n\n  - suspend/resume，不推荐使用\n\n  - 缺陷：\n\n    - 挂起操作不会释放锁，如果加锁放生在suspend之前，没有其他线程可以访问锁，直到resume，容易造成死锁\n    - 如果resume先于suspend执行，线程无法结束会持续处于RUNNABLE状态，like this：\n\n    ```java\n    public class BadSuspend {\n        private static final Object lock = new Object();\n\n        public static class ChangeObjectThread extends Thread {\n            public ChangeObjectThread(String name) {\n                super.setName(name);\n            }\n\n            @Override\n            public void run() {\n                synchronized (lock) {\n                    System.out.println(\"in \" + getName());\n                    Thread.currentThread().suspend();\n                }\n            }\n        }\n\n        public static void main(String[] args) throws InterruptedException {\n            ChangeObjectThread thread1 = new ChangeObjectThread(\"thread1\");\n            thread1.start();\n            // 确保thread1一定执行\n            TimeUnit.MILLISECONDS.sleep(100);\n            ChangeObjectThread thread2 = new ChangeObjectThread(\"thread2\");\n            thread2.start();\n            thread1.resume();\n            thread2.resume();\n            thread1.join();\n            thread2.join();\n        }\n    }\n    ```\n\n    运行代码后，程序始终没有结束，查看线程详细信息，发现thread1线程已不存在，thread2卡在suspend方法并且状态仍然是RUNNABLE的，like this：\n\n    ![BadSuspend.jpg](https://ooo.0o0.ooo/2017/03/24/58d511f21c11c.jpg)\n\n- Join/Yeild\n\n  - yeild表示：别说我欺负你，我把机会让出来，我们一起抢\n  - join表示：我就是欺负你，你等着，我先来\n  - join的具体的实现参照后面的Object.wait方法介绍\n\n  守护线程\n\n  - 当只有守护线程时，JVM会自动退出\n  - `thread.setDaemon(true);`\n\n- 线程优先级：thread.setPriority(Thread.MAX_PRIORITY);\n\n- 同步：synchronized\n\n  - 加锁对象：对象锁\n  - 加锁实例方法：加锁在方法所在对象实例，如果多个线程加在多个实例上并没有什么卵用\n  - 加锁静态方法：加锁在方法所在Class对象上\n\n## Object中的线程相关方法\n\nObject.wait()/Object.notify()\n\n- 先看JDK中对两个方法的描述：\n\n  - wait()：\n\n    Causes the current thread to wait until another thread invokes the java.lang.Object.notify() method or the java.lang.Object.notifyAll() method for this object.\n\n  - notify()：\n\n    Wakes up a single thread that is waiting on this object's monitor.\n\n- 简言之，就是通过一个（monitor）对象，让线程停下来或是动起来\n\n- 这两个方法在操作之前都一定要取得monitor对象的锁\n\n- wait方法执行后线程会释放持有的锁，直到被他线程notify monitor时重新持有锁\n\n- wait的典型使用场景：Thread.join\n\n  join方法内部的关键实现：\n\n  ```java\n  public final synchronized void join(long millis) {\n    if (millis == 0) {\n      while (isAlive()) {\n        wait(0);\n      }\n    } else {\n      while (isAlive()) {\n        long delay = millis - now;\n        if (delay <= 0) {\n          break;\n        }\n        wait(delay);\n        now = System.currentTimeMillis() - base;\n      }\n    }\n  }\n  ```\n\n- 两点需要注意的：\n\n  - join最终的实现依赖：wait(delay);\n  - 加锁位置：public final synchronized void join(long millis)，相当于synchronized(this)\n\n  以一个例子说明：\n\n  ```java\n  public class JoinDemo {\n      private volatile static long count = 0;\n\n      public static void main(String[] args) throws InterruptedException {\n          Thread thread = new Thread(() -> {\n              while (++count < 1_000_000_000) {\n              }\n          });\n          thread.start();\n          thread.join();\n          System.out.println(count);\n      }\n  }\n  ```\n\n  Main线程中执行thread.join，在join(int)方法中锁加在了thread对象上，内部的wait()是在thread对象上执行的。也就是说对于Main线程而言，thread线程是它的monitor。\n\n  在join方法执行后Main线程处于WAITING状态，直到有人对它的monitor（thread 线程）执行notify操作，这一步是在thread线程执行完毕由JVM操作的。\n\n  可以说thread既当爹又当妈，既要让当前线程停下来，又要自己跑起来。在thread执行完毕后重新对自己notify，让Main线程跑起来。\n","slug":"Java线程基本操作","published":1,"updated":"2017-07-15T16:23:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2pp0015d82e96clprif","content":"<h2 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h2><p>Java中线程的定义与操作系统线程状态并不是一一对应的关系。</p>\n<p>Java在<code>java.lang.Thread.State</code>中给出了关于线程状态的描述：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/24/58d507cd6f253.png\" alt=\"线程状态.png\"></p>\n<h2 id=\"Thread定义的基本方法\"><a href=\"#Thread定义的基本方法\" class=\"headerlink\" title=\"Thread定义的基本方法\"></a>Thread定义的基本方法</h2><ul>\n<li><p>新建</p>\n<ul>\n<li><p>start：用于启动线程</p>\n</li>\n<li><p>run：普通方法,直接调用run方法将不会开启新的线程，依旧是在原有线程上顺序执行</p>\n</li>\n</ul>\n</li>\n<li><p>终止</p>\n<ul>\n<li>stop：不推荐使用，释放所有的锁，如果锁内的代码没有执行完毕，会出现不一致</li>\n<li>会抛出ThreadDeath Error</li>\n</ul>\n</li>\n<li><p>中断</p>\n<ul>\n<li><p>给线程一个标记，让线程自己响应中断，具体怎么响应甚至于是否响应由被中断线程自己决定</p>\n</li>\n<li><p>与中断相关的方法包括：</p>\n<p>| 方法                                     | 说明                        |<br>| :————————————- | ————————- |<br>| <code>public void interrupt()</code>              | 中断线程， 将中断状态设置为true        |<br>| <code>public boolean isInterrupted()</code>      | 测试线程是否已经中断。线程中断状态不受该方法的影响 |<br>| <code>public static boolean interrupted()</code> | 测试当前线程是否已经中断，并清除中断状态      |</p>\n</li>\n<li><p>中断的处理</p>\n<ul>\n<li><p>中断与异常</p>\n<p>InterruptedException往往是阻塞的方法响应中断的方式，吞掉该异常将导致上层无法响应中断；</p>\n<p>具体处理方式可以上抛，或者重设中断状态，但不建议吞掉；</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>sleep</p>\n<ul>\n<li>休眠线程，使线程进入TIMED_WAITING状态</li>\n<li>线程休眠期间不会释放锁</li>\n<li>休眠期间可以响应中断，会抛出InterruptedException</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>挂起与恢复</p>\n<ul>\n<li><p>suspend/resume，不推荐使用</p>\n</li>\n<li><p>缺陷：</p>\n<ul>\n<li>挂起操作不会释放锁，如果加锁放生在suspend之前，没有其他线程可以访问锁，直到resume，容易造成死锁</li>\n<li>如果resume先于suspend执行，线程无法结束会持续处于RUNNABLE状态，like this：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BadSuspend</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object lock = <span class=\"keyword\">new</span> Object();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChangeObjectThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChangeObjectThread</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>.setName(name);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"in \"</span> + getName());</div><div class=\"line\">                Thread.currentThread().suspend();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">        ChangeObjectThread thread1 = <span class=\"keyword\">new</span> ChangeObjectThread(<span class=\"string\">\"thread1\"</span>);</div><div class=\"line\">        thread1.start();</div><div class=\"line\">        <span class=\"comment\">// 确保thread1一定执行</span></div><div class=\"line\">        TimeUnit.MILLISECONDS.sleep(<span class=\"number\">100</span>);</div><div class=\"line\">        ChangeObjectThread thread2 = <span class=\"keyword\">new</span> ChangeObjectThread(<span class=\"string\">\"thread2\"</span>);</div><div class=\"line\">        thread2.start();</div><div class=\"line\">        thread1.resume();</div><div class=\"line\">        thread2.resume();</div><div class=\"line\">        thread1.join();</div><div class=\"line\">        thread2.join();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行代码后，程序始终没有结束，查看线程详细信息，发现thread1线程已不存在，thread2卡在suspend方法并且状态仍然是RUNNABLE的，like this：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/24/58d511f21c11c.jpg\" alt=\"BadSuspend.jpg\"></p>\n</li>\n</ul>\n</li>\n<li><p>Join/Yeild</p>\n<ul>\n<li>yeild表示：别说我欺负你，我把机会让出来，我们一起抢</li>\n<li>join表示：我就是欺负你，你等着，我先来</li>\n<li>join的具体的实现参照后面的Object.wait方法介绍</li>\n</ul>\n<p>守护线程</p>\n<ul>\n<li>当只有守护线程时，JVM会自动退出</li>\n<li><code>thread.setDaemon(true);</code></li>\n</ul>\n</li>\n<li><p>线程优先级：thread.setPriority(Thread.MAX_PRIORITY);</p>\n</li>\n<li><p>同步：synchronized</p>\n<ul>\n<li>加锁对象：对象锁</li>\n<li>加锁实例方法：加锁在方法所在对象实例，如果多个线程加在多个实例上并没有什么卵用</li>\n<li>加锁静态方法：加锁在方法所在Class对象上</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Object中的线程相关方法\"><a href=\"#Object中的线程相关方法\" class=\"headerlink\" title=\"Object中的线程相关方法\"></a>Object中的线程相关方法</h2><p>Object.wait()/Object.notify()</p>\n<ul>\n<li><p>先看JDK中对两个方法的描述：</p>\n<ul>\n<li><p>wait()：</p>\n<p>Causes the current thread to wait until another thread invokes the java.lang.Object.notify() method or the java.lang.Object.notifyAll() method for this object.</p>\n</li>\n<li><p>notify()：</p>\n<p>Wakes up a single thread that is waiting on this object’s monitor.</p>\n</li>\n</ul>\n</li>\n<li><p>简言之，就是通过一个（monitor）对象，让线程停下来或是动起来</p>\n</li>\n<li><p>这两个方法在操作之前都一定要取得monitor对象的锁</p>\n</li>\n<li><p>wait方法执行后线程会释放持有的锁，直到被他线程notify monitor时重新持有锁</p>\n</li>\n<li><p>wait的典型使用场景：Thread.join</p>\n<p>join方法内部的关键实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">(<span class=\"keyword\">long</span> millis)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (millis == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (isAlive()) &#123;</div><div class=\"line\">      wait(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (isAlive()) &#123;</div><div class=\"line\">      <span class=\"keyword\">long</span> delay = millis - now;</div><div class=\"line\">      <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      wait(delay);</div><div class=\"line\">      now = System.currentTimeMillis() - base;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>两点需要注意的：</p>\n<ul>\n<li>join最终的实现依赖：wait(delay);</li>\n<li>加锁位置：public final synchronized void join(long millis)，相当于synchronized(this)</li>\n</ul>\n<p>以一个例子说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JoinDemo</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> count = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</div><div class=\"line\">            <span class=\"keyword\">while</span> (++count &lt; <span class=\"number\">1_000_000_000</span>) &#123;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        thread.start();</div><div class=\"line\">        thread.join();</div><div class=\"line\">        System.out.println(count);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Main线程中执行thread.join，在join(int)方法中锁加在了thread对象上，内部的wait()是在thread对象上执行的。也就是说对于Main线程而言，thread线程是它的monitor。</p>\n<p>在join方法执行后Main线程处于WAITING状态，直到有人对它的monitor（thread 线程）执行notify操作，这一步是在thread线程执行完毕由JVM操作的。</p>\n<p>可以说thread既当爹又当妈，既要让当前线程停下来，又要自己跑起来。在thread执行完毕后重新对自己notify，让Main线程跑起来。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h2><p>Java中线程的定义与操作系统线程状态并不是一一对应的关系。</p>\n<p>Java在<code>java.lang.Thread.State</code>中给出了关于线程状态的描述：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/24/58d507cd6f253.png\" alt=\"线程状态.png\"></p>\n<h2 id=\"Thread定义的基本方法\"><a href=\"#Thread定义的基本方法\" class=\"headerlink\" title=\"Thread定义的基本方法\"></a>Thread定义的基本方法</h2><ul>\n<li><p>新建</p>\n<ul>\n<li><p>start：用于启动线程</p>\n</li>\n<li><p>run：普通方法,直接调用run方法将不会开启新的线程，依旧是在原有线程上顺序执行</p>\n</li>\n</ul>\n</li>\n<li><p>终止</p>\n<ul>\n<li>stop：不推荐使用，释放所有的锁，如果锁内的代码没有执行完毕，会出现不一致</li>\n<li>会抛出ThreadDeath Error</li>\n</ul>\n</li>\n<li><p>中断</p>\n<ul>\n<li><p>给线程一个标记，让线程自己响应中断，具体怎么响应甚至于是否响应由被中断线程自己决定</p>\n</li>\n<li><p>与中断相关的方法包括：</p>\n<p>| 方法                                     | 说明                        |<br>| :————————————- | ————————- |<br>| <code>public void interrupt()</code>              | 中断线程， 将中断状态设置为true        |<br>| <code>public boolean isInterrupted()</code>      | 测试线程是否已经中断。线程中断状态不受该方法的影响 |<br>| <code>public static boolean interrupted()</code> | 测试当前线程是否已经中断，并清除中断状态      |</p>\n</li>\n<li><p>中断的处理</p>\n<ul>\n<li><p>中断与异常</p>\n<p>InterruptedException往往是阻塞的方法响应中断的方式，吞掉该异常将导致上层无法响应中断；</p>\n<p>具体处理方式可以上抛，或者重设中断状态，但不建议吞掉；</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>sleep</p>\n<ul>\n<li>休眠线程，使线程进入TIMED_WAITING状态</li>\n<li>线程休眠期间不会释放锁</li>\n<li>休眠期间可以响应中断，会抛出InterruptedException</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>挂起与恢复</p>\n<ul>\n<li><p>suspend/resume，不推荐使用</p>\n</li>\n<li><p>缺陷：</p>\n<ul>\n<li>挂起操作不会释放锁，如果加锁放生在suspend之前，没有其他线程可以访问锁，直到resume，容易造成死锁</li>\n<li>如果resume先于suspend执行，线程无法结束会持续处于RUNNABLE状态，like this：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BadSuspend</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object lock = <span class=\"keyword\">new</span> Object();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChangeObjectThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChangeObjectThread</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>.setName(name);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"in \"</span> + getName());</div><div class=\"line\">                Thread.currentThread().suspend();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">        ChangeObjectThread thread1 = <span class=\"keyword\">new</span> ChangeObjectThread(<span class=\"string\">\"thread1\"</span>);</div><div class=\"line\">        thread1.start();</div><div class=\"line\">        <span class=\"comment\">// 确保thread1一定执行</span></div><div class=\"line\">        TimeUnit.MILLISECONDS.sleep(<span class=\"number\">100</span>);</div><div class=\"line\">        ChangeObjectThread thread2 = <span class=\"keyword\">new</span> ChangeObjectThread(<span class=\"string\">\"thread2\"</span>);</div><div class=\"line\">        thread2.start();</div><div class=\"line\">        thread1.resume();</div><div class=\"line\">        thread2.resume();</div><div class=\"line\">        thread1.join();</div><div class=\"line\">        thread2.join();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行代码后，程序始终没有结束，查看线程详细信息，发现thread1线程已不存在，thread2卡在suspend方法并且状态仍然是RUNNABLE的，like this：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/24/58d511f21c11c.jpg\" alt=\"BadSuspend.jpg\"></p>\n</li>\n</ul>\n</li>\n<li><p>Join/Yeild</p>\n<ul>\n<li>yeild表示：别说我欺负你，我把机会让出来，我们一起抢</li>\n<li>join表示：我就是欺负你，你等着，我先来</li>\n<li>join的具体的实现参照后面的Object.wait方法介绍</li>\n</ul>\n<p>守护线程</p>\n<ul>\n<li>当只有守护线程时，JVM会自动退出</li>\n<li><code>thread.setDaemon(true);</code></li>\n</ul>\n</li>\n<li><p>线程优先级：thread.setPriority(Thread.MAX_PRIORITY);</p>\n</li>\n<li><p>同步：synchronized</p>\n<ul>\n<li>加锁对象：对象锁</li>\n<li>加锁实例方法：加锁在方法所在对象实例，如果多个线程加在多个实例上并没有什么卵用</li>\n<li>加锁静态方法：加锁在方法所在Class对象上</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Object中的线程相关方法\"><a href=\"#Object中的线程相关方法\" class=\"headerlink\" title=\"Object中的线程相关方法\"></a>Object中的线程相关方法</h2><p>Object.wait()/Object.notify()</p>\n<ul>\n<li><p>先看JDK中对两个方法的描述：</p>\n<ul>\n<li><p>wait()：</p>\n<p>Causes the current thread to wait until another thread invokes the java.lang.Object.notify() method or the java.lang.Object.notifyAll() method for this object.</p>\n</li>\n<li><p>notify()：</p>\n<p>Wakes up a single thread that is waiting on this object’s monitor.</p>\n</li>\n</ul>\n</li>\n<li><p>简言之，就是通过一个（monitor）对象，让线程停下来或是动起来</p>\n</li>\n<li><p>这两个方法在操作之前都一定要取得monitor对象的锁</p>\n</li>\n<li><p>wait方法执行后线程会释放持有的锁，直到被他线程notify monitor时重新持有锁</p>\n</li>\n<li><p>wait的典型使用场景：Thread.join</p>\n<p>join方法内部的关键实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">(<span class=\"keyword\">long</span> millis)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (millis == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (isAlive()) &#123;</div><div class=\"line\">      wait(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (isAlive()) &#123;</div><div class=\"line\">      <span class=\"keyword\">long</span> delay = millis - now;</div><div class=\"line\">      <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      wait(delay);</div><div class=\"line\">      now = System.currentTimeMillis() - base;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>两点需要注意的：</p>\n<ul>\n<li>join最终的实现依赖：wait(delay);</li>\n<li>加锁位置：public final synchronized void join(long millis)，相当于synchronized(this)</li>\n</ul>\n<p>以一个例子说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JoinDemo</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> count = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</div><div class=\"line\">            <span class=\"keyword\">while</span> (++count &lt; <span class=\"number\">1_000_000_000</span>) &#123;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        thread.start();</div><div class=\"line\">        thread.join();</div><div class=\"line\">        System.out.println(count);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Main线程中执行thread.join，在join(int)方法中锁加在了thread对象上，内部的wait()是在thread对象上执行的。也就是说对于Main线程而言，thread线程是它的monitor。</p>\n<p>在join方法执行后Main线程处于WAITING状态，直到有人对它的monitor（thread 线程）执行notify操作，这一步是在thread线程执行完毕由JVM操作的。</p>\n<p>可以说thread既当爹又当妈，既要让当前线程停下来，又要自己跑起来。在thread执行完毕后重新对自己notify，让Main线程跑起来。</p>\n</li>\n</ul>\n"},{"title":"Spring之AOP【一】","date":"2017-03-19T18:33:06.000Z","_content":"\n## 关于AOP\n\n实现方式：\n\n- 动态代理【Spring AOP默认】\n- 动态字节码增强【Spring AOP备选】\n- Java代码生成\n- 自定义类加载器\n- AOP扩展\n\nAOP组成：\n\n- Joinpoint：添加（织入）横切逻辑的位置\n- Pointcut：Jointpoint的表述方式\n- Advice：横切逻辑\n- Weaver：织入器\n- 目标对象\n\n## Spring AOP\n\nSpring AOP实现机制：动态代理机制和字节码生成技术实现，在运行期为目标对象生成一个代理对象。\n\nSpring对AOP的实现实质上是使用代理机制对上述基本AOP组成概念实现，组合。\n\n### Pointcut\n\nSpring AOP只支持方法级别的Joinpoint，在Pointcut上也可以体现出来：Pointcut接口只定义两个方法分别用于匹配类和方法。\n\nPointcut根据方法匹配可以分为两类：\n\n- StaticMethodMatcherPontcut，不会检查Joinpoint的方法参数\n- DynamicMethodMatcherPointcut，每次都要对方法参数进行检查\n\n具体的实现可以不做任何限制，可以根据方法名，注解等各种形式，正则，逻辑运算，调用顺序等多种方式进行过滤。\n\n### Advice\n\n跟与Advice是否在目标对象之间共享可以分为：per-class和per-instance\n\n#### per-class\n\nAdvice实例可以在目标对象的所有实例之间共享，又可以分为：\n\n- Before Advice\n- ThrowsAdvice\n- AfterReturningAdvice\n- AroundAdvice\n\n每种情况都有对应有接口，要实现对应的Advice之需要实现对应接口。\n\nAroundAdvice比较特殊，Spring没有定义对应接口，而是使用了AOP Alliance的标准接口，接口定义如下：\n\n```java\npublic interface MethodInterceptor extends Interceptor {\n  Object invoke(MethodInvocation invocation) throws Throwable;\n}\n```\n\nMethodInterceptor：Advice，唯一方法invoke封装横切逻辑\n\nMethodInvocation：控制拦截行为，可以获取Joinpoint的信息，重要方法：process\n\n#### per-instance\n\nAdvice会为不同实例对象保存各自的状态及逻辑，Spring围绕Introduction实现per-instance型Advice。\n\n![Introduction.png](https://ooo.0o0.ooo/2017/03/19/58ce9fe4f321a.png)\n\n拦截器——IntroductionInterceptor\n\n继承自：\n\n- DynamicIntroductionAdvice：判断给定接口是否是扩展逻辑\n- MethodInterceptor：\n  - 当接口是扩展逻辑：通过Method.invoke()执行扩展逻辑\n  - 当接口不是扩展逻辑：通过MethodInvocation.proceed()调用代理对象\n\nIntroduction可以分为两类：\n\n- 以IntroductionInfo为首的静态分支\n  - 预先定义扩展逻辑接口\n  - DelegatingIntroductionInterceptor：内部持有一个扩展逻辑实现类，供统一目标类的所有实例共享使用\n- DynamicIntroductionAdvice为首的动态分支\n  - 运行时获取扩展逻辑接口\n  - DelegatePerTargetObjectIntroductionInterceptor：内部持有一个映射关系，映射目标对象与扩展逻辑实现类\n\n### Aspect\n\n在Spring第一代的实现中是没有Aspect的概念的，与之对应的是Advisor。\n\n根据Advice的不同，又可以分为：PointcutAdvisor和IntroductionAdvisor，其中IntroductionAdvisor是专门为Introduction使用的。\n\n当在一个Joinpoint处理多个Advice时，可以指定优先级。\n\n#### PointcutAdvisor\n\n根据Pointcut，Advisor的不同实现，PointcutAdvisor提供了多种具体实现组合\n\n####  IntroductionAdvisor\n\n只有一个默认实现：DefaultIntroductionAdvisor\n\n### Weaver\n\n通过Aspect封装了Pointcut和Advice之后，Weaver只需要关注目标对象和Aspect就可以了。\n\n根据目标对象和Advice，织入器就可以完成织入，典型的织入器有：ProxyFactory，ProxyFactoryBean\n\n#### ProxyFactory\n\nSpring最基本的织入器——ProxyFactory：\n\n![ProxyFactory.png](https://ooo.0o0.ooo/2017/03/20/58cec4ff8c8fd.png)\n\nAdvicedSupport包含生成代理对象所需的信息\n\nAopProxy抽象不同AOP实现（动态代理，CGLIB）\n\n最终对ProxyFactory进行配置后就可以生成代理对象了，配置功能是从ProxyCreatorSupport继承而来，生成代理对象委托给具体的AopProxy实现类。\n\n#### ProxyFactoryBean\n\n与ProxyFactory功能类似，本质是一个产生代理对象的FactoryBean\n\n#### 自动织入\n\n无论ProxyFactory还是ProxyFactoryBean都需要配置目标对象和Advice才能完成一个织入过程，自动织入可以借助IoC容器，在BeanPostProcessor阶段自动扫描完成所有织入动作。\n\n整个自动织入过程可以描述为：\n\n```java\nfor bean in IoC container\n  if bean isAutoProxyBean\n    return createProxy(bean)\n  else\n    return createInstance(bean)\n```\n\nSpring默认提供了多个可用的AutoProxyCreator，可以根据bean name指定目标对象，扫描Advice生成代理对象，甚至可以全自动生成代理对象。\n\n\n### TargetSource\n\n作为目标对象的容器，TargetSource最重要的作用就是获取目标对象。\n\nTargetSource不同的实现提供了目标对象singleton，prototype，热替换，对象池等多种管理形式。\n\n在多数据源替换的场景还是很有用的。\n","source":"_posts/Spring之AOP【一】.md","raw":"---\ntitle: Spring之AOP【一】\ndate: 2017-03-20 02:33:06\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n\n## 关于AOP\n\n实现方式：\n\n- 动态代理【Spring AOP默认】\n- 动态字节码增强【Spring AOP备选】\n- Java代码生成\n- 自定义类加载器\n- AOP扩展\n\nAOP组成：\n\n- Joinpoint：添加（织入）横切逻辑的位置\n- Pointcut：Jointpoint的表述方式\n- Advice：横切逻辑\n- Weaver：织入器\n- 目标对象\n\n## Spring AOP\n\nSpring AOP实现机制：动态代理机制和字节码生成技术实现，在运行期为目标对象生成一个代理对象。\n\nSpring对AOP的实现实质上是使用代理机制对上述基本AOP组成概念实现，组合。\n\n### Pointcut\n\nSpring AOP只支持方法级别的Joinpoint，在Pointcut上也可以体现出来：Pointcut接口只定义两个方法分别用于匹配类和方法。\n\nPointcut根据方法匹配可以分为两类：\n\n- StaticMethodMatcherPontcut，不会检查Joinpoint的方法参数\n- DynamicMethodMatcherPointcut，每次都要对方法参数进行检查\n\n具体的实现可以不做任何限制，可以根据方法名，注解等各种形式，正则，逻辑运算，调用顺序等多种方式进行过滤。\n\n### Advice\n\n跟与Advice是否在目标对象之间共享可以分为：per-class和per-instance\n\n#### per-class\n\nAdvice实例可以在目标对象的所有实例之间共享，又可以分为：\n\n- Before Advice\n- ThrowsAdvice\n- AfterReturningAdvice\n- AroundAdvice\n\n每种情况都有对应有接口，要实现对应的Advice之需要实现对应接口。\n\nAroundAdvice比较特殊，Spring没有定义对应接口，而是使用了AOP Alliance的标准接口，接口定义如下：\n\n```java\npublic interface MethodInterceptor extends Interceptor {\n  Object invoke(MethodInvocation invocation) throws Throwable;\n}\n```\n\nMethodInterceptor：Advice，唯一方法invoke封装横切逻辑\n\nMethodInvocation：控制拦截行为，可以获取Joinpoint的信息，重要方法：process\n\n#### per-instance\n\nAdvice会为不同实例对象保存各自的状态及逻辑，Spring围绕Introduction实现per-instance型Advice。\n\n![Introduction.png](https://ooo.0o0.ooo/2017/03/19/58ce9fe4f321a.png)\n\n拦截器——IntroductionInterceptor\n\n继承自：\n\n- DynamicIntroductionAdvice：判断给定接口是否是扩展逻辑\n- MethodInterceptor：\n  - 当接口是扩展逻辑：通过Method.invoke()执行扩展逻辑\n  - 当接口不是扩展逻辑：通过MethodInvocation.proceed()调用代理对象\n\nIntroduction可以分为两类：\n\n- 以IntroductionInfo为首的静态分支\n  - 预先定义扩展逻辑接口\n  - DelegatingIntroductionInterceptor：内部持有一个扩展逻辑实现类，供统一目标类的所有实例共享使用\n- DynamicIntroductionAdvice为首的动态分支\n  - 运行时获取扩展逻辑接口\n  - DelegatePerTargetObjectIntroductionInterceptor：内部持有一个映射关系，映射目标对象与扩展逻辑实现类\n\n### Aspect\n\n在Spring第一代的实现中是没有Aspect的概念的，与之对应的是Advisor。\n\n根据Advice的不同，又可以分为：PointcutAdvisor和IntroductionAdvisor，其中IntroductionAdvisor是专门为Introduction使用的。\n\n当在一个Joinpoint处理多个Advice时，可以指定优先级。\n\n#### PointcutAdvisor\n\n根据Pointcut，Advisor的不同实现，PointcutAdvisor提供了多种具体实现组合\n\n####  IntroductionAdvisor\n\n只有一个默认实现：DefaultIntroductionAdvisor\n\n### Weaver\n\n通过Aspect封装了Pointcut和Advice之后，Weaver只需要关注目标对象和Aspect就可以了。\n\n根据目标对象和Advice，织入器就可以完成织入，典型的织入器有：ProxyFactory，ProxyFactoryBean\n\n#### ProxyFactory\n\nSpring最基本的织入器——ProxyFactory：\n\n![ProxyFactory.png](https://ooo.0o0.ooo/2017/03/20/58cec4ff8c8fd.png)\n\nAdvicedSupport包含生成代理对象所需的信息\n\nAopProxy抽象不同AOP实现（动态代理，CGLIB）\n\n最终对ProxyFactory进行配置后就可以生成代理对象了，配置功能是从ProxyCreatorSupport继承而来，生成代理对象委托给具体的AopProxy实现类。\n\n#### ProxyFactoryBean\n\n与ProxyFactory功能类似，本质是一个产生代理对象的FactoryBean\n\n#### 自动织入\n\n无论ProxyFactory还是ProxyFactoryBean都需要配置目标对象和Advice才能完成一个织入过程，自动织入可以借助IoC容器，在BeanPostProcessor阶段自动扫描完成所有织入动作。\n\n整个自动织入过程可以描述为：\n\n```java\nfor bean in IoC container\n  if bean isAutoProxyBean\n    return createProxy(bean)\n  else\n    return createInstance(bean)\n```\n\nSpring默认提供了多个可用的AutoProxyCreator，可以根据bean name指定目标对象，扫描Advice生成代理对象，甚至可以全自动生成代理对象。\n\n\n### TargetSource\n\n作为目标对象的容器，TargetSource最重要的作用就是获取目标对象。\n\nTargetSource不同的实现提供了目标对象singleton，prototype，热替换，对象池等多种管理形式。\n\n在多数据源替换的场景还是很有用的。\n","slug":"Spring之AOP【一】","published":1,"updated":"2017-03-19T18:41:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2ps0019d82e108qjefg","content":"<h2 id=\"关于AOP\"><a href=\"#关于AOP\" class=\"headerlink\" title=\"关于AOP\"></a>关于AOP</h2><p>实现方式：</p>\n<ul>\n<li>动态代理【Spring AOP默认】</li>\n<li>动态字节码增强【Spring AOP备选】</li>\n<li>Java代码生成</li>\n<li>自定义类加载器</li>\n<li>AOP扩展</li>\n</ul>\n<p>AOP组成：</p>\n<ul>\n<li>Joinpoint：添加（织入）横切逻辑的位置</li>\n<li>Pointcut：Jointpoint的表述方式</li>\n<li>Advice：横切逻辑</li>\n<li>Weaver：织入器</li>\n<li>目标对象</li>\n</ul>\n<h2 id=\"Spring-AOP\"><a href=\"#Spring-AOP\" class=\"headerlink\" title=\"Spring AOP\"></a>Spring AOP</h2><p>Spring AOP实现机制：动态代理机制和字节码生成技术实现，在运行期为目标对象生成一个代理对象。</p>\n<p>Spring对AOP的实现实质上是使用代理机制对上述基本AOP组成概念实现，组合。</p>\n<h3 id=\"Pointcut\"><a href=\"#Pointcut\" class=\"headerlink\" title=\"Pointcut\"></a>Pointcut</h3><p>Spring AOP只支持方法级别的Joinpoint，在Pointcut上也可以体现出来：Pointcut接口只定义两个方法分别用于匹配类和方法。</p>\n<p>Pointcut根据方法匹配可以分为两类：</p>\n<ul>\n<li>StaticMethodMatcherPontcut，不会检查Joinpoint的方法参数</li>\n<li>DynamicMethodMatcherPointcut，每次都要对方法参数进行检查</li>\n</ul>\n<p>具体的实现可以不做任何限制，可以根据方法名，注解等各种形式，正则，逻辑运算，调用顺序等多种方式进行过滤。</p>\n<h3 id=\"Advice\"><a href=\"#Advice\" class=\"headerlink\" title=\"Advice\"></a>Advice</h3><p>跟与Advice是否在目标对象之间共享可以分为：per-class和per-instance</p>\n<h4 id=\"per-class\"><a href=\"#per-class\" class=\"headerlink\" title=\"per-class\"></a>per-class</h4><p>Advice实例可以在目标对象的所有实例之间共享，又可以分为：</p>\n<ul>\n<li>Before Advice</li>\n<li>ThrowsAdvice</li>\n<li>AfterReturningAdvice</li>\n<li>AroundAdvice</li>\n</ul>\n<p>每种情况都有对应有接口，要实现对应的Advice之需要实现对应接口。</p>\n<p>AroundAdvice比较特殊，Spring没有定义对应接口，而是使用了AOP Alliance的标准接口，接口定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Interceptor</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(MethodInvocation invocation)</span> <span class=\"keyword\">throws</span> Throwable</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>MethodInterceptor：Advice，唯一方法invoke封装横切逻辑</p>\n<p>MethodInvocation：控制拦截行为，可以获取Joinpoint的信息，重要方法：process</p>\n<h4 id=\"per-instance\"><a href=\"#per-instance\" class=\"headerlink\" title=\"per-instance\"></a>per-instance</h4><p>Advice会为不同实例对象保存各自的状态及逻辑，Spring围绕Introduction实现per-instance型Advice。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/19/58ce9fe4f321a.png\" alt=\"Introduction.png\"></p>\n<p>拦截器——IntroductionInterceptor</p>\n<p>继承自：</p>\n<ul>\n<li>DynamicIntroductionAdvice：判断给定接口是否是扩展逻辑</li>\n<li>MethodInterceptor：<ul>\n<li>当接口是扩展逻辑：通过Method.invoke()执行扩展逻辑</li>\n<li>当接口不是扩展逻辑：通过MethodInvocation.proceed()调用代理对象</li>\n</ul>\n</li>\n</ul>\n<p>Introduction可以分为两类：</p>\n<ul>\n<li>以IntroductionInfo为首的静态分支<ul>\n<li>预先定义扩展逻辑接口</li>\n<li>DelegatingIntroductionInterceptor：内部持有一个扩展逻辑实现类，供统一目标类的所有实例共享使用</li>\n</ul>\n</li>\n<li>DynamicIntroductionAdvice为首的动态分支<ul>\n<li>运行时获取扩展逻辑接口</li>\n<li>DelegatePerTargetObjectIntroductionInterceptor：内部持有一个映射关系，映射目标对象与扩展逻辑实现类</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Aspect\"><a href=\"#Aspect\" class=\"headerlink\" title=\"Aspect\"></a>Aspect</h3><p>在Spring第一代的实现中是没有Aspect的概念的，与之对应的是Advisor。</p>\n<p>根据Advice的不同，又可以分为：PointcutAdvisor和IntroductionAdvisor，其中IntroductionAdvisor是专门为Introduction使用的。</p>\n<p>当在一个Joinpoint处理多个Advice时，可以指定优先级。</p>\n<h4 id=\"PointcutAdvisor\"><a href=\"#PointcutAdvisor\" class=\"headerlink\" title=\"PointcutAdvisor\"></a>PointcutAdvisor</h4><p>根据Pointcut，Advisor的不同实现，PointcutAdvisor提供了多种具体实现组合</p>\n<h4 id=\"IntroductionAdvisor\"><a href=\"#IntroductionAdvisor\" class=\"headerlink\" title=\"IntroductionAdvisor\"></a>IntroductionAdvisor</h4><p>只有一个默认实现：DefaultIntroductionAdvisor</p>\n<h3 id=\"Weaver\"><a href=\"#Weaver\" class=\"headerlink\" title=\"Weaver\"></a>Weaver</h3><p>通过Aspect封装了Pointcut和Advice之后，Weaver只需要关注目标对象和Aspect就可以了。</p>\n<p>根据目标对象和Advice，织入器就可以完成织入，典型的织入器有：ProxyFactory，ProxyFactoryBean</p>\n<h4 id=\"ProxyFactory\"><a href=\"#ProxyFactory\" class=\"headerlink\" title=\"ProxyFactory\"></a>ProxyFactory</h4><p>Spring最基本的织入器——ProxyFactory：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/20/58cec4ff8c8fd.png\" alt=\"ProxyFactory.png\"></p>\n<p>AdvicedSupport包含生成代理对象所需的信息</p>\n<p>AopProxy抽象不同AOP实现（动态代理，CGLIB）</p>\n<p>最终对ProxyFactory进行配置后就可以生成代理对象了，配置功能是从ProxyCreatorSupport继承而来，生成代理对象委托给具体的AopProxy实现类。</p>\n<h4 id=\"ProxyFactoryBean\"><a href=\"#ProxyFactoryBean\" class=\"headerlink\" title=\"ProxyFactoryBean\"></a>ProxyFactoryBean</h4><p>与ProxyFactory功能类似，本质是一个产生代理对象的FactoryBean</p>\n<h4 id=\"自动织入\"><a href=\"#自动织入\" class=\"headerlink\" title=\"自动织入\"></a>自动织入</h4><p>无论ProxyFactory还是ProxyFactoryBean都需要配置目标对象和Advice才能完成一个织入过程，自动织入可以借助IoC容器，在BeanPostProcessor阶段自动扫描完成所有织入动作。</p>\n<p>整个自动织入过程可以描述为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">for</span> bean in IoC container</span></div><div class=\"line\">  <span class=\"keyword\">if</span> bean isAutoProxyBean</div><div class=\"line\">    return <span class=\"title\">createProxy</span><span class=\"params\">(bean)</span></div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    return <span class=\"title\">createInstance</span><span class=\"params\">(bean)</span></div></pre></td></tr></table></figure>\n<p>Spring默认提供了多个可用的AutoProxyCreator，可以根据bean name指定目标对象，扫描Advice生成代理对象，甚至可以全自动生成代理对象。</p>\n<h3 id=\"TargetSource\"><a href=\"#TargetSource\" class=\"headerlink\" title=\"TargetSource\"></a>TargetSource</h3><p>作为目标对象的容器，TargetSource最重要的作用就是获取目标对象。</p>\n<p>TargetSource不同的实现提供了目标对象singleton，prototype，热替换，对象池等多种管理形式。</p>\n<p>在多数据源替换的场景还是很有用的。</p>\n","excerpt":"","more":"<h2 id=\"关于AOP\"><a href=\"#关于AOP\" class=\"headerlink\" title=\"关于AOP\"></a>关于AOP</h2><p>实现方式：</p>\n<ul>\n<li>动态代理【Spring AOP默认】</li>\n<li>动态字节码增强【Spring AOP备选】</li>\n<li>Java代码生成</li>\n<li>自定义类加载器</li>\n<li>AOP扩展</li>\n</ul>\n<p>AOP组成：</p>\n<ul>\n<li>Joinpoint：添加（织入）横切逻辑的位置</li>\n<li>Pointcut：Jointpoint的表述方式</li>\n<li>Advice：横切逻辑</li>\n<li>Weaver：织入器</li>\n<li>目标对象</li>\n</ul>\n<h2 id=\"Spring-AOP\"><a href=\"#Spring-AOP\" class=\"headerlink\" title=\"Spring AOP\"></a>Spring AOP</h2><p>Spring AOP实现机制：动态代理机制和字节码生成技术实现，在运行期为目标对象生成一个代理对象。</p>\n<p>Spring对AOP的实现实质上是使用代理机制对上述基本AOP组成概念实现，组合。</p>\n<h3 id=\"Pointcut\"><a href=\"#Pointcut\" class=\"headerlink\" title=\"Pointcut\"></a>Pointcut</h3><p>Spring AOP只支持方法级别的Joinpoint，在Pointcut上也可以体现出来：Pointcut接口只定义两个方法分别用于匹配类和方法。</p>\n<p>Pointcut根据方法匹配可以分为两类：</p>\n<ul>\n<li>StaticMethodMatcherPontcut，不会检查Joinpoint的方法参数</li>\n<li>DynamicMethodMatcherPointcut，每次都要对方法参数进行检查</li>\n</ul>\n<p>具体的实现可以不做任何限制，可以根据方法名，注解等各种形式，正则，逻辑运算，调用顺序等多种方式进行过滤。</p>\n<h3 id=\"Advice\"><a href=\"#Advice\" class=\"headerlink\" title=\"Advice\"></a>Advice</h3><p>跟与Advice是否在目标对象之间共享可以分为：per-class和per-instance</p>\n<h4 id=\"per-class\"><a href=\"#per-class\" class=\"headerlink\" title=\"per-class\"></a>per-class</h4><p>Advice实例可以在目标对象的所有实例之间共享，又可以分为：</p>\n<ul>\n<li>Before Advice</li>\n<li>ThrowsAdvice</li>\n<li>AfterReturningAdvice</li>\n<li>AroundAdvice</li>\n</ul>\n<p>每种情况都有对应有接口，要实现对应的Advice之需要实现对应接口。</p>\n<p>AroundAdvice比较特殊，Spring没有定义对应接口，而是使用了AOP Alliance的标准接口，接口定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Interceptor</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(MethodInvocation invocation)</span> <span class=\"keyword\">throws</span> Throwable</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>MethodInterceptor：Advice，唯一方法invoke封装横切逻辑</p>\n<p>MethodInvocation：控制拦截行为，可以获取Joinpoint的信息，重要方法：process</p>\n<h4 id=\"per-instance\"><a href=\"#per-instance\" class=\"headerlink\" title=\"per-instance\"></a>per-instance</h4><p>Advice会为不同实例对象保存各自的状态及逻辑，Spring围绕Introduction实现per-instance型Advice。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/19/58ce9fe4f321a.png\" alt=\"Introduction.png\"></p>\n<p>拦截器——IntroductionInterceptor</p>\n<p>继承自：</p>\n<ul>\n<li>DynamicIntroductionAdvice：判断给定接口是否是扩展逻辑</li>\n<li>MethodInterceptor：<ul>\n<li>当接口是扩展逻辑：通过Method.invoke()执行扩展逻辑</li>\n<li>当接口不是扩展逻辑：通过MethodInvocation.proceed()调用代理对象</li>\n</ul>\n</li>\n</ul>\n<p>Introduction可以分为两类：</p>\n<ul>\n<li>以IntroductionInfo为首的静态分支<ul>\n<li>预先定义扩展逻辑接口</li>\n<li>DelegatingIntroductionInterceptor：内部持有一个扩展逻辑实现类，供统一目标类的所有实例共享使用</li>\n</ul>\n</li>\n<li>DynamicIntroductionAdvice为首的动态分支<ul>\n<li>运行时获取扩展逻辑接口</li>\n<li>DelegatePerTargetObjectIntroductionInterceptor：内部持有一个映射关系，映射目标对象与扩展逻辑实现类</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Aspect\"><a href=\"#Aspect\" class=\"headerlink\" title=\"Aspect\"></a>Aspect</h3><p>在Spring第一代的实现中是没有Aspect的概念的，与之对应的是Advisor。</p>\n<p>根据Advice的不同，又可以分为：PointcutAdvisor和IntroductionAdvisor，其中IntroductionAdvisor是专门为Introduction使用的。</p>\n<p>当在一个Joinpoint处理多个Advice时，可以指定优先级。</p>\n<h4 id=\"PointcutAdvisor\"><a href=\"#PointcutAdvisor\" class=\"headerlink\" title=\"PointcutAdvisor\"></a>PointcutAdvisor</h4><p>根据Pointcut，Advisor的不同实现，PointcutAdvisor提供了多种具体实现组合</p>\n<h4 id=\"IntroductionAdvisor\"><a href=\"#IntroductionAdvisor\" class=\"headerlink\" title=\"IntroductionAdvisor\"></a>IntroductionAdvisor</h4><p>只有一个默认实现：DefaultIntroductionAdvisor</p>\n<h3 id=\"Weaver\"><a href=\"#Weaver\" class=\"headerlink\" title=\"Weaver\"></a>Weaver</h3><p>通过Aspect封装了Pointcut和Advice之后，Weaver只需要关注目标对象和Aspect就可以了。</p>\n<p>根据目标对象和Advice，织入器就可以完成织入，典型的织入器有：ProxyFactory，ProxyFactoryBean</p>\n<h4 id=\"ProxyFactory\"><a href=\"#ProxyFactory\" class=\"headerlink\" title=\"ProxyFactory\"></a>ProxyFactory</h4><p>Spring最基本的织入器——ProxyFactory：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/20/58cec4ff8c8fd.png\" alt=\"ProxyFactory.png\"></p>\n<p>AdvicedSupport包含生成代理对象所需的信息</p>\n<p>AopProxy抽象不同AOP实现（动态代理，CGLIB）</p>\n<p>最终对ProxyFactory进行配置后就可以生成代理对象了，配置功能是从ProxyCreatorSupport继承而来，生成代理对象委托给具体的AopProxy实现类。</p>\n<h4 id=\"ProxyFactoryBean\"><a href=\"#ProxyFactoryBean\" class=\"headerlink\" title=\"ProxyFactoryBean\"></a>ProxyFactoryBean</h4><p>与ProxyFactory功能类似，本质是一个产生代理对象的FactoryBean</p>\n<h4 id=\"自动织入\"><a href=\"#自动织入\" class=\"headerlink\" title=\"自动织入\"></a>自动织入</h4><p>无论ProxyFactory还是ProxyFactoryBean都需要配置目标对象和Advice才能完成一个织入过程，自动织入可以借助IoC容器，在BeanPostProcessor阶段自动扫描完成所有织入动作。</p>\n<p>整个自动织入过程可以描述为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">for</span> bean in IoC container</div><div class=\"line\">  <span class=\"keyword\">if</span> bean isAutoProxyBean</div><div class=\"line\">    return <span class=\"title\">createProxy</span><span class=\"params\">(bean)</span></div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    return <span class=\"title\">createInstance</span><span class=\"params\">(bean)</span></span></div></pre></td></tr></table></figure>\n<p>Spring默认提供了多个可用的AutoProxyCreator，可以根据bean name指定目标对象，扫描Advice生成代理对象，甚至可以全自动生成代理对象。</p>\n<h3 id=\"TargetSource\"><a href=\"#TargetSource\" class=\"headerlink\" title=\"TargetSource\"></a>TargetSource</h3><p>作为目标对象的容器，TargetSource最重要的作用就是获取目标对象。</p>\n<p>TargetSource不同的实现提供了目标对象singleton，prototype，热替换，对象池等多种管理形式。</p>\n<p>在多数据源替换的场景还是很有用的。</p>\n"},{"title":"Spring之ApplicationContext","date":"2017-03-19T12:57:27.000Z","_content":"相较于BeanFactory，ApplicationContext进一步扩展了基本功能。主要有：统一资源加载，国际化信息支持，容器内部事件发布，多配置模块加载的简化。\n\n## 统一资源加载\n\n在Spring中资源的表示和加载时分开的：使用Resource表示资源，使用Resource Loader加载资源。\n\n二者与Application Context的关系：\n\n![ResourceLoader.png](https://ooo.0o0.ooo/2017/03/19/58ce56622ec9d.png)\n\n从很多地方都能看出Spring优秀的设计，资源加载策略就是其中。\n\n为什么说统一的资源加载？因为什么资源都能加载。\n\n首先，Spring抽象了资源的表示以Resource表示各种资源的形式，根据具体形式又提供了例如ClassPathResource的具体形式。\n\n其次，ResourceLoader抽象了资源查找定位策略的抽象，其分为大体可以分为两类：\n\n- 以DefaultResourceLoader为基础的，一般的ResourceLoader\n- 以ResourcePatternResolver为基础的，批量查找的ResourceLoader\n\n容器启动是加载的配置文件所使用的资源路径协议也是在此定义的。\n\n最后看看Application Context与Resource Loader的关系：Application Context是一个Resource Loader，更一般的情况Application Context还是ResourcePatternResolver\n\n## 国际化信息支持\n\nSpring对国际化得支持不仅是针对还是对整个应用的支持，以MessageSource作为国际化信息的访问接口，封装了相应的信息查询，针对不同的需求做出了不同实现（例如热替换）。\n\nApplication Context同时继承了MessageSource，因此容器获得国际化的支持，对普通Bean可以通过注入MessageSource获得国际化的能力。\n\n## 容器内部事件发布\n\n标准的事件发布功能包含三个角色：自定义事件类型，事件监听接口，事件发布者。Spring对相关角色的定义：\n\n![事件发布.png](https://ooo.0o0.ooo/2017/03/19/58ce7c99afcc3.png)\n\nApplication Context继承ApplicationEventPublisher，将具体的实现委托给ApplicationEventMulticaster接口的实现类来实现。\n\n具体的ApplicationEvent实现Spring提供了容器生命周期相关的和Web请求相关的事件类型，容器还支持自定义事件类型的发布。\n\n## 多配置模块加载的简化\n\n相较于BeanFactory，Application Context还提供多个配置文件加载的简化\n\n## Application Context\n\n一言以蔽之，Application Context是这样的Bena容器：\n\n![Application Context.png](https://ooo.0o0.ooo/2017/03/19/58ce7f9a578b6.png)\n","source":"_posts/Spring之ApplicationContext.md","raw":"---\ntitle: Spring之ApplicationContext\ndate: 2017-03-19 20:57:27\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n相较于BeanFactory，ApplicationContext进一步扩展了基本功能。主要有：统一资源加载，国际化信息支持，容器内部事件发布，多配置模块加载的简化。\n\n## 统一资源加载\n\n在Spring中资源的表示和加载时分开的：使用Resource表示资源，使用Resource Loader加载资源。\n\n二者与Application Context的关系：\n\n![ResourceLoader.png](https://ooo.0o0.ooo/2017/03/19/58ce56622ec9d.png)\n\n从很多地方都能看出Spring优秀的设计，资源加载策略就是其中。\n\n为什么说统一的资源加载？因为什么资源都能加载。\n\n首先，Spring抽象了资源的表示以Resource表示各种资源的形式，根据具体形式又提供了例如ClassPathResource的具体形式。\n\n其次，ResourceLoader抽象了资源查找定位策略的抽象，其分为大体可以分为两类：\n\n- 以DefaultResourceLoader为基础的，一般的ResourceLoader\n- 以ResourcePatternResolver为基础的，批量查找的ResourceLoader\n\n容器启动是加载的配置文件所使用的资源路径协议也是在此定义的。\n\n最后看看Application Context与Resource Loader的关系：Application Context是一个Resource Loader，更一般的情况Application Context还是ResourcePatternResolver\n\n## 国际化信息支持\n\nSpring对国际化得支持不仅是针对还是对整个应用的支持，以MessageSource作为国际化信息的访问接口，封装了相应的信息查询，针对不同的需求做出了不同实现（例如热替换）。\n\nApplication Context同时继承了MessageSource，因此容器获得国际化的支持，对普通Bean可以通过注入MessageSource获得国际化的能力。\n\n## 容器内部事件发布\n\n标准的事件发布功能包含三个角色：自定义事件类型，事件监听接口，事件发布者。Spring对相关角色的定义：\n\n![事件发布.png](https://ooo.0o0.ooo/2017/03/19/58ce7c99afcc3.png)\n\nApplication Context继承ApplicationEventPublisher，将具体的实现委托给ApplicationEventMulticaster接口的实现类来实现。\n\n具体的ApplicationEvent实现Spring提供了容器生命周期相关的和Web请求相关的事件类型，容器还支持自定义事件类型的发布。\n\n## 多配置模块加载的简化\n\n相较于BeanFactory，Application Context还提供多个配置文件加载的简化\n\n## Application Context\n\n一言以蔽之，Application Context是这样的Bena容器：\n\n![Application Context.png](https://ooo.0o0.ooo/2017/03/19/58ce7f9a578b6.png)\n","slug":"Spring之ApplicationContext","published":1,"updated":"2017-03-19T12:59:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2pt001cd82ex81xuujq","content":"<p>相较于BeanFactory，ApplicationContext进一步扩展了基本功能。主要有：统一资源加载，国际化信息支持，容器内部事件发布，多配置模块加载的简化。</p>\n<h2 id=\"统一资源加载\"><a href=\"#统一资源加载\" class=\"headerlink\" title=\"统一资源加载\"></a>统一资源加载</h2><p>在Spring中资源的表示和加载时分开的：使用Resource表示资源，使用Resource Loader加载资源。</p>\n<p>二者与Application Context的关系：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/19/58ce56622ec9d.png\" alt=\"ResourceLoader.png\"></p>\n<p>从很多地方都能看出Spring优秀的设计，资源加载策略就是其中。</p>\n<p>为什么说统一的资源加载？因为什么资源都能加载。</p>\n<p>首先，Spring抽象了资源的表示以Resource表示各种资源的形式，根据具体形式又提供了例如ClassPathResource的具体形式。</p>\n<p>其次，ResourceLoader抽象了资源查找定位策略的抽象，其分为大体可以分为两类：</p>\n<ul>\n<li>以DefaultResourceLoader为基础的，一般的ResourceLoader</li>\n<li>以ResourcePatternResolver为基础的，批量查找的ResourceLoader</li>\n</ul>\n<p>容器启动是加载的配置文件所使用的资源路径协议也是在此定义的。</p>\n<p>最后看看Application Context与Resource Loader的关系：Application Context是一个Resource Loader，更一般的情况Application Context还是ResourcePatternResolver</p>\n<h2 id=\"国际化信息支持\"><a href=\"#国际化信息支持\" class=\"headerlink\" title=\"国际化信息支持\"></a>国际化信息支持</h2><p>Spring对国际化得支持不仅是针对还是对整个应用的支持，以MessageSource作为国际化信息的访问接口，封装了相应的信息查询，针对不同的需求做出了不同实现（例如热替换）。</p>\n<p>Application Context同时继承了MessageSource，因此容器获得国际化的支持，对普通Bean可以通过注入MessageSource获得国际化的能力。</p>\n<h2 id=\"容器内部事件发布\"><a href=\"#容器内部事件发布\" class=\"headerlink\" title=\"容器内部事件发布\"></a>容器内部事件发布</h2><p>标准的事件发布功能包含三个角色：自定义事件类型，事件监听接口，事件发布者。Spring对相关角色的定义：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/19/58ce7c99afcc3.png\" alt=\"事件发布.png\"></p>\n<p>Application Context继承ApplicationEventPublisher，将具体的实现委托给ApplicationEventMulticaster接口的实现类来实现。</p>\n<p>具体的ApplicationEvent实现Spring提供了容器生命周期相关的和Web请求相关的事件类型，容器还支持自定义事件类型的发布。</p>\n<h2 id=\"多配置模块加载的简化\"><a href=\"#多配置模块加载的简化\" class=\"headerlink\" title=\"多配置模块加载的简化\"></a>多配置模块加载的简化</h2><p>相较于BeanFactory，Application Context还提供多个配置文件加载的简化</p>\n<h2 id=\"Application-Context\"><a href=\"#Application-Context\" class=\"headerlink\" title=\"Application Context\"></a>Application Context</h2><p>一言以蔽之，Application Context是这样的Bena容器：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/19/58ce7f9a578b6.png\" alt=\"Application Context.png\"></p>\n","excerpt":"","more":"<p>相较于BeanFactory，ApplicationContext进一步扩展了基本功能。主要有：统一资源加载，国际化信息支持，容器内部事件发布，多配置模块加载的简化。</p>\n<h2 id=\"统一资源加载\"><a href=\"#统一资源加载\" class=\"headerlink\" title=\"统一资源加载\"></a>统一资源加载</h2><p>在Spring中资源的表示和加载时分开的：使用Resource表示资源，使用Resource Loader加载资源。</p>\n<p>二者与Application Context的关系：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/19/58ce56622ec9d.png\" alt=\"ResourceLoader.png\"></p>\n<p>从很多地方都能看出Spring优秀的设计，资源加载策略就是其中。</p>\n<p>为什么说统一的资源加载？因为什么资源都能加载。</p>\n<p>首先，Spring抽象了资源的表示以Resource表示各种资源的形式，根据具体形式又提供了例如ClassPathResource的具体形式。</p>\n<p>其次，ResourceLoader抽象了资源查找定位策略的抽象，其分为大体可以分为两类：</p>\n<ul>\n<li>以DefaultResourceLoader为基础的，一般的ResourceLoader</li>\n<li>以ResourcePatternResolver为基础的，批量查找的ResourceLoader</li>\n</ul>\n<p>容器启动是加载的配置文件所使用的资源路径协议也是在此定义的。</p>\n<p>最后看看Application Context与Resource Loader的关系：Application Context是一个Resource Loader，更一般的情况Application Context还是ResourcePatternResolver</p>\n<h2 id=\"国际化信息支持\"><a href=\"#国际化信息支持\" class=\"headerlink\" title=\"国际化信息支持\"></a>国际化信息支持</h2><p>Spring对国际化得支持不仅是针对还是对整个应用的支持，以MessageSource作为国际化信息的访问接口，封装了相应的信息查询，针对不同的需求做出了不同实现（例如热替换）。</p>\n<p>Application Context同时继承了MessageSource，因此容器获得国际化的支持，对普通Bean可以通过注入MessageSource获得国际化的能力。</p>\n<h2 id=\"容器内部事件发布\"><a href=\"#容器内部事件发布\" class=\"headerlink\" title=\"容器内部事件发布\"></a>容器内部事件发布</h2><p>标准的事件发布功能包含三个角色：自定义事件类型，事件监听接口，事件发布者。Spring对相关角色的定义：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/19/58ce7c99afcc3.png\" alt=\"事件发布.png\"></p>\n<p>Application Context继承ApplicationEventPublisher，将具体的实现委托给ApplicationEventMulticaster接口的实现类来实现。</p>\n<p>具体的ApplicationEvent实现Spring提供了容器生命周期相关的和Web请求相关的事件类型，容器还支持自定义事件类型的发布。</p>\n<h2 id=\"多配置模块加载的简化\"><a href=\"#多配置模块加载的简化\" class=\"headerlink\" title=\"多配置模块加载的简化\"></a>多配置模块加载的简化</h2><p>相较于BeanFactory，Application Context还提供多个配置文件加载的简化</p>\n<h2 id=\"Application-Context\"><a href=\"#Application-Context\" class=\"headerlink\" title=\"Application Context\"></a>Application Context</h2><p>一言以蔽之，Application Context是这样的Bena容器：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/19/58ce7f9a578b6.png\" alt=\"Application Context.png\"></p>\n"},{"title":"Spring之BeanFactory","date":"2017-03-12T17:19:54.000Z","_content":"Spring核心的功能是IoC和AOP，IoC又是AOP的基础。对于IoC，Spring提供了两种容器类型：\n\n- BeanFactory\n- ApplicationContext\n\nApplicationContext可以简单理解为是BeanFactory的升级版。\n\n本文试图讨论与BeanFactory相关的大致过程。\n\n### 调用实现\n\n#### 直接编码\n\nBeanFactory是基础的IoC容器，提供了完成的IoC服务。先看看BeanFactory和Bean之间的关系：\n\n![BeanFactory.png](https://ooo.0o0.ooo/2017/03/12/58c4fc455dda9.png)\n\nBeanFactory，BeanDefinitionRegistry，BeanDefinition都是基本接口。其中：\n\n- BeanFactory定义了基本的查询相关方法；\n- BeanDefinitionRegistry定义了Bean注册管理的相关方法；\n- BeanDefinition定义容器中的一个Bean实例；\n\nDefaultListableBeanFactory实现了Bean注册，查询相关方法，Bean之间的关系则通过Bean实例维护，以上构成了一个最基本的IoC结构。\n\n使用Spring IoC最直接的方式就是依赖上述几个类来加载、维护、查询Bean实例，只是当更先进的方式到来后，直接编码的方式已经离我们很远了。\n\n#### 外部配置\n\n程序员总是希望以更便捷的方式维护配置信息，配置文件是其中一个手段，也是Spring配置最常使用的一种方式。\n\nSpring配置文件最常见的方式是XML形式，其实还有Properties，得益于良好可扩展性，我们甚至可以自定义配置文件及加载方式。\n\nBeanDefinitionReader通过处理外部配置文件，根据不同的配置文件格式，BeanDefinitionReader不同子类将相应的配置文件内容加载并解析映射到BeanDefinition，然后将映射后的BeanDefinition测试到BeanDefinitionRegistry。\n\n加入BeanDefinitionRegistry后的类图：\n\n![BeanFactory.png](https://ooo.0o0.ooo/2017/03/12/58c5115a0c0fa.png)\n\n### 背后的细节\n\nIoC容器功能实现简单可以分类两个阶段：\n\n- 容器启动\n- Bean实例化\n\n#### 容器启动\n\n容器启动主要的过程包括了：\n\n1. 加载配置\n2. 分析配置信息\n3. 装配到BeanDefinition\n4. 其他后续\n\n在整个启动阶段可以通过BeanFactoryPostProcessor，在实例化阶段开始之前，对注册到容器的BeanDefinition保存的原始数据做出修改。\n\nSpring自带了几个BeanFactoryPostProcessor的实现：\n\n- PropertyPlaceholderConfigurer：占位符替换\n- PropertyOverrideConfigurer：替换bean字段\n- CustomEidtorConfigurer：配置解析\n\n#### Bean实例化\n\n对于BeanFactory，当容器启动后只有当客户端调用`getBean()`方法时才会触发实例化阶段活动。\n\n完整的Bean实例化过程如下：\n\n![Bean实例化.png](https://ooo.0o0.ooo/2017/03/12/58c51014ca1e0.png)\n\n几个说明的点：\n\n1. Bean的实例化\n\n   实例化有两种方式实现：\n\n   - 反射\n   - CGLIB（默认）\n\n   实例化完成后，不直接返回生成的实例化对象，使用BeanWrapper对对象进行包裹\n\n2. 设置对象属性\n\n   BeanWrapper使用PropertyEditor对获取的属性值做出相应转换，设置对象属性值\n\n3. 设置Aware依赖\n\n   容器根据Aware接口，对Bean实例设置相应属性\n\n4. BeanPostProcessor\n\n   一般用于筛选bean，对bean实例化过程扩展，AOP更多在此生成代理对象\n\n   ApplicationContext在此阶段设置Aware依赖\n","source":"_posts/Spring之BeanFactory.md","raw":"---\ntitle: Spring之BeanFactory\ndate: 2017-03-13 01:19:54\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\nSpring核心的功能是IoC和AOP，IoC又是AOP的基础。对于IoC，Spring提供了两种容器类型：\n\n- BeanFactory\n- ApplicationContext\n\nApplicationContext可以简单理解为是BeanFactory的升级版。\n\n本文试图讨论与BeanFactory相关的大致过程。\n\n### 调用实现\n\n#### 直接编码\n\nBeanFactory是基础的IoC容器，提供了完成的IoC服务。先看看BeanFactory和Bean之间的关系：\n\n![BeanFactory.png](https://ooo.0o0.ooo/2017/03/12/58c4fc455dda9.png)\n\nBeanFactory，BeanDefinitionRegistry，BeanDefinition都是基本接口。其中：\n\n- BeanFactory定义了基本的查询相关方法；\n- BeanDefinitionRegistry定义了Bean注册管理的相关方法；\n- BeanDefinition定义容器中的一个Bean实例；\n\nDefaultListableBeanFactory实现了Bean注册，查询相关方法，Bean之间的关系则通过Bean实例维护，以上构成了一个最基本的IoC结构。\n\n使用Spring IoC最直接的方式就是依赖上述几个类来加载、维护、查询Bean实例，只是当更先进的方式到来后，直接编码的方式已经离我们很远了。\n\n#### 外部配置\n\n程序员总是希望以更便捷的方式维护配置信息，配置文件是其中一个手段，也是Spring配置最常使用的一种方式。\n\nSpring配置文件最常见的方式是XML形式，其实还有Properties，得益于良好可扩展性，我们甚至可以自定义配置文件及加载方式。\n\nBeanDefinitionReader通过处理外部配置文件，根据不同的配置文件格式，BeanDefinitionReader不同子类将相应的配置文件内容加载并解析映射到BeanDefinition，然后将映射后的BeanDefinition测试到BeanDefinitionRegistry。\n\n加入BeanDefinitionRegistry后的类图：\n\n![BeanFactory.png](https://ooo.0o0.ooo/2017/03/12/58c5115a0c0fa.png)\n\n### 背后的细节\n\nIoC容器功能实现简单可以分类两个阶段：\n\n- 容器启动\n- Bean实例化\n\n#### 容器启动\n\n容器启动主要的过程包括了：\n\n1. 加载配置\n2. 分析配置信息\n3. 装配到BeanDefinition\n4. 其他后续\n\n在整个启动阶段可以通过BeanFactoryPostProcessor，在实例化阶段开始之前，对注册到容器的BeanDefinition保存的原始数据做出修改。\n\nSpring自带了几个BeanFactoryPostProcessor的实现：\n\n- PropertyPlaceholderConfigurer：占位符替换\n- PropertyOverrideConfigurer：替换bean字段\n- CustomEidtorConfigurer：配置解析\n\n#### Bean实例化\n\n对于BeanFactory，当容器启动后只有当客户端调用`getBean()`方法时才会触发实例化阶段活动。\n\n完整的Bean实例化过程如下：\n\n![Bean实例化.png](https://ooo.0o0.ooo/2017/03/12/58c51014ca1e0.png)\n\n几个说明的点：\n\n1. Bean的实例化\n\n   实例化有两种方式实现：\n\n   - 反射\n   - CGLIB（默认）\n\n   实例化完成后，不直接返回生成的实例化对象，使用BeanWrapper对对象进行包裹\n\n2. 设置对象属性\n\n   BeanWrapper使用PropertyEditor对获取的属性值做出相应转换，设置对象属性值\n\n3. 设置Aware依赖\n\n   容器根据Aware接口，对Bean实例设置相应属性\n\n4. BeanPostProcessor\n\n   一般用于筛选bean，对bean实例化过程扩展，AOP更多在此生成代理对象\n\n   ApplicationContext在此阶段设置Aware依赖\n","slug":"Spring之BeanFactory","published":1,"updated":"2017-03-12T17:23:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2pv001fd82ehxsitxog","content":"<p>Spring核心的功能是IoC和AOP，IoC又是AOP的基础。对于IoC，Spring提供了两种容器类型：</p>\n<ul>\n<li>BeanFactory</li>\n<li>ApplicationContext</li>\n</ul>\n<p>ApplicationContext可以简单理解为是BeanFactory的升级版。</p>\n<p>本文试图讨论与BeanFactory相关的大致过程。</p>\n<h3 id=\"调用实现\"><a href=\"#调用实现\" class=\"headerlink\" title=\"调用实现\"></a>调用实现</h3><h4 id=\"直接编码\"><a href=\"#直接编码\" class=\"headerlink\" title=\"直接编码\"></a>直接编码</h4><p>BeanFactory是基础的IoC容器，提供了完成的IoC服务。先看看BeanFactory和Bean之间的关系：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c4fc455dda9.png\" alt=\"BeanFactory.png\"></p>\n<p>BeanFactory，BeanDefinitionRegistry，BeanDefinition都是基本接口。其中：</p>\n<ul>\n<li>BeanFactory定义了基本的查询相关方法；</li>\n<li>BeanDefinitionRegistry定义了Bean注册管理的相关方法；</li>\n<li>BeanDefinition定义容器中的一个Bean实例；</li>\n</ul>\n<p>DefaultListableBeanFactory实现了Bean注册，查询相关方法，Bean之间的关系则通过Bean实例维护，以上构成了一个最基本的IoC结构。</p>\n<p>使用Spring IoC最直接的方式就是依赖上述几个类来加载、维护、查询Bean实例，只是当更先进的方式到来后，直接编码的方式已经离我们很远了。</p>\n<h4 id=\"外部配置\"><a href=\"#外部配置\" class=\"headerlink\" title=\"外部配置\"></a>外部配置</h4><p>程序员总是希望以更便捷的方式维护配置信息，配置文件是其中一个手段，也是Spring配置最常使用的一种方式。</p>\n<p>Spring配置文件最常见的方式是XML形式，其实还有Properties，得益于良好可扩展性，我们甚至可以自定义配置文件及加载方式。</p>\n<p>BeanDefinitionReader通过处理外部配置文件，根据不同的配置文件格式，BeanDefinitionReader不同子类将相应的配置文件内容加载并解析映射到BeanDefinition，然后将映射后的BeanDefinition测试到BeanDefinitionRegistry。</p>\n<p>加入BeanDefinitionRegistry后的类图：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c5115a0c0fa.png\" alt=\"BeanFactory.png\"></p>\n<h3 id=\"背后的细节\"><a href=\"#背后的细节\" class=\"headerlink\" title=\"背后的细节\"></a>背后的细节</h3><p>IoC容器功能实现简单可以分类两个阶段：</p>\n<ul>\n<li>容器启动</li>\n<li>Bean实例化</li>\n</ul>\n<h4 id=\"容器启动\"><a href=\"#容器启动\" class=\"headerlink\" title=\"容器启动\"></a>容器启动</h4><p>容器启动主要的过程包括了：</p>\n<ol>\n<li>加载配置</li>\n<li>分析配置信息</li>\n<li>装配到BeanDefinition</li>\n<li>其他后续</li>\n</ol>\n<p>在整个启动阶段可以通过BeanFactoryPostProcessor，在实例化阶段开始之前，对注册到容器的BeanDefinition保存的原始数据做出修改。</p>\n<p>Spring自带了几个BeanFactoryPostProcessor的实现：</p>\n<ul>\n<li>PropertyPlaceholderConfigurer：占位符替换</li>\n<li>PropertyOverrideConfigurer：替换bean字段</li>\n<li>CustomEidtorConfigurer：配置解析</li>\n</ul>\n<h4 id=\"Bean实例化\"><a href=\"#Bean实例化\" class=\"headerlink\" title=\"Bean实例化\"></a>Bean实例化</h4><p>对于BeanFactory，当容器启动后只有当客户端调用<code>getBean()</code>方法时才会触发实例化阶段活动。</p>\n<p>完整的Bean实例化过程如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c51014ca1e0.png\" alt=\"Bean实例化.png\"></p>\n<p>几个说明的点：</p>\n<ol>\n<li><p>Bean的实例化</p>\n<p>实例化有两种方式实现：</p>\n<ul>\n<li>反射</li>\n<li>CGLIB（默认）</li>\n</ul>\n<p>实例化完成后，不直接返回生成的实例化对象，使用BeanWrapper对对象进行包裹</p>\n</li>\n<li><p>设置对象属性</p>\n<p>BeanWrapper使用PropertyEditor对获取的属性值做出相应转换，设置对象属性值</p>\n</li>\n<li><p>设置Aware依赖</p>\n<p>容器根据Aware接口，对Bean实例设置相应属性</p>\n</li>\n<li><p>BeanPostProcessor</p>\n<p>一般用于筛选bean，对bean实例化过程扩展，AOP更多在此生成代理对象</p>\n<p>ApplicationContext在此阶段设置Aware依赖</p>\n</li>\n</ol>\n","excerpt":"","more":"<p>Spring核心的功能是IoC和AOP，IoC又是AOP的基础。对于IoC，Spring提供了两种容器类型：</p>\n<ul>\n<li>BeanFactory</li>\n<li>ApplicationContext</li>\n</ul>\n<p>ApplicationContext可以简单理解为是BeanFactory的升级版。</p>\n<p>本文试图讨论与BeanFactory相关的大致过程。</p>\n<h3 id=\"调用实现\"><a href=\"#调用实现\" class=\"headerlink\" title=\"调用实现\"></a>调用实现</h3><h4 id=\"直接编码\"><a href=\"#直接编码\" class=\"headerlink\" title=\"直接编码\"></a>直接编码</h4><p>BeanFactory是基础的IoC容器，提供了完成的IoC服务。先看看BeanFactory和Bean之间的关系：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c4fc455dda9.png\" alt=\"BeanFactory.png\"></p>\n<p>BeanFactory，BeanDefinitionRegistry，BeanDefinition都是基本接口。其中：</p>\n<ul>\n<li>BeanFactory定义了基本的查询相关方法；</li>\n<li>BeanDefinitionRegistry定义了Bean注册管理的相关方法；</li>\n<li>BeanDefinition定义容器中的一个Bean实例；</li>\n</ul>\n<p>DefaultListableBeanFactory实现了Bean注册，查询相关方法，Bean之间的关系则通过Bean实例维护，以上构成了一个最基本的IoC结构。</p>\n<p>使用Spring IoC最直接的方式就是依赖上述几个类来加载、维护、查询Bean实例，只是当更先进的方式到来后，直接编码的方式已经离我们很远了。</p>\n<h4 id=\"外部配置\"><a href=\"#外部配置\" class=\"headerlink\" title=\"外部配置\"></a>外部配置</h4><p>程序员总是希望以更便捷的方式维护配置信息，配置文件是其中一个手段，也是Spring配置最常使用的一种方式。</p>\n<p>Spring配置文件最常见的方式是XML形式，其实还有Properties，得益于良好可扩展性，我们甚至可以自定义配置文件及加载方式。</p>\n<p>BeanDefinitionReader通过处理外部配置文件，根据不同的配置文件格式，BeanDefinitionReader不同子类将相应的配置文件内容加载并解析映射到BeanDefinition，然后将映射后的BeanDefinition测试到BeanDefinitionRegistry。</p>\n<p>加入BeanDefinitionRegistry后的类图：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c5115a0c0fa.png\" alt=\"BeanFactory.png\"></p>\n<h3 id=\"背后的细节\"><a href=\"#背后的细节\" class=\"headerlink\" title=\"背后的细节\"></a>背后的细节</h3><p>IoC容器功能实现简单可以分类两个阶段：</p>\n<ul>\n<li>容器启动</li>\n<li>Bean实例化</li>\n</ul>\n<h4 id=\"容器启动\"><a href=\"#容器启动\" class=\"headerlink\" title=\"容器启动\"></a>容器启动</h4><p>容器启动主要的过程包括了：</p>\n<ol>\n<li>加载配置</li>\n<li>分析配置信息</li>\n<li>装配到BeanDefinition</li>\n<li>其他后续</li>\n</ol>\n<p>在整个启动阶段可以通过BeanFactoryPostProcessor，在实例化阶段开始之前，对注册到容器的BeanDefinition保存的原始数据做出修改。</p>\n<p>Spring自带了几个BeanFactoryPostProcessor的实现：</p>\n<ul>\n<li>PropertyPlaceholderConfigurer：占位符替换</li>\n<li>PropertyOverrideConfigurer：替换bean字段</li>\n<li>CustomEidtorConfigurer：配置解析</li>\n</ul>\n<h4 id=\"Bean实例化\"><a href=\"#Bean实例化\" class=\"headerlink\" title=\"Bean实例化\"></a>Bean实例化</h4><p>对于BeanFactory，当容器启动后只有当客户端调用<code>getBean()</code>方法时才会触发实例化阶段活动。</p>\n<p>完整的Bean实例化过程如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/12/58c51014ca1e0.png\" alt=\"Bean实例化.png\"></p>\n<p>几个说明的点：</p>\n<ol>\n<li><p>Bean的实例化</p>\n<p>实例化有两种方式实现：</p>\n<ul>\n<li>反射</li>\n<li>CGLIB（默认）</li>\n</ul>\n<p>实例化完成后，不直接返回生成的实例化对象，使用BeanWrapper对对象进行包裹</p>\n</li>\n<li><p>设置对象属性</p>\n<p>BeanWrapper使用PropertyEditor对获取的属性值做出相应转换，设置对象属性值</p>\n</li>\n<li><p>设置Aware依赖</p>\n<p>容器根据Aware接口，对Bean实例设置相应属性</p>\n</li>\n<li><p>BeanPostProcessor</p>\n<p>一般用于筛选bean，对bean实例化过程扩展，AOP更多在此生成代理对象</p>\n<p>ApplicationContext在此阶段设置Aware依赖</p>\n</li>\n</ol>\n"},{"title":"Spring之AOP【二】","date":"2017-03-24T18:42:16.000Z","_content":"\n## @AspectJ形式的Pointcut\n\n### Pointcut的组成：\n\n- Pointcut Expression\n  - 以@Pointcut为载体\n  - 由两部分组成：Pointcut标识符，表达式匹配模式\n- Pointcut Signature\n  - Pointcut Expression的载体\n\n#### Pointcut标识符\n\n**execution**\n\n日常使用最多的标识符，使用execution标识符的Pointcut表达式格式：\n\n```\nexecution (modifiers-pattern? ret-type-pattern declaring-type-pattern? \n\t\t\tname-pattern(param-pattern) throws-pattern?)\n```\n\n- 方法返回类型、方法名以及参数必须制定，其他可以省略\n- 可选通配符：`*` 和` ..`\n  - `*`：匹配一个单词\n  - `..`：只能在declaring-type-pattern和param-pattern位置使用\n    - 用于declaring-type-pattern可以指定多个层次\n    - 用于param-pattern表示可以有0到多个参数，可以与`*`和具体类型组合\n\n**within**\n\n指定类型，类型下所有方法。可以使用`*`和`..`扩展，like：`within(tk.zhangh.spring..*)`\n\n**this和target**\n\n- this：目标对象的代理对象\n- target：目标对象\n\nSpring中使用this和target实际作用类似\n\n**args**\n\n指定参数类型，指定参数数量\n\n与execution标识符不同，args标识符会在运行期间动态检查参数类型\n\n**@within**\n\n指定类型，类型下的所有方法，要求类型标记了指定注解，like：\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD, ElementType.TYPE})\npublic @Log AnyJoinpontAnnotation{}\n\n@Log\npublic class Bean {\n  public void method();\n}\n\n@with(Log)\n```\n\n**@target**\n\n指定标记了给定注解类型的目标对象的所有方法\n\n**@args**\n\n指定参数类型，要求参数参数类型标记了指定注解\n\n**@annotation**\n\n指定标记了指定注解的方法，@Transctional的实现方式\n\n### Pointcut表达式的解析\n\n所有@AspectJ形式声明的这些Pointcut表达式最终都会转化成Pointcut的具体实现。\n\nAspectJExpressionPointcut如同他的名字面向AspectJ的pointcut实现，整个继承体系：\n\n![Pointcut.png](https://ooo.0o0.ooo/2017/03/23/58d3d30a2cc93.png)\n\n## @AspectJ形式的Advice\n\n使用@Aspect注解标记的类中，具体的Advice形式由具体的Advice注解标示。\n\n注解的方法中需要访问上下文信息最主要的方式：将方法的第一个参数声明为JoinPoint类型\n\n- @Before\n\n- @AfterReturning\n\n- @AfterThrowing\n\n  - 获取异常：在JoinPoint类型参数后面加上RuntimeException类型参数\n\n- @After\n\n- @Around\n\n  - 获取上下文信息不同以上，需要方法第一个参数声明为ProcessingJoinPoint类型\n\n- @DeclareParents\n\n  - 最特殊，使用如下：\n\n  ```java\n  @Aspect\n  public class IntroductionAspect {\n    @DeclareParents(value=\"....NewImpl\", defaultImpl=Target.class)\n    public INew new;\n  }\n  ```\n\n## 其他\n\n### Advice执行顺序\n\n- 同一个Aspect中最先声明的Advice拥有最高优先级，优先入栈\n- 不同Aspect的Advice需要实现Order接口声明优先级\n\n### 同一对象内的嵌套方法调用拦截失效\n\n以事务为例，事务管理也是使用AOP，具体是@annotation形式的Pointcut声明（这样我就不用声明Advice了）\n\n```java\npublic class ServiceImpl implents Service {\n  public void methodA() {\n    doSomething();\n    methodB();\n  }\n  \n  @Transactional\n  public void methodB() {\n    // ...\n  }\n}\n```\n\n当在aFun内调用bFun时事务没有开启，也就是AOP没有生效，原因：\n\n![AOP嵌套调用.png](https://ooo.0o0.ooo/2017/03/24/58d5043b70bbc.png)\n\n我们期望虚线的调用方式，实际上调用时红色的路线，添加在代理对象上的AOP逻辑在嵌套调用时根本没有机会触发。在事务处理时尤其要注意避免这样的嵌套调用问题。\n\n解决：\n\n- 使用AopContext.currentProxy()获取代理对象\n- 从ApplicationContext中获取代理对象\n\n不管是那种方式都要注入相关Bean，具体那种更优雅由你来决定了。\n","source":"_posts/Spring之AOP【二】.md","raw":"---\ntitle: Spring之AOP【二】\ndate: 2017-03-25 02:42:16\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n\n## @AspectJ形式的Pointcut\n\n### Pointcut的组成：\n\n- Pointcut Expression\n  - 以@Pointcut为载体\n  - 由两部分组成：Pointcut标识符，表达式匹配模式\n- Pointcut Signature\n  - Pointcut Expression的载体\n\n#### Pointcut标识符\n\n**execution**\n\n日常使用最多的标识符，使用execution标识符的Pointcut表达式格式：\n\n```\nexecution (modifiers-pattern? ret-type-pattern declaring-type-pattern? \n\t\t\tname-pattern(param-pattern) throws-pattern?)\n```\n\n- 方法返回类型、方法名以及参数必须制定，其他可以省略\n- 可选通配符：`*` 和` ..`\n  - `*`：匹配一个单词\n  - `..`：只能在declaring-type-pattern和param-pattern位置使用\n    - 用于declaring-type-pattern可以指定多个层次\n    - 用于param-pattern表示可以有0到多个参数，可以与`*`和具体类型组合\n\n**within**\n\n指定类型，类型下所有方法。可以使用`*`和`..`扩展，like：`within(tk.zhangh.spring..*)`\n\n**this和target**\n\n- this：目标对象的代理对象\n- target：目标对象\n\nSpring中使用this和target实际作用类似\n\n**args**\n\n指定参数类型，指定参数数量\n\n与execution标识符不同，args标识符会在运行期间动态检查参数类型\n\n**@within**\n\n指定类型，类型下的所有方法，要求类型标记了指定注解，like：\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD, ElementType.TYPE})\npublic @Log AnyJoinpontAnnotation{}\n\n@Log\npublic class Bean {\n  public void method();\n}\n\n@with(Log)\n```\n\n**@target**\n\n指定标记了给定注解类型的目标对象的所有方法\n\n**@args**\n\n指定参数类型，要求参数参数类型标记了指定注解\n\n**@annotation**\n\n指定标记了指定注解的方法，@Transctional的实现方式\n\n### Pointcut表达式的解析\n\n所有@AspectJ形式声明的这些Pointcut表达式最终都会转化成Pointcut的具体实现。\n\nAspectJExpressionPointcut如同他的名字面向AspectJ的pointcut实现，整个继承体系：\n\n![Pointcut.png](https://ooo.0o0.ooo/2017/03/23/58d3d30a2cc93.png)\n\n## @AspectJ形式的Advice\n\n使用@Aspect注解标记的类中，具体的Advice形式由具体的Advice注解标示。\n\n注解的方法中需要访问上下文信息最主要的方式：将方法的第一个参数声明为JoinPoint类型\n\n- @Before\n\n- @AfterReturning\n\n- @AfterThrowing\n\n  - 获取异常：在JoinPoint类型参数后面加上RuntimeException类型参数\n\n- @After\n\n- @Around\n\n  - 获取上下文信息不同以上，需要方法第一个参数声明为ProcessingJoinPoint类型\n\n- @DeclareParents\n\n  - 最特殊，使用如下：\n\n  ```java\n  @Aspect\n  public class IntroductionAspect {\n    @DeclareParents(value=\"....NewImpl\", defaultImpl=Target.class)\n    public INew new;\n  }\n  ```\n\n## 其他\n\n### Advice执行顺序\n\n- 同一个Aspect中最先声明的Advice拥有最高优先级，优先入栈\n- 不同Aspect的Advice需要实现Order接口声明优先级\n\n### 同一对象内的嵌套方法调用拦截失效\n\n以事务为例，事务管理也是使用AOP，具体是@annotation形式的Pointcut声明（这样我就不用声明Advice了）\n\n```java\npublic class ServiceImpl implents Service {\n  public void methodA() {\n    doSomething();\n    methodB();\n  }\n  \n  @Transactional\n  public void methodB() {\n    // ...\n  }\n}\n```\n\n当在aFun内调用bFun时事务没有开启，也就是AOP没有生效，原因：\n\n![AOP嵌套调用.png](https://ooo.0o0.ooo/2017/03/24/58d5043b70bbc.png)\n\n我们期望虚线的调用方式，实际上调用时红色的路线，添加在代理对象上的AOP逻辑在嵌套调用时根本没有机会触发。在事务处理时尤其要注意避免这样的嵌套调用问题。\n\n解决：\n\n- 使用AopContext.currentProxy()获取代理对象\n- 从ApplicationContext中获取代理对象\n\n不管是那种方式都要注入相关Bean，具体那种更优雅由你来决定了。\n","slug":"Spring之AOP【二】","published":1,"updated":"2017-03-24T18:45:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2px001jd82epd1hlul8","content":"<h2 id=\"AspectJ形式的Pointcut\"><a href=\"#AspectJ形式的Pointcut\" class=\"headerlink\" title=\"@AspectJ形式的Pointcut\"></a>@AspectJ形式的Pointcut</h2><h3 id=\"Pointcut的组成：\"><a href=\"#Pointcut的组成：\" class=\"headerlink\" title=\"Pointcut的组成：\"></a>Pointcut的组成：</h3><ul>\n<li>Pointcut Expression<ul>\n<li>以@Pointcut为载体</li>\n<li>由两部分组成：Pointcut标识符，表达式匹配模式</li>\n</ul>\n</li>\n<li>Pointcut Signature<ul>\n<li>Pointcut Expression的载体</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Pointcut标识符\"><a href=\"#Pointcut标识符\" class=\"headerlink\" title=\"Pointcut标识符\"></a>Pointcut标识符</h4><p><strong>execution</strong></p>\n<p>日常使用最多的标识符，使用execution标识符的Pointcut表达式格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">execution (modifiers-pattern? ret-type-pattern declaring-type-pattern? </div><div class=\"line\">\t\t\tname-pattern(param-pattern) throws-pattern?)</div></pre></td></tr></table></figure>\n<ul>\n<li>方法返回类型、方法名以及参数必须制定，其他可以省略</li>\n<li>可选通配符：<code>*</code> 和<code>..</code><ul>\n<li><code>*</code>：匹配一个单词</li>\n<li><code>..</code>：只能在declaring-type-pattern和param-pattern位置使用<ul>\n<li>用于declaring-type-pattern可以指定多个层次</li>\n<li>用于param-pattern表示可以有0到多个参数，可以与<code>*</code>和具体类型组合</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>within</strong></p>\n<p>指定类型，类型下所有方法。可以使用<code>*</code>和<code>..</code>扩展，like：<code>within(tk.zhangh.spring..*)</code></p>\n<p><strong>this和target</strong></p>\n<ul>\n<li>this：目标对象的代理对象</li>\n<li>target：目标对象</li>\n</ul>\n<p>Spring中使用this和target实际作用类似</p>\n<p><strong>args</strong></p>\n<p>指定参数类型，指定参数数量</p>\n<p>与execution标识符不同，args标识符会在运行期间动态检查参数类型</p>\n<p><strong>@within</strong></p>\n<p>指定类型，类型下的所有方法，要求类型标记了指定注解，like：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@Log</span> AnyJoinpontAnnotation&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Log</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@with</span>(Log)</div></pre></td></tr></table></figure>\n<p><strong>@target</strong></p>\n<p>指定标记了给定注解类型的目标对象的所有方法</p>\n<p><strong>@args</strong></p>\n<p>指定参数类型，要求参数参数类型标记了指定注解</p>\n<p><strong>@annotation</strong></p>\n<p>指定标记了指定注解的方法，@Transctional的实现方式</p>\n<h3 id=\"Pointcut表达式的解析\"><a href=\"#Pointcut表达式的解析\" class=\"headerlink\" title=\"Pointcut表达式的解析\"></a>Pointcut表达式的解析</h3><p>所有@AspectJ形式声明的这些Pointcut表达式最终都会转化成Pointcut的具体实现。</p>\n<p>AspectJExpressionPointcut如同他的名字面向AspectJ的pointcut实现，整个继承体系：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/23/58d3d30a2cc93.png\" alt=\"Pointcut.png\"></p>\n<h2 id=\"AspectJ形式的Advice\"><a href=\"#AspectJ形式的Advice\" class=\"headerlink\" title=\"@AspectJ形式的Advice\"></a>@AspectJ形式的Advice</h2><p>使用@Aspect注解标记的类中，具体的Advice形式由具体的Advice注解标示。</p>\n<p>注解的方法中需要访问上下文信息最主要的方式：将方法的第一个参数声明为JoinPoint类型</p>\n<ul>\n<li><p>@Before</p>\n</li>\n<li><p>@AfterReturning</p>\n</li>\n<li><p>@AfterThrowing</p>\n<ul>\n<li>获取异常：在JoinPoint类型参数后面加上RuntimeException类型参数</li>\n</ul>\n</li>\n<li><p>@After</p>\n</li>\n<li><p>@Around</p>\n<ul>\n<li>获取上下文信息不同以上，需要方法第一个参数声明为ProcessingJoinPoint类型</li>\n</ul>\n</li>\n<li><p>@DeclareParents</p>\n<ul>\n<li>最特殊，使用如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Aspect</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntroductionAspect</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@DeclareParents</span>(value=<span class=\"string\">\"....NewImpl\"</span>, defaultImpl=Target.class)</div><div class=\"line\">  <span class=\"keyword\">public</span> INew <span class=\"keyword\">new</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"Advice执行顺序\"><a href=\"#Advice执行顺序\" class=\"headerlink\" title=\"Advice执行顺序\"></a>Advice执行顺序</h3><ul>\n<li>同一个Aspect中最先声明的Advice拥有最高优先级，优先入栈</li>\n<li>不同Aspect的Advice需要实现Order接口声明优先级</li>\n</ul>\n<h3 id=\"同一对象内的嵌套方法调用拦截失效\"><a href=\"#同一对象内的嵌套方法调用拦截失效\" class=\"headerlink\" title=\"同一对象内的嵌套方法调用拦截失效\"></a>同一对象内的嵌套方法调用拦截失效</h3><p>以事务为例，事务管理也是使用AOP，具体是@annotation形式的Pointcut声明（这样我就不用声明Advice了）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceImpl</span> <span class=\"title\">implents</span> <span class=\"title\">Service</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    doSomething();</div><div class=\"line\">    methodB();</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Transactional</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当在aFun内调用bFun时事务没有开启，也就是AOP没有生效，原因：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/24/58d5043b70bbc.png\" alt=\"AOP嵌套调用.png\"></p>\n<p>我们期望虚线的调用方式，实际上调用时红色的路线，添加在代理对象上的AOP逻辑在嵌套调用时根本没有机会触发。在事务处理时尤其要注意避免这样的嵌套调用问题。</p>\n<p>解决：</p>\n<ul>\n<li>使用AopContext.currentProxy()获取代理对象</li>\n<li>从ApplicationContext中获取代理对象</li>\n</ul>\n<p>不管是那种方式都要注入相关Bean，具体那种更优雅由你来决定了。</p>\n","excerpt":"","more":"<h2 id=\"AspectJ形式的Pointcut\"><a href=\"#AspectJ形式的Pointcut\" class=\"headerlink\" title=\"@AspectJ形式的Pointcut\"></a>@AspectJ形式的Pointcut</h2><h3 id=\"Pointcut的组成：\"><a href=\"#Pointcut的组成：\" class=\"headerlink\" title=\"Pointcut的组成：\"></a>Pointcut的组成：</h3><ul>\n<li>Pointcut Expression<ul>\n<li>以@Pointcut为载体</li>\n<li>由两部分组成：Pointcut标识符，表达式匹配模式</li>\n</ul>\n</li>\n<li>Pointcut Signature<ul>\n<li>Pointcut Expression的载体</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Pointcut标识符\"><a href=\"#Pointcut标识符\" class=\"headerlink\" title=\"Pointcut标识符\"></a>Pointcut标识符</h4><p><strong>execution</strong></p>\n<p>日常使用最多的标识符，使用execution标识符的Pointcut表达式格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">execution (modifiers-pattern? ret-type-pattern declaring-type-pattern? </div><div class=\"line\">\t\t\tname-pattern(param-pattern) throws-pattern?)</div></pre></td></tr></table></figure>\n<ul>\n<li>方法返回类型、方法名以及参数必须制定，其他可以省略</li>\n<li>可选通配符：<code>*</code> 和<code>..</code><ul>\n<li><code>*</code>：匹配一个单词</li>\n<li><code>..</code>：只能在declaring-type-pattern和param-pattern位置使用<ul>\n<li>用于declaring-type-pattern可以指定多个层次</li>\n<li>用于param-pattern表示可以有0到多个参数，可以与<code>*</code>和具体类型组合</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>within</strong></p>\n<p>指定类型，类型下所有方法。可以使用<code>*</code>和<code>..</code>扩展，like：<code>within(tk.zhangh.spring..*)</code></p>\n<p><strong>this和target</strong></p>\n<ul>\n<li>this：目标对象的代理对象</li>\n<li>target：目标对象</li>\n</ul>\n<p>Spring中使用this和target实际作用类似</p>\n<p><strong>args</strong></p>\n<p>指定参数类型，指定参数数量</p>\n<p>与execution标识符不同，args标识符会在运行期间动态检查参数类型</p>\n<p><strong>@within</strong></p>\n<p>指定类型，类型下的所有方法，要求类型标记了指定注解，like：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@Log</span> AnyJoinpontAnnotation&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Log</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@with</span>(Log)</div></pre></td></tr></table></figure>\n<p><strong>@target</strong></p>\n<p>指定标记了给定注解类型的目标对象的所有方法</p>\n<p><strong>@args</strong></p>\n<p>指定参数类型，要求参数参数类型标记了指定注解</p>\n<p><strong>@annotation</strong></p>\n<p>指定标记了指定注解的方法，@Transctional的实现方式</p>\n<h3 id=\"Pointcut表达式的解析\"><a href=\"#Pointcut表达式的解析\" class=\"headerlink\" title=\"Pointcut表达式的解析\"></a>Pointcut表达式的解析</h3><p>所有@AspectJ形式声明的这些Pointcut表达式最终都会转化成Pointcut的具体实现。</p>\n<p>AspectJExpressionPointcut如同他的名字面向AspectJ的pointcut实现，整个继承体系：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/23/58d3d30a2cc93.png\" alt=\"Pointcut.png\"></p>\n<h2 id=\"AspectJ形式的Advice\"><a href=\"#AspectJ形式的Advice\" class=\"headerlink\" title=\"@AspectJ形式的Advice\"></a>@AspectJ形式的Advice</h2><p>使用@Aspect注解标记的类中，具体的Advice形式由具体的Advice注解标示。</p>\n<p>注解的方法中需要访问上下文信息最主要的方式：将方法的第一个参数声明为JoinPoint类型</p>\n<ul>\n<li><p>@Before</p>\n</li>\n<li><p>@AfterReturning</p>\n</li>\n<li><p>@AfterThrowing</p>\n<ul>\n<li>获取异常：在JoinPoint类型参数后面加上RuntimeException类型参数</li>\n</ul>\n</li>\n<li><p>@After</p>\n</li>\n<li><p>@Around</p>\n<ul>\n<li>获取上下文信息不同以上，需要方法第一个参数声明为ProcessingJoinPoint类型</li>\n</ul>\n</li>\n<li><p>@DeclareParents</p>\n<ul>\n<li>最特殊，使用如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Aspect</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntroductionAspect</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@DeclareParents</span>(value=<span class=\"string\">\"....NewImpl\"</span>, defaultImpl=Target.class)</div><div class=\"line\">  <span class=\"keyword\">public</span> INew <span class=\"keyword\">new</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"Advice执行顺序\"><a href=\"#Advice执行顺序\" class=\"headerlink\" title=\"Advice执行顺序\"></a>Advice执行顺序</h3><ul>\n<li>同一个Aspect中最先声明的Advice拥有最高优先级，优先入栈</li>\n<li>不同Aspect的Advice需要实现Order接口声明优先级</li>\n</ul>\n<h3 id=\"同一对象内的嵌套方法调用拦截失效\"><a href=\"#同一对象内的嵌套方法调用拦截失效\" class=\"headerlink\" title=\"同一对象内的嵌套方法调用拦截失效\"></a>同一对象内的嵌套方法调用拦截失效</h3><p>以事务为例，事务管理也是使用AOP，具体是@annotation形式的Pointcut声明（这样我就不用声明Advice了）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceImpl</span> <span class=\"title\">implents</span> <span class=\"title\">Service</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    doSomething();</div><div class=\"line\">    methodB();</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Transactional</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当在aFun内调用bFun时事务没有开启，也就是AOP没有生效，原因：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/24/58d5043b70bbc.png\" alt=\"AOP嵌套调用.png\"></p>\n<p>我们期望虚线的调用方式，实际上调用时红色的路线，添加在代理对象上的AOP逻辑在嵌套调用时根本没有机会触发。在事务处理时尤其要注意避免这样的嵌套调用问题。</p>\n<p>解决：</p>\n<ul>\n<li>使用AopContext.currentProxy()获取代理对象</li>\n<li>从ApplicationContext中获取代理对象</li>\n</ul>\n<p>不管是那种方式都要注入相关Bean，具体那种更优雅由你来决定了。</p>\n"},{"title":"Spring之数据访问","date":"2017-04-16T08:19:33.000Z","_content":"\n提起JDBC的使用大家一般集中喷两个地方：\n\n1. JDBC的异常处理\n2. JDBC数据处理的冗长代码\n\n看看Spring中对这两个问题是怎么举得的吧：\n\n## 统一的数据访问异常层次体系\n\n针对数据访问异常JDBC定义了4个异常，可以说是高度的抽象了，但换句话说就是没什么卵用。\n\n尤其是SQLException，这个异常是个checked exception。如果直接抛出会污染上层接口；如果在数据访问层内处理，这个异常却包含了多种问题，例如：\n\n- 无法连接数据库\n- SQL语法错误\n- SQL违反数据库约束\n\n即使拿到SQLException我们并不能马上准确的获取具体异常问题。\n\nSpring解决的也是简单直接：\n\n- 所有的数据访问异常都定义为了unchecked exception。你嫌弃它要抛出，那就都不要抛出了\n- 转译SQLException。你说它不知道怎么处理，那就提供更细粒度的异常\n\n## 数据访问模板——JdbcTemplate\n\n提到数据访问模板我想起了在学习JDBC操作时，当时写过一个标准的JDBC增删查该的模板，整个过程涉及到的内容还是不那么简单的。\n\nSpring在这里直接提供了JdbcTemplate作为数据访问的基础，这个类主要解决了两件事：\n\n1. 使用模板模式封装基于JDBC的数据访问\n2. 对数据访问异常转译，将JDBC异常转化为Spring自定义数据访问异常\n\n针对Jdbc的操作和Jdbc的访问Spring分类提供了两个抽象接口由JdbcTemplate继承：\n\n![JdbcTemplate.png](https://ooo.0o0.ooo/2017/04/16/58f3143a23751.png)\n\nJdbcAccessor：JdbcTemplate的直接父类，主要两个属性：\n\n- DataSource：作为Jdbc的连接工厂\n- SQLExceptionTranslator：处理SQLException的转译\n\nJdbcOperations：定义JDBC操作集合的抽象接口。\n\n针对不同类型的操作，Spring提供不同的回调接口而不是简单的抽象模板\n\n除此，JdbcTemplate内部实现细节还有值得注意的地方：\n\n**connection**\n\nconnection有两点需要注意：\n\n1. connection获取是使用DataSourceUtils获取的。而不是简单的从dataSource中获取的。\n\n   DataSourceUtils会将connection绑定到当前线程，以便事务管理使用\n\n2. 具体的connection由NativeJdbcExtractor获取\n\n**查询控制**\n\n具体的查询语句执行前会先调用applyStatementSettings方法以控制具体的查询行为。\n\n**异常转译**\n\nSQLExceptionTranslator作为异常转译的接口，其具体可以针对message，errorCode，自定义信息转译SQLException。\n\n**JdbcTemplate的增强**\n\n除了基本的JdbcTemplate之外，Spring还提供了NamedParameterJdbcTemplate等操作以增强JdbcTemplate的基本功能。\n\n**DataSource**\n\nSpring提供了多个DataSource实现，也可以使用第三方的，自定义DataSource既可以继承AbstractDataSource或者实现DelegatingDataSource。\n\n这里额外提及TransactionAwareDateSourceProxy，从其获取的Connection可以自动加入Spring的统一事务管理。\n","source":"_posts/Spring之数据访问.md","raw":"---\ntitle: Spring之数据访问\ndate: 2017-04-16 16:19:33\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n\n提起JDBC的使用大家一般集中喷两个地方：\n\n1. JDBC的异常处理\n2. JDBC数据处理的冗长代码\n\n看看Spring中对这两个问题是怎么举得的吧：\n\n## 统一的数据访问异常层次体系\n\n针对数据访问异常JDBC定义了4个异常，可以说是高度的抽象了，但换句话说就是没什么卵用。\n\n尤其是SQLException，这个异常是个checked exception。如果直接抛出会污染上层接口；如果在数据访问层内处理，这个异常却包含了多种问题，例如：\n\n- 无法连接数据库\n- SQL语法错误\n- SQL违反数据库约束\n\n即使拿到SQLException我们并不能马上准确的获取具体异常问题。\n\nSpring解决的也是简单直接：\n\n- 所有的数据访问异常都定义为了unchecked exception。你嫌弃它要抛出，那就都不要抛出了\n- 转译SQLException。你说它不知道怎么处理，那就提供更细粒度的异常\n\n## 数据访问模板——JdbcTemplate\n\n提到数据访问模板我想起了在学习JDBC操作时，当时写过一个标准的JDBC增删查该的模板，整个过程涉及到的内容还是不那么简单的。\n\nSpring在这里直接提供了JdbcTemplate作为数据访问的基础，这个类主要解决了两件事：\n\n1. 使用模板模式封装基于JDBC的数据访问\n2. 对数据访问异常转译，将JDBC异常转化为Spring自定义数据访问异常\n\n针对Jdbc的操作和Jdbc的访问Spring分类提供了两个抽象接口由JdbcTemplate继承：\n\n![JdbcTemplate.png](https://ooo.0o0.ooo/2017/04/16/58f3143a23751.png)\n\nJdbcAccessor：JdbcTemplate的直接父类，主要两个属性：\n\n- DataSource：作为Jdbc的连接工厂\n- SQLExceptionTranslator：处理SQLException的转译\n\nJdbcOperations：定义JDBC操作集合的抽象接口。\n\n针对不同类型的操作，Spring提供不同的回调接口而不是简单的抽象模板\n\n除此，JdbcTemplate内部实现细节还有值得注意的地方：\n\n**connection**\n\nconnection有两点需要注意：\n\n1. connection获取是使用DataSourceUtils获取的。而不是简单的从dataSource中获取的。\n\n   DataSourceUtils会将connection绑定到当前线程，以便事务管理使用\n\n2. 具体的connection由NativeJdbcExtractor获取\n\n**查询控制**\n\n具体的查询语句执行前会先调用applyStatementSettings方法以控制具体的查询行为。\n\n**异常转译**\n\nSQLExceptionTranslator作为异常转译的接口，其具体可以针对message，errorCode，自定义信息转译SQLException。\n\n**JdbcTemplate的增强**\n\n除了基本的JdbcTemplate之外，Spring还提供了NamedParameterJdbcTemplate等操作以增强JdbcTemplate的基本功能。\n\n**DataSource**\n\nSpring提供了多个DataSource实现，也可以使用第三方的，自定义DataSource既可以继承AbstractDataSource或者实现DelegatingDataSource。\n\n这里额外提及TransactionAwareDateSourceProxy，从其获取的Connection可以自动加入Spring的统一事务管理。\n","slug":"Spring之数据访问","published":1,"updated":"2017-04-16T08:29:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2pz001nd82ef6cqi5lp","content":"<p>提起JDBC的使用大家一般集中喷两个地方：</p>\n<ol>\n<li>JDBC的异常处理</li>\n<li>JDBC数据处理的冗长代码</li>\n</ol>\n<p>看看Spring中对这两个问题是怎么举得的吧：</p>\n<h2 id=\"统一的数据访问异常层次体系\"><a href=\"#统一的数据访问异常层次体系\" class=\"headerlink\" title=\"统一的数据访问异常层次体系\"></a>统一的数据访问异常层次体系</h2><p>针对数据访问异常JDBC定义了4个异常，可以说是高度的抽象了，但换句话说就是没什么卵用。</p>\n<p>尤其是SQLException，这个异常是个checked exception。如果直接抛出会污染上层接口；如果在数据访问层内处理，这个异常却包含了多种问题，例如：</p>\n<ul>\n<li>无法连接数据库</li>\n<li>SQL语法错误</li>\n<li>SQL违反数据库约束</li>\n</ul>\n<p>即使拿到SQLException我们并不能马上准确的获取具体异常问题。</p>\n<p>Spring解决的也是简单直接：</p>\n<ul>\n<li>所有的数据访问异常都定义为了unchecked exception。你嫌弃它要抛出，那就都不要抛出了</li>\n<li>转译SQLException。你说它不知道怎么处理，那就提供更细粒度的异常</li>\n</ul>\n<h2 id=\"数据访问模板——JdbcTemplate\"><a href=\"#数据访问模板——JdbcTemplate\" class=\"headerlink\" title=\"数据访问模板——JdbcTemplate\"></a>数据访问模板——JdbcTemplate</h2><p>提到数据访问模板我想起了在学习JDBC操作时，当时写过一个标准的JDBC增删查该的模板，整个过程涉及到的内容还是不那么简单的。</p>\n<p>Spring在这里直接提供了JdbcTemplate作为数据访问的基础，这个类主要解决了两件事：</p>\n<ol>\n<li>使用模板模式封装基于JDBC的数据访问</li>\n<li>对数据访问异常转译，将JDBC异常转化为Spring自定义数据访问异常</li>\n</ol>\n<p>针对Jdbc的操作和Jdbc的访问Spring分类提供了两个抽象接口由JdbcTemplate继承：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/16/58f3143a23751.png\" alt=\"JdbcTemplate.png\"></p>\n<p>JdbcAccessor：JdbcTemplate的直接父类，主要两个属性：</p>\n<ul>\n<li>DataSource：作为Jdbc的连接工厂</li>\n<li>SQLExceptionTranslator：处理SQLException的转译</li>\n</ul>\n<p>JdbcOperations：定义JDBC操作集合的抽象接口。</p>\n<p>针对不同类型的操作，Spring提供不同的回调接口而不是简单的抽象模板</p>\n<p>除此，JdbcTemplate内部实现细节还有值得注意的地方：</p>\n<p><strong>connection</strong></p>\n<p>connection有两点需要注意：</p>\n<ol>\n<li><p>connection获取是使用DataSourceUtils获取的。而不是简单的从dataSource中获取的。</p>\n<p>DataSourceUtils会将connection绑定到当前线程，以便事务管理使用</p>\n</li>\n<li><p>具体的connection由NativeJdbcExtractor获取</p>\n</li>\n</ol>\n<p><strong>查询控制</strong></p>\n<p>具体的查询语句执行前会先调用applyStatementSettings方法以控制具体的查询行为。</p>\n<p><strong>异常转译</strong></p>\n<p>SQLExceptionTranslator作为异常转译的接口，其具体可以针对message，errorCode，自定义信息转译SQLException。</p>\n<p><strong>JdbcTemplate的增强</strong></p>\n<p>除了基本的JdbcTemplate之外，Spring还提供了NamedParameterJdbcTemplate等操作以增强JdbcTemplate的基本功能。</p>\n<p><strong>DataSource</strong></p>\n<p>Spring提供了多个DataSource实现，也可以使用第三方的，自定义DataSource既可以继承AbstractDataSource或者实现DelegatingDataSource。</p>\n<p>这里额外提及TransactionAwareDateSourceProxy，从其获取的Connection可以自动加入Spring的统一事务管理。</p>\n","excerpt":"","more":"<p>提起JDBC的使用大家一般集中喷两个地方：</p>\n<ol>\n<li>JDBC的异常处理</li>\n<li>JDBC数据处理的冗长代码</li>\n</ol>\n<p>看看Spring中对这两个问题是怎么举得的吧：</p>\n<h2 id=\"统一的数据访问异常层次体系\"><a href=\"#统一的数据访问异常层次体系\" class=\"headerlink\" title=\"统一的数据访问异常层次体系\"></a>统一的数据访问异常层次体系</h2><p>针对数据访问异常JDBC定义了4个异常，可以说是高度的抽象了，但换句话说就是没什么卵用。</p>\n<p>尤其是SQLException，这个异常是个checked exception。如果直接抛出会污染上层接口；如果在数据访问层内处理，这个异常却包含了多种问题，例如：</p>\n<ul>\n<li>无法连接数据库</li>\n<li>SQL语法错误</li>\n<li>SQL违反数据库约束</li>\n</ul>\n<p>即使拿到SQLException我们并不能马上准确的获取具体异常问题。</p>\n<p>Spring解决的也是简单直接：</p>\n<ul>\n<li>所有的数据访问异常都定义为了unchecked exception。你嫌弃它要抛出，那就都不要抛出了</li>\n<li>转译SQLException。你说它不知道怎么处理，那就提供更细粒度的异常</li>\n</ul>\n<h2 id=\"数据访问模板——JdbcTemplate\"><a href=\"#数据访问模板——JdbcTemplate\" class=\"headerlink\" title=\"数据访问模板——JdbcTemplate\"></a>数据访问模板——JdbcTemplate</h2><p>提到数据访问模板我想起了在学习JDBC操作时，当时写过一个标准的JDBC增删查该的模板，整个过程涉及到的内容还是不那么简单的。</p>\n<p>Spring在这里直接提供了JdbcTemplate作为数据访问的基础，这个类主要解决了两件事：</p>\n<ol>\n<li>使用模板模式封装基于JDBC的数据访问</li>\n<li>对数据访问异常转译，将JDBC异常转化为Spring自定义数据访问异常</li>\n</ol>\n<p>针对Jdbc的操作和Jdbc的访问Spring分类提供了两个抽象接口由JdbcTemplate继承：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/16/58f3143a23751.png\" alt=\"JdbcTemplate.png\"></p>\n<p>JdbcAccessor：JdbcTemplate的直接父类，主要两个属性：</p>\n<ul>\n<li>DataSource：作为Jdbc的连接工厂</li>\n<li>SQLExceptionTranslator：处理SQLException的转译</li>\n</ul>\n<p>JdbcOperations：定义JDBC操作集合的抽象接口。</p>\n<p>针对不同类型的操作，Spring提供不同的回调接口而不是简单的抽象模板</p>\n<p>除此，JdbcTemplate内部实现细节还有值得注意的地方：</p>\n<p><strong>connection</strong></p>\n<p>connection有两点需要注意：</p>\n<ol>\n<li><p>connection获取是使用DataSourceUtils获取的。而不是简单的从dataSource中获取的。</p>\n<p>DataSourceUtils会将connection绑定到当前线程，以便事务管理使用</p>\n</li>\n<li><p>具体的connection由NativeJdbcExtractor获取</p>\n</li>\n</ol>\n<p><strong>查询控制</strong></p>\n<p>具体的查询语句执行前会先调用applyStatementSettings方法以控制具体的查询行为。</p>\n<p><strong>异常转译</strong></p>\n<p>SQLExceptionTranslator作为异常转译的接口，其具体可以针对message，errorCode，自定义信息转译SQLException。</p>\n<p><strong>JdbcTemplate的增强</strong></p>\n<p>除了基本的JdbcTemplate之外，Spring还提供了NamedParameterJdbcTemplate等操作以增强JdbcTemplate的基本功能。</p>\n<p><strong>DataSource</strong></p>\n<p>Spring提供了多个DataSource实现，也可以使用第三方的，自定义DataSource既可以继承AbstractDataSource或者实现DelegatingDataSource。</p>\n<p>这里额外提及TransactionAwareDateSourceProxy，从其获取的Connection可以自动加入Spring的统一事务管理。</p>\n"},{"title":"Spring事件驱动模型与观察者模式","date":"2017-08-14T15:25:10.000Z","_content":"## 事件驱动模式\n\n关于事件驱动模式，这又是个大话题了，不是本文的核心关注点，开涛的博客中以用户注册为例子做了[介绍](http://jinnianshilongnian.iteye.com/blog/1902886)，这里就不做搬运工了。总结起来，事件驱动的关键点：松散耦合对象间的一对多依赖关系。\n\n具体到实现可以在语言层面使用观察者模式进行对象解耦，也可以使用消息队列对服务进行解耦，下面看看观察者模式。\n\n## 观察者模式\n\n### JDK 支持\n\nJDK 中直接提供了对观察者模式的抽象：\n\n- 被观察者：java.util.Observable\n- 观察者：java.util.Observer\n\nJDK 观察者模式的简单使用 [demo](https://github.com/zhanghTK/JPattern/tree/master/src/main/java/tk/zhangh/pattern/behavior/observer)\n\n值得注意的是：JDK 的观察者模式同时支持了 push 和 pull 两种模式，具体来说：\n\npush：每当被观察者（主题）更新，被观察者主动推送消息到各个观察者\n\npull：每当被观察者（主题）更新，被观察者仅通知观察者已更新，由观察者自行决定更新策略\n\n### push & pull\n\npush 的优点，被观察者（主题）可控：\n\n1. 可以实时推送，事件发生后第一时间即可触发通知操作\n2. 延迟推送，避开繁忙时间、明确事件发生顺序\n\npull 的优点：\n\n1. 减轻被观察者（主题类）负担\n2. 更新策略策略自定义，何时更新，更新哪些内容都由观察者自定义\n3. 权限管控，被观察者（主题类）可以根据不同主题集中处理权限管控\n\n网上看到关系新浪微博的推/拉架构的讨论：\n\n[软件架构模式-事件驱动不错哦](http://www.jianshu.com/p/dfb7fd88cd33)\n\n[微博feed系统的推(push)模式和拉(pull)模式和时间分区拉模式架构探讨](http://www.cnblogs.com/sunli/archive/2010/08/24/twitter_feeds_push_pull.html)\n\n## Spring 事件机制\n\n其实之前在[【SpringBoot】监听器篇](http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91%E7%9B%91%E5%90%AC%E5%99%A8%E7%AF%87/)，[【Spring】容器刷新](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/) 中已经把 Spring 中的使用到的场景说的七七八八了，这里做一下补充和归纳，合起来阅读效果更佳。\n\nSpring 事件体系包括三个组件：事件，事件监听器，事件广播器。\n\n### 事件\n\n![Spring 事件](https://i.loli.net/2017/08/14/5991c0618bfb4.jpeg)\n\nSpring 默认对 ApplicationEvent 事件提供了如下实现：\n\n- ContextStoppedEvent：ApplicationContext停止后触发的事件；\n- ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件；\n- ContextClosedEvent：ApplicationContext关闭后触发的事件；（如web容器关闭时自动会触发spring容器的关闭，如果是普通java应用，需要调用ctx.registerShutdownHook();注册虚拟机关闭时的钩子才行）\n\n- ContextStartedEvent：ApplicationContext启动后触发的事件；\n\nSpring Boot 额外支持的事件类型：\n\n- ApplicationStartingEvent\n- ApplicationEnvironmentPreparedEvent\n- ApplicationFailedEvent\n- ApplicationPreparedEvent\n\n### 事件监听器\n\n![Spring事件监听器](https://i.loli.net/2017/08/14/5991bfaf3c0a7.jpeg)\n\nSpring 事件监听器注册：[Spring 事件监听器注册](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#registerListeners)\n\nSpring Boot 事件监听器：[【SpringBoot】监听器篇](http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91%E7%9B%91%E5%90%AC%E5%99%A8%E7%AF%87/)\n\n自定义事件、事件监听器的使用：\n\n- [Spring Boot 自定义事件监听器](https://github.com/zhanghTK/spring-boot-start/tree/master/listener)\n- [Spring 自定义事件监听器](https://github.com/zhanghTK/spring-boot-start/tree/master/refresh)\n\n### 事件广播器\n\n![事件广播器.png](https://i.loli.net/2017/08/14/599114f2dda29.png)\n\nSpring 事件广播器的初始化：[Spring 事件广播器的初始化](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#initMessageSource)\n\n#### 事件同步、异步广播\n\n事件广播：\n\n```java\n@Override\npublic void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {\n   ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n   for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {\n      Executor executor = getTaskExecutor();\n      if (executor != null) {\n         executor.execute(new Runnable() {\n            @Override\n            public void run() {\n               invokeListener(listener, event);\n            }\n         });\n      }\n      else {\n         invokeListener(listener, event);\n      }\n   }\n}\n```\n\n方法一：指定线程池\n\n当未指定线程池时（getTaskExecutor = null），使用同步的方式广播线程，因此可以同步指定线程池开启异步调用。缺点：全局异步，无法对指定的事件进行异步处理。\n\n方法二：@Aync 注解\n\n使用 @Aync 注解指定需要异步调用的事件监听器监听器。\n","source":"_posts/Spring事件驱动模型与观察者模式.md","raw":"---\ntitle: Spring事件驱动模型与观察者模式\ndate: 2017-08-14 23:25:10\ntags:\n - Java\n - Spring\ncategories: Spring\n---\n## 事件驱动模式\n\n关于事件驱动模式，这又是个大话题了，不是本文的核心关注点，开涛的博客中以用户注册为例子做了[介绍](http://jinnianshilongnian.iteye.com/blog/1902886)，这里就不做搬运工了。总结起来，事件驱动的关键点：松散耦合对象间的一对多依赖关系。\n\n具体到实现可以在语言层面使用观察者模式进行对象解耦，也可以使用消息队列对服务进行解耦，下面看看观察者模式。\n\n## 观察者模式\n\n### JDK 支持\n\nJDK 中直接提供了对观察者模式的抽象：\n\n- 被观察者：java.util.Observable\n- 观察者：java.util.Observer\n\nJDK 观察者模式的简单使用 [demo](https://github.com/zhanghTK/JPattern/tree/master/src/main/java/tk/zhangh/pattern/behavior/observer)\n\n值得注意的是：JDK 的观察者模式同时支持了 push 和 pull 两种模式，具体来说：\n\npush：每当被观察者（主题）更新，被观察者主动推送消息到各个观察者\n\npull：每当被观察者（主题）更新，被观察者仅通知观察者已更新，由观察者自行决定更新策略\n\n### push & pull\n\npush 的优点，被观察者（主题）可控：\n\n1. 可以实时推送，事件发生后第一时间即可触发通知操作\n2. 延迟推送，避开繁忙时间、明确事件发生顺序\n\npull 的优点：\n\n1. 减轻被观察者（主题类）负担\n2. 更新策略策略自定义，何时更新，更新哪些内容都由观察者自定义\n3. 权限管控，被观察者（主题类）可以根据不同主题集中处理权限管控\n\n网上看到关系新浪微博的推/拉架构的讨论：\n\n[软件架构模式-事件驱动不错哦](http://www.jianshu.com/p/dfb7fd88cd33)\n\n[微博feed系统的推(push)模式和拉(pull)模式和时间分区拉模式架构探讨](http://www.cnblogs.com/sunli/archive/2010/08/24/twitter_feeds_push_pull.html)\n\n## Spring 事件机制\n\n其实之前在[【SpringBoot】监听器篇](http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91%E7%9B%91%E5%90%AC%E5%99%A8%E7%AF%87/)，[【Spring】容器刷新](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/) 中已经把 Spring 中的使用到的场景说的七七八八了，这里做一下补充和归纳，合起来阅读效果更佳。\n\nSpring 事件体系包括三个组件：事件，事件监听器，事件广播器。\n\n### 事件\n\n![Spring 事件](https://i.loli.net/2017/08/14/5991c0618bfb4.jpeg)\n\nSpring 默认对 ApplicationEvent 事件提供了如下实现：\n\n- ContextStoppedEvent：ApplicationContext停止后触发的事件；\n- ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件；\n- ContextClosedEvent：ApplicationContext关闭后触发的事件；（如web容器关闭时自动会触发spring容器的关闭，如果是普通java应用，需要调用ctx.registerShutdownHook();注册虚拟机关闭时的钩子才行）\n\n- ContextStartedEvent：ApplicationContext启动后触发的事件；\n\nSpring Boot 额外支持的事件类型：\n\n- ApplicationStartingEvent\n- ApplicationEnvironmentPreparedEvent\n- ApplicationFailedEvent\n- ApplicationPreparedEvent\n\n### 事件监听器\n\n![Spring事件监听器](https://i.loli.net/2017/08/14/5991bfaf3c0a7.jpeg)\n\nSpring 事件监听器注册：[Spring 事件监听器注册](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#registerListeners)\n\nSpring Boot 事件监听器：[【SpringBoot】监听器篇](http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91%E7%9B%91%E5%90%AC%E5%99%A8%E7%AF%87/)\n\n自定义事件、事件监听器的使用：\n\n- [Spring Boot 自定义事件监听器](https://github.com/zhanghTK/spring-boot-start/tree/master/listener)\n- [Spring 自定义事件监听器](https://github.com/zhanghTK/spring-boot-start/tree/master/refresh)\n\n### 事件广播器\n\n![事件广播器.png](https://i.loli.net/2017/08/14/599114f2dda29.png)\n\nSpring 事件广播器的初始化：[Spring 事件广播器的初始化](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#initMessageSource)\n\n#### 事件同步、异步广播\n\n事件广播：\n\n```java\n@Override\npublic void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {\n   ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n   for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {\n      Executor executor = getTaskExecutor();\n      if (executor != null) {\n         executor.execute(new Runnable() {\n            @Override\n            public void run() {\n               invokeListener(listener, event);\n            }\n         });\n      }\n      else {\n         invokeListener(listener, event);\n      }\n   }\n}\n```\n\n方法一：指定线程池\n\n当未指定线程池时（getTaskExecutor = null），使用同步的方式广播线程，因此可以同步指定线程池开启异步调用。缺点：全局异步，无法对指定的事件进行异步处理。\n\n方法二：@Aync 注解\n\n使用 @Aync 注解指定需要异步调用的事件监听器监听器。\n","slug":"Spring事件驱动模型与观察者模式","published":1,"updated":"2017-08-14T15:26:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2q0001pd82eet6sz7vw","content":"<h2 id=\"事件驱动模式\"><a href=\"#事件驱动模式\" class=\"headerlink\" title=\"事件驱动模式\"></a>事件驱动模式</h2><p>关于事件驱动模式，这又是个大话题了，不是本文的核心关注点，开涛的博客中以用户注册为例子做了<a href=\"http://jinnianshilongnian.iteye.com/blog/1902886\" target=\"_blank\" rel=\"external\">介绍</a>，这里就不做搬运工了。总结起来，事件驱动的关键点：松散耦合对象间的一对多依赖关系。</p>\n<p>具体到实现可以在语言层面使用观察者模式进行对象解耦，也可以使用消息队列对服务进行解耦，下面看看观察者模式。</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><h3 id=\"JDK-支持\"><a href=\"#JDK-支持\" class=\"headerlink\" title=\"JDK 支持\"></a>JDK 支持</h3><p>JDK 中直接提供了对观察者模式的抽象：</p>\n<ul>\n<li>被观察者：java.util.Observable</li>\n<li>观察者：java.util.Observer</li>\n</ul>\n<p>JDK 观察者模式的简单使用 <a href=\"https://github.com/zhanghTK/JPattern/tree/master/src/main/java/tk/zhangh/pattern/behavior/observer\" target=\"_blank\" rel=\"external\">demo</a></p>\n<p>值得注意的是：JDK 的观察者模式同时支持了 push 和 pull 两种模式，具体来说：</p>\n<p>push：每当被观察者（主题）更新，被观察者主动推送消息到各个观察者</p>\n<p>pull：每当被观察者（主题）更新，被观察者仅通知观察者已更新，由观察者自行决定更新策略</p>\n<h3 id=\"push-amp-pull\"><a href=\"#push-amp-pull\" class=\"headerlink\" title=\"push &amp; pull\"></a>push &amp; pull</h3><p>push 的优点，被观察者（主题）可控：</p>\n<ol>\n<li>可以实时推送，事件发生后第一时间即可触发通知操作</li>\n<li>延迟推送，避开繁忙时间、明确事件发生顺序</li>\n</ol>\n<p>pull 的优点：</p>\n<ol>\n<li>减轻被观察者（主题类）负担</li>\n<li>更新策略策略自定义，何时更新，更新哪些内容都由观察者自定义</li>\n<li>权限管控，被观察者（主题类）可以根据不同主题集中处理权限管控</li>\n</ol>\n<p>网上看到关系新浪微博的推/拉架构的讨论：</p>\n<p><a href=\"http://www.jianshu.com/p/dfb7fd88cd33\" target=\"_blank\" rel=\"external\">软件架构模式-事件驱动不错哦</a></p>\n<p><a href=\"http://www.cnblogs.com/sunli/archive/2010/08/24/twitter_feeds_push_pull.html\" target=\"_blank\" rel=\"external\">微博feed系统的推(push)模式和拉(pull)模式和时间分区拉模式架构探讨</a></p>\n<h2 id=\"Spring-事件机制\"><a href=\"#Spring-事件机制\" class=\"headerlink\" title=\"Spring 事件机制\"></a>Spring 事件机制</h2><p>其实之前在<a href=\"http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91%E7%9B%91%E5%90%AC%E5%99%A8%E7%AF%87/\" target=\"_blank\" rel=\"external\">【SpringBoot】监听器篇</a>，<a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/\" target=\"_blank\" rel=\"external\">【Spring】容器刷新</a> 中已经把 Spring 中的使用到的场景说的七七八八了，这里做一下补充和归纳，合起来阅读效果更佳。</p>\n<p>Spring 事件体系包括三个组件：事件，事件监听器，事件广播器。</p>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p><img src=\"https://i.loli.net/2017/08/14/5991c0618bfb4.jpeg\" alt=\"Spring 事件\"></p>\n<p>Spring 默认对 ApplicationEvent 事件提供了如下实现：</p>\n<ul>\n<li>ContextStoppedEvent：ApplicationContext停止后触发的事件；</li>\n<li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件；</li>\n<li><p>ContextClosedEvent：ApplicationContext关闭后触发的事件；（如web容器关闭时自动会触发spring容器的关闭，如果是普通java应用，需要调用ctx.registerShutdownHook();注册虚拟机关闭时的钩子才行）</p>\n</li>\n<li><p>ContextStartedEvent：ApplicationContext启动后触发的事件；</p>\n</li>\n</ul>\n<p>Spring Boot 额外支持的事件类型：</p>\n<ul>\n<li>ApplicationStartingEvent</li>\n<li>ApplicationEnvironmentPreparedEvent</li>\n<li>ApplicationFailedEvent</li>\n<li>ApplicationPreparedEvent</li>\n</ul>\n<h3 id=\"事件监听器\"><a href=\"#事件监听器\" class=\"headerlink\" title=\"事件监听器\"></a>事件监听器</h3><p><img src=\"https://i.loli.net/2017/08/14/5991bfaf3c0a7.jpeg\" alt=\"Spring事件监听器\"></p>\n<p>Spring 事件监听器注册：<a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#registerListeners\" target=\"_blank\" rel=\"external\">Spring 事件监听器注册</a></p>\n<p>Spring Boot 事件监听器：<a href=\"http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91%E7%9B%91%E5%90%AC%E5%99%A8%E7%AF%87/\" target=\"_blank\" rel=\"external\">【SpringBoot】监听器篇</a></p>\n<p>自定义事件、事件监听器的使用：</p>\n<ul>\n<li><a href=\"https://github.com/zhanghTK/spring-boot-start/tree/master/listener\" target=\"_blank\" rel=\"external\">Spring Boot 自定义事件监听器</a></li>\n<li><a href=\"https://github.com/zhanghTK/spring-boot-start/tree/master/refresh\" target=\"_blank\" rel=\"external\">Spring 自定义事件监听器</a></li>\n</ul>\n<h3 id=\"事件广播器\"><a href=\"#事件广播器\" class=\"headerlink\" title=\"事件广播器\"></a>事件广播器</h3><p><img src=\"https://i.loli.net/2017/08/14/599114f2dda29.png\" alt=\"事件广播器.png\"></p>\n<p>Spring 事件广播器的初始化：<a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#initMessageSource\" target=\"_blank\" rel=\"external\">Spring 事件广播器的初始化</a></p>\n<h4 id=\"事件同步、异步广播\"><a href=\"#事件同步、异步广播\" class=\"headerlink\" title=\"事件同步、异步广播\"></a>事件同步、异步广播</h4><p>事件广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">multicastEvent</span><span class=\"params\">(<span class=\"keyword\">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>&#123;</div><div class=\"line\">   ResolvableType type = (eventType != <span class=\"keyword\">null</span> ? eventType : resolveDefaultEventType(event));</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</div><div class=\"line\">      Executor executor = getTaskExecutor();</div><div class=\"line\">      <span class=\"keyword\">if</span> (executor != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">               invokeListener(listener, event);</div><div class=\"line\">            &#125;</div><div class=\"line\">         &#125;);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         invokeListener(listener, event);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法一：指定线程池</p>\n<p>当未指定线程池时（getTaskExecutor = null），使用同步的方式广播线程，因此可以同步指定线程池开启异步调用。缺点：全局异步，无法对指定的事件进行异步处理。</p>\n<p>方法二：@Aync 注解</p>\n<p>使用 @Aync 注解指定需要异步调用的事件监听器监听器。</p>\n","excerpt":"","more":"<h2 id=\"事件驱动模式\"><a href=\"#事件驱动模式\" class=\"headerlink\" title=\"事件驱动模式\"></a>事件驱动模式</h2><p>关于事件驱动模式，这又是个大话题了，不是本文的核心关注点，开涛的博客中以用户注册为例子做了<a href=\"http://jinnianshilongnian.iteye.com/blog/1902886\">介绍</a>，这里就不做搬运工了。总结起来，事件驱动的关键点：松散耦合对象间的一对多依赖关系。</p>\n<p>具体到实现可以在语言层面使用观察者模式进行对象解耦，也可以使用消息队列对服务进行解耦，下面看看观察者模式。</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><h3 id=\"JDK-支持\"><a href=\"#JDK-支持\" class=\"headerlink\" title=\"JDK 支持\"></a>JDK 支持</h3><p>JDK 中直接提供了对观察者模式的抽象：</p>\n<ul>\n<li>被观察者：java.util.Observable</li>\n<li>观察者：java.util.Observer</li>\n</ul>\n<p>JDK 观察者模式的简单使用 <a href=\"https://github.com/zhanghTK/JPattern/tree/master/src/main/java/tk/zhangh/pattern/behavior/observer\">demo</a></p>\n<p>值得注意的是：JDK 的观察者模式同时支持了 push 和 pull 两种模式，具体来说：</p>\n<p>push：每当被观察者（主题）更新，被观察者主动推送消息到各个观察者</p>\n<p>pull：每当被观察者（主题）更新，被观察者仅通知观察者已更新，由观察者自行决定更新策略</p>\n<h3 id=\"push-amp-pull\"><a href=\"#push-amp-pull\" class=\"headerlink\" title=\"push &amp; pull\"></a>push &amp; pull</h3><p>push 的优点，被观察者（主题）可控：</p>\n<ol>\n<li>可以实时推送，事件发生后第一时间即可触发通知操作</li>\n<li>延迟推送，避开繁忙时间、明确事件发生顺序</li>\n</ol>\n<p>pull 的优点：</p>\n<ol>\n<li>减轻被观察者（主题类）负担</li>\n<li>更新策略策略自定义，何时更新，更新哪些内容都由观察者自定义</li>\n<li>权限管控，被观察者（主题类）可以根据不同主题集中处理权限管控</li>\n</ol>\n<p>网上看到关系新浪微博的推/拉架构的讨论：</p>\n<p><a href=\"http://www.jianshu.com/p/dfb7fd88cd33\">软件架构模式-事件驱动不错哦</a></p>\n<p><a href=\"http://www.cnblogs.com/sunli/archive/2010/08/24/twitter_feeds_push_pull.html\">微博feed系统的推(push)模式和拉(pull)模式和时间分区拉模式架构探讨</a></p>\n<h2 id=\"Spring-事件机制\"><a href=\"#Spring-事件机制\" class=\"headerlink\" title=\"Spring 事件机制\"></a>Spring 事件机制</h2><p>其实之前在<a href=\"http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91%E7%9B%91%E5%90%AC%E5%99%A8%E7%AF%87/\">【SpringBoot】监听器篇</a>，<a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/\">【Spring】容器刷新</a> 中已经把 Spring 中的使用到的场景说的七七八八了，这里做一下补充和归纳，合起来阅读效果更佳。</p>\n<p>Spring 事件体系包括三个组件：事件，事件监听器，事件广播器。</p>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p><img src=\"https://i.loli.net/2017/08/14/5991c0618bfb4.jpeg\" alt=\"Spring 事件\"></p>\n<p>Spring 默认对 ApplicationEvent 事件提供了如下实现：</p>\n<ul>\n<li>ContextStoppedEvent：ApplicationContext停止后触发的事件；</li>\n<li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件；</li>\n<li><p>ContextClosedEvent：ApplicationContext关闭后触发的事件；（如web容器关闭时自动会触发spring容器的关闭，如果是普通java应用，需要调用ctx.registerShutdownHook();注册虚拟机关闭时的钩子才行）</p>\n</li>\n<li><p>ContextStartedEvent：ApplicationContext启动后触发的事件；</p>\n</li>\n</ul>\n<p>Spring Boot 额外支持的事件类型：</p>\n<ul>\n<li>ApplicationStartingEvent</li>\n<li>ApplicationEnvironmentPreparedEvent</li>\n<li>ApplicationFailedEvent</li>\n<li>ApplicationPreparedEvent</li>\n</ul>\n<h3 id=\"事件监听器\"><a href=\"#事件监听器\" class=\"headerlink\" title=\"事件监听器\"></a>事件监听器</h3><p><img src=\"https://i.loli.net/2017/08/14/5991bfaf3c0a7.jpeg\" alt=\"Spring事件监听器\"></p>\n<p>Spring 事件监听器注册：<a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#registerListeners\">Spring 事件监听器注册</a></p>\n<p>Spring Boot 事件监听器：<a href=\"http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91%E7%9B%91%E5%90%AC%E5%99%A8%E7%AF%87/\">【SpringBoot】监听器篇</a></p>\n<p>自定义事件、事件监听器的使用：</p>\n<ul>\n<li><a href=\"https://github.com/zhanghTK/spring-boot-start/tree/master/listener\">Spring Boot 自定义事件监听器</a></li>\n<li><a href=\"https://github.com/zhanghTK/spring-boot-start/tree/master/refresh\">Spring 自定义事件监听器</a></li>\n</ul>\n<h3 id=\"事件广播器\"><a href=\"#事件广播器\" class=\"headerlink\" title=\"事件广播器\"></a>事件广播器</h3><p><img src=\"https://i.loli.net/2017/08/14/599114f2dda29.png\" alt=\"事件广播器.png\"></p>\n<p>Spring 事件广播器的初始化：<a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#initMessageSource\">Spring 事件广播器的初始化</a></p>\n<h4 id=\"事件同步、异步广播\"><a href=\"#事件同步、异步广播\" class=\"headerlink\" title=\"事件同步、异步广播\"></a>事件同步、异步广播</h4><p>事件广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">multicastEvent</span><span class=\"params\">(<span class=\"keyword\">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>&#123;</div><div class=\"line\">   ResolvableType type = (eventType != <span class=\"keyword\">null</span> ? eventType : resolveDefaultEventType(event));</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</div><div class=\"line\">      Executor executor = getTaskExecutor();</div><div class=\"line\">      <span class=\"keyword\">if</span> (executor != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">               invokeListener(listener, event);</div><div class=\"line\">            &#125;</div><div class=\"line\">         &#125;);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         invokeListener(listener, event);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法一：指定线程池</p>\n<p>当未指定线程池时（getTaskExecutor = null），使用同步的方式广播线程，因此可以同步指定线程池开启异步调用。缺点：全局异步，无法对指定的事件进行异步处理。</p>\n<p>方法二：@Aync 注解</p>\n<p>使用 @Aync 注解指定需要异步调用的事件监听器监听器。</p>\n"},{"title":"Spring事务行为","date":"2017-12-08T13:15:53.000Z","_content":"## 事务\n\n### 特性\n\n原子性：事务是一个不可分割的单位，事务中的操作要么都发生，要么都不发生。\n\n一致性：事务执行前后数据的完整性必须保持一致\n\n隔离性：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离\n\n持久性：一个事务一旦被提交，它对数据库中的数据的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响\n\n### 隔离级别\n\n隔离级别引发的问题：\n\n- 脏读：一个事务读取到了另一个事务改写但还未提交的数据（如果这些数据被回滚，则读到的数据是无效的）\n- 不可重复读：在同一个事务里，多次读取同一数据返回的结果有所不同\n- 幻读：一个事务读取了几行记录后，另一个事务插入（或删除）了一些记录，第一个事务再查询发生不一致\n\n隔离级别：\n\n| 隔离级别            | 含义                        | 脏读   | 不可重复读 | 幻读   | 备注        |\n| --------------- | ------------------------- | ---- | ----- | ---- | --------- |\n| READ_UBCOMMITED | 允许读还未提交的改变了的数据            | 是    | 是     | 是    |           |\n| READ_COMMITED   | 允许在并发事务应景提交后读取            | 否    | 是     | 是    | Oracle 默认 |\n| REREATABLE_READ | 对相同字段的多次读取是一致的，除非数据被本事务改变 | 否    | 否     | 是    | MySQL默认   |\n| SERIALIZABLE    | 完全服从 ACID 的隔离级别           | 否    | 否     | 否    |           |\n\n## Spring 接口\n\nSpring 事务管理高层抽象主要的接口有：\n\n- 事务管理器：PlatformTranscationManager\n- 事务定义信息：TransactionDefinition\n- 事务具体运行状态：TransactionStatus\n\n使用 TransactionDefinition 定义事务信息，由 PlatformTransactionManager 负责执行事务，执行的结果记录在 TransactionStatus。\n\n### PlatformTransactionManager\n\n包含多个实现，可以为不同持久化框架提供不同实现\n\n| 实现                           | 说明                                  |\n| ---------------------------- | ----------------------------------- |\n| DataSourceTransactionManager | 使用 Spring JDBC 或 MyBatis 进行持久化数据时使用 |\n| HibernateTransactionManager  | 使用 Hibernate 进行持久化数据时使用             |\n| JpaTransactionManager        | 使用 JPA 进行持久化时使用                     |\n| JdoTransactionManager        | Jdo 持久化机制时使用                        |\n| JtaTransactionManager        | 使用 JTA 管理事务                         |\n\n### TransactionDefinition\n\n- 常量\n\n  ISOLATION_XXX 定义了事务的隔离级别\n\n  PROPAGATION_XXX 定义了事务的传播行为\n\n  TIMEOUT_DEFAULT 默认超时\n\n- 方法\n\n  获得事务以上信息\n\n#### 隔离级别\n\nSpring 事务隔离级别所有事务隔离级别，默认使用 DB 的事务隔离级别\n\n#### 传播行为\n\n传播行为解决事务方法相互调用时，事务的处理方式。Spring 事务提供的传播行为：\n\n| 事务传播行为                    | 含义                      |\n| ------------------------- | ----------------------- |\n| PROPAGATION_REQUIRED      | 支持当前事务，如果不存在就新建一个       |\n| PROPAGATION_SUPPORTS      | 支持当前事务，如果不存在，就不使用事务     |\n| PROPAGATION_MANDATORY     | 支持当前事务，如果不存在，抛出异常       |\n| PROPAGATION_REQUIRES_NEW  | 如果有事务存在，挂起当前事务，创建一个新的事务 |\n| PROPAGATION_NOT_SUPPORTED | 以非事务方式运行，如果有事务存在，挂起当前事务 |\n| PROPAGATION_NEVER         | 以非事务方式运行，如果有事务存在，抛出异常   |\n| PROPAGATION_NESTED        | 如果当前事务存在，则嵌套事务（保存点）     |\n\n##### PROPAGATION_REQUIRED\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\n  methodB();\n}\n\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodB() {\n}\n\nmethodB();  // 当前上下文不存在事务，methodB 开启一个新的事务\nmethodA();  // 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 发现当前上下文有事务，因此就加入到当前事务中来\n```\n\n##### PROPAGATION_SUPPORTS\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\n  methodB();\n}\n\n@Transactional(propagation = Propagation.SUPPORTS)\npublic void methodB() {\n}\n\nmethodB();  // methodB 以非事务的方式执行\nmtthodA();  // 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 加入 methodA 的事务\n```\n\n##### PROPAGATION_MANDATORY\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\ndoSomeThingA();\n  methodB();\n}\n\n\n// 事务属性为REQUIRES_NEW\n@Transactional(propagation = Propagation.MANDATOR)\npublic void methodB() {\n}\n\nmethodB();  // 当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);\nmethodA();  // 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 加入 methodA 的事务\n```\n\n##### PROPAGATION_REQUIRES_NEW\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\n  doSomeThing1();\n  methodB();\n  doSomeThing2();\n}\n\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void methodB() {\n}\n```\n\n当调用 methodB() ，当前上下文不存在事务，methodB 开启一个新的事务\n\n当调用 methodA() 相当于执行了以下的代码：\n\n```java\n\nTransactionManager tm = null;\ntry{\n  // 获得一个JTA事务管理器\n  tm = getTransactionManager();\n  tm.begin();// 开启一个新的事务\n  Transaction ts1 = tm.getTransaction();\n  doSomeThing1();\n  tm.suspend1();// 挂起当前事务\n  try{\n    tm.begin();// 重新开启第二个事务\n    Transaction ts2 = tm.getTransaction();\n    methodB();\n    ts2.commit();// 提交第二个事务\n  } Catch(RunTimeException ex) {\n    ts2.rollback();// 回滚第二个事务\n  } finally {\n    // 释放资源\n  }\n  // methodB执行完后，恢复第一个事务\n  tm.resume(ts1);\n  doSomeThing2();\n  ts1.commit();// 提交第一个事务\n} catch(RunTimeException ex) {\n  ts1.rollback();// 回滚第一个事务\n} finally {\n  // 释放资源\n}\n```\n\n上面的 ts1 和 ts2 是两个独立的事务，互不干扰， ts2 是否成功并不依赖于 ts1。如果 methodA 在调用 methodB 方法后的 doSomeThing2 发生异常，methodB 并不受影响结构依然没提交，但 methodA 的其他代码则会被回滚。\n\n使用 PROPAGATION_REQUIRES_NEW 需要使用 JtaTransactionManager 作为事务管理器。\n\n##### PROPAGATION_NOT_SUPPORTED\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\n  doSomeThing1();\n  methodB();\n  doSomeThing2();\n}\n\n@Transactional(propagation = Propagation.PROPAGATION_NOT_SUPPORTED)\npublic void methodB() {\n}\n```\n\n总是以非事务的形式执行，当 methodA 执行到 methodB(); 时先挂起事务，再执行 methodB(), 完成后再恢复 methodA 的事务继续执行 doSomeThing2 方法。\n\n使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。\n\n##### PROPAGATION_NEVER\n\n总是非事务地执行，如果存在一个活动事务，则抛出异常。\n\n##### PROPAGATION_NESTED\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA(){\n  doSomeThing1();\n  methodB();\n  doSomeThing2();\n}\n\n@Transactional(propagation = Propagation.NEWSTED)\npublic void methodB(){\n}\n```\n\n当调用 methodB() ，则按照 PROPAGATION_REQUIRED 执行，当前上下文不存在事务，methodB 开启一个新的事务\n\n当调用 methodA() 相当于执行了以下的代码：\n\n```java\nConnection con = null;\nSavepoint savepoint = null;\ntry{\n  con = getConnection();\n  con.setAutoCommit(false);\n  doSomeThing1();\n  savepoint = con2.setSavepoint();\n  try{\n    methodB();\n  } catch(RuntimeException ex) {\n    con.rollback(savepoint);\n  } finally {\n    //释放资源\n  }\n  doSomeThing2();\n  con.commit();\n} catch(RuntimeException ex) {\n  con.rollback();\n} finally {\n  //释放资源\n}\n```\n\n在调用 methodB 之前，先调用 setSavepoint 方法，保存当前的状态到 savepoint。如果 methodB 执行失败，则恢复到  savepoint 保存的状态。\n\n如果外层事务执行失败，会回滚内层事务所做的动作；\n\n如果内层事务执行失败，不会引起外层事务的回滚；\n\n使用JDBC 3.0驱动时,仅仅支持 DataSourceTransactionManager 作为事务管理器，PlatformTransactionManager的nestedTransactionAllowed属性设为true(属性值默认为false)\n\n### TransactionStatus\n\n维护，获取事务的各种状态\n\n## 使用 Spring 事务\n\nSpring 提供编程式和声明式的事务管理，具体的代码实现可以参考：[spring-tx-test](https://github.com/zhanghTK/spring-tx-test)\n","source":"_posts/Spring事务行为.md","raw":"---\ntitle: Spring事务行为\ndate: 2017-12-08 21:15:53\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n## 事务\n\n### 特性\n\n原子性：事务是一个不可分割的单位，事务中的操作要么都发生，要么都不发生。\n\n一致性：事务执行前后数据的完整性必须保持一致\n\n隔离性：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离\n\n持久性：一个事务一旦被提交，它对数据库中的数据的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响\n\n### 隔离级别\n\n隔离级别引发的问题：\n\n- 脏读：一个事务读取到了另一个事务改写但还未提交的数据（如果这些数据被回滚，则读到的数据是无效的）\n- 不可重复读：在同一个事务里，多次读取同一数据返回的结果有所不同\n- 幻读：一个事务读取了几行记录后，另一个事务插入（或删除）了一些记录，第一个事务再查询发生不一致\n\n隔离级别：\n\n| 隔离级别            | 含义                        | 脏读   | 不可重复读 | 幻读   | 备注        |\n| --------------- | ------------------------- | ---- | ----- | ---- | --------- |\n| READ_UBCOMMITED | 允许读还未提交的改变了的数据            | 是    | 是     | 是    |           |\n| READ_COMMITED   | 允许在并发事务应景提交后读取            | 否    | 是     | 是    | Oracle 默认 |\n| REREATABLE_READ | 对相同字段的多次读取是一致的，除非数据被本事务改变 | 否    | 否     | 是    | MySQL默认   |\n| SERIALIZABLE    | 完全服从 ACID 的隔离级别           | 否    | 否     | 否    |           |\n\n## Spring 接口\n\nSpring 事务管理高层抽象主要的接口有：\n\n- 事务管理器：PlatformTranscationManager\n- 事务定义信息：TransactionDefinition\n- 事务具体运行状态：TransactionStatus\n\n使用 TransactionDefinition 定义事务信息，由 PlatformTransactionManager 负责执行事务，执行的结果记录在 TransactionStatus。\n\n### PlatformTransactionManager\n\n包含多个实现，可以为不同持久化框架提供不同实现\n\n| 实现                           | 说明                                  |\n| ---------------------------- | ----------------------------------- |\n| DataSourceTransactionManager | 使用 Spring JDBC 或 MyBatis 进行持久化数据时使用 |\n| HibernateTransactionManager  | 使用 Hibernate 进行持久化数据时使用             |\n| JpaTransactionManager        | 使用 JPA 进行持久化时使用                     |\n| JdoTransactionManager        | Jdo 持久化机制时使用                        |\n| JtaTransactionManager        | 使用 JTA 管理事务                         |\n\n### TransactionDefinition\n\n- 常量\n\n  ISOLATION_XXX 定义了事务的隔离级别\n\n  PROPAGATION_XXX 定义了事务的传播行为\n\n  TIMEOUT_DEFAULT 默认超时\n\n- 方法\n\n  获得事务以上信息\n\n#### 隔离级别\n\nSpring 事务隔离级别所有事务隔离级别，默认使用 DB 的事务隔离级别\n\n#### 传播行为\n\n传播行为解决事务方法相互调用时，事务的处理方式。Spring 事务提供的传播行为：\n\n| 事务传播行为                    | 含义                      |\n| ------------------------- | ----------------------- |\n| PROPAGATION_REQUIRED      | 支持当前事务，如果不存在就新建一个       |\n| PROPAGATION_SUPPORTS      | 支持当前事务，如果不存在，就不使用事务     |\n| PROPAGATION_MANDATORY     | 支持当前事务，如果不存在，抛出异常       |\n| PROPAGATION_REQUIRES_NEW  | 如果有事务存在，挂起当前事务，创建一个新的事务 |\n| PROPAGATION_NOT_SUPPORTED | 以非事务方式运行，如果有事务存在，挂起当前事务 |\n| PROPAGATION_NEVER         | 以非事务方式运行，如果有事务存在，抛出异常   |\n| PROPAGATION_NESTED        | 如果当前事务存在，则嵌套事务（保存点）     |\n\n##### PROPAGATION_REQUIRED\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\n  methodB();\n}\n\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodB() {\n}\n\nmethodB();  // 当前上下文不存在事务，methodB 开启一个新的事务\nmethodA();  // 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 发现当前上下文有事务，因此就加入到当前事务中来\n```\n\n##### PROPAGATION_SUPPORTS\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\n  methodB();\n}\n\n@Transactional(propagation = Propagation.SUPPORTS)\npublic void methodB() {\n}\n\nmethodB();  // methodB 以非事务的方式执行\nmtthodA();  // 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 加入 methodA 的事务\n```\n\n##### PROPAGATION_MANDATORY\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\ndoSomeThingA();\n  methodB();\n}\n\n\n// 事务属性为REQUIRES_NEW\n@Transactional(propagation = Propagation.MANDATOR)\npublic void methodB() {\n}\n\nmethodB();  // 当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);\nmethodA();  // 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 加入 methodA 的事务\n```\n\n##### PROPAGATION_REQUIRES_NEW\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\n  doSomeThing1();\n  methodB();\n  doSomeThing2();\n}\n\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void methodB() {\n}\n```\n\n当调用 methodB() ，当前上下文不存在事务，methodB 开启一个新的事务\n\n当调用 methodA() 相当于执行了以下的代码：\n\n```java\n\nTransactionManager tm = null;\ntry{\n  // 获得一个JTA事务管理器\n  tm = getTransactionManager();\n  tm.begin();// 开启一个新的事务\n  Transaction ts1 = tm.getTransaction();\n  doSomeThing1();\n  tm.suspend1();// 挂起当前事务\n  try{\n    tm.begin();// 重新开启第二个事务\n    Transaction ts2 = tm.getTransaction();\n    methodB();\n    ts2.commit();// 提交第二个事务\n  } Catch(RunTimeException ex) {\n    ts2.rollback();// 回滚第二个事务\n  } finally {\n    // 释放资源\n  }\n  // methodB执行完后，恢复第一个事务\n  tm.resume(ts1);\n  doSomeThing2();\n  ts1.commit();// 提交第一个事务\n} catch(RunTimeException ex) {\n  ts1.rollback();// 回滚第一个事务\n} finally {\n  // 释放资源\n}\n```\n\n上面的 ts1 和 ts2 是两个独立的事务，互不干扰， ts2 是否成功并不依赖于 ts1。如果 methodA 在调用 methodB 方法后的 doSomeThing2 发生异常，methodB 并不受影响结构依然没提交，但 methodA 的其他代码则会被回滚。\n\n使用 PROPAGATION_REQUIRES_NEW 需要使用 JtaTransactionManager 作为事务管理器。\n\n##### PROPAGATION_NOT_SUPPORTED\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\n  doSomeThing1();\n  methodB();\n  doSomeThing2();\n}\n\n@Transactional(propagation = Propagation.PROPAGATION_NOT_SUPPORTED)\npublic void methodB() {\n}\n```\n\n总是以非事务的形式执行，当 methodA 执行到 methodB(); 时先挂起事务，再执行 methodB(), 完成后再恢复 methodA 的事务继续执行 doSomeThing2 方法。\n\n使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。\n\n##### PROPAGATION_NEVER\n\n总是非事务地执行，如果存在一个活动事务，则抛出异常。\n\n##### PROPAGATION_NESTED\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA(){\n  doSomeThing1();\n  methodB();\n  doSomeThing2();\n}\n\n@Transactional(propagation = Propagation.NEWSTED)\npublic void methodB(){\n}\n```\n\n当调用 methodB() ，则按照 PROPAGATION_REQUIRED 执行，当前上下文不存在事务，methodB 开启一个新的事务\n\n当调用 methodA() 相当于执行了以下的代码：\n\n```java\nConnection con = null;\nSavepoint savepoint = null;\ntry{\n  con = getConnection();\n  con.setAutoCommit(false);\n  doSomeThing1();\n  savepoint = con2.setSavepoint();\n  try{\n    methodB();\n  } catch(RuntimeException ex) {\n    con.rollback(savepoint);\n  } finally {\n    //释放资源\n  }\n  doSomeThing2();\n  con.commit();\n} catch(RuntimeException ex) {\n  con.rollback();\n} finally {\n  //释放资源\n}\n```\n\n在调用 methodB 之前，先调用 setSavepoint 方法，保存当前的状态到 savepoint。如果 methodB 执行失败，则恢复到  savepoint 保存的状态。\n\n如果外层事务执行失败，会回滚内层事务所做的动作；\n\n如果内层事务执行失败，不会引起外层事务的回滚；\n\n使用JDBC 3.0驱动时,仅仅支持 DataSourceTransactionManager 作为事务管理器，PlatformTransactionManager的nestedTransactionAllowed属性设为true(属性值默认为false)\n\n### TransactionStatus\n\n维护，获取事务的各种状态\n\n## 使用 Spring 事务\n\nSpring 提供编程式和声明式的事务管理，具体的代码实现可以参考：[spring-tx-test](https://github.com/zhanghTK/spring-tx-test)\n","slug":"Spring事务行为","published":1,"updated":"2017-12-08T13:18:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2q3001rd82ewehp0b7g","content":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>原子性：事务是一个不可分割的单位，事务中的操作要么都发生，要么都不发生。</p>\n<p>一致性：事务执行前后数据的完整性必须保持一致</p>\n<p>隔离性：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离</p>\n<p>持久性：一个事务一旦被提交，它对数据库中的数据的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响</p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><p>隔离级别引发的问题：</p>\n<ul>\n<li>脏读：一个事务读取到了另一个事务改写但还未提交的数据（如果这些数据被回滚，则读到的数据是无效的）</li>\n<li>不可重复读：在同一个事务里，多次读取同一数据返回的结果有所不同</li>\n<li>幻读：一个事务读取了几行记录后，另一个事务插入（或删除）了一些记录，第一个事务再查询发生不一致</li>\n</ul>\n<p>隔离级别：</p>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>含义</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>READ_UBCOMMITED</td>\n<td>允许读还未提交的改变了的数据</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td></td>\n</tr>\n<tr>\n<td>READ_COMMITED</td>\n<td>允许在并发事务应景提交后读取</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n<td>Oracle 默认</td>\n</tr>\n<tr>\n<td>REREATABLE_READ</td>\n<td>对相同字段的多次读取是一致的，除非数据被本事务改变</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n<td>MySQL默认</td>\n</tr>\n<tr>\n<td>SERIALIZABLE</td>\n<td>完全服从 ACID 的隔离级别</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Spring-接口\"><a href=\"#Spring-接口\" class=\"headerlink\" title=\"Spring 接口\"></a>Spring 接口</h2><p>Spring 事务管理高层抽象主要的接口有：</p>\n<ul>\n<li>事务管理器：PlatformTranscationManager</li>\n<li>事务定义信息：TransactionDefinition</li>\n<li>事务具体运行状态：TransactionStatus</li>\n</ul>\n<p>使用 TransactionDefinition 定义事务信息，由 PlatformTransactionManager 负责执行事务，执行的结果记录在 TransactionStatus。</p>\n<h3 id=\"PlatformTransactionManager\"><a href=\"#PlatformTransactionManager\" class=\"headerlink\" title=\"PlatformTransactionManager\"></a>PlatformTransactionManager</h3><p>包含多个实现，可以为不同持久化框架提供不同实现</p>\n<table>\n<thead>\n<tr>\n<th>实现</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DataSourceTransactionManager</td>\n<td>使用 Spring JDBC 或 MyBatis 进行持久化数据时使用</td>\n</tr>\n<tr>\n<td>HibernateTransactionManager</td>\n<td>使用 Hibernate 进行持久化数据时使用</td>\n</tr>\n<tr>\n<td>JpaTransactionManager</td>\n<td>使用 JPA 进行持久化时使用</td>\n</tr>\n<tr>\n<td>JdoTransactionManager</td>\n<td>Jdo 持久化机制时使用</td>\n</tr>\n<tr>\n<td>JtaTransactionManager</td>\n<td>使用 JTA 管理事务</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"TransactionDefinition\"><a href=\"#TransactionDefinition\" class=\"headerlink\" title=\"TransactionDefinition\"></a>TransactionDefinition</h3><ul>\n<li><p>常量</p>\n<p>ISOLATION_XXX 定义了事务的隔离级别</p>\n<p>PROPAGATION_XXX 定义了事务的传播行为</p>\n<p>TIMEOUT_DEFAULT 默认超时</p>\n</li>\n<li><p>方法</p>\n<p>获得事务以上信息</p>\n</li>\n</ul>\n<h4 id=\"隔离级别-1\"><a href=\"#隔离级别-1\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h4><p>Spring 事务隔离级别所有事务隔离级别，默认使用 DB 的事务隔离级别</p>\n<h4 id=\"传播行为\"><a href=\"#传播行为\" class=\"headerlink\" title=\"传播行为\"></a>传播行为</h4><p>传播行为解决事务方法相互调用时，事务的处理方式。Spring 事务提供的传播行为：</p>\n<table>\n<thead>\n<tr>\n<th>事务传播行为</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PROPAGATION_REQUIRED</td>\n<td>支持当前事务，如果不存在就新建一个</td>\n</tr>\n<tr>\n<td>PROPAGATION_SUPPORTS</td>\n<td>支持当前事务，如果不存在，就不使用事务</td>\n</tr>\n<tr>\n<td>PROPAGATION_MANDATORY</td>\n<td>支持当前事务，如果不存在，抛出异常</td>\n</tr>\n<tr>\n<td>PROPAGATION_REQUIRES_NEW</td>\n<td>如果有事务存在，挂起当前事务，创建一个新的事务</td>\n</tr>\n<tr>\n<td>PROPAGATION_NOT_SUPPORTED</td>\n<td>以非事务方式运行，如果有事务存在，挂起当前事务</td>\n</tr>\n<tr>\n<td>PROPAGATION_NEVER</td>\n<td>以非事务方式运行，如果有事务存在，抛出异常</td>\n</tr>\n<tr>\n<td>PROPAGATION_NESTED</td>\n<td>如果当前事务存在，则嵌套事务（保存点）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"PROPAGATION-REQUIRED\"><a href=\"#PROPAGATION-REQUIRED\" class=\"headerlink\" title=\"PROPAGATION_REQUIRED\"></a>PROPAGATION_REQUIRED</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  methodB();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">methodB();  <span class=\"comment\">// 当前上下文不存在事务，methodB 开启一个新的事务</span></div><div class=\"line\">methodA();  <span class=\"comment\">// 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 发现当前上下文有事务，因此就加入到当前事务中来</span></div></pre></td></tr></table></figure>\n<h5 id=\"PROPAGATION-SUPPORTS\"><a href=\"#PROPAGATION-SUPPORTS\" class=\"headerlink\" title=\"PROPAGATION_SUPPORTS\"></a>PROPAGATION_SUPPORTS</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  methodB();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.SUPPORTS)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">methodB();  <span class=\"comment\">// methodB 以非事务的方式执行</span></div><div class=\"line\">mtthodA();  <span class=\"comment\">// 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 加入 methodA 的事务</span></div></pre></td></tr></table></figure>\n<h5 id=\"PROPAGATION-MANDATORY\"><a href=\"#PROPAGATION-MANDATORY\" class=\"headerlink\" title=\"PROPAGATION_MANDATORY\"></a>PROPAGATION_MANDATORY</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">doSomeThingA();</div><div class=\"line\">  methodB();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 事务属性为REQUIRES_NEW</span></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.MANDATOR)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">methodB();  <span class=\"comment\">// 当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);</span></div><div class=\"line\">methodA();  <span class=\"comment\">// 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 加入 methodA 的事务</span></div></pre></td></tr></table></figure>\n<h5 id=\"PROPAGATION-REQUIRES-NEW\"><a href=\"#PROPAGATION-REQUIRES-NEW\" class=\"headerlink\" title=\"PROPAGATION_REQUIRES_NEW\"></a>PROPAGATION_REQUIRES_NEW</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  doSomeThing1();</div><div class=\"line\">  methodB();</div><div class=\"line\">  doSomeThing2();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当调用 methodB() ，当前上下文不存在事务，methodB 开启一个新的事务</p>\n<p>当调用 methodA() 相当于执行了以下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">TransactionManager tm = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 获得一个JTA事务管理器</span></div><div class=\"line\">  tm = getTransactionManager();</div><div class=\"line\">  tm.begin();<span class=\"comment\">// 开启一个新的事务</span></div><div class=\"line\">  Transaction ts1 = tm.getTransaction();</div><div class=\"line\">  doSomeThing1();</div><div class=\"line\">  tm.suspend1();<span class=\"comment\">// 挂起当前事务</span></div><div class=\"line\">  <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    tm.begin();<span class=\"comment\">// 重新开启第二个事务</span></div><div class=\"line\">    Transaction ts2 = tm.getTransaction();</div><div class=\"line\">    methodB();</div><div class=\"line\">    ts2.commit();<span class=\"comment\">// 提交第二个事务</span></div><div class=\"line\">  &#125; Catch(RunTimeException ex) &#123;</div><div class=\"line\">    ts2.rollback();<span class=\"comment\">// 回滚第二个事务</span></div><div class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 释放资源</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// methodB执行完后，恢复第一个事务</span></div><div class=\"line\">  tm.resume(ts1);</div><div class=\"line\">  doSomeThing2();</div><div class=\"line\">  ts1.commit();<span class=\"comment\">// 提交第一个事务</span></div><div class=\"line\">&#125; <span class=\"keyword\">catch</span>(RunTimeException ex) &#123;</div><div class=\"line\">  ts1.rollback();<span class=\"comment\">// 回滚第一个事务</span></div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// 释放资源</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的 ts1 和 ts2 是两个独立的事务，互不干扰， ts2 是否成功并不依赖于 ts1。如果 methodA 在调用 methodB 方法后的 doSomeThing2 发生异常，methodB 并不受影响结构依然没提交，但 methodA 的其他代码则会被回滚。</p>\n<p>使用 PROPAGATION_REQUIRES_NEW 需要使用 JtaTransactionManager 作为事务管理器。</p>\n<h5 id=\"PROPAGATION-NOT-SUPPORTED\"><a href=\"#PROPAGATION-NOT-SUPPORTED\" class=\"headerlink\" title=\"PROPAGATION_NOT_SUPPORTED\"></a>PROPAGATION_NOT_SUPPORTED</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  doSomeThing1();</div><div class=\"line\">  methodB();</div><div class=\"line\">  doSomeThing2();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.PROPAGATION_NOT_SUPPORTED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总是以非事务的形式执行，当 methodA 执行到 methodB(); 时先挂起事务，再执行 methodB(), 完成后再恢复 methodA 的事务继续执行 doSomeThing2 方法。</p>\n<p>使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。</p>\n<h5 id=\"PROPAGATION-NEVER\"><a href=\"#PROPAGATION-NEVER\" class=\"headerlink\" title=\"PROPAGATION_NEVER\"></a>PROPAGATION_NEVER</h5><p>总是非事务地执行，如果存在一个活动事务，则抛出异常。</p>\n<h5 id=\"PROPAGATION-NESTED\"><a href=\"#PROPAGATION-NESTED\" class=\"headerlink\" title=\"PROPAGATION_NESTED\"></a>PROPAGATION_NESTED</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  doSomeThing1();</div><div class=\"line\">  methodB();</div><div class=\"line\">  doSomeThing2();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.NEWSTED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当调用 methodB() ，则按照 PROPAGATION_REQUIRED 执行，当前上下文不存在事务，methodB 开启一个新的事务</p>\n<p>当调用 methodA() 相当于执行了以下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">Connection con = <span class=\"keyword\">null</span>;</div><div class=\"line\">Savepoint savepoint = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">  con = getConnection();</div><div class=\"line\">  con.setAutoCommit(<span class=\"keyword\">false</span>);</div><div class=\"line\">  doSomeThing1();</div><div class=\"line\">  savepoint = con2.setSavepoint();</div><div class=\"line\">  <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    methodB();</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span>(RuntimeException ex) &#123;</div><div class=\"line\">    con.rollback(savepoint);</div><div class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//释放资源</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  doSomeThing2();</div><div class=\"line\">  con.commit();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span>(RuntimeException ex) &#123;</div><div class=\"line\">  con.rollback();</div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">  <span class=\"comment\">//释放资源</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在调用 methodB 之前，先调用 setSavepoint 方法，保存当前的状态到 savepoint。如果 methodB 执行失败，则恢复到  savepoint 保存的状态。</p>\n<p>如果外层事务执行失败，会回滚内层事务所做的动作；</p>\n<p>如果内层事务执行失败，不会引起外层事务的回滚；</p>\n<p>使用JDBC 3.0驱动时,仅仅支持 DataSourceTransactionManager 作为事务管理器，PlatformTransactionManager的nestedTransactionAllowed属性设为true(属性值默认为false)</p>\n<h3 id=\"TransactionStatus\"><a href=\"#TransactionStatus\" class=\"headerlink\" title=\"TransactionStatus\"></a>TransactionStatus</h3><p>维护，获取事务的各种状态</p>\n<h2 id=\"使用-Spring-事务\"><a href=\"#使用-Spring-事务\" class=\"headerlink\" title=\"使用 Spring 事务\"></a>使用 Spring 事务</h2><p>Spring 提供编程式和声明式的事务管理，具体的代码实现可以参考：<a href=\"https://github.com/zhanghTK/spring-tx-test\" target=\"_blank\" rel=\"external\">spring-tx-test</a></p>\n","excerpt":"","more":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>原子性：事务是一个不可分割的单位，事务中的操作要么都发生，要么都不发生。</p>\n<p>一致性：事务执行前后数据的完整性必须保持一致</p>\n<p>隔离性：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离</p>\n<p>持久性：一个事务一旦被提交，它对数据库中的数据的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响</p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><p>隔离级别引发的问题：</p>\n<ul>\n<li>脏读：一个事务读取到了另一个事务改写但还未提交的数据（如果这些数据被回滚，则读到的数据是无效的）</li>\n<li>不可重复读：在同一个事务里，多次读取同一数据返回的结果有所不同</li>\n<li>幻读：一个事务读取了几行记录后，另一个事务插入（或删除）了一些记录，第一个事务再查询发生不一致</li>\n</ul>\n<p>隔离级别：</p>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>含义</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>READ_UBCOMMITED</td>\n<td>允许读还未提交的改变了的数据</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td></td>\n</tr>\n<tr>\n<td>READ_COMMITED</td>\n<td>允许在并发事务应景提交后读取</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n<td>Oracle 默认</td>\n</tr>\n<tr>\n<td>REREATABLE_READ</td>\n<td>对相同字段的多次读取是一致的，除非数据被本事务改变</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n<td>MySQL默认</td>\n</tr>\n<tr>\n<td>SERIALIZABLE</td>\n<td>完全服从 ACID 的隔离级别</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Spring-接口\"><a href=\"#Spring-接口\" class=\"headerlink\" title=\"Spring 接口\"></a>Spring 接口</h2><p>Spring 事务管理高层抽象主要的接口有：</p>\n<ul>\n<li>事务管理器：PlatformTranscationManager</li>\n<li>事务定义信息：TransactionDefinition</li>\n<li>事务具体运行状态：TransactionStatus</li>\n</ul>\n<p>使用 TransactionDefinition 定义事务信息，由 PlatformTransactionManager 负责执行事务，执行的结果记录在 TransactionStatus。</p>\n<h3 id=\"PlatformTransactionManager\"><a href=\"#PlatformTransactionManager\" class=\"headerlink\" title=\"PlatformTransactionManager\"></a>PlatformTransactionManager</h3><p>包含多个实现，可以为不同持久化框架提供不同实现</p>\n<table>\n<thead>\n<tr>\n<th>实现</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DataSourceTransactionManager</td>\n<td>使用 Spring JDBC 或 MyBatis 进行持久化数据时使用</td>\n</tr>\n<tr>\n<td>HibernateTransactionManager</td>\n<td>使用 Hibernate 进行持久化数据时使用</td>\n</tr>\n<tr>\n<td>JpaTransactionManager</td>\n<td>使用 JPA 进行持久化时使用</td>\n</tr>\n<tr>\n<td>JdoTransactionManager</td>\n<td>Jdo 持久化机制时使用</td>\n</tr>\n<tr>\n<td>JtaTransactionManager</td>\n<td>使用 JTA 管理事务</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"TransactionDefinition\"><a href=\"#TransactionDefinition\" class=\"headerlink\" title=\"TransactionDefinition\"></a>TransactionDefinition</h3><ul>\n<li><p>常量</p>\n<p>ISOLATION_XXX 定义了事务的隔离级别</p>\n<p>PROPAGATION_XXX 定义了事务的传播行为</p>\n<p>TIMEOUT_DEFAULT 默认超时</p>\n</li>\n<li><p>方法</p>\n<p>获得事务以上信息</p>\n</li>\n</ul>\n<h4 id=\"隔离级别-1\"><a href=\"#隔离级别-1\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h4><p>Spring 事务隔离级别所有事务隔离级别，默认使用 DB 的事务隔离级别</p>\n<h4 id=\"传播行为\"><a href=\"#传播行为\" class=\"headerlink\" title=\"传播行为\"></a>传播行为</h4><p>传播行为解决事务方法相互调用时，事务的处理方式。Spring 事务提供的传播行为：</p>\n<table>\n<thead>\n<tr>\n<th>事务传播行为</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PROPAGATION_REQUIRED</td>\n<td>支持当前事务，如果不存在就新建一个</td>\n</tr>\n<tr>\n<td>PROPAGATION_SUPPORTS</td>\n<td>支持当前事务，如果不存在，就不使用事务</td>\n</tr>\n<tr>\n<td>PROPAGATION_MANDATORY</td>\n<td>支持当前事务，如果不存在，抛出异常</td>\n</tr>\n<tr>\n<td>PROPAGATION_REQUIRES_NEW</td>\n<td>如果有事务存在，挂起当前事务，创建一个新的事务</td>\n</tr>\n<tr>\n<td>PROPAGATION_NOT_SUPPORTED</td>\n<td>以非事务方式运行，如果有事务存在，挂起当前事务</td>\n</tr>\n<tr>\n<td>PROPAGATION_NEVER</td>\n<td>以非事务方式运行，如果有事务存在，抛出异常</td>\n</tr>\n<tr>\n<td>PROPAGATION_NESTED</td>\n<td>如果当前事务存在，则嵌套事务（保存点）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"PROPAGATION-REQUIRED\"><a href=\"#PROPAGATION-REQUIRED\" class=\"headerlink\" title=\"PROPAGATION_REQUIRED\"></a>PROPAGATION_REQUIRED</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  methodB();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">methodB();  <span class=\"comment\">// 当前上下文不存在事务，methodB 开启一个新的事务</span></div><div class=\"line\">methodA();  <span class=\"comment\">// 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 发现当前上下文有事务，因此就加入到当前事务中来</span></div></pre></td></tr></table></figure>\n<h5 id=\"PROPAGATION-SUPPORTS\"><a href=\"#PROPAGATION-SUPPORTS\" class=\"headerlink\" title=\"PROPAGATION_SUPPORTS\"></a>PROPAGATION_SUPPORTS</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  methodB();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.SUPPORTS)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">methodB();  <span class=\"comment\">// methodB 以非事务的方式执行</span></div><div class=\"line\">mtthodA();  <span class=\"comment\">// 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 加入 methodA 的事务</span></div></pre></td></tr></table></figure>\n<h5 id=\"PROPAGATION-MANDATORY\"><a href=\"#PROPAGATION-MANDATORY\" class=\"headerlink\" title=\"PROPAGATION_MANDATORY\"></a>PROPAGATION_MANDATORY</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">doSomeThingA();</div><div class=\"line\">  methodB();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 事务属性为REQUIRES_NEW</span></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.MANDATOR)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">methodB();  <span class=\"comment\">// 当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);</span></div><div class=\"line\">methodA();  <span class=\"comment\">// 当前上下文不存在事务，methodA 开启一个新的事务，当执行内部 methodB() 时，methodB 加入 methodA 的事务</span></div></pre></td></tr></table></figure>\n<h5 id=\"PROPAGATION-REQUIRES-NEW\"><a href=\"#PROPAGATION-REQUIRES-NEW\" class=\"headerlink\" title=\"PROPAGATION_REQUIRES_NEW\"></a>PROPAGATION_REQUIRES_NEW</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  doSomeThing1();</div><div class=\"line\">  methodB();</div><div class=\"line\">  doSomeThing2();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当调用 methodB() ，当前上下文不存在事务，methodB 开启一个新的事务</p>\n<p>当调用 methodA() 相当于执行了以下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">TransactionManager tm = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 获得一个JTA事务管理器</span></div><div class=\"line\">  tm = getTransactionManager();</div><div class=\"line\">  tm.begin();<span class=\"comment\">// 开启一个新的事务</span></div><div class=\"line\">  Transaction ts1 = tm.getTransaction();</div><div class=\"line\">  doSomeThing1();</div><div class=\"line\">  tm.suspend1();<span class=\"comment\">// 挂起当前事务</span></div><div class=\"line\">  <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    tm.begin();<span class=\"comment\">// 重新开启第二个事务</span></div><div class=\"line\">    Transaction ts2 = tm.getTransaction();</div><div class=\"line\">    methodB();</div><div class=\"line\">    ts2.commit();<span class=\"comment\">// 提交第二个事务</span></div><div class=\"line\">  &#125; Catch(RunTimeException ex) &#123;</div><div class=\"line\">    ts2.rollback();<span class=\"comment\">// 回滚第二个事务</span></div><div class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 释放资源</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// methodB执行完后，恢复第一个事务</span></div><div class=\"line\">  tm.resume(ts1);</div><div class=\"line\">  doSomeThing2();</div><div class=\"line\">  ts1.commit();<span class=\"comment\">// 提交第一个事务</span></div><div class=\"line\">&#125; <span class=\"keyword\">catch</span>(RunTimeException ex) &#123;</div><div class=\"line\">  ts1.rollback();<span class=\"comment\">// 回滚第一个事务</span></div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// 释放资源</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的 ts1 和 ts2 是两个独立的事务，互不干扰， ts2 是否成功并不依赖于 ts1。如果 methodA 在调用 methodB 方法后的 doSomeThing2 发生异常，methodB 并不受影响结构依然没提交，但 methodA 的其他代码则会被回滚。</p>\n<p>使用 PROPAGATION_REQUIRES_NEW 需要使用 JtaTransactionManager 作为事务管理器。</p>\n<h5 id=\"PROPAGATION-NOT-SUPPORTED\"><a href=\"#PROPAGATION-NOT-SUPPORTED\" class=\"headerlink\" title=\"PROPAGATION_NOT_SUPPORTED\"></a>PROPAGATION_NOT_SUPPORTED</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  doSomeThing1();</div><div class=\"line\">  methodB();</div><div class=\"line\">  doSomeThing2();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.PROPAGATION_NOT_SUPPORTED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总是以非事务的形式执行，当 methodA 执行到 methodB(); 时先挂起事务，再执行 methodB(), 完成后再恢复 methodA 的事务继续执行 doSomeThing2 方法。</p>\n<p>使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。</p>\n<h5 id=\"PROPAGATION-NEVER\"><a href=\"#PROPAGATION-NEVER\" class=\"headerlink\" title=\"PROPAGATION_NEVER\"></a>PROPAGATION_NEVER</h5><p>总是非事务地执行，如果存在一个活动事务，则抛出异常。</p>\n<h5 id=\"PROPAGATION-NESTED\"><a href=\"#PROPAGATION-NESTED\" class=\"headerlink\" title=\"PROPAGATION_NESTED\"></a>PROPAGATION_NESTED</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  doSomeThing1();</div><div class=\"line\">  methodB();</div><div class=\"line\">  doSomeThing2();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Transactional</span>(propagation = Propagation.NEWSTED)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当调用 methodB() ，则按照 PROPAGATION_REQUIRED 执行，当前上下文不存在事务，methodB 开启一个新的事务</p>\n<p>当调用 methodA() 相当于执行了以下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">Connection con = <span class=\"keyword\">null</span>;</div><div class=\"line\">Savepoint savepoint = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">  con = getConnection();</div><div class=\"line\">  con.setAutoCommit(<span class=\"keyword\">false</span>);</div><div class=\"line\">  doSomeThing1();</div><div class=\"line\">  savepoint = con2.setSavepoint();</div><div class=\"line\">  <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    methodB();</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span>(RuntimeException ex) &#123;</div><div class=\"line\">    con.rollback(savepoint);</div><div class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//释放资源</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  doSomeThing2();</div><div class=\"line\">  con.commit();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span>(RuntimeException ex) &#123;</div><div class=\"line\">  con.rollback();</div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">  <span class=\"comment\">//释放资源</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在调用 methodB 之前，先调用 setSavepoint 方法，保存当前的状态到 savepoint。如果 methodB 执行失败，则恢复到  savepoint 保存的状态。</p>\n<p>如果外层事务执行失败，会回滚内层事务所做的动作；</p>\n<p>如果内层事务执行失败，不会引起外层事务的回滚；</p>\n<p>使用JDBC 3.0驱动时,仅仅支持 DataSourceTransactionManager 作为事务管理器，PlatformTransactionManager的nestedTransactionAllowed属性设为true(属性值默认为false)</p>\n<h3 id=\"TransactionStatus\"><a href=\"#TransactionStatus\" class=\"headerlink\" title=\"TransactionStatus\"></a>TransactionStatus</h3><p>维护，获取事务的各种状态</p>\n<h2 id=\"使用-Spring-事务\"><a href=\"#使用-Spring-事务\" class=\"headerlink\" title=\"使用 Spring 事务\"></a>使用 Spring 事务</h2><p>Spring 提供编程式和声明式的事务管理，具体的代码实现可以参考：<a href=\"https://github.com/zhanghTK/spring-tx-test\">spring-tx-test</a></p>\n"},{"title":"《Java并发编程实战》读书笔记","date":"2016-09-29T05:14:27.000Z","_content":"右键->新标签页中打开图片->放大预览\n![Java并发编程实战.png](https://ooo.0o0.ooo/2016/09/29/57eca40868441.png)\n","source":"_posts/《Java并发编程实战》读书笔记.md","raw":"---\ntitle: 《Java并发编程实战》读书笔记\ndate: 2016-09-29 13:14:27\ntags:\n  - Java\ncategories: 读书笔记\n---\n右键->新标签页中打开图片->放大预览\n![Java并发编程实战.png](https://ooo.0o0.ooo/2016/09/29/57eca40868441.png)\n","slug":"《Java并发编程实战》读书笔记","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2q7001vd82e4m5zgbgw","content":"<p>右键-&gt;新标签页中打开图片-&gt;放大预览<br><img src=\"https://ooo.0o0.ooo/2016/09/29/57eca40868441.png\" alt=\"Java并发编程实战.png\"></p>\n","excerpt":"","more":"<p>右键-&gt;新标签页中打开图片-&gt;放大预览<br><img src=\"https://ooo.0o0.ooo/2016/09/29/57eca40868441.png\" alt=\"Java并发编程实战.png\"></p>\n"},{"title":"ThreadLocal小记","date":"2016-09-11T11:33:39.000Z","_content":"\n# ThreadLocal\n\n最近《Java并发编程实战》第三章谈及了对象共享的问题。对共享的可变数据最简单粗暴的做法当然是同步，但是同步的缺点也很明显，代码复杂可维护性降低。针对这个问题，书上谈及到了通过线程封闭避免同步，其中的ThreadLocal类就是帮助维持线程封闭性的。\n\n之前对ThreadLocal的认识非常简单，就是把一个变量绑定到线程上。参照网上的例子自己也实现了类似功能的例子ThreadLocalVariable(https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。\n\n看JDK之前想当然的以为ThreadLocal应该就是简单对`Map<Thread, Object>`做一个封装，然而实际并没有这么简单。参照了网上一些文章的说法，早期的ThreadLocal确实是这样实现的。但是这样实现存在一些问题：\n\n1. 线程安全问题，如果使用线程安全的Map实现那么就会带来性能问题，当有大量的线程使用ThreadLocal，伴随着线程生命周期ThreadLocal也需要频繁向底层的Map添加删除数据。\n2. 内存回收问题，用Thread当key，除非手动调用remove，否则即使线程退出了会导致：1)该Thread对象无法回收；2)该线程在所有ThreadLocal中对应的value也无法回收。\n\nThreadLocal实际给出了不同的实现方式。首先绑定到线程的变量没有维护在ThreadLocal内，而是维护在各个Thread类实例内——在Thread类内使用了ThreadLocal的静态内部类`ThreadLocalMap`实例去维护需要绑定到线程的变量。这样原本需要维护在ThreadLocal内的数据现在就分散到了各个线程内去维护。\n\n\n\n在Thread中ThreadLocalMap的声明长这样：\n\n```java\n// 真的就只是声明了一下，什么都没干    \nThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n\n\nThreadLocal一共只有五个非私有的方法，首先是两个并没有什么卵用的方法：\n\n```java\n// 构造，什么都没干\npublic ThreadLocal() {}\n\n// 设置ThreadLocal的初始值，protected很明显是希望子类重写\nprotected T initialValue() {return null}\n```\n\n看看其余三个方法的实现（JDK8）\n\n```java\n    public T get() {\n        Thread t = Thread.currentThread();\n        // 从线程里获取ThreadLocalMap\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            // 根据ThreadLocal实例获取Entity\n            // 一会看ThreadLocal的实现\n            // 暂时可以看做类似Map<ThreadLocal,Object>\n            // 注意key类型是ThreadLocal，不是Thread\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        // 如果获得的map为null或者从map通过key获取的value为空时获取一个初始值\n        // setInitialValue方法里调用了initialValue方法\n        // 宝宝不管，反正宝宝想要有值，宝宝不想为null\n        return setInitialValue();\n    }\n\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            // 没什么说的set进去\n            map.set(this, value);\n        else\n            // 当map不存在时，使用初始值创建一个\n            createMap(t, value);\n    }\n\n     public void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             // 没什么说的，remove掉\n             m.remove(this);\n     }\n    \n    ThreadLocalMap getMap(Thread t) {\n        // 你给我一个线程，我换你一个map\n        return t.threadLocals;\n    }\n```\nThreadLocal所有的操作都是围绕着内部类ThreadLocalMap的，ThreadLocal只是让ThreadLocalMap更加容易访问。咦，有点耳熟，没错外观模式。\n\n下面看一下ThreadLocal的静态内部类ThreadLocalMap，JDK文档对它的描述主要集中在一下几点：\n\n1. 是什么：定制的hash map用于维护本地线程变量\n2. 可见性：ThreadLocal之外没有任何方法可访问，Thread类使用它定义了私有属性\n3. 特殊性：为了管理大对象、长生命周期对象，使用WeakReference包装ThreadLocal对象作为key\n\n前面两点没什么好说的，主要是第三点：key使用了弱引用类型管理（关于弱引用可以先参考https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。\n\n![image](http://img.blog.csdn.net/20160121000731607)\n\n图片来自互联网，实线表示强引用，虚线表示弱引用。\n\n简而言之，一个对象在没有强引用引用，只有弱引用引用时，当GC发生这个对象就会被标记回收。将ThreadLocal对象设置成弱引用作为key的好处是显而易见：当ThreadLocal没有任何强引用引用时，只有ThreadLocalMap的Entry对它存在弱引用，这样GC的时候这个ThreadLocal对象就可以被回收了。但是这又带来了一个问题：Entry的key可能被回收了，但留下了一个并没有什么卵用的value。只要线程生命周期不结束，那么这个value对象始终保持了一个强引用链条：\n\nThread Ref -> Thread -> ThreadLocalMap -> Entry -> value\n\n当内存有大量驻留的线程时，因为强引用存在，GC始终无法回收，就导致了内存泄漏。\n\n真对这个问题ThreadLocalMap在实现的时候也采取了一些防护措施，比如ThreadLocalMap的get（set，remove方法也类似，限于篇幅不展开了）：\n\n```java\n    private Entry getEntry(ThreadLocal<?> key) {\n        // hash函数获取索引位置\n        int i = key.threadLocalHashCode & (table.length - 1);\n        Entry e = table[i];\n        if (e != null && e.get() == key)\n            // 命中了\n            return e;\n        else\n            // miss了\n            return getEntryAfterMiss(key, i, e);\n    }\n\n    private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n        Entry[] tab = table;\n        int len = tab.length;\n\t\t\n        // 遍历table\n        while (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == key)\n                // 找到了\n                return e;\n            if (k == null)\n                // 发现key为空（也就是上面描述的内存泄漏的情况），做删除\n                expungeStaleEntry(i);\n            else\n                // 找下一个Entty位置\n                i = nextIndex(i, len);\n            e = tab[i];\n        }\n        return null;\n    }\n```\n\n在get的过程中凡是碰到了key为null的Entry，这个Entry就会被擦除，从而避免内存泄漏。类似的思路在set，remove方法中都有实现。针对内存泄漏问题ThreadLocal实际是需要手动触发函数删除key为null的Entry，所以当不要再需要一个变量当定到线程时手动的remove还是很有必要的。\n\n\n\n最后，在网上看到对ThreadLocal有多种说法：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。\n\n关于第一种说法我觉得是部分正确的，ThreadLocal将需要共享的对象封闭在了线程内确实解决了并发的一部分问题，但并不是万能的。比如重写initialValue方法时返回的是一个全局共享的对象，那实际上ThreadLocal只是把这个全局共享的对象又封装到了Thread对象里，ThreadLocal本身并没有做类似深拷贝的操作，因此这个变量依然是线程不安全的（逸出）。\n\n关于第二种说法，我觉得问题就比较大了。ThreadLocal根本不是为了线程间共享，实际是为了将状态封闭在线程内以确保线程安全。这样做确实带来了访问共享状态的便利，但这个状态的共享是在单个线程内的，而不是线程之间的。比如在action中将session对象绑定在线程内，在service、dao里都可以方便的共享，但所有的共享都是在单个的线程内部，而不是在多个的线程之间共享。\n\n\n\n参考资料：\n\n《Java并发编程实战》\n\nJDK8帮助手册\n\nhttp://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/\n\nhttp://my.oschina.net/xianggao/blog/392440#navbar-header\n","source":"_posts/ThreadLocal小记.md","raw":"---\ntitle: ThreadLocal小记\ndate: 2016-09-11 19:33:39\ntags: Java\ncategories: Java\n---\n\n# ThreadLocal\n\n最近《Java并发编程实战》第三章谈及了对象共享的问题。对共享的可变数据最简单粗暴的做法当然是同步，但是同步的缺点也很明显，代码复杂可维护性降低。针对这个问题，书上谈及到了通过线程封闭避免同步，其中的ThreadLocal类就是帮助维持线程封闭性的。\n\n之前对ThreadLocal的认识非常简单，就是把一个变量绑定到线程上。参照网上的例子自己也实现了类似功能的例子ThreadLocalVariable(https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。\n\n看JDK之前想当然的以为ThreadLocal应该就是简单对`Map<Thread, Object>`做一个封装，然而实际并没有这么简单。参照了网上一些文章的说法，早期的ThreadLocal确实是这样实现的。但是这样实现存在一些问题：\n\n1. 线程安全问题，如果使用线程安全的Map实现那么就会带来性能问题，当有大量的线程使用ThreadLocal，伴随着线程生命周期ThreadLocal也需要频繁向底层的Map添加删除数据。\n2. 内存回收问题，用Thread当key，除非手动调用remove，否则即使线程退出了会导致：1)该Thread对象无法回收；2)该线程在所有ThreadLocal中对应的value也无法回收。\n\nThreadLocal实际给出了不同的实现方式。首先绑定到线程的变量没有维护在ThreadLocal内，而是维护在各个Thread类实例内——在Thread类内使用了ThreadLocal的静态内部类`ThreadLocalMap`实例去维护需要绑定到线程的变量。这样原本需要维护在ThreadLocal内的数据现在就分散到了各个线程内去维护。\n\n\n\n在Thread中ThreadLocalMap的声明长这样：\n\n```java\n// 真的就只是声明了一下，什么都没干    \nThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n\n\nThreadLocal一共只有五个非私有的方法，首先是两个并没有什么卵用的方法：\n\n```java\n// 构造，什么都没干\npublic ThreadLocal() {}\n\n// 设置ThreadLocal的初始值，protected很明显是希望子类重写\nprotected T initialValue() {return null}\n```\n\n看看其余三个方法的实现（JDK8）\n\n```java\n    public T get() {\n        Thread t = Thread.currentThread();\n        // 从线程里获取ThreadLocalMap\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            // 根据ThreadLocal实例获取Entity\n            // 一会看ThreadLocal的实现\n            // 暂时可以看做类似Map<ThreadLocal,Object>\n            // 注意key类型是ThreadLocal，不是Thread\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        // 如果获得的map为null或者从map通过key获取的value为空时获取一个初始值\n        // setInitialValue方法里调用了initialValue方法\n        // 宝宝不管，反正宝宝想要有值，宝宝不想为null\n        return setInitialValue();\n    }\n\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            // 没什么说的set进去\n            map.set(this, value);\n        else\n            // 当map不存在时，使用初始值创建一个\n            createMap(t, value);\n    }\n\n     public void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             // 没什么说的，remove掉\n             m.remove(this);\n     }\n    \n    ThreadLocalMap getMap(Thread t) {\n        // 你给我一个线程，我换你一个map\n        return t.threadLocals;\n    }\n```\nThreadLocal所有的操作都是围绕着内部类ThreadLocalMap的，ThreadLocal只是让ThreadLocalMap更加容易访问。咦，有点耳熟，没错外观模式。\n\n下面看一下ThreadLocal的静态内部类ThreadLocalMap，JDK文档对它的描述主要集中在一下几点：\n\n1. 是什么：定制的hash map用于维护本地线程变量\n2. 可见性：ThreadLocal之外没有任何方法可访问，Thread类使用它定义了私有属性\n3. 特殊性：为了管理大对象、长生命周期对象，使用WeakReference包装ThreadLocal对象作为key\n\n前面两点没什么好说的，主要是第三点：key使用了弱引用类型管理（关于弱引用可以先参考https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。\n\n![image](http://img.blog.csdn.net/20160121000731607)\n\n图片来自互联网，实线表示强引用，虚线表示弱引用。\n\n简而言之，一个对象在没有强引用引用，只有弱引用引用时，当GC发生这个对象就会被标记回收。将ThreadLocal对象设置成弱引用作为key的好处是显而易见：当ThreadLocal没有任何强引用引用时，只有ThreadLocalMap的Entry对它存在弱引用，这样GC的时候这个ThreadLocal对象就可以被回收了。但是这又带来了一个问题：Entry的key可能被回收了，但留下了一个并没有什么卵用的value。只要线程生命周期不结束，那么这个value对象始终保持了一个强引用链条：\n\nThread Ref -> Thread -> ThreadLocalMap -> Entry -> value\n\n当内存有大量驻留的线程时，因为强引用存在，GC始终无法回收，就导致了内存泄漏。\n\n真对这个问题ThreadLocalMap在实现的时候也采取了一些防护措施，比如ThreadLocalMap的get（set，remove方法也类似，限于篇幅不展开了）：\n\n```java\n    private Entry getEntry(ThreadLocal<?> key) {\n        // hash函数获取索引位置\n        int i = key.threadLocalHashCode & (table.length - 1);\n        Entry e = table[i];\n        if (e != null && e.get() == key)\n            // 命中了\n            return e;\n        else\n            // miss了\n            return getEntryAfterMiss(key, i, e);\n    }\n\n    private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n        Entry[] tab = table;\n        int len = tab.length;\n\t\t\n        // 遍历table\n        while (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == key)\n                // 找到了\n                return e;\n            if (k == null)\n                // 发现key为空（也就是上面描述的内存泄漏的情况），做删除\n                expungeStaleEntry(i);\n            else\n                // 找下一个Entty位置\n                i = nextIndex(i, len);\n            e = tab[i];\n        }\n        return null;\n    }\n```\n\n在get的过程中凡是碰到了key为null的Entry，这个Entry就会被擦除，从而避免内存泄漏。类似的思路在set，remove方法中都有实现。针对内存泄漏问题ThreadLocal实际是需要手动触发函数删除key为null的Entry，所以当不要再需要一个变量当定到线程时手动的remove还是很有必要的。\n\n\n\n最后，在网上看到对ThreadLocal有多种说法：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。\n\n关于第一种说法我觉得是部分正确的，ThreadLocal将需要共享的对象封闭在了线程内确实解决了并发的一部分问题，但并不是万能的。比如重写initialValue方法时返回的是一个全局共享的对象，那实际上ThreadLocal只是把这个全局共享的对象又封装到了Thread对象里，ThreadLocal本身并没有做类似深拷贝的操作，因此这个变量依然是线程不安全的（逸出）。\n\n关于第二种说法，我觉得问题就比较大了。ThreadLocal根本不是为了线程间共享，实际是为了将状态封闭在线程内以确保线程安全。这样做确实带来了访问共享状态的便利，但这个状态的共享是在单个线程内的，而不是线程之间的。比如在action中将session对象绑定在线程内，在service、dao里都可以方便的共享，但所有的共享都是在单个的线程内部，而不是在多个的线程之间共享。\n\n\n\n参考资料：\n\n《Java并发编程实战》\n\nJDK8帮助手册\n\nhttp://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/\n\nhttp://my.oschina.net/xianggao/blog/392440#navbar-header\n","slug":"ThreadLocal小记","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2qc001yd82et1vz5d3u","content":"<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><p>最近《Java并发编程实战》第三章谈及了对象共享的问题。对共享的可变数据最简单粗暴的做法当然是同步，但是同步的缺点也很明显，代码复杂可维护性降低。针对这个问题，书上谈及到了通过线程封闭避免同步，其中的ThreadLocal类就是帮助维持线程封闭性的。</p>\n<p>之前对ThreadLocal的认识非常简单，就是把一个变量绑定到线程上。参照网上的例子自己也实现了类似功能的例子ThreadLocalVariable(<a href=\"https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。\" target=\"_blank\" rel=\"external\">https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。</a></p>\n<p>看JDK之前想当然的以为ThreadLocal应该就是简单对<code>Map&lt;Thread, Object&gt;</code>做一个封装，然而实际并没有这么简单。参照了网上一些文章的说法，早期的ThreadLocal确实是这样实现的。但是这样实现存在一些问题：</p>\n<ol>\n<li>线程安全问题，如果使用线程安全的Map实现那么就会带来性能问题，当有大量的线程使用ThreadLocal，伴随着线程生命周期ThreadLocal也需要频繁向底层的Map添加删除数据。</li>\n<li>内存回收问题，用Thread当key，除非手动调用remove，否则即使线程退出了会导致：1)该Thread对象无法回收；2)该线程在所有ThreadLocal中对应的value也无法回收。</li>\n</ol>\n<p>ThreadLocal实际给出了不同的实现方式。首先绑定到线程的变量没有维护在ThreadLocal内，而是维护在各个Thread类实例内——在Thread类内使用了ThreadLocal的静态内部类<code>ThreadLocalMap</code>实例去维护需要绑定到线程的变量。这样原本需要维护在ThreadLocal内的数据现在就分散到了各个线程内去维护。</p>\n<p>在Thread中ThreadLocalMap的声明长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 真的就只是声明了一下，什么都没干    </span></div><div class=\"line\">ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</div></pre></td></tr></table></figure>\n<p>ThreadLocal一共只有五个非私有的方法，首先是两个并没有什么卵用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 构造，什么都没干</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadLocal</span><span class=\"params\">()</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置ThreadLocal的初始值，protected很明显是希望子类重写</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>&#125;</div></pre></td></tr></table></figure>\n<p>看看其余三个方法的实现（JDK8）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Thread t = Thread.currentThread();</div><div class=\"line\">    <span class=\"comment\">// 从线程里获取ThreadLocalMap</span></div><div class=\"line\">    ThreadLocalMap map = getMap(t);</div><div class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 根据ThreadLocal实例获取Entity</span></div><div class=\"line\">        <span class=\"comment\">// 一会看ThreadLocal的实现</span></div><div class=\"line\">        <span class=\"comment\">// 暂时可以看做类似Map&lt;ThreadLocal,Object&gt;</span></div><div class=\"line\">        <span class=\"comment\">// 注意key类型是ThreadLocal，不是Thread</span></div><div class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</div><div class=\"line\">            T result = (T)e.value;</div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 如果获得的map为null或者从map通过key获取的value为空时获取一个初始值</span></div><div class=\"line\">    <span class=\"comment\">// setInitialValue方法里调用了initialValue方法</span></div><div class=\"line\">    <span class=\"comment\">// 宝宝不管，反正宝宝想要有值，宝宝不想为null</span></div><div class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">    Thread t = Thread.currentThread();</div><div class=\"line\">    ThreadLocalMap map = getMap(t);</div><div class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"comment\">// 没什么说的set进去</span></div><div class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"comment\">// 当map不存在时，使用初始值创建一个</span></div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     ThreadLocalMap m = getMap(Thread.currentThread());</div><div class=\"line\">     <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</div><div class=\"line\">         <span class=\"comment\">// 没什么说的，remove掉</span></div><div class=\"line\">         m.remove(<span class=\"keyword\">this</span>);</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 你给我一个线程，我换你一个map</span></div><div class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ThreadLocal所有的操作都是围绕着内部类ThreadLocalMap的，ThreadLocal只是让ThreadLocalMap更加容易访问。咦，有点耳熟，没错外观模式。</p>\n<p>下面看一下ThreadLocal的静态内部类ThreadLocalMap，JDK文档对它的描述主要集中在一下几点：</p>\n<ol>\n<li>是什么：定制的hash map用于维护本地线程变量</li>\n<li>可见性：ThreadLocal之外没有任何方法可访问，Thread类使用它定义了私有属性</li>\n<li>特殊性：为了管理大对象、长生命周期对象，使用WeakReference包装ThreadLocal对象作为key</li>\n</ol>\n<p>前面两点没什么好说的，主要是第三点：key使用了弱引用类型管理（关于弱引用可以先参考<a href=\"https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。\" target=\"_blank\" rel=\"external\">https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。</a></p>\n<p><img src=\"http://img.blog.csdn.net/20160121000731607\" alt=\"image\"></p>\n<p>图片来自互联网，实线表示强引用，虚线表示弱引用。</p>\n<p>简而言之，一个对象在没有强引用引用，只有弱引用引用时，当GC发生这个对象就会被标记回收。将ThreadLocal对象设置成弱引用作为key的好处是显而易见：当ThreadLocal没有任何强引用引用时，只有ThreadLocalMap的Entry对它存在弱引用，这样GC的时候这个ThreadLocal对象就可以被回收了。但是这又带来了一个问题：Entry的key可能被回收了，但留下了一个并没有什么卵用的value。只要线程生命周期不结束，那么这个value对象始终保持了一个强引用链条：</p>\n<p>Thread Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</p>\n<p>当内存有大量驻留的线程时，因为强引用存在，GC始终无法回收，就导致了内存泄漏。</p>\n<p>真对这个问题ThreadLocalMap在实现的时候也采取了一些防护措施，比如ThreadLocalMap的get（set，remove方法也类似，限于篇幅不展开了）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// hash函数获取索引位置</span></div><div class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</div><div class=\"line\">    Entry e = table[i];</div><div class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</div><div class=\"line\">        <span class=\"comment\">// 命中了</span></div><div class=\"line\">        <span class=\"keyword\">return</span> e;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"comment\">// miss了</span></div><div class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</div><div class=\"line\">    Entry[] tab = table;</div><div class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</div><div class=\"line\">\t\t</div><div class=\"line\">    <span class=\"comment\">// 遍历table</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</div><div class=\"line\">        <span class=\"keyword\">if</span> (k == key)</div><div class=\"line\">            <span class=\"comment\">// 找到了</span></div><div class=\"line\">            <span class=\"keyword\">return</span> e;</div><div class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"comment\">// 发现key为空（也就是上面描述的内存泄漏的情况），做删除</span></div><div class=\"line\">            expungeStaleEntry(i);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"comment\">// 找下一个Entty位置</span></div><div class=\"line\">            i = nextIndex(i, len);</div><div class=\"line\">        e = tab[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在get的过程中凡是碰到了key为null的Entry，这个Entry就会被擦除，从而避免内存泄漏。类似的思路在set，remove方法中都有实现。针对内存泄漏问题ThreadLocal实际是需要手动触发函数删除key为null的Entry，所以当不要再需要一个变量当定到线程时手动的remove还是很有必要的。</p>\n<p>最后，在网上看到对ThreadLocal有多种说法：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。</p>\n<p>关于第一种说法我觉得是部分正确的，ThreadLocal将需要共享的对象封闭在了线程内确实解决了并发的一部分问题，但并不是万能的。比如重写initialValue方法时返回的是一个全局共享的对象，那实际上ThreadLocal只是把这个全局共享的对象又封装到了Thread对象里，ThreadLocal本身并没有做类似深拷贝的操作，因此这个变量依然是线程不安全的（逸出）。</p>\n<p>关于第二种说法，我觉得问题就比较大了。ThreadLocal根本不是为了线程间共享，实际是为了将状态封闭在线程内以确保线程安全。这样做确实带来了访问共享状态的便利，但这个状态的共享是在单个线程内的，而不是线程之间的。比如在action中将session对象绑定在线程内，在service、dao里都可以方便的共享，但所有的共享都是在单个的线程内部，而不是在多个的线程之间共享。</p>\n<p>参考资料：</p>\n<p>《Java并发编程实战》</p>\n<p>JDK8帮助手册</p>\n<p><a href=\"http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/\" target=\"_blank\" rel=\"external\">http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/</a></p>\n<p><a href=\"http://my.oschina.net/xianggao/blog/392440#navbar-header\" target=\"_blank\" rel=\"external\">http://my.oschina.net/xianggao/blog/392440#navbar-header</a></p>\n","excerpt":"","more":"<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><p>最近《Java并发编程实战》第三章谈及了对象共享的问题。对共享的可变数据最简单粗暴的做法当然是同步，但是同步的缺点也很明显，代码复杂可维护性降低。针对这个问题，书上谈及到了通过线程封闭避免同步，其中的ThreadLocal类就是帮助维持线程封闭性的。</p>\n<p>之前对ThreadLocal的认识非常简单，就是把一个变量绑定到线程上。参照网上的例子自己也实现了类似功能的例子ThreadLocalVariable(<a href=\"https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。\">https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/thread/ThreadLocalVariable.java)，但总的来说没什么体会。今天参照别人的文章看了一下ThreadLocal的实现，发现还是有蛮多注意点的。</a></p>\n<p>看JDK之前想当然的以为ThreadLocal应该就是简单对<code>Map&lt;Thread, Object&gt;</code>做一个封装，然而实际并没有这么简单。参照了网上一些文章的说法，早期的ThreadLocal确实是这样实现的。但是这样实现存在一些问题：</p>\n<ol>\n<li>线程安全问题，如果使用线程安全的Map实现那么就会带来性能问题，当有大量的线程使用ThreadLocal，伴随着线程生命周期ThreadLocal也需要频繁向底层的Map添加删除数据。</li>\n<li>内存回收问题，用Thread当key，除非手动调用remove，否则即使线程退出了会导致：1)该Thread对象无法回收；2)该线程在所有ThreadLocal中对应的value也无法回收。</li>\n</ol>\n<p>ThreadLocal实际给出了不同的实现方式。首先绑定到线程的变量没有维护在ThreadLocal内，而是维护在各个Thread类实例内——在Thread类内使用了ThreadLocal的静态内部类<code>ThreadLocalMap</code>实例去维护需要绑定到线程的变量。这样原本需要维护在ThreadLocal内的数据现在就分散到了各个线程内去维护。</p>\n<p>在Thread中ThreadLocalMap的声明长这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 真的就只是声明了一下，什么都没干    </span></div><div class=\"line\">ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</div></pre></td></tr></table></figure>\n<p>ThreadLocal一共只有五个非私有的方法，首先是两个并没有什么卵用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 构造，什么都没干</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadLocal</span><span class=\"params\">()</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置ThreadLocal的初始值，protected很明显是希望子类重写</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>&#125;</div></pre></td></tr></table></figure>\n<p>看看其余三个方法的实现（JDK8）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Thread t = Thread.currentThread();</div><div class=\"line\">    <span class=\"comment\">// 从线程里获取ThreadLocalMap</span></div><div class=\"line\">    ThreadLocalMap map = getMap(t);</div><div class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 根据ThreadLocal实例获取Entity</span></div><div class=\"line\">        <span class=\"comment\">// 一会看ThreadLocal的实现</span></div><div class=\"line\">        <span class=\"comment\">// 暂时可以看做类似Map&lt;ThreadLocal,Object&gt;</span></div><div class=\"line\">        <span class=\"comment\">// 注意key类型是ThreadLocal，不是Thread</span></div><div class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</div><div class=\"line\">            T result = (T)e.value;</div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 如果获得的map为null或者从map通过key获取的value为空时获取一个初始值</span></div><div class=\"line\">    <span class=\"comment\">// setInitialValue方法里调用了initialValue方法</span></div><div class=\"line\">    <span class=\"comment\">// 宝宝不管，反正宝宝想要有值，宝宝不想为null</span></div><div class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">    Thread t = Thread.currentThread();</div><div class=\"line\">    ThreadLocalMap map = getMap(t);</div><div class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"comment\">// 没什么说的set进去</span></div><div class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"comment\">// 当map不存在时，使用初始值创建一个</span></div><div class=\"line\">        createMap(t, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     ThreadLocalMap m = getMap(Thread.currentThread());</div><div class=\"line\">     <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</div><div class=\"line\">         <span class=\"comment\">// 没什么说的，remove掉</span></div><div class=\"line\">         m.remove(<span class=\"keyword\">this</span>);</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 你给我一个线程，我换你一个map</span></div><div class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ThreadLocal所有的操作都是围绕着内部类ThreadLocalMap的，ThreadLocal只是让ThreadLocalMap更加容易访问。咦，有点耳熟，没错外观模式。</p>\n<p>下面看一下ThreadLocal的静态内部类ThreadLocalMap，JDK文档对它的描述主要集中在一下几点：</p>\n<ol>\n<li>是什么：定制的hash map用于维护本地线程变量</li>\n<li>可见性：ThreadLocal之外没有任何方法可访问，Thread类使用它定义了私有属性</li>\n<li>特殊性：为了管理大对象、长生命周期对象，使用WeakReference包装ThreadLocal对象作为key</li>\n</ol>\n<p>前面两点没什么好说的，主要是第三点：key使用了弱引用类型管理（关于弱引用可以先参考<a href=\"https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。\">https://github.com/zhanghTK/HelloJava/blob/master/src/main/java/tk/zhangh/java/jvm/reference/ReferenceTest.java，后面我会单独写文章记录Java引用的使用，先挖个坑）。</a></p>\n<p><img src=\"http://img.blog.csdn.net/20160121000731607\" alt=\"image\"></p>\n<p>图片来自互联网，实线表示强引用，虚线表示弱引用。</p>\n<p>简而言之，一个对象在没有强引用引用，只有弱引用引用时，当GC发生这个对象就会被标记回收。将ThreadLocal对象设置成弱引用作为key的好处是显而易见：当ThreadLocal没有任何强引用引用时，只有ThreadLocalMap的Entry对它存在弱引用，这样GC的时候这个ThreadLocal对象就可以被回收了。但是这又带来了一个问题：Entry的key可能被回收了，但留下了一个并没有什么卵用的value。只要线程生命周期不结束，那么这个value对象始终保持了一个强引用链条：</p>\n<p>Thread Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</p>\n<p>当内存有大量驻留的线程时，因为强引用存在，GC始终无法回收，就导致了内存泄漏。</p>\n<p>真对这个问题ThreadLocalMap在实现的时候也采取了一些防护措施，比如ThreadLocalMap的get（set，remove方法也类似，限于篇幅不展开了）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// hash函数获取索引位置</span></div><div class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</div><div class=\"line\">    Entry e = table[i];</div><div class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</div><div class=\"line\">        <span class=\"comment\">// 命中了</span></div><div class=\"line\">        <span class=\"keyword\">return</span> e;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"comment\">// miss了</span></div><div class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</div><div class=\"line\">    Entry[] tab = table;</div><div class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</div><div class=\"line\">\t\t</div><div class=\"line\">    <span class=\"comment\">// 遍历table</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</div><div class=\"line\">        <span class=\"keyword\">if</span> (k == key)</div><div class=\"line\">            <span class=\"comment\">// 找到了</span></div><div class=\"line\">            <span class=\"keyword\">return</span> e;</div><div class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"comment\">// 发现key为空（也就是上面描述的内存泄漏的情况），做删除</span></div><div class=\"line\">            expungeStaleEntry(i);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"comment\">// 找下一个Entty位置</span></div><div class=\"line\">            i = nextIndex(i, len);</div><div class=\"line\">        e = tab[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在get的过程中凡是碰到了key为null的Entry，这个Entry就会被擦除，从而避免内存泄漏。类似的思路在set，remove方法中都有实现。针对内存泄漏问题ThreadLocal实际是需要手动触发函数删除key为null的Entry，所以当不要再需要一个变量当定到线程时手动的remove还是很有必要的。</p>\n<p>最后，在网上看到对ThreadLocal有多种说法：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。</p>\n<p>关于第一种说法我觉得是部分正确的，ThreadLocal将需要共享的对象封闭在了线程内确实解决了并发的一部分问题，但并不是万能的。比如重写initialValue方法时返回的是一个全局共享的对象，那实际上ThreadLocal只是把这个全局共享的对象又封装到了Thread对象里，ThreadLocal本身并没有做类似深拷贝的操作，因此这个变量依然是线程不安全的（逸出）。</p>\n<p>关于第二种说法，我觉得问题就比较大了。ThreadLocal根本不是为了线程间共享，实际是为了将状态封闭在线程内以确保线程安全。这样做确实带来了访问共享状态的便利，但这个状态的共享是在单个线程内的，而不是线程之间的。比如在action中将session对象绑定在线程内，在service、dao里都可以方便的共享，但所有的共享都是在单个的线程内部，而不是在多个的线程之间共享。</p>\n<p>参考资料：</p>\n<p>《Java并发编程实战》</p>\n<p>JDK8帮助手册</p>\n<p><a href=\"http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/\">http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/</a></p>\n<p><a href=\"http://my.oschina.net/xianggao/blog/392440#navbar-header\">http://my.oschina.net/xianggao/blog/392440#navbar-header</a></p>\n"},{"title":"《函数式编程思维》读书笔记","date":"2016-08-27T14:20:48.000Z","_content":"\n![函数式编程思维.png](http://i2.buimg.com/4851/efe49260863d5566.png)","source":"_posts/《函数式编程思维》读书笔记.md","raw":"---\ntitle: 《函数式编程思维》读书笔记\ndate: 2016-08-27 22:20:48\ntags:\n  - Functional\ncategories: 读书笔记\n---\n\n![函数式编程思维.png](http://i2.buimg.com/4851/efe49260863d5566.png)","slug":"《函数式编程思维》读书笔记","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2qg0022d82e7ss7z2kb","content":"<p><img src=\"http://i2.buimg.com/4851/efe49260863d5566.png\" alt=\"函数式编程思维.png\"></p>\n","excerpt":"","more":"<p><img src=\"http://i2.buimg.com/4851/efe49260863d5566.png\" alt=\"函数式编程思维.png\"></p>\n"},{"title":"【MQ】可靠消息","date":"2017-12-08T13:55:53.000Z","_content":"\n初始【MQ】最后说到默认情况下，消息发送后 MQ 不会向发送方确认消息到达，也不会进行持久化处理。即在发送方眼里消息只要发出去，就不再关心消息消息了。这确实做到了生产者与 MQ 的解耦，并且效率很高。但缺点也非常明显，无法确定消息投递是可靠的：\n\n- 正在运行的 MQ 宕机后，无法恢复已发送的消息（持久化问题）\n- 没有匹配的 queue，那么消息将被 exchange 直接丢弃，而发送方对此毫不知情（确认问题）\n- 消息发送过程中在网络中丢失，发送方毫不知情（确认问题）\n\nRabbit MQ 是被设计为金融行业服务的，在这些方面当然有考虑。本文将从持久化和消息确认两方面来了解 Rabbit MQ 的可靠消息实践。\n\n## 持久化\n\n为了确保消息在 MQ 各个环节的不丢失，需要将 exchange, queue, 投递方式都进行持久化声明。具体持久化的方式很简单，调用 API 就可以了。\n\n### exchange 持久化\n\nexchange 声明时，将 durable 设置为 true 就可以了。这顺便看一下 exchange 创建方法\n\n```java\nExchange.DeclareOk exchangeDeclare(String exchange, String type, boolean durable) \n  throws IOException;\n\nExchange.DeclareOk exchangeDeclare(String exchange, String type, boolean durable, \n                                   boolean autoDelete,Map<String, Object> arguments) \n  throws IOException;\n\nExchange.DeclareOk exchangeDeclare(String exchange, String type) \n  throws IOException;\n\nExchange.DeclareOk exchangeDeclare(String exchange,  // 交换器名称\n                                   String type,  // 交换器类型\n                                   boolean durable, // 是否持久化\n                                   boolean autoDelete,  // 是否自动删除\n                                   boolean internal,  // 内部\n                                   Map<String, Object> arguments  // 其他构造参数\n                                  ) throws IOException;\n\n// 等价于 exchangeDeclare 方法设置 nowait 参数\nvoid exchangeDeclareNoWait(String exchange, String type, boolean durable, boolean autoDelete,\n                           boolean internal, Map<String, Object> arguments) \n  throws IOException;\n\n// 被动声明队列，声明前先检查\nExchange.DeclareOk exchangeDeclarePassive(String name) throws IOException;\n\n```\n\nexchange 声明持久化后只能确保重启后 exchange 重新创建。否则 exchange 将丢失，生产者就无法正常发送消息了。\n\n### queue 持久化\n\nqueue 持久化也是一样的套路，将 durable 设置为 true 就可以了。queue 创建的 AIP：\n\n```java\nQueue.DeclareOk queueDeclare() throws IOException;\n\nQueue.DeclareOk queueDeclare(String queue,  // queue 名称 \n                             boolean durable,  // 持久化\n                             boolean exclusive,  // 排他队列\n                             boolean autoDelete,  // 自动删除\n                             Map<String, Object> arguments  // 其他构造参数\n                            ) throws IOException;\n\nvoid queueDeclareNoWait(String queue, boolean durable, boolean exclusive, boolean autoDelete, \n                        Map<String, Object> arguments) throws IOException;\n\nQueue.DeclareOk queueDeclarePassive(String queue) throws IOException;\n```\n\n对 durable 没什么好说的，确保重启后 queue 重新创建，但消息无法恢复，消息的持久化依赖于投递方式的持久化。\n\n注意一下 exclusive 参数：一个队列被声明为排他队列，该队列仅对首次申明它的连接可见，并在连接断开时自动删除：\n\n1. 排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一连接创建的排他队列；\n2. “首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；\n3. 即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。\n\n### 投递方式持久化声明\n\n套路基本一致，还是看 API：\n\n```java\nvoid basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) \n  throws IOException;\n\nvoid basicPublish(String exchange, String routingKey, boolean mandatory, BasicProperties props,\n                  byte[] body)throws IOException;\n\nvoid basicPublish(String exchange,  // 交换器\n                  String routingKey,  // routing key\n                  boolean mandatory,  // 消息确认\n                  boolean immediate,  // 废弃\n                  BasicProperties props,  // 参数\n                  byte[] body  // 消息有效负载\n                 ) throws IOException;\n```\n\n持久化的参数包含在 BasicProperties 定义中：\n\n```java\npublic static class BasicProperties extends AMQBasicProperties {\n    private String contentType;  // 消息类型\n    private String contentEncoding;  // 编码\n    private Map<String, Object> headers;\n    private Integer deliveryMode;  // 持久化。1：非持久化；2：持久化\n    private Integer priority;  // 优先级\n    private String correlationId;\n    private String replyTo;  // 反馈队列\n    private String expiration;  // expiration到期时间\n    private String messageId;\n    private Date timestamp;\n    private String type;\n    private String userId;\n    private String appId;\n    private String clusterId;\n    // 省略方法   \n}    \n```\n\nBasicProperties 的构造除了提供默认的方法外，对常用的参数可以直接获得，还支持使用 builder 模式构造。\n\n**如果单独持久化投递方式，重启后因为交换器、队列已不存在所以毫无意义**\n\n### 持久化的影响\n\n- 性能\n\n  《Rabbit MQ 实战》 一书在说明持久化对性能影响时，举例：“使用持久化机制而导致消息吞吐量降低至少 10 倍的情况并不少见”。这个说法还是很让我震惊的，很好奇 Rabbit MQ 的持久化策略是怎么做的影响这么大，还是说非持久化策略太优秀了，以至于磁盘性能极大影响了整体吞吐量。这里挖个坑，争取以后看看内部实现吧，毕竟 erlang 对我是个大问题。\n\n- 集群模式下工作的不好\n\n  暂时不清楚集群模式下的影响，先 mark 一下\n\n- 依旧无法 100% 数据不丢失\n\n  即使 exchange，queue，投递方式都进行持久化声明依旧不能做到 100% 数据不丢失，原因有二：\n\n  1. Rabbit MQ 不是为每条消息进行 fsync（同步 IO） 处理\n\n     依旧可能出现挂掉时有消息没有持久化的情况，解决有两种方式：镜像队列和消息确认\n\n  2. 看到网上有提到 erlang 写文件的实时问题，不懂，先 mark，待求证\n\n## 消息确认\n\n消息确认可以分为生产者确认消息正确投递和消费者确认消息正确接收，对  Rabbit MQ 有三种更具体的情况：\n\n- confire/事务：确认消息到达 broker，避免消息在生产者发出后丢失\n- 客户端 ACK：确认消费者接收消息，避免消息在消息队列发出后丢失\n- mandatory/immediate：确认消息到达队列，避免到达交换器后找不到队列而丢弃\n\n### 事务/confire\n\n#### 事务\n\n确认消息成功被 exchange 接收。事务是 AMQP 协议内定义的， Rabbit MQ 也做了相应的实现。与事务相关有三个方法，具体使用的模板：\n\n```java\ntry {\n  channel.txSelect();\n  channel.basicPublish(...);\n  channel.txCommit();\n} catch (Exception e) {\n  e.printStackTrace();\n  channel.txRollback();\n}\n```\n\n事务缺点：最大的问题是执行前后需要开启事务，提交/回滚事务，而这几个过程又必须是同步的因此会造成很大的性能问题\n\n#### confire\n\nconfire 是 Rabbit MQ 为解决事务性能问题设计的确认机制，主要的做法是为每条消息都设置唯一 ID 且 ID 以 1  为步长生序，MQ 通过发送 ACK, NACK 异步确认消息是否到达交换器。\n\n网上普遍对 confire 的描述都集中在异步性上。除了异步，可以设置 basic.ack 的 multiple 域进行累计确认，这有点 TCP 的确认方式。\n\nconfire 最大的问题是无法回滚，导致生产者本身也不确定消息是否放成功。如果程序需要实现类似回滚功能，则维护一个 unconfire 消息的集合，每次收到 ACK/NACK 时更新集合（还需要考虑是否是累计确认）\n\n我使用了三种方式实现 confire 并进行对比：\n\n- 对每条消息要求接收对应的 confire 消息\n- 对一组消息要求接收一条 confire 消息\n- 使用监听器完全异步的接收 confire 消息\n\n不出意外的第三种方式的性能是最好的。\n\n### 客户端 ACK\n\n声明队列时指定 noAck 参数：\n\n- noAck=false：Rabbit MQ 向消费者发出消息后等待消费者显式发出 ack 信号后才移除消息\n- noAck=true：Rabbit MQ 向消费者发出消息后立即移除消息\n\n当设置队列 noAck 为 false 时，客户端必须根据消息的处理情况向 MQ 反馈，默认情况下 会自动确认。如果希望手动确认需要关闭自动确认。\n\n客户端除了 ACK 为还可以向 MQ 反馈其他信息，反馈的 API 分别有：\n\n- channel.basicAck：向 MQ 确认消息正确接收\n- channel.basicRecover：向 MQ 确认消息需要重发，可以根据参数重发给当前消费者或重新入队\n- channel.basicReject：向 MQ 确认消息退回\n- channel.basicNack：向 MQ 确认批量退回消息，可以根据参数选择是否批量\n\n### mandatory/immediate\n\n#### mandatory\n\nmandatory 设置为 true 时：MQ 至少将该消息路由到至少一个队列中，否则将消息返还给生产者\n\nmandatory 实现时只需要：\n\n1. 投递消息时设置 mandatory 参数为true\n\n   ```java\n   void basicPublish(String exchange,  // 交换器\n                 String routingKey,  // routing key\n                 boolean mandatory,  // 消息确认\n                 boolean immediate,  // 废弃\n                 BasicProperties props,  // 参数\n                 byte[] body  // 消息有效负载\n                ) throws IOException;\n   ```\n\n2. 设置监听器\n\n   ```java\n   channel.addReturnListener(new ReturnListener() {\n       public void handleReturn(int replyCode, String replyText, String exchange,\n                                String routingKey, AMQP.BasicProperties basicProperties,\n                                byte[] body) throws IOException {\n                                  // TODO\n                                }\n   });\n   ```\n\n当消息没有被正确路由到至少一个队列时，AMQP协议会返回对应消息，监听器内的代码将被调用；\n\n**当消息正确投递，什么也不发生**\n\n#### immediate\n\n**Rabbit MQ 3.0 之后已移除**。设置为 true 时：消息路由到 queue 前，如果 queue 有消费者，则马上将消息投递给 queue，否则直接把消息返还给生产者，消息不再入队。\n\n---\n\n参考：\n\n《Rabbit MQ 实战》\n\n[RabbitMQ(二)：mandatory标志的作用](http://www.cnblogs.com/520playboy/p/6925196.html)\n\n[RabbitMQ：Publisher的消息确认机制](https://github.com/pzxwhc/MineKnowContainer/issues/49)\n\n[RabbitMQ之mandatory和immediate](http://blog.csdn.net/u013256816/article/details/54914525)\n\n [RabbitMQ之消息确认机制（事务+Confirm）](http://blog.csdn.net/u013256816/article/details/55515234)\n\n[rabbitMq生产者角度:消息持久化、事务机制、PublisherConfirm、mandatory](http://blog.csdn.net/u014045580/article/details/70311746)\n","source":"_posts/【MQ】可靠消息.md","raw":"---\ntitle: 【MQ】可靠消息\ndate: 2017-12-08 21:55:53\ntags: MQ\ncategories: MQ\n---\n\n初始【MQ】最后说到默认情况下，消息发送后 MQ 不会向发送方确认消息到达，也不会进行持久化处理。即在发送方眼里消息只要发出去，就不再关心消息消息了。这确实做到了生产者与 MQ 的解耦，并且效率很高。但缺点也非常明显，无法确定消息投递是可靠的：\n\n- 正在运行的 MQ 宕机后，无法恢复已发送的消息（持久化问题）\n- 没有匹配的 queue，那么消息将被 exchange 直接丢弃，而发送方对此毫不知情（确认问题）\n- 消息发送过程中在网络中丢失，发送方毫不知情（确认问题）\n\nRabbit MQ 是被设计为金融行业服务的，在这些方面当然有考虑。本文将从持久化和消息确认两方面来了解 Rabbit MQ 的可靠消息实践。\n\n## 持久化\n\n为了确保消息在 MQ 各个环节的不丢失，需要将 exchange, queue, 投递方式都进行持久化声明。具体持久化的方式很简单，调用 API 就可以了。\n\n### exchange 持久化\n\nexchange 声明时，将 durable 设置为 true 就可以了。这顺便看一下 exchange 创建方法\n\n```java\nExchange.DeclareOk exchangeDeclare(String exchange, String type, boolean durable) \n  throws IOException;\n\nExchange.DeclareOk exchangeDeclare(String exchange, String type, boolean durable, \n                                   boolean autoDelete,Map<String, Object> arguments) \n  throws IOException;\n\nExchange.DeclareOk exchangeDeclare(String exchange, String type) \n  throws IOException;\n\nExchange.DeclareOk exchangeDeclare(String exchange,  // 交换器名称\n                                   String type,  // 交换器类型\n                                   boolean durable, // 是否持久化\n                                   boolean autoDelete,  // 是否自动删除\n                                   boolean internal,  // 内部\n                                   Map<String, Object> arguments  // 其他构造参数\n                                  ) throws IOException;\n\n// 等价于 exchangeDeclare 方法设置 nowait 参数\nvoid exchangeDeclareNoWait(String exchange, String type, boolean durable, boolean autoDelete,\n                           boolean internal, Map<String, Object> arguments) \n  throws IOException;\n\n// 被动声明队列，声明前先检查\nExchange.DeclareOk exchangeDeclarePassive(String name) throws IOException;\n\n```\n\nexchange 声明持久化后只能确保重启后 exchange 重新创建。否则 exchange 将丢失，生产者就无法正常发送消息了。\n\n### queue 持久化\n\nqueue 持久化也是一样的套路，将 durable 设置为 true 就可以了。queue 创建的 AIP：\n\n```java\nQueue.DeclareOk queueDeclare() throws IOException;\n\nQueue.DeclareOk queueDeclare(String queue,  // queue 名称 \n                             boolean durable,  // 持久化\n                             boolean exclusive,  // 排他队列\n                             boolean autoDelete,  // 自动删除\n                             Map<String, Object> arguments  // 其他构造参数\n                            ) throws IOException;\n\nvoid queueDeclareNoWait(String queue, boolean durable, boolean exclusive, boolean autoDelete, \n                        Map<String, Object> arguments) throws IOException;\n\nQueue.DeclareOk queueDeclarePassive(String queue) throws IOException;\n```\n\n对 durable 没什么好说的，确保重启后 queue 重新创建，但消息无法恢复，消息的持久化依赖于投递方式的持久化。\n\n注意一下 exclusive 参数：一个队列被声明为排他队列，该队列仅对首次申明它的连接可见，并在连接断开时自动删除：\n\n1. 排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一连接创建的排他队列；\n2. “首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；\n3. 即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。\n\n### 投递方式持久化声明\n\n套路基本一致，还是看 API：\n\n```java\nvoid basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) \n  throws IOException;\n\nvoid basicPublish(String exchange, String routingKey, boolean mandatory, BasicProperties props,\n                  byte[] body)throws IOException;\n\nvoid basicPublish(String exchange,  // 交换器\n                  String routingKey,  // routing key\n                  boolean mandatory,  // 消息确认\n                  boolean immediate,  // 废弃\n                  BasicProperties props,  // 参数\n                  byte[] body  // 消息有效负载\n                 ) throws IOException;\n```\n\n持久化的参数包含在 BasicProperties 定义中：\n\n```java\npublic static class BasicProperties extends AMQBasicProperties {\n    private String contentType;  // 消息类型\n    private String contentEncoding;  // 编码\n    private Map<String, Object> headers;\n    private Integer deliveryMode;  // 持久化。1：非持久化；2：持久化\n    private Integer priority;  // 优先级\n    private String correlationId;\n    private String replyTo;  // 反馈队列\n    private String expiration;  // expiration到期时间\n    private String messageId;\n    private Date timestamp;\n    private String type;\n    private String userId;\n    private String appId;\n    private String clusterId;\n    // 省略方法   \n}    \n```\n\nBasicProperties 的构造除了提供默认的方法外，对常用的参数可以直接获得，还支持使用 builder 模式构造。\n\n**如果单独持久化投递方式，重启后因为交换器、队列已不存在所以毫无意义**\n\n### 持久化的影响\n\n- 性能\n\n  《Rabbit MQ 实战》 一书在说明持久化对性能影响时，举例：“使用持久化机制而导致消息吞吐量降低至少 10 倍的情况并不少见”。这个说法还是很让我震惊的，很好奇 Rabbit MQ 的持久化策略是怎么做的影响这么大，还是说非持久化策略太优秀了，以至于磁盘性能极大影响了整体吞吐量。这里挖个坑，争取以后看看内部实现吧，毕竟 erlang 对我是个大问题。\n\n- 集群模式下工作的不好\n\n  暂时不清楚集群模式下的影响，先 mark 一下\n\n- 依旧无法 100% 数据不丢失\n\n  即使 exchange，queue，投递方式都进行持久化声明依旧不能做到 100% 数据不丢失，原因有二：\n\n  1. Rabbit MQ 不是为每条消息进行 fsync（同步 IO） 处理\n\n     依旧可能出现挂掉时有消息没有持久化的情况，解决有两种方式：镜像队列和消息确认\n\n  2. 看到网上有提到 erlang 写文件的实时问题，不懂，先 mark，待求证\n\n## 消息确认\n\n消息确认可以分为生产者确认消息正确投递和消费者确认消息正确接收，对  Rabbit MQ 有三种更具体的情况：\n\n- confire/事务：确认消息到达 broker，避免消息在生产者发出后丢失\n- 客户端 ACK：确认消费者接收消息，避免消息在消息队列发出后丢失\n- mandatory/immediate：确认消息到达队列，避免到达交换器后找不到队列而丢弃\n\n### 事务/confire\n\n#### 事务\n\n确认消息成功被 exchange 接收。事务是 AMQP 协议内定义的， Rabbit MQ 也做了相应的实现。与事务相关有三个方法，具体使用的模板：\n\n```java\ntry {\n  channel.txSelect();\n  channel.basicPublish(...);\n  channel.txCommit();\n} catch (Exception e) {\n  e.printStackTrace();\n  channel.txRollback();\n}\n```\n\n事务缺点：最大的问题是执行前后需要开启事务，提交/回滚事务，而这几个过程又必须是同步的因此会造成很大的性能问题\n\n#### confire\n\nconfire 是 Rabbit MQ 为解决事务性能问题设计的确认机制，主要的做法是为每条消息都设置唯一 ID 且 ID 以 1  为步长生序，MQ 通过发送 ACK, NACK 异步确认消息是否到达交换器。\n\n网上普遍对 confire 的描述都集中在异步性上。除了异步，可以设置 basic.ack 的 multiple 域进行累计确认，这有点 TCP 的确认方式。\n\nconfire 最大的问题是无法回滚，导致生产者本身也不确定消息是否放成功。如果程序需要实现类似回滚功能，则维护一个 unconfire 消息的集合，每次收到 ACK/NACK 时更新集合（还需要考虑是否是累计确认）\n\n我使用了三种方式实现 confire 并进行对比：\n\n- 对每条消息要求接收对应的 confire 消息\n- 对一组消息要求接收一条 confire 消息\n- 使用监听器完全异步的接收 confire 消息\n\n不出意外的第三种方式的性能是最好的。\n\n### 客户端 ACK\n\n声明队列时指定 noAck 参数：\n\n- noAck=false：Rabbit MQ 向消费者发出消息后等待消费者显式发出 ack 信号后才移除消息\n- noAck=true：Rabbit MQ 向消费者发出消息后立即移除消息\n\n当设置队列 noAck 为 false 时，客户端必须根据消息的处理情况向 MQ 反馈，默认情况下 会自动确认。如果希望手动确认需要关闭自动确认。\n\n客户端除了 ACK 为还可以向 MQ 反馈其他信息，反馈的 API 分别有：\n\n- channel.basicAck：向 MQ 确认消息正确接收\n- channel.basicRecover：向 MQ 确认消息需要重发，可以根据参数重发给当前消费者或重新入队\n- channel.basicReject：向 MQ 确认消息退回\n- channel.basicNack：向 MQ 确认批量退回消息，可以根据参数选择是否批量\n\n### mandatory/immediate\n\n#### mandatory\n\nmandatory 设置为 true 时：MQ 至少将该消息路由到至少一个队列中，否则将消息返还给生产者\n\nmandatory 实现时只需要：\n\n1. 投递消息时设置 mandatory 参数为true\n\n   ```java\n   void basicPublish(String exchange,  // 交换器\n                 String routingKey,  // routing key\n                 boolean mandatory,  // 消息确认\n                 boolean immediate,  // 废弃\n                 BasicProperties props,  // 参数\n                 byte[] body  // 消息有效负载\n                ) throws IOException;\n   ```\n\n2. 设置监听器\n\n   ```java\n   channel.addReturnListener(new ReturnListener() {\n       public void handleReturn(int replyCode, String replyText, String exchange,\n                                String routingKey, AMQP.BasicProperties basicProperties,\n                                byte[] body) throws IOException {\n                                  // TODO\n                                }\n   });\n   ```\n\n当消息没有被正确路由到至少一个队列时，AMQP协议会返回对应消息，监听器内的代码将被调用；\n\n**当消息正确投递，什么也不发生**\n\n#### immediate\n\n**Rabbit MQ 3.0 之后已移除**。设置为 true 时：消息路由到 queue 前，如果 queue 有消费者，则马上将消息投递给 queue，否则直接把消息返还给生产者，消息不再入队。\n\n---\n\n参考：\n\n《Rabbit MQ 实战》\n\n[RabbitMQ(二)：mandatory标志的作用](http://www.cnblogs.com/520playboy/p/6925196.html)\n\n[RabbitMQ：Publisher的消息确认机制](https://github.com/pzxwhc/MineKnowContainer/issues/49)\n\n[RabbitMQ之mandatory和immediate](http://blog.csdn.net/u013256816/article/details/54914525)\n\n [RabbitMQ之消息确认机制（事务+Confirm）](http://blog.csdn.net/u013256816/article/details/55515234)\n\n[rabbitMq生产者角度:消息持久化、事务机制、PublisherConfirm、mandatory](http://blog.csdn.net/u014045580/article/details/70311746)\n","slug":"【MQ】可靠消息","published":1,"updated":"2017-12-08T13:57:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2qi0025d82egvjps2ee","content":"<p>初始【MQ】最后说到默认情况下，消息发送后 MQ 不会向发送方确认消息到达，也不会进行持久化处理。即在发送方眼里消息只要发出去，就不再关心消息消息了。这确实做到了生产者与 MQ 的解耦，并且效率很高。但缺点也非常明显，无法确定消息投递是可靠的：</p>\n<ul>\n<li>正在运行的 MQ 宕机后，无法恢复已发送的消息（持久化问题）</li>\n<li>没有匹配的 queue，那么消息将被 exchange 直接丢弃，而发送方对此毫不知情（确认问题）</li>\n<li>消息发送过程中在网络中丢失，发送方毫不知情（确认问题）</li>\n</ul>\n<p>Rabbit MQ 是被设计为金融行业服务的，在这些方面当然有考虑。本文将从持久化和消息确认两方面来了解 Rabbit MQ 的可靠消息实践。</p>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>为了确保消息在 MQ 各个环节的不丢失，需要将 exchange, queue, 投递方式都进行持久化声明。具体持久化的方式很简单，调用 API 就可以了。</p>\n<h3 id=\"exchange-持久化\"><a href=\"#exchange-持久化\" class=\"headerlink\" title=\"exchange 持久化\"></a>exchange 持久化</h3><p>exchange 声明时，将 durable 设置为 true 就可以了。这顺便看一下 exchange 创建方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Exchange.<span class=\"function\">DeclareOk <span class=\"title\">exchangeDeclare</span><span class=\"params\">(String exchange, String type, <span class=\"keyword\">boolean</span> durable)</span> </span></div><div class=\"line\">  <span class=\"keyword\">throws</span> IOException;</div><div class=\"line\"></div><div class=\"line\">Exchange.<span class=\"function\">DeclareOk <span class=\"title\">exchangeDeclare</span><span class=\"params\">(String exchange, String type, <span class=\"keyword\">boolean</span> durable, </span></span></div><div class=\"line\">                                   <span class=\"keyword\">boolean</span> autoDelete,Map&lt;String, Object&gt; arguments) </div><div class=\"line\">  <span class=\"keyword\">throws</span> IOException;</div><div class=\"line\"></div><div class=\"line\">Exchange.<span class=\"function\">DeclareOk <span class=\"title\">exchangeDeclare</span><span class=\"params\">(String exchange, String type)</span> </span></div><div class=\"line\">  <span class=\"keyword\">throws</span> IOException;</div><div class=\"line\"></div><div class=\"line\">Exchange.<span class=\"function\">DeclareOk <span class=\"title\">exchangeDeclare</span><span class=\"params\">(String exchange,  // 交换器名称</span></span></div><div class=\"line\">                                   String type,  // 交换器类型</div><div class=\"line\">                                   <span class=\"keyword\">boolean</span> durable, // 是否持久化</div><div class=\"line\">                                   <span class=\"keyword\">boolean</span> autoDelete,  // 是否自动删除</div><div class=\"line\">                                   <span class=\"keyword\">boolean</span> internal,  // 内部</div><div class=\"line\">                                   Map&lt;String, Object&gt; arguments  // 其他构造参数</div><div class=\"line\">                                  ) <span class=\"keyword\">throws</span> IOException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等价于 exchangeDeclare 方法设置 nowait 参数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">exchangeDeclareNoWait</span><span class=\"params\">(String exchange, String type, <span class=\"keyword\">boolean</span> durable, <span class=\"keyword\">boolean</span> autoDelete,</span></span></div><div class=\"line\">                           <span class=\"keyword\">boolean</span> internal, Map&lt;String, Object&gt; arguments) </div><div class=\"line\">  <span class=\"keyword\">throws</span> IOException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 被动声明队列，声明前先检查</span></div><div class=\"line\">Exchange.<span class=\"function\">DeclareOk <span class=\"title\">exchangeDeclarePassive</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> IOException</span>;</div></pre></td></tr></table></figure>\n<p>exchange 声明持久化后只能确保重启后 exchange 重新创建。否则 exchange 将丢失，生产者就无法正常发送消息了。</p>\n<h3 id=\"queue-持久化\"><a href=\"#queue-持久化\" class=\"headerlink\" title=\"queue 持久化\"></a>queue 持久化</h3><p>queue 持久化也是一样的套路，将 durable 设置为 true 就可以了。queue 创建的 AIP：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Queue.<span class=\"function\">DeclareOk <span class=\"title\">queueDeclare</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\">Queue.<span class=\"function\">DeclareOk <span class=\"title\">queueDeclare</span><span class=\"params\">(String queue,  // queue 名称 </span></span></div><div class=\"line\">                             <span class=\"keyword\">boolean</span> durable,  // 持久化</div><div class=\"line\">                             <span class=\"keyword\">boolean</span> exclusive,  // 排他队列</div><div class=\"line\">                             <span class=\"keyword\">boolean</span> autoDelete,  // 自动删除</div><div class=\"line\">                             Map&lt;String, Object&gt; arguments  // 其他构造参数</div><div class=\"line\">                            ) <span class=\"keyword\">throws</span> IOException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">queueDeclareNoWait</span><span class=\"params\">(String queue, <span class=\"keyword\">boolean</span> durable, <span class=\"keyword\">boolean</span> exclusive, <span class=\"keyword\">boolean</span> autoDelete, </span></span></div><div class=\"line\">                        Map&lt;String, Object&gt; arguments) <span class=\"keyword\">throws</span> IOException;</div><div class=\"line\"></div><div class=\"line\">Queue.<span class=\"function\">DeclareOk <span class=\"title\">queueDeclarePassive</span><span class=\"params\">(String queue)</span> <span class=\"keyword\">throws</span> IOException</span>;</div></pre></td></tr></table></figure>\n<p>对 durable 没什么好说的，确保重启后 queue 重新创建，但消息无法恢复，消息的持久化依赖于投递方式的持久化。</p>\n<p>注意一下 exclusive 参数：一个队列被声明为排他队列，该队列仅对首次申明它的连接可见，并在连接断开时自动删除：</p>\n<ol>\n<li>排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一连接创建的排他队列；</li>\n<li>“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；</li>\n<li>即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。</li>\n</ol>\n<h3 id=\"投递方式持久化声明\"><a href=\"#投递方式持久化声明\" class=\"headerlink\" title=\"投递方式持久化声明\"></a>投递方式持久化声明</h3><p>套路基本一致，还是看 API：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicPublish</span><span class=\"params\">(String exchange, String routingKey, BasicProperties props, <span class=\"keyword\">byte</span>[] body)</span> </span></div><div class=\"line\">  <span class=\"keyword\">throws</span> IOException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicPublish</span><span class=\"params\">(String exchange, String routingKey, <span class=\"keyword\">boolean</span> mandatory, BasicProperties props,</span></span></div><div class=\"line\">                  <span class=\"keyword\">byte</span>[] body)<span class=\"keyword\">throws</span> IOException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicPublish</span><span class=\"params\">(String exchange,  // 交换器</span></span></div><div class=\"line\">                  String routingKey,  // routing key</div><div class=\"line\">                  <span class=\"keyword\">boolean</span> mandatory,  // 消息确认</div><div class=\"line\">                  <span class=\"keyword\">boolean</span> immediate,  // 废弃</div><div class=\"line\">                  BasicProperties props,  // 参数</div><div class=\"line\">                  <span class=\"keyword\">byte</span>[] body  // 消息有效负载</div><div class=\"line\">                 ) <span class=\"keyword\">throws</span> IOException;</div></pre></td></tr></table></figure>\n<p>持久化的参数包含在 BasicProperties 定义中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasicProperties</span> <span class=\"keyword\">extends</span> <span class=\"title\">AMQBasicProperties</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String contentType;  <span class=\"comment\">// 消息类型</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String contentEncoding;  <span class=\"comment\">// 编码</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Object&gt; headers;</div><div class=\"line\">    <span class=\"keyword\">private</span> Integer deliveryMode;  <span class=\"comment\">// 持久化。1：非持久化；2：持久化</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Integer priority;  <span class=\"comment\">// 优先级</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String correlationId;</div><div class=\"line\">    <span class=\"keyword\">private</span> String replyTo;  <span class=\"comment\">// 反馈队列</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String expiration;  <span class=\"comment\">// expiration到期时间</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String messageId;</div><div class=\"line\">    <span class=\"keyword\">private</span> Date timestamp;</div><div class=\"line\">    <span class=\"keyword\">private</span> String type;</div><div class=\"line\">    <span class=\"keyword\">private</span> String userId;</div><div class=\"line\">    <span class=\"keyword\">private</span> String appId;</div><div class=\"line\">    <span class=\"keyword\">private</span> String clusterId;</div><div class=\"line\">    <span class=\"comment\">// 省略方法   </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>BasicProperties 的构造除了提供默认的方法外，对常用的参数可以直接获得，还支持使用 builder 模式构造。</p>\n<p><strong>如果单独持久化投递方式，重启后因为交换器、队列已不存在所以毫无意义</strong></p>\n<h3 id=\"持久化的影响\"><a href=\"#持久化的影响\" class=\"headerlink\" title=\"持久化的影响\"></a>持久化的影响</h3><ul>\n<li><p>性能</p>\n<p>《Rabbit MQ 实战》 一书在说明持久化对性能影响时，举例：“使用持久化机制而导致消息吞吐量降低至少 10 倍的情况并不少见”。这个说法还是很让我震惊的，很好奇 Rabbit MQ 的持久化策略是怎么做的影响这么大，还是说非持久化策略太优秀了，以至于磁盘性能极大影响了整体吞吐量。这里挖个坑，争取以后看看内部实现吧，毕竟 erlang 对我是个大问题。</p>\n</li>\n<li><p>集群模式下工作的不好</p>\n<p>暂时不清楚集群模式下的影响，先 mark 一下</p>\n</li>\n<li><p>依旧无法 100% 数据不丢失</p>\n<p>即使 exchange，queue，投递方式都进行持久化声明依旧不能做到 100% 数据不丢失，原因有二：</p>\n<ol>\n<li><p>Rabbit MQ 不是为每条消息进行 fsync（同步 IO） 处理</p>\n<p>依旧可能出现挂掉时有消息没有持久化的情况，解决有两种方式：镜像队列和消息确认</p>\n</li>\n<li><p>看到网上有提到 erlang 写文件的实时问题，不懂，先 mark，待求证</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"消息确认\"><a href=\"#消息确认\" class=\"headerlink\" title=\"消息确认\"></a>消息确认</h2><p>消息确认可以分为生产者确认消息正确投递和消费者确认消息正确接收，对  Rabbit MQ 有三种更具体的情况：</p>\n<ul>\n<li>confire/事务：确认消息到达 broker，避免消息在生产者发出后丢失</li>\n<li>客户端 ACK：确认消费者接收消息，避免消息在消息队列发出后丢失</li>\n<li>mandatory/immediate：确认消息到达队列，避免到达交换器后找不到队列而丢弃</li>\n</ul>\n<h3 id=\"事务-confire\"><a href=\"#事务-confire\" class=\"headerlink\" title=\"事务/confire\"></a>事务/confire</h3><h4 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h4><p>确认消息成功被 exchange 接收。事务是 AMQP 协议内定义的， Rabbit MQ 也做了相应的实现。与事务相关有三个方法，具体使用的模板：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  channel.txSelect();</div><div class=\"line\">  channel.basicPublish(...);</div><div class=\"line\">  channel.txCommit();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">  e.printStackTrace();</div><div class=\"line\">  channel.txRollback();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事务缺点：最大的问题是执行前后需要开启事务，提交/回滚事务，而这几个过程又必须是同步的因此会造成很大的性能问题</p>\n<h4 id=\"confire\"><a href=\"#confire\" class=\"headerlink\" title=\"confire\"></a>confire</h4><p>confire 是 Rabbit MQ 为解决事务性能问题设计的确认机制，主要的做法是为每条消息都设置唯一 ID 且 ID 以 1  为步长生序，MQ 通过发送 ACK, NACK 异步确认消息是否到达交换器。</p>\n<p>网上普遍对 confire 的描述都集中在异步性上。除了异步，可以设置 basic.ack 的 multiple 域进行累计确认，这有点 TCP 的确认方式。</p>\n<p>confire 最大的问题是无法回滚，导致生产者本身也不确定消息是否放成功。如果程序需要实现类似回滚功能，则维护一个 unconfire 消息的集合，每次收到 ACK/NACK 时更新集合（还需要考虑是否是累计确认）</p>\n<p>我使用了三种方式实现 confire 并进行对比：</p>\n<ul>\n<li>对每条消息要求接收对应的 confire 消息</li>\n<li>对一组消息要求接收一条 confire 消息</li>\n<li>使用监听器完全异步的接收 confire 消息</li>\n</ul>\n<p>不出意外的第三种方式的性能是最好的。</p>\n<h3 id=\"客户端-ACK\"><a href=\"#客户端-ACK\" class=\"headerlink\" title=\"客户端 ACK\"></a>客户端 ACK</h3><p>声明队列时指定 noAck 参数：</p>\n<ul>\n<li>noAck=false：Rabbit MQ 向消费者发出消息后等待消费者显式发出 ack 信号后才移除消息</li>\n<li>noAck=true：Rabbit MQ 向消费者发出消息后立即移除消息</li>\n</ul>\n<p>当设置队列 noAck 为 false 时，客户端必须根据消息的处理情况向 MQ 反馈，默认情况下 会自动确认。如果希望手动确认需要关闭自动确认。</p>\n<p>客户端除了 ACK 为还可以向 MQ 反馈其他信息，反馈的 API 分别有：</p>\n<ul>\n<li>channel.basicAck：向 MQ 确认消息正确接收</li>\n<li>channel.basicRecover：向 MQ 确认消息需要重发，可以根据参数重发给当前消费者或重新入队</li>\n<li>channel.basicReject：向 MQ 确认消息退回</li>\n<li>channel.basicNack：向 MQ 确认批量退回消息，可以根据参数选择是否批量</li>\n</ul>\n<h3 id=\"mandatory-immediate\"><a href=\"#mandatory-immediate\" class=\"headerlink\" title=\"mandatory/immediate\"></a>mandatory/immediate</h3><h4 id=\"mandatory\"><a href=\"#mandatory\" class=\"headerlink\" title=\"mandatory\"></a>mandatory</h4><p>mandatory 设置为 true 时：MQ 至少将该消息路由到至少一个队列中，否则将消息返还给生产者</p>\n<p>mandatory 实现时只需要：</p>\n<ol>\n<li><p>投递消息时设置 mandatory 参数为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicPublish</span><span class=\"params\">(String exchange,  // 交换器</span></span></div><div class=\"line\">              String routingKey,  // routing key</div><div class=\"line\">              <span class=\"keyword\">boolean</span> mandatory,  // 消息确认</div><div class=\"line\">              <span class=\"keyword\">boolean</span> immediate,  // 废弃</div><div class=\"line\">              BasicProperties props,  // 参数</div><div class=\"line\">              <span class=\"keyword\">byte</span>[] body  // 消息有效负载</div><div class=\"line\">             ) <span class=\"keyword\">throws</span> IOException;</div></pre></td></tr></table></figure>\n</li>\n<li><p>设置监听器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.addReturnListener(<span class=\"keyword\">new</span> ReturnListener() &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleReturn</span><span class=\"params\">(<span class=\"keyword\">int</span> replyCode, String replyText, String exchange,</span></span></div><div class=\"line\">                             String routingKey, AMQP.BasicProperties basicProperties,</div><div class=\"line\">                             <span class=\"keyword\">byte</span>[] body) <span class=\"keyword\">throws</span> IOException &#123;</div><div class=\"line\">                               <span class=\"comment\">// TODO</span></div><div class=\"line\">                             &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当消息没有被正确路由到至少一个队列时，AMQP协议会返回对应消息，监听器内的代码将被调用；</p>\n<p><strong>当消息正确投递，什么也不发生</strong></p>\n<h4 id=\"immediate\"><a href=\"#immediate\" class=\"headerlink\" title=\"immediate\"></a>immediate</h4><p><strong>Rabbit MQ 3.0 之后已移除</strong>。设置为 true 时：消息路由到 queue 前，如果 queue 有消费者，则马上将消息投递给 queue，否则直接把消息返还给生产者，消息不再入队。</p>\n<hr>\n<p>参考：</p>\n<p>《Rabbit MQ 实战》</p>\n<p><a href=\"http://www.cnblogs.com/520playboy/p/6925196.html\" target=\"_blank\" rel=\"external\">RabbitMQ(二)：mandatory标志的作用</a></p>\n<p><a href=\"https://github.com/pzxwhc/MineKnowContainer/issues/49\" target=\"_blank\" rel=\"external\">RabbitMQ：Publisher的消息确认机制</a></p>\n<p><a href=\"http://blog.csdn.net/u013256816/article/details/54914525\" target=\"_blank\" rel=\"external\">RabbitMQ之mandatory和immediate</a></p>\n<p> <a href=\"http://blog.csdn.net/u013256816/article/details/55515234\" target=\"_blank\" rel=\"external\">RabbitMQ之消息确认机制（事务+Confirm）</a></p>\n<p><a href=\"http://blog.csdn.net/u014045580/article/details/70311746\" target=\"_blank\" rel=\"external\">rabbitMq生产者角度:消息持久化、事务机制、PublisherConfirm、mandatory</a></p>\n","excerpt":"","more":"<p>初始【MQ】最后说到默认情况下，消息发送后 MQ 不会向发送方确认消息到达，也不会进行持久化处理。即在发送方眼里消息只要发出去，就不再关心消息消息了。这确实做到了生产者与 MQ 的解耦，并且效率很高。但缺点也非常明显，无法确定消息投递是可靠的：</p>\n<ul>\n<li>正在运行的 MQ 宕机后，无法恢复已发送的消息（持久化问题）</li>\n<li>没有匹配的 queue，那么消息将被 exchange 直接丢弃，而发送方对此毫不知情（确认问题）</li>\n<li>消息发送过程中在网络中丢失，发送方毫不知情（确认问题）</li>\n</ul>\n<p>Rabbit MQ 是被设计为金融行业服务的，在这些方面当然有考虑。本文将从持久化和消息确认两方面来了解 Rabbit MQ 的可靠消息实践。</p>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>为了确保消息在 MQ 各个环节的不丢失，需要将 exchange, queue, 投递方式都进行持久化声明。具体持久化的方式很简单，调用 API 就可以了。</p>\n<h3 id=\"exchange-持久化\"><a href=\"#exchange-持久化\" class=\"headerlink\" title=\"exchange 持久化\"></a>exchange 持久化</h3><p>exchange 声明时，将 durable 设置为 true 就可以了。这顺便看一下 exchange 创建方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Exchange.<span class=\"function\">DeclareOk <span class=\"title\">exchangeDeclare</span><span class=\"params\">(String exchange, String type, <span class=\"keyword\">boolean</span> durable)</span> </div><div class=\"line\">  <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\">Exchange.<span class=\"function\">DeclareOk <span class=\"title\">exchangeDeclare</span><span class=\"params\">(String exchange, String type, <span class=\"keyword\">boolean</span> durable, </div><div class=\"line\">                                   <span class=\"keyword\">boolean</span> autoDelete,Map&lt;String, Object&gt; arguments)</span> </div><div class=\"line\">  <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\">Exchange.<span class=\"function\">DeclareOk <span class=\"title\">exchangeDeclare</span><span class=\"params\">(String exchange, String type)</span> </div><div class=\"line\">  <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\">Exchange.<span class=\"function\">DeclareOk <span class=\"title\">exchangeDeclare</span><span class=\"params\">(String exchange,  // 交换器名称</div><div class=\"line\">                                   String type,  // 交换器类型</div><div class=\"line\">                                   <span class=\"keyword\">boolean</span> durable, // 是否持久化</div><div class=\"line\">                                   <span class=\"keyword\">boolean</span> autoDelete,  // 是否自动删除</div><div class=\"line\">                                   <span class=\"keyword\">boolean</span> internal,  // 内部</div><div class=\"line\">                                   Map&lt;String, Object&gt; arguments  // 其他构造参数</div><div class=\"line\">                                  )</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等价于 exchangeDeclare 方法设置 nowait 参数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">exchangeDeclareNoWait</span><span class=\"params\">(String exchange, String type, <span class=\"keyword\">boolean</span> durable, <span class=\"keyword\">boolean</span> autoDelete,</div><div class=\"line\">                           <span class=\"keyword\">boolean</span> internal, Map&lt;String, Object&gt; arguments)</span> </div><div class=\"line\">  <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 被动声明队列，声明前先检查</span></div><div class=\"line\">Exchange.<span class=\"function\">DeclareOk <span class=\"title\">exchangeDeclarePassive</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> IOException</span>;</div></pre></td></tr></table></figure>\n<p>exchange 声明持久化后只能确保重启后 exchange 重新创建。否则 exchange 将丢失，生产者就无法正常发送消息了。</p>\n<h3 id=\"queue-持久化\"><a href=\"#queue-持久化\" class=\"headerlink\" title=\"queue 持久化\"></a>queue 持久化</h3><p>queue 持久化也是一样的套路，将 durable 设置为 true 就可以了。queue 创建的 AIP：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Queue.<span class=\"function\">DeclareOk <span class=\"title\">queueDeclare</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\">Queue.<span class=\"function\">DeclareOk <span class=\"title\">queueDeclare</span><span class=\"params\">(String queue,  // queue 名称 </div><div class=\"line\">                             <span class=\"keyword\">boolean</span> durable,  // 持久化</div><div class=\"line\">                             <span class=\"keyword\">boolean</span> exclusive,  // 排他队列</div><div class=\"line\">                             <span class=\"keyword\">boolean</span> autoDelete,  // 自动删除</div><div class=\"line\">                             Map&lt;String, Object&gt; arguments  // 其他构造参数</div><div class=\"line\">                            )</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">queueDeclareNoWait</span><span class=\"params\">(String queue, <span class=\"keyword\">boolean</span> durable, <span class=\"keyword\">boolean</span> exclusive, <span class=\"keyword\">boolean</span> autoDelete, </div><div class=\"line\">                        Map&lt;String, Object&gt; arguments)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\">Queue.<span class=\"function\">DeclareOk <span class=\"title\">queueDeclarePassive</span><span class=\"params\">(String queue)</span> <span class=\"keyword\">throws</span> IOException</span>;</div></pre></td></tr></table></figure>\n<p>对 durable 没什么好说的，确保重启后 queue 重新创建，但消息无法恢复，消息的持久化依赖于投递方式的持久化。</p>\n<p>注意一下 exclusive 参数：一个队列被声明为排他队列，该队列仅对首次申明它的连接可见，并在连接断开时自动删除：</p>\n<ol>\n<li>排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一连接创建的排他队列；</li>\n<li>“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；</li>\n<li>即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。</li>\n</ol>\n<h3 id=\"投递方式持久化声明\"><a href=\"#投递方式持久化声明\" class=\"headerlink\" title=\"投递方式持久化声明\"></a>投递方式持久化声明</h3><p>套路基本一致，还是看 API：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicPublish</span><span class=\"params\">(String exchange, String routingKey, BasicProperties props, <span class=\"keyword\">byte</span>[] body)</span> </div><div class=\"line\">  <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicPublish</span><span class=\"params\">(String exchange, String routingKey, <span class=\"keyword\">boolean</span> mandatory, BasicProperties props,</div><div class=\"line\">                  <span class=\"keyword\">byte</span>[] body)</span><span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicPublish</span><span class=\"params\">(String exchange,  // 交换器</div><div class=\"line\">                  String routingKey,  // routing key</div><div class=\"line\">                  <span class=\"keyword\">boolean</span> mandatory,  // 消息确认</div><div class=\"line\">                  <span class=\"keyword\">boolean</span> immediate,  // 废弃</div><div class=\"line\">                  BasicProperties props,  // 参数</div><div class=\"line\">                  <span class=\"keyword\">byte</span>[] body  // 消息有效负载</div><div class=\"line\">                 )</span> <span class=\"keyword\">throws</span> IOException</span>;</div></pre></td></tr></table></figure>\n<p>持久化的参数包含在 BasicProperties 定义中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasicProperties</span> <span class=\"keyword\">extends</span> <span class=\"title\">AMQBasicProperties</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String contentType;  <span class=\"comment\">// 消息类型</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String contentEncoding;  <span class=\"comment\">// 编码</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Object&gt; headers;</div><div class=\"line\">    <span class=\"keyword\">private</span> Integer deliveryMode;  <span class=\"comment\">// 持久化。1：非持久化；2：持久化</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Integer priority;  <span class=\"comment\">// 优先级</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String correlationId;</div><div class=\"line\">    <span class=\"keyword\">private</span> String replyTo;  <span class=\"comment\">// 反馈队列</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String expiration;  <span class=\"comment\">// expiration到期时间</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String messageId;</div><div class=\"line\">    <span class=\"keyword\">private</span> Date timestamp;</div><div class=\"line\">    <span class=\"keyword\">private</span> String type;</div><div class=\"line\">    <span class=\"keyword\">private</span> String userId;</div><div class=\"line\">    <span class=\"keyword\">private</span> String appId;</div><div class=\"line\">    <span class=\"keyword\">private</span> String clusterId;</div><div class=\"line\">    <span class=\"comment\">// 省略方法   </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>BasicProperties 的构造除了提供默认的方法外，对常用的参数可以直接获得，还支持使用 builder 模式构造。</p>\n<p><strong>如果单独持久化投递方式，重启后因为交换器、队列已不存在所以毫无意义</strong></p>\n<h3 id=\"持久化的影响\"><a href=\"#持久化的影响\" class=\"headerlink\" title=\"持久化的影响\"></a>持久化的影响</h3><ul>\n<li><p>性能</p>\n<p>《Rabbit MQ 实战》 一书在说明持久化对性能影响时，举例：“使用持久化机制而导致消息吞吐量降低至少 10 倍的情况并不少见”。这个说法还是很让我震惊的，很好奇 Rabbit MQ 的持久化策略是怎么做的影响这么大，还是说非持久化策略太优秀了，以至于磁盘性能极大影响了整体吞吐量。这里挖个坑，争取以后看看内部实现吧，毕竟 erlang 对我是个大问题。</p>\n</li>\n<li><p>集群模式下工作的不好</p>\n<p>暂时不清楚集群模式下的影响，先 mark 一下</p>\n</li>\n<li><p>依旧无法 100% 数据不丢失</p>\n<p>即使 exchange，queue，投递方式都进行持久化声明依旧不能做到 100% 数据不丢失，原因有二：</p>\n<ol>\n<li><p>Rabbit MQ 不是为每条消息进行 fsync（同步 IO） 处理</p>\n<p>依旧可能出现挂掉时有消息没有持久化的情况，解决有两种方式：镜像队列和消息确认</p>\n</li>\n<li><p>看到网上有提到 erlang 写文件的实时问题，不懂，先 mark，待求证</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"消息确认\"><a href=\"#消息确认\" class=\"headerlink\" title=\"消息确认\"></a>消息确认</h2><p>消息确认可以分为生产者确认消息正确投递和消费者确认消息正确接收，对  Rabbit MQ 有三种更具体的情况：</p>\n<ul>\n<li>confire/事务：确认消息到达 broker，避免消息在生产者发出后丢失</li>\n<li>客户端 ACK：确认消费者接收消息，避免消息在消息队列发出后丢失</li>\n<li>mandatory/immediate：确认消息到达队列，避免到达交换器后找不到队列而丢弃</li>\n</ul>\n<h3 id=\"事务-confire\"><a href=\"#事务-confire\" class=\"headerlink\" title=\"事务/confire\"></a>事务/confire</h3><h4 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h4><p>确认消息成功被 exchange 接收。事务是 AMQP 协议内定义的， Rabbit MQ 也做了相应的实现。与事务相关有三个方法，具体使用的模板：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  channel.txSelect();</div><div class=\"line\">  channel.basicPublish(...);</div><div class=\"line\">  channel.txCommit();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">  e.printStackTrace();</div><div class=\"line\">  channel.txRollback();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事务缺点：最大的问题是执行前后需要开启事务，提交/回滚事务，而这几个过程又必须是同步的因此会造成很大的性能问题</p>\n<h4 id=\"confire\"><a href=\"#confire\" class=\"headerlink\" title=\"confire\"></a>confire</h4><p>confire 是 Rabbit MQ 为解决事务性能问题设计的确认机制，主要的做法是为每条消息都设置唯一 ID 且 ID 以 1  为步长生序，MQ 通过发送 ACK, NACK 异步确认消息是否到达交换器。</p>\n<p>网上普遍对 confire 的描述都集中在异步性上。除了异步，可以设置 basic.ack 的 multiple 域进行累计确认，这有点 TCP 的确认方式。</p>\n<p>confire 最大的问题是无法回滚，导致生产者本身也不确定消息是否放成功。如果程序需要实现类似回滚功能，则维护一个 unconfire 消息的集合，每次收到 ACK/NACK 时更新集合（还需要考虑是否是累计确认）</p>\n<p>我使用了三种方式实现 confire 并进行对比：</p>\n<ul>\n<li>对每条消息要求接收对应的 confire 消息</li>\n<li>对一组消息要求接收一条 confire 消息</li>\n<li>使用监听器完全异步的接收 confire 消息</li>\n</ul>\n<p>不出意外的第三种方式的性能是最好的。</p>\n<h3 id=\"客户端-ACK\"><a href=\"#客户端-ACK\" class=\"headerlink\" title=\"客户端 ACK\"></a>客户端 ACK</h3><p>声明队列时指定 noAck 参数：</p>\n<ul>\n<li>noAck=false：Rabbit MQ 向消费者发出消息后等待消费者显式发出 ack 信号后才移除消息</li>\n<li>noAck=true：Rabbit MQ 向消费者发出消息后立即移除消息</li>\n</ul>\n<p>当设置队列 noAck 为 false 时，客户端必须根据消息的处理情况向 MQ 反馈，默认情况下 会自动确认。如果希望手动确认需要关闭自动确认。</p>\n<p>客户端除了 ACK 为还可以向 MQ 反馈其他信息，反馈的 API 分别有：</p>\n<ul>\n<li>channel.basicAck：向 MQ 确认消息正确接收</li>\n<li>channel.basicRecover：向 MQ 确认消息需要重发，可以根据参数重发给当前消费者或重新入队</li>\n<li>channel.basicReject：向 MQ 确认消息退回</li>\n<li>channel.basicNack：向 MQ 确认批量退回消息，可以根据参数选择是否批量</li>\n</ul>\n<h3 id=\"mandatory-immediate\"><a href=\"#mandatory-immediate\" class=\"headerlink\" title=\"mandatory/immediate\"></a>mandatory/immediate</h3><h4 id=\"mandatory\"><a href=\"#mandatory\" class=\"headerlink\" title=\"mandatory\"></a>mandatory</h4><p>mandatory 设置为 true 时：MQ 至少将该消息路由到至少一个队列中，否则将消息返还给生产者</p>\n<p>mandatory 实现时只需要：</p>\n<ol>\n<li><p>投递消息时设置 mandatory 参数为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicPublish</span><span class=\"params\">(String exchange,  // 交换器</div><div class=\"line\">              String routingKey,  // routing key</div><div class=\"line\">              <span class=\"keyword\">boolean</span> mandatory,  // 消息确认</div><div class=\"line\">              <span class=\"keyword\">boolean</span> immediate,  // 废弃</div><div class=\"line\">              BasicProperties props,  // 参数</div><div class=\"line\">              <span class=\"keyword\">byte</span>[] body  // 消息有效负载</div><div class=\"line\">             )</span> <span class=\"keyword\">throws</span> IOException</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>设置监听器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.addReturnListener(<span class=\"keyword\">new</span> ReturnListener() &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleReturn</span><span class=\"params\">(<span class=\"keyword\">int</span> replyCode, String replyText, String exchange,</div><div class=\"line\">                             String routingKey, AMQP.BasicProperties basicProperties,</div><div class=\"line\">                             <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">                               <span class=\"comment\">// TODO</span></div><div class=\"line\">                             &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当消息没有被正确路由到至少一个队列时，AMQP协议会返回对应消息，监听器内的代码将被调用；</p>\n<p><strong>当消息正确投递，什么也不发生</strong></p>\n<h4 id=\"immediate\"><a href=\"#immediate\" class=\"headerlink\" title=\"immediate\"></a>immediate</h4><p><strong>Rabbit MQ 3.0 之后已移除</strong>。设置为 true 时：消息路由到 queue 前，如果 queue 有消费者，则马上将消息投递给 queue，否则直接把消息返还给生产者，消息不再入队。</p>\n<hr>\n<p>参考：</p>\n<p>《Rabbit MQ 实战》</p>\n<p><a href=\"http://www.cnblogs.com/520playboy/p/6925196.html\">RabbitMQ(二)：mandatory标志的作用</a></p>\n<p><a href=\"https://github.com/pzxwhc/MineKnowContainer/issues/49\">RabbitMQ：Publisher的消息确认机制</a></p>\n<p><a href=\"http://blog.csdn.net/u013256816/article/details/54914525\">RabbitMQ之mandatory和immediate</a></p>\n<p> <a href=\"http://blog.csdn.net/u013256816/article/details/55515234\">RabbitMQ之消息确认机制（事务+Confirm）</a></p>\n<p><a href=\"http://blog.csdn.net/u014045580/article/details/70311746\">rabbitMq生产者角度:消息持久化、事务机制、PublisherConfirm、mandatory</a></p>\n"},{"title":"【MQ】初始MQ","date":"2017-12-08T13:48:26.000Z","_content":"\n接触 MQ 之前简单的理解消息队列就是一个理论上无限大的线性表，接触后发现 MQ 支持的功能远不止这些。MQ 的功能可以概括为：削峰填谷，异步解耦。\n\n从模型上看，MQ 模型不是狭义上的 C/S 模型，而是消息服务投递模型：\n\n- 在程序角度：当程序连接到 RabbitMQ 时必须决定自己是发送者还是接受者\n- 在 MQ 角度：MQ 及接收消息，又发送消息\n\nAMQP（高级消息队列协议）是对 MQ 最抽象的描述。\n\n## AMQP\n\nAMQP 定义了一个 MQ 的几个组件，官方的描述还是比较晦涩的，我以自己的理解描述所以可能不够准确：\n\n- Server（broker）：MQ 服务器\n- Exchange：一个功能强大 router，不做消息的存储，单纯转发给 MQ\n- Message Queue：消息队列，具体存储未被消费的消息\n- Message：消息\n- Binding：关联 Exchange  和 Message Queeu 的路由表\n- Connection：链接，TCP 链接\n- Channel：子链接，复用 Connection\n- Command：命令\n- Virtual Host：服务器创建的 mini 版的 MQ\n\n### Exchange & Binding\n\n这两个东东算是 MQ 核心功能的实现组件，网上描述的我觉得不是很清楚。\n\n可以把 exchange 当路由器理解，把 binding 当路由表理解。路由器根据路由表把数据从路由器路由到一下节点，exchange 根据 binding 把消息从 exchange 路由到 queue。exchange 的核心功能是路由转发，而路由转发的依据是 binding。把 binding 当路由表的话，那么这个路由表有三项：\n\n- exchange name\n- queue name\n- router key\n\n三者的关系需要在实际生产、消费消息之前完成绑定。而后消息到达 exchange 后根据 routing key 路由到指定 queue。而 exchange  有多种不同实现，不同实现的 exchange 根据 routing key 的路由方式不同，适用于不同场景。\n\n## 典型场景\n\n以下例子从 Rabbit MQ 官网给搬运，[传送门](http://www.rabbitmq.com/tutorials/tutorial-one-java.html)。\n\n### direct\n\ndirect 类型的交换器严格根据消息头的 exchange name, queue name, router key 将消息路由到对应的队列\n\n#### 消息投递到一个队列\n\n![direct1](http://www.rabbitmq.com/img/tutorials/python-one.png)\n\n所有消息由默认交换器根据消息头 queue name 投递到队列。没有声明交换器，自动将队列绑定到了默认交换器。下面代码的第二个参数很容易被当做 queue name，实际上这个字段是 routing key，发送方是不关心 queue 的。\n\n```java\nchannel.queueDeclare(QUEUE_NAME, false, false, false, null);  // 声明队列\nchannel.basicPublish(\"\",  // exchange name，空则投递到默认交换器\n                     QUEUE_NAME,  // 以 queue_name 作为 routing key\n                     null, \n                     message.getBytes());\n```\n\n#### 消息投递到一个队列由多个消费者消费\n\n![direct2](http://www.rabbitmq.com/img/tutorials/python-two.png)\n\n可以用于负载均衡的生产者消费者模型，每个消息正常只被消费一次。\n\n投递过程与上一个一样，队列的消息同时由多个消费者消费\n\n#### 消息有选择的分散到多个队列\n\n![direct3](http://www.rabbitmq.com/img/tutorials/direct-exchange.png)\n\n```java\nchannel.exchangeDeclare(EXCHANGE_NAME, \"direct\");  // 声明 direct 类型交换器\nString queueName = channel.queueDeclare().getQueue();  // 声明随机队列，并获取该队列名字\nchannel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);  // 绑定\n\n// 发送\nchannel.basicPublish(EXCHANGE_NAME, \n                     ROUTING_KEY, \n                     null, \n                     message.getBytes());\n```\n\n完整的交换器，队列声明并绑定，消息根据绑定信息投递到对应队列。\n\n一个交换器与多个队列使用相同的 routing key 进行绑定，当该 routing key 消息发送至交换器可以形成广播的形式。\n\n### fanout\n\n![fanout](http://www.rabbitmq.com/img/tutorials/exchanges.png)\n\n```java\nchannel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");  // 声明 fanout 类型交换器\nString queueName = channel.queueDeclare().getQueue();  // 创建非持久的，唯一的，自动删除的队列\nchannel.queueBind(queueName, EXCHANGE_NAME, \"\");  // 绑定队列与交换器，不要 routing key\n\n// 发送\nchannel.basicPublish(EXCHANGE_NAME, \n                     \"\",  // routing key\n                     null, \n                     message.getBytes());\n```\n\n交换器收到的消息广播至所有绑定的队列，绑定不需要给定 routing key\n\n### topic\n\n![topic](http://www.rabbitmq.com/img/tutorials/python-five.png)\n\n```java\nchannel.exchangeDeclare(EXCHANGE_NAME, \"topic\");  // 声明 topic 类型交换器\nString queueName = channel.queueDeclare().getQueue();  // 创建非持久的、唯一的、自动删除的队列\nchannel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);  // 绑定队列，交换器，路由键\n\n// 发送\nchannel.basicPublish(EXCHANGE_NAME, \n                     ROUTING_KEY, \n                     null, \n                     msg.getBytes());\n```\n\n编码过程与使用 direct 交换器的完整过程一直，但是 routing key 可以使用通配符：\n\n- `*` 将 . 视为分隔符进行匹配\n- `#`将任意字符串视为关键字匹配\n\n## 其他\n\n- 消息发后即忘：消息单向传递，默认并不会向发送方确认发送，也不会做持久化\n- prefetch count：在 direct 的第二场景下，消息会被平均分配给各个消费者，而不考虑消费者的消费能力。可以使用设置 Prefetch count 保持各消费者负载均衡\n- binding key：有的文章将 bindling 中使用的 routing key 也称作 binding key，我统一称为 binding key 了\n- 相关 demo [传送门](https://github.com/zhanghTK/rabbit-mq)\n","source":"_posts/【MQ】初始MQ.md","raw":"---\ntitle: 【MQ】初始MQ\ndate: 2017-12-08 21:48:26\ntags: MQ\ncategories: MQ\n---\n\n接触 MQ 之前简单的理解消息队列就是一个理论上无限大的线性表，接触后发现 MQ 支持的功能远不止这些。MQ 的功能可以概括为：削峰填谷，异步解耦。\n\n从模型上看，MQ 模型不是狭义上的 C/S 模型，而是消息服务投递模型：\n\n- 在程序角度：当程序连接到 RabbitMQ 时必须决定自己是发送者还是接受者\n- 在 MQ 角度：MQ 及接收消息，又发送消息\n\nAMQP（高级消息队列协议）是对 MQ 最抽象的描述。\n\n## AMQP\n\nAMQP 定义了一个 MQ 的几个组件，官方的描述还是比较晦涩的，我以自己的理解描述所以可能不够准确：\n\n- Server（broker）：MQ 服务器\n- Exchange：一个功能强大 router，不做消息的存储，单纯转发给 MQ\n- Message Queue：消息队列，具体存储未被消费的消息\n- Message：消息\n- Binding：关联 Exchange  和 Message Queeu 的路由表\n- Connection：链接，TCP 链接\n- Channel：子链接，复用 Connection\n- Command：命令\n- Virtual Host：服务器创建的 mini 版的 MQ\n\n### Exchange & Binding\n\n这两个东东算是 MQ 核心功能的实现组件，网上描述的我觉得不是很清楚。\n\n可以把 exchange 当路由器理解，把 binding 当路由表理解。路由器根据路由表把数据从路由器路由到一下节点，exchange 根据 binding 把消息从 exchange 路由到 queue。exchange 的核心功能是路由转发，而路由转发的依据是 binding。把 binding 当路由表的话，那么这个路由表有三项：\n\n- exchange name\n- queue name\n- router key\n\n三者的关系需要在实际生产、消费消息之前完成绑定。而后消息到达 exchange 后根据 routing key 路由到指定 queue。而 exchange  有多种不同实现，不同实现的 exchange 根据 routing key 的路由方式不同，适用于不同场景。\n\n## 典型场景\n\n以下例子从 Rabbit MQ 官网给搬运，[传送门](http://www.rabbitmq.com/tutorials/tutorial-one-java.html)。\n\n### direct\n\ndirect 类型的交换器严格根据消息头的 exchange name, queue name, router key 将消息路由到对应的队列\n\n#### 消息投递到一个队列\n\n![direct1](http://www.rabbitmq.com/img/tutorials/python-one.png)\n\n所有消息由默认交换器根据消息头 queue name 投递到队列。没有声明交换器，自动将队列绑定到了默认交换器。下面代码的第二个参数很容易被当做 queue name，实际上这个字段是 routing key，发送方是不关心 queue 的。\n\n```java\nchannel.queueDeclare(QUEUE_NAME, false, false, false, null);  // 声明队列\nchannel.basicPublish(\"\",  // exchange name，空则投递到默认交换器\n                     QUEUE_NAME,  // 以 queue_name 作为 routing key\n                     null, \n                     message.getBytes());\n```\n\n#### 消息投递到一个队列由多个消费者消费\n\n![direct2](http://www.rabbitmq.com/img/tutorials/python-two.png)\n\n可以用于负载均衡的生产者消费者模型，每个消息正常只被消费一次。\n\n投递过程与上一个一样，队列的消息同时由多个消费者消费\n\n#### 消息有选择的分散到多个队列\n\n![direct3](http://www.rabbitmq.com/img/tutorials/direct-exchange.png)\n\n```java\nchannel.exchangeDeclare(EXCHANGE_NAME, \"direct\");  // 声明 direct 类型交换器\nString queueName = channel.queueDeclare().getQueue();  // 声明随机队列，并获取该队列名字\nchannel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);  // 绑定\n\n// 发送\nchannel.basicPublish(EXCHANGE_NAME, \n                     ROUTING_KEY, \n                     null, \n                     message.getBytes());\n```\n\n完整的交换器，队列声明并绑定，消息根据绑定信息投递到对应队列。\n\n一个交换器与多个队列使用相同的 routing key 进行绑定，当该 routing key 消息发送至交换器可以形成广播的形式。\n\n### fanout\n\n![fanout](http://www.rabbitmq.com/img/tutorials/exchanges.png)\n\n```java\nchannel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");  // 声明 fanout 类型交换器\nString queueName = channel.queueDeclare().getQueue();  // 创建非持久的，唯一的，自动删除的队列\nchannel.queueBind(queueName, EXCHANGE_NAME, \"\");  // 绑定队列与交换器，不要 routing key\n\n// 发送\nchannel.basicPublish(EXCHANGE_NAME, \n                     \"\",  // routing key\n                     null, \n                     message.getBytes());\n```\n\n交换器收到的消息广播至所有绑定的队列，绑定不需要给定 routing key\n\n### topic\n\n![topic](http://www.rabbitmq.com/img/tutorials/python-five.png)\n\n```java\nchannel.exchangeDeclare(EXCHANGE_NAME, \"topic\");  // 声明 topic 类型交换器\nString queueName = channel.queueDeclare().getQueue();  // 创建非持久的、唯一的、自动删除的队列\nchannel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);  // 绑定队列，交换器，路由键\n\n// 发送\nchannel.basicPublish(EXCHANGE_NAME, \n                     ROUTING_KEY, \n                     null, \n                     msg.getBytes());\n```\n\n编码过程与使用 direct 交换器的完整过程一直，但是 routing key 可以使用通配符：\n\n- `*` 将 . 视为分隔符进行匹配\n- `#`将任意字符串视为关键字匹配\n\n## 其他\n\n- 消息发后即忘：消息单向传递，默认并不会向发送方确认发送，也不会做持久化\n- prefetch count：在 direct 的第二场景下，消息会被平均分配给各个消费者，而不考虑消费者的消费能力。可以使用设置 Prefetch count 保持各消费者负载均衡\n- binding key：有的文章将 bindling 中使用的 routing key 也称作 binding key，我统一称为 binding key 了\n- 相关 demo [传送门](https://github.com/zhanghTK/rabbit-mq)\n","slug":"【MQ】初始MQ","published":1,"updated":"2017-12-08T13:55:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2qk002ad82eel2obgdp","content":"<p>接触 MQ 之前简单的理解消息队列就是一个理论上无限大的线性表，接触后发现 MQ 支持的功能远不止这些。MQ 的功能可以概括为：削峰填谷，异步解耦。</p>\n<p>从模型上看，MQ 模型不是狭义上的 C/S 模型，而是消息服务投递模型：</p>\n<ul>\n<li>在程序角度：当程序连接到 RabbitMQ 时必须决定自己是发送者还是接受者</li>\n<li>在 MQ 角度：MQ 及接收消息，又发送消息</li>\n</ul>\n<p>AMQP（高级消息队列协议）是对 MQ 最抽象的描述。</p>\n<h2 id=\"AMQP\"><a href=\"#AMQP\" class=\"headerlink\" title=\"AMQP\"></a>AMQP</h2><p>AMQP 定义了一个 MQ 的几个组件，官方的描述还是比较晦涩的，我以自己的理解描述所以可能不够准确：</p>\n<ul>\n<li>Server（broker）：MQ 服务器</li>\n<li>Exchange：一个功能强大 router，不做消息的存储，单纯转发给 MQ</li>\n<li>Message Queue：消息队列，具体存储未被消费的消息</li>\n<li>Message：消息</li>\n<li>Binding：关联 Exchange  和 Message Queeu 的路由表</li>\n<li>Connection：链接，TCP 链接</li>\n<li>Channel：子链接，复用 Connection</li>\n<li>Command：命令</li>\n<li>Virtual Host：服务器创建的 mini 版的 MQ</li>\n</ul>\n<h3 id=\"Exchange-amp-Binding\"><a href=\"#Exchange-amp-Binding\" class=\"headerlink\" title=\"Exchange &amp; Binding\"></a>Exchange &amp; Binding</h3><p>这两个东东算是 MQ 核心功能的实现组件，网上描述的我觉得不是很清楚。</p>\n<p>可以把 exchange 当路由器理解，把 binding 当路由表理解。路由器根据路由表把数据从路由器路由到一下节点，exchange 根据 binding 把消息从 exchange 路由到 queue。exchange 的核心功能是路由转发，而路由转发的依据是 binding。把 binding 当路由表的话，那么这个路由表有三项：</p>\n<ul>\n<li>exchange name</li>\n<li>queue name</li>\n<li>router key</li>\n</ul>\n<p>三者的关系需要在实际生产、消费消息之前完成绑定。而后消息到达 exchange 后根据 routing key 路由到指定 queue。而 exchange  有多种不同实现，不同实现的 exchange 根据 routing key 的路由方式不同，适用于不同场景。</p>\n<h2 id=\"典型场景\"><a href=\"#典型场景\" class=\"headerlink\" title=\"典型场景\"></a>典型场景</h2><p>以下例子从 Rabbit MQ 官网给搬运，<a href=\"http://www.rabbitmq.com/tutorials/tutorial-one-java.html\" target=\"_blank\" rel=\"external\">传送门</a>。</p>\n<h3 id=\"direct\"><a href=\"#direct\" class=\"headerlink\" title=\"direct\"></a>direct</h3><p>direct 类型的交换器严格根据消息头的 exchange name, queue name, router key 将消息路由到对应的队列</p>\n<h4 id=\"消息投递到一个队列\"><a href=\"#消息投递到一个队列\" class=\"headerlink\" title=\"消息投递到一个队列\"></a>消息投递到一个队列</h4><p><img src=\"http://www.rabbitmq.com/img/tutorials/python-one.png\" alt=\"direct1\"></p>\n<p>所有消息由默认交换器根据消息头 queue name 投递到队列。没有声明交换器，自动将队列绑定到了默认交换器。下面代码的第二个参数很容易被当做 queue name，实际上这个字段是 routing key，发送方是不关心 queue 的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);  <span class=\"comment\">// 声明队列</span></div><div class=\"line\">channel.basicPublish(<span class=\"string\">\"\"</span>,  <span class=\"comment\">// exchange name，空则投递到默认交换器</span></div><div class=\"line\">                     QUEUE_NAME,  <span class=\"comment\">// 以 queue_name 作为 routing key</span></div><div class=\"line\">                     <span class=\"keyword\">null</span>, </div><div class=\"line\">                     message.getBytes());</div></pre></td></tr></table></figure>\n<h4 id=\"消息投递到一个队列由多个消费者消费\"><a href=\"#消息投递到一个队列由多个消费者消费\" class=\"headerlink\" title=\"消息投递到一个队列由多个消费者消费\"></a>消息投递到一个队列由多个消费者消费</h4><p><img src=\"http://www.rabbitmq.com/img/tutorials/python-two.png\" alt=\"direct2\"></p>\n<p>可以用于负载均衡的生产者消费者模型，每个消息正常只被消费一次。</p>\n<p>投递过程与上一个一样，队列的消息同时由多个消费者消费</p>\n<h4 id=\"消息有选择的分散到多个队列\"><a href=\"#消息有选择的分散到多个队列\" class=\"headerlink\" title=\"消息有选择的分散到多个队列\"></a>消息有选择的分散到多个队列</h4><p><img src=\"http://www.rabbitmq.com/img/tutorials/direct-exchange.png\" alt=\"direct3\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">\"direct\"</span>);  <span class=\"comment\">// 声明 direct 类型交换器</span></div><div class=\"line\">String queueName = channel.queueDeclare().getQueue();  <span class=\"comment\">// 声明随机队列，并获取该队列名字</span></div><div class=\"line\">channel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);  <span class=\"comment\">// 绑定</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 发送</span></div><div class=\"line\">channel.basicPublish(EXCHANGE_NAME, </div><div class=\"line\">                     ROUTING_KEY, </div><div class=\"line\">                     <span class=\"keyword\">null</span>, </div><div class=\"line\">                     message.getBytes());</div></pre></td></tr></table></figure>\n<p>完整的交换器，队列声明并绑定，消息根据绑定信息投递到对应队列。</p>\n<p>一个交换器与多个队列使用相同的 routing key 进行绑定，当该 routing key 消息发送至交换器可以形成广播的形式。</p>\n<h3 id=\"fanout\"><a href=\"#fanout\" class=\"headerlink\" title=\"fanout\"></a>fanout</h3><p><img src=\"http://www.rabbitmq.com/img/tutorials/exchanges.png\" alt=\"fanout\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">\"fanout\"</span>);  <span class=\"comment\">// 声明 fanout 类型交换器</span></div><div class=\"line\">String queueName = channel.queueDeclare().getQueue();  <span class=\"comment\">// 创建非持久的，唯一的，自动删除的队列</span></div><div class=\"line\">channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">\"\"</span>);  <span class=\"comment\">// 绑定队列与交换器，不要 routing key</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 发送</span></div><div class=\"line\">channel.basicPublish(EXCHANGE_NAME, </div><div class=\"line\">                     <span class=\"string\">\"\"</span>,  <span class=\"comment\">// routing key</span></div><div class=\"line\">                     <span class=\"keyword\">null</span>, </div><div class=\"line\">                     message.getBytes());</div></pre></td></tr></table></figure>\n<p>交换器收到的消息广播至所有绑定的队列，绑定不需要给定 routing key</p>\n<h3 id=\"topic\"><a href=\"#topic\" class=\"headerlink\" title=\"topic\"></a>topic</h3><p><img src=\"http://www.rabbitmq.com/img/tutorials/python-five.png\" alt=\"topic\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">\"topic\"</span>);  <span class=\"comment\">// 声明 topic 类型交换器</span></div><div class=\"line\">String queueName = channel.queueDeclare().getQueue();  <span class=\"comment\">// 创建非持久的、唯一的、自动删除的队列</span></div><div class=\"line\">channel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);  <span class=\"comment\">// 绑定队列，交换器，路由键</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 发送</span></div><div class=\"line\">channel.basicPublish(EXCHANGE_NAME, </div><div class=\"line\">                     ROUTING_KEY, </div><div class=\"line\">                     <span class=\"keyword\">null</span>, </div><div class=\"line\">                     msg.getBytes());</div></pre></td></tr></table></figure>\n<p>编码过程与使用 direct 交换器的完整过程一直，但是 routing key 可以使用通配符：</p>\n<ul>\n<li><code>*</code> 将 . 视为分隔符进行匹配</li>\n<li><code>#</code>将任意字符串视为关键字匹配</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>消息发后即忘：消息单向传递，默认并不会向发送方确认发送，也不会做持久化</li>\n<li>prefetch count：在 direct 的第二场景下，消息会被平均分配给各个消费者，而不考虑消费者的消费能力。可以使用设置 Prefetch count 保持各消费者负载均衡</li>\n<li>binding key：有的文章将 bindling 中使用的 routing key 也称作 binding key，我统一称为 binding key 了</li>\n<li>相关 demo <a href=\"https://github.com/zhanghTK/rabbit-mq\" target=\"_blank\" rel=\"external\">传送门</a></li>\n</ul>\n","excerpt":"","more":"<p>接触 MQ 之前简单的理解消息队列就是一个理论上无限大的线性表，接触后发现 MQ 支持的功能远不止这些。MQ 的功能可以概括为：削峰填谷，异步解耦。</p>\n<p>从模型上看，MQ 模型不是狭义上的 C/S 模型，而是消息服务投递模型：</p>\n<ul>\n<li>在程序角度：当程序连接到 RabbitMQ 时必须决定自己是发送者还是接受者</li>\n<li>在 MQ 角度：MQ 及接收消息，又发送消息</li>\n</ul>\n<p>AMQP（高级消息队列协议）是对 MQ 最抽象的描述。</p>\n<h2 id=\"AMQP\"><a href=\"#AMQP\" class=\"headerlink\" title=\"AMQP\"></a>AMQP</h2><p>AMQP 定义了一个 MQ 的几个组件，官方的描述还是比较晦涩的，我以自己的理解描述所以可能不够准确：</p>\n<ul>\n<li>Server（broker）：MQ 服务器</li>\n<li>Exchange：一个功能强大 router，不做消息的存储，单纯转发给 MQ</li>\n<li>Message Queue：消息队列，具体存储未被消费的消息</li>\n<li>Message：消息</li>\n<li>Binding：关联 Exchange  和 Message Queeu 的路由表</li>\n<li>Connection：链接，TCP 链接</li>\n<li>Channel：子链接，复用 Connection</li>\n<li>Command：命令</li>\n<li>Virtual Host：服务器创建的 mini 版的 MQ</li>\n</ul>\n<h3 id=\"Exchange-amp-Binding\"><a href=\"#Exchange-amp-Binding\" class=\"headerlink\" title=\"Exchange &amp; Binding\"></a>Exchange &amp; Binding</h3><p>这两个东东算是 MQ 核心功能的实现组件，网上描述的我觉得不是很清楚。</p>\n<p>可以把 exchange 当路由器理解，把 binding 当路由表理解。路由器根据路由表把数据从路由器路由到一下节点，exchange 根据 binding 把消息从 exchange 路由到 queue。exchange 的核心功能是路由转发，而路由转发的依据是 binding。把 binding 当路由表的话，那么这个路由表有三项：</p>\n<ul>\n<li>exchange name</li>\n<li>queue name</li>\n<li>router key</li>\n</ul>\n<p>三者的关系需要在实际生产、消费消息之前完成绑定。而后消息到达 exchange 后根据 routing key 路由到指定 queue。而 exchange  有多种不同实现，不同实现的 exchange 根据 routing key 的路由方式不同，适用于不同场景。</p>\n<h2 id=\"典型场景\"><a href=\"#典型场景\" class=\"headerlink\" title=\"典型场景\"></a>典型场景</h2><p>以下例子从 Rabbit MQ 官网给搬运，<a href=\"http://www.rabbitmq.com/tutorials/tutorial-one-java.html\">传送门</a>。</p>\n<h3 id=\"direct\"><a href=\"#direct\" class=\"headerlink\" title=\"direct\"></a>direct</h3><p>direct 类型的交换器严格根据消息头的 exchange name, queue name, router key 将消息路由到对应的队列</p>\n<h4 id=\"消息投递到一个队列\"><a href=\"#消息投递到一个队列\" class=\"headerlink\" title=\"消息投递到一个队列\"></a>消息投递到一个队列</h4><p><img src=\"http://www.rabbitmq.com/img/tutorials/python-one.png\" alt=\"direct1\"></p>\n<p>所有消息由默认交换器根据消息头 queue name 投递到队列。没有声明交换器，自动将队列绑定到了默认交换器。下面代码的第二个参数很容易被当做 queue name，实际上这个字段是 routing key，发送方是不关心 queue 的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);  <span class=\"comment\">// 声明队列</span></div><div class=\"line\">channel.basicPublish(<span class=\"string\">\"\"</span>,  <span class=\"comment\">// exchange name，空则投递到默认交换器</span></div><div class=\"line\">                     QUEUE_NAME,  <span class=\"comment\">// 以 queue_name 作为 routing key</span></div><div class=\"line\">                     <span class=\"keyword\">null</span>, </div><div class=\"line\">                     message.getBytes());</div></pre></td></tr></table></figure>\n<h4 id=\"消息投递到一个队列由多个消费者消费\"><a href=\"#消息投递到一个队列由多个消费者消费\" class=\"headerlink\" title=\"消息投递到一个队列由多个消费者消费\"></a>消息投递到一个队列由多个消费者消费</h4><p><img src=\"http://www.rabbitmq.com/img/tutorials/python-two.png\" alt=\"direct2\"></p>\n<p>可以用于负载均衡的生产者消费者模型，每个消息正常只被消费一次。</p>\n<p>投递过程与上一个一样，队列的消息同时由多个消费者消费</p>\n<h4 id=\"消息有选择的分散到多个队列\"><a href=\"#消息有选择的分散到多个队列\" class=\"headerlink\" title=\"消息有选择的分散到多个队列\"></a>消息有选择的分散到多个队列</h4><p><img src=\"http://www.rabbitmq.com/img/tutorials/direct-exchange.png\" alt=\"direct3\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">\"direct\"</span>);  <span class=\"comment\">// 声明 direct 类型交换器</span></div><div class=\"line\">String queueName = channel.queueDeclare().getQueue();  <span class=\"comment\">// 声明随机队列，并获取该队列名字</span></div><div class=\"line\">channel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);  <span class=\"comment\">// 绑定</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 发送</span></div><div class=\"line\">channel.basicPublish(EXCHANGE_NAME, </div><div class=\"line\">                     ROUTING_KEY, </div><div class=\"line\">                     <span class=\"keyword\">null</span>, </div><div class=\"line\">                     message.getBytes());</div></pre></td></tr></table></figure>\n<p>完整的交换器，队列声明并绑定，消息根据绑定信息投递到对应队列。</p>\n<p>一个交换器与多个队列使用相同的 routing key 进行绑定，当该 routing key 消息发送至交换器可以形成广播的形式。</p>\n<h3 id=\"fanout\"><a href=\"#fanout\" class=\"headerlink\" title=\"fanout\"></a>fanout</h3><p><img src=\"http://www.rabbitmq.com/img/tutorials/exchanges.png\" alt=\"fanout\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">\"fanout\"</span>);  <span class=\"comment\">// 声明 fanout 类型交换器</span></div><div class=\"line\">String queueName = channel.queueDeclare().getQueue();  <span class=\"comment\">// 创建非持久的，唯一的，自动删除的队列</span></div><div class=\"line\">channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">\"\"</span>);  <span class=\"comment\">// 绑定队列与交换器，不要 routing key</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 发送</span></div><div class=\"line\">channel.basicPublish(EXCHANGE_NAME, </div><div class=\"line\">                     <span class=\"string\">\"\"</span>,  <span class=\"comment\">// routing key</span></div><div class=\"line\">                     <span class=\"keyword\">null</span>, </div><div class=\"line\">                     message.getBytes());</div></pre></td></tr></table></figure>\n<p>交换器收到的消息广播至所有绑定的队列，绑定不需要给定 routing key</p>\n<h3 id=\"topic\"><a href=\"#topic\" class=\"headerlink\" title=\"topic\"></a>topic</h3><p><img src=\"http://www.rabbitmq.com/img/tutorials/python-five.png\" alt=\"topic\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">\"topic\"</span>);  <span class=\"comment\">// 声明 topic 类型交换器</span></div><div class=\"line\">String queueName = channel.queueDeclare().getQueue();  <span class=\"comment\">// 创建非持久的、唯一的、自动删除的队列</span></div><div class=\"line\">channel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);  <span class=\"comment\">// 绑定队列，交换器，路由键</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 发送</span></div><div class=\"line\">channel.basicPublish(EXCHANGE_NAME, </div><div class=\"line\">                     ROUTING_KEY, </div><div class=\"line\">                     <span class=\"keyword\">null</span>, </div><div class=\"line\">                     msg.getBytes());</div></pre></td></tr></table></figure>\n<p>编码过程与使用 direct 交换器的完整过程一直，但是 routing key 可以使用通配符：</p>\n<ul>\n<li><code>*</code> 将 . 视为分隔符进行匹配</li>\n<li><code>#</code>将任意字符串视为关键字匹配</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>消息发后即忘：消息单向传递，默认并不会向发送方确认发送，也不会做持久化</li>\n<li>prefetch count：在 direct 的第二场景下，消息会被平均分配给各个消费者，而不考虑消费者的消费能力。可以使用设置 Prefetch count 保持各消费者负载均衡</li>\n<li>binding key：有的文章将 bindling 中使用的 routing key 也称作 binding key，我统一称为 binding key 了</li>\n<li>相关 demo <a href=\"https://github.com/zhanghTK/rabbit-mq\">传送门</a></li>\n</ul>\n"},{"title":"【MQ】使用扩展","date":"2017-12-08T14:00:03.000Z","_content":"\n## TTL\n\n### 带有 TTL 的消息\n\n消息指定 TTL 有两种方式：\n\n1. 通过队列属性设置，到达该队列的所有消息都具有相同的 TTL（x-message-ttl）\n2. 对消息进行单独设置，每条消息的 TTL 可以不同（setExpiration）\n\n两者差异：方式一设置的消息一旦过期就会从队列中丢弃，方式二设置的消息过期后需要在被消费时才丢弃\n\n如果同时使用以上两种消息则以较小的为准。\n\n### 带有 TTL 的队列\n\n队列声明时可以（通过 x-expires）指定多久未使用后队列将被删除，使用场景：RPC 模式下用于回复而创建的 queue。\n\n## 死信\n\n死信：队列无法处理的消息，文档中定义了以下三种场景：\n\n- 消费端发送 basic.reject or basic.nack 指令（并且需要设置 requeue=false ）\n- TTL 过期的消息\n- 队列达到最大长度\n\n在消息投递前如果指定消息成为死信后的处理交换器和 routking，当消息成为死信后 Rabbit MQ 可以根据先前的配置重新投递。\n\n## 延时消息\n\n使用 TTL 消息和死信重新投递就可以容易的构造出延时消息的功能了。\n\n创建两个交换器，两个 binding， 两个队列，延时的过程：\n\n- exchange1 接收生产者的消息，根据 binding 转发给 queue1\n- queue1 的消息设置统一的 TTL，并且不对 queue1 数据进行任何消费动作\n- 等 queue1 的消息过期后 MQ 重新将消息投递到 exchange2\n- exchange2 根据 bindling 信息转发给 queue2\n- 消费者从 queue2 消费消息\n\n## 优先级队列\n\n消息在发送时如果指定优先级，则当队列中消息堆积时，高优先级的消息可以被优先消费掉。具体的做法：\n\n1. 创建队列时，指定队列的最大优先级\n2. 投递消息时指定消息的优先级\n\n消息到达队列后，Rabbit MQ 会根据优先级进行处理，完全自动。\n\n\n","source":"_posts/【MQ】使用扩展.md","raw":"---\ntitle: 【MQ】使用扩展\ndate: 2017-12-08 22:00:03\ntags: MQ\ncategories: MQ\n---\n\n## TTL\n\n### 带有 TTL 的消息\n\n消息指定 TTL 有两种方式：\n\n1. 通过队列属性设置，到达该队列的所有消息都具有相同的 TTL（x-message-ttl）\n2. 对消息进行单独设置，每条消息的 TTL 可以不同（setExpiration）\n\n两者差异：方式一设置的消息一旦过期就会从队列中丢弃，方式二设置的消息过期后需要在被消费时才丢弃\n\n如果同时使用以上两种消息则以较小的为准。\n\n### 带有 TTL 的队列\n\n队列声明时可以（通过 x-expires）指定多久未使用后队列将被删除，使用场景：RPC 模式下用于回复而创建的 queue。\n\n## 死信\n\n死信：队列无法处理的消息，文档中定义了以下三种场景：\n\n- 消费端发送 basic.reject or basic.nack 指令（并且需要设置 requeue=false ）\n- TTL 过期的消息\n- 队列达到最大长度\n\n在消息投递前如果指定消息成为死信后的处理交换器和 routking，当消息成为死信后 Rabbit MQ 可以根据先前的配置重新投递。\n\n## 延时消息\n\n使用 TTL 消息和死信重新投递就可以容易的构造出延时消息的功能了。\n\n创建两个交换器，两个 binding， 两个队列，延时的过程：\n\n- exchange1 接收生产者的消息，根据 binding 转发给 queue1\n- queue1 的消息设置统一的 TTL，并且不对 queue1 数据进行任何消费动作\n- 等 queue1 的消息过期后 MQ 重新将消息投递到 exchange2\n- exchange2 根据 bindling 信息转发给 queue2\n- 消费者从 queue2 消费消息\n\n## 优先级队列\n\n消息在发送时如果指定优先级，则当队列中消息堆积时，高优先级的消息可以被优先消费掉。具体的做法：\n\n1. 创建队列时，指定队列的最大优先级\n2. 投递消息时指定消息的优先级\n\n消息到达队列后，Rabbit MQ 会根据优先级进行处理，完全自动。\n\n\n","slug":"【MQ】使用扩展","published":1,"updated":"2017-12-08T14:00:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2qn002cd82ex9f74av8","content":"<h2 id=\"TTL\"><a href=\"#TTL\" class=\"headerlink\" title=\"TTL\"></a>TTL</h2><h3 id=\"带有-TTL-的消息\"><a href=\"#带有-TTL-的消息\" class=\"headerlink\" title=\"带有 TTL 的消息\"></a>带有 TTL 的消息</h3><p>消息指定 TTL 有两种方式：</p>\n<ol>\n<li>通过队列属性设置，到达该队列的所有消息都具有相同的 TTL（x-message-ttl）</li>\n<li>对消息进行单独设置，每条消息的 TTL 可以不同（setExpiration）</li>\n</ol>\n<p>两者差异：方式一设置的消息一旦过期就会从队列中丢弃，方式二设置的消息过期后需要在被消费时才丢弃</p>\n<p>如果同时使用以上两种消息则以较小的为准。</p>\n<h3 id=\"带有-TTL-的队列\"><a href=\"#带有-TTL-的队列\" class=\"headerlink\" title=\"带有 TTL 的队列\"></a>带有 TTL 的队列</h3><p>队列声明时可以（通过 x-expires）指定多久未使用后队列将被删除，使用场景：RPC 模式下用于回复而创建的 queue。</p>\n<h2 id=\"死信\"><a href=\"#死信\" class=\"headerlink\" title=\"死信\"></a>死信</h2><p>死信：队列无法处理的消息，文档中定义了以下三种场景：</p>\n<ul>\n<li>消费端发送 basic.reject or basic.nack 指令（并且需要设置 requeue=false ）</li>\n<li>TTL 过期的消息</li>\n<li>队列达到最大长度</li>\n</ul>\n<p>在消息投递前如果指定消息成为死信后的处理交换器和 routking，当消息成为死信后 Rabbit MQ 可以根据先前的配置重新投递。</p>\n<h2 id=\"延时消息\"><a href=\"#延时消息\" class=\"headerlink\" title=\"延时消息\"></a>延时消息</h2><p>使用 TTL 消息和死信重新投递就可以容易的构造出延时消息的功能了。</p>\n<p>创建两个交换器，两个 binding， 两个队列，延时的过程：</p>\n<ul>\n<li>exchange1 接收生产者的消息，根据 binding 转发给 queue1</li>\n<li>queue1 的消息设置统一的 TTL，并且不对 queue1 数据进行任何消费动作</li>\n<li>等 queue1 的消息过期后 MQ 重新将消息投递到 exchange2</li>\n<li>exchange2 根据 bindling 信息转发给 queue2</li>\n<li>消费者从 queue2 消费消息</li>\n</ul>\n<h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><p>消息在发送时如果指定优先级，则当队列中消息堆积时，高优先级的消息可以被优先消费掉。具体的做法：</p>\n<ol>\n<li>创建队列时，指定队列的最大优先级</li>\n<li>投递消息时指定消息的优先级</li>\n</ol>\n<p>消息到达队列后，Rabbit MQ 会根据优先级进行处理，完全自动。</p>\n","excerpt":"","more":"<h2 id=\"TTL\"><a href=\"#TTL\" class=\"headerlink\" title=\"TTL\"></a>TTL</h2><h3 id=\"带有-TTL-的消息\"><a href=\"#带有-TTL-的消息\" class=\"headerlink\" title=\"带有 TTL 的消息\"></a>带有 TTL 的消息</h3><p>消息指定 TTL 有两种方式：</p>\n<ol>\n<li>通过队列属性设置，到达该队列的所有消息都具有相同的 TTL（x-message-ttl）</li>\n<li>对消息进行单独设置，每条消息的 TTL 可以不同（setExpiration）</li>\n</ol>\n<p>两者差异：方式一设置的消息一旦过期就会从队列中丢弃，方式二设置的消息过期后需要在被消费时才丢弃</p>\n<p>如果同时使用以上两种消息则以较小的为准。</p>\n<h3 id=\"带有-TTL-的队列\"><a href=\"#带有-TTL-的队列\" class=\"headerlink\" title=\"带有 TTL 的队列\"></a>带有 TTL 的队列</h3><p>队列声明时可以（通过 x-expires）指定多久未使用后队列将被删除，使用场景：RPC 模式下用于回复而创建的 queue。</p>\n<h2 id=\"死信\"><a href=\"#死信\" class=\"headerlink\" title=\"死信\"></a>死信</h2><p>死信：队列无法处理的消息，文档中定义了以下三种场景：</p>\n<ul>\n<li>消费端发送 basic.reject or basic.nack 指令（并且需要设置 requeue=false ）</li>\n<li>TTL 过期的消息</li>\n<li>队列达到最大长度</li>\n</ul>\n<p>在消息投递前如果指定消息成为死信后的处理交换器和 routking，当消息成为死信后 Rabbit MQ 可以根据先前的配置重新投递。</p>\n<h2 id=\"延时消息\"><a href=\"#延时消息\" class=\"headerlink\" title=\"延时消息\"></a>延时消息</h2><p>使用 TTL 消息和死信重新投递就可以容易的构造出延时消息的功能了。</p>\n<p>创建两个交换器，两个 binding， 两个队列，延时的过程：</p>\n<ul>\n<li>exchange1 接收生产者的消息，根据 binding 转发给 queue1</li>\n<li>queue1 的消息设置统一的 TTL，并且不对 queue1 数据进行任何消费动作</li>\n<li>等 queue1 的消息过期后 MQ 重新将消息投递到 exchange2</li>\n<li>exchange2 根据 bindling 信息转发给 queue2</li>\n<li>消费者从 queue2 消费消息</li>\n</ul>\n<h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><p>消息在发送时如果指定优先级，则当队列中消息堆积时，高优先级的消息可以被优先消费掉。具体的做法：</p>\n<ol>\n<li>创建队列时，指定队列的最大优先级</li>\n<li>投递消息时指定消息的优先级</li>\n</ol>\n<p>消息到达队列后，Rabbit MQ 会根据优先级进行处理，完全自动。</p>\n"},{"title":"【SpringBoot】Servlet容器","date":"2017-08-31T13:25:12.000Z","_content":"\n记得自己看 Spring Boot 源码的初衷是对部署时不需要额外的 Servlet 容器的好奇，好像看着看着关注到了其他细节。挖了几个坑就跳过了，今天把之前关于 Spring Boot 与 Servlet 容器的坑填一下。\n\n先回（rang）顾（wo）一（xiang）下（xiang）之前与 Web 环境相关的内容：\n\n- [SpringBoot包文件执行分析](http://zhangh.tk/2017/06/20/SpringBoot%E5%8C%85%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90/)，这里说到开启了新线程调用应用入口，该线程设置了上下文类加载器 LaunchedURLClassLoader\n- [【SpringBoot】SpringApplication实例创建](http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91SpringApplication%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA/)，这里说到根据 CLASSPTH 的包含的类推断当前是否是 web 环境\n- [【SpringBoot】容器启动](http://zhangh.tk/2017/07/10/%E3%80%90SpringBoot%E3%80%91%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8/)，这里说到根据是否 web 环境创建做相关准备，创建处理 web 环境对应的 Spring容器\n- [【Spring容器刷新】](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/)，这里说到 Spring 容器生命周期的相关方法\n\n## Servlet 容器启动\n\n[【SpringBoot】容器启动 ](http://zhangh.tk/2017/07/10/%E3%80%90SpringBoot%E3%80%91%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8/)中提到的创建处理 web 环境对应的 Spring 容器实际创建的就是 AnnotationConfigEmbeddedWebApplicationContext，这个类是 ApplicationContext 的子类。其分别在 onRefresh 和 finishRefresh 方法中创建和启动 Servlet 容器：\n\n```java\n@Override\nprotected void onRefresh() {\n   super.onRefresh();\n   try {\n      createEmbeddedServletContainer();\n   }\n   catch (Throwable ex) {\n      throw new ApplicationContextException(\"Unable to start embedded container\", ex);\n   }\n}\n\n@Override\nprotected void finishRefresh() {\n  super.finishRefresh();\n  EmbeddedServletContainer localContainer = startEmbeddedServletContainer();\n  if (localContainer != null) {\n    publishEvent(\n\tnew EmbeddedServletContainerInitializedEvent(this, localContainer));\n  }\n}\n```\n\n在 Spring 容器生命周期里与 Servlet 容器相关的逻辑封装在以上两个方法，分别用以创建和启动 Servlet 容器。\n\n## Servlet 容器创建细节\n\n上面说到 AnnotationConfigEmbeddedWebApplicationContext 中创建 Servlet 容器，具体的细节如下：\n\n```java\n// AnnotationConfigEmbeddedWebApplicationContext\nprivate void createEmbeddedServletContainer() {\n   EmbeddedServletContainer localContainer = this.embeddedServletContainer;\n   ServletContext localServletContext = getServletContext();\n   if (localContainer == null && localServletContext == null) {\n      // 获取 Servlet 容器工厂\n      EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();\n      // 获取 Servlet 容器初始化器\n      // 使用 Servlet 容器初始化器创建 Servlet 容器\n      this.embeddedServletContainer = \n        containerFactory.getEmbeddedServletContainer(getSelfInitializer());\n   }\n   else if (localServletContext != null) {\n      try {\n         getSelfInitializer().onStartup(localServletContext);\n      }\n      catch (ServletException ex) {\n         throw new ApplicationContextException(\"Cannot initialize servlet context\",\n               ex);\n      }\n   }\n   initPropertySources();\n}\n```\n\n细节可以分为：\n\n1. 获取 Servlet 容器工厂\n2. 获取 Servlet 容器初始化器\n3. 创建 Servlet 容器\n\n### 获取 Servlet 容器工厂\n\n```java\n// AnnotationConfigEmbeddedWebApplicationContext\n\nprotected EmbeddedServletContainerFactory getEmbeddedServletContainerFactory() {\n   // Use bean names so that we don't consider the hierarchy\n   String[] beanNames = getBeanFactory()\n         .getBeanNamesForType(EmbeddedServletContainerFactory.class);\n   // 省略异常\n   return getBeanFactory().getBean(beanNames[0],\n         EmbeddedServletContainerFactory.class);\n}\n```\n\n直接从 Spring 容器里获取 Servlet 容器工厂。一时之间卡住了不知道 EmbeddedServletContainerFactory 这个类时怎么注册到 Spring 容器中的。在网上查了一下发现是 META-INF/spring.factories 里指定了 EmbeddedServletContainerAutoConfiguration 这个配置类。而 EmbeddedServletContainerFactory 是 EmbeddedServletContainerAutoConfiguration 这个自动化配置类中被注册到 Spring 容器中的，关于配置类的注册我又要挖坑了。EmbeddedServletContainerAutoConfiguration：\n\n```java\n@AutoConfigureOrder(-2147483648)\n@Configuration\n@ConditionalOnWebApplication  // 在Web环境下起作用\n@Import({EmbeddedServletContainerAutoConfiguration.BeanPostProcessorsRegistrar.class})\npublic class EmbeddedServletContainerAutoConfiguration {\n    public EmbeddedServletContainerAutoConfiguration() {\n    }\n    \n    // 在 import 中导入该类\n    // 主要作用是注册 EmbeddedServletContainerCustomizerBeanPostProcessor,\n    // ErrorPageRegistrarBeanPostProcessor\n    public static class BeanPostProcessorsRegistrar \n      implements ImportBeanDefinitionRegistrar, BeanFactoryAware {\n        // 省略\n        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,\n                                            BeanDefinitionRegistry registry) {\n            if(this.beanFactory != null) {\n                // 注册 EmbeddedServletContainerCustomizerBeanPostProcessor\n                this.registerSyntheticBeanIfMissing(\n                  registry, \"embeddedServletContainerCustomizerBeanPostProcessor\", \n                  EmbeddedServletContainerCustomizerBeanPostProcessor.class);\n                // 注册 ErrorPageRegistrarBeanPostProcessor\n                this.registerSyntheticBeanIfMissing(\n                  registry, \"errorPageRegistrarBeanPostProcessor\", \n                  ErrorPageRegistrarBeanPostProcessor.class);\n            }\n        }\n\n        private void registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry, \n                                                    String name, Class<?> beanClass) {\n            if(ObjectUtils.isEmpty(this.beanFactory.getBeanNamesForType(beanClass, \n                                                                        true, false))) {\n                RootBeanDefinition beanDefinition = new RootBeanDefinition(beanClass);\n                beanDefinition.setSynthetic(true);\n                registry.registerBeanDefinition(name, beanDefinition);\n            }\n\n        }\n    }\n\n    // 省略 Jetty，Undertow 配置\n\n    @Configuration\n    @ConditionalOnClass({Servlet.class, Tomcat.class})\n    @ConditionalOnMissingBean(\n        value = {EmbeddedServletContainerFactory.class},\n        search = SearchStrategy.CURRENT\n    )\n    public static class EmbeddedTomcat {\n        public EmbeddedTomcat() {\n        }\n\n        @Bean\n        public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {\n            // 注册 EmbeddedServletContainerFactory 的实现类\n            return new TomcatEmbeddedServletContainerFactory();\n        }\n    }\n}\n```\n\n当满足特定条件时会注册具体的 EmbeddedServletContainerFactory 实现类，例如 TomcatEmbeddedServletContainerFactory。\n\n这里还看到 注册了 EmbeddedServletContainerCustomizerBeanPostProcessor 和 ErrorPageRegistrarBeanPostProcessor 。简单看了一下 EmbeddedServletContainerCustomizerBeanPostProcessor，这是一个基本的 BeanPostProcessor，具体作用是对 EmbeddedServletContainerCustomizer 的实例进行定制，具体的实现包括：ErrorPageCustomizer，TomcatWebSocketContainerCustomizer，ServerProperties 等。\n\n```java\n// EmbeddedServletContainerCustomizerBeanPostProcessor \npublic class EmbeddedServletContainerCustomizerBeanPostProcessor\n      implements BeanPostProcessor, BeanFactoryAware {\n\n   private ListableBeanFactory beanFactory;\n\n   private List<EmbeddedServletContainerCustomizer> customizers;\n\n   @Override\n   public Object postProcessBeforeInitialization(Object bean, String beanName)\n         throws BeansException {\n      if (bean instanceof ConfigurableEmbeddedServletContainer) {\n         // 处理ConfigurableEmbeddedServletContainer类型的bean\n         postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);\n      }\n      return bean;\n   }\n\n   private void postProcessBeforeInitialization(\n         ConfigurableEmbeddedServletContainer bean) {\n      // 对ConfigurableEmbeddedServletContainer类型的bean定制化处理\n      for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {\n         customizer.customize(bean);\n      }\n   }\n\n   private Collection<EmbeddedServletContainerCustomizer> getCustomizers() {\n      if (this.customizers == null) {\n         // 从容器中找出所有EmbeddedServletContainerCustomizer类型的bean\n         this.customizers = new ArrayList<EmbeddedServletContainerCustomizer>(\n               this.beanFactory.getBeansOfType(EmbeddedServletContainerCustomizer.class,\n                                               false, false).values());\n         Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);\n         this.customizers = Collections.unmodifiableList(this.customizers);\n      }\n      return this.customizers;\n   }\n\n}\n```\n\n### Servlet 容器初始化器\n\n再回顾一下 Servlet 容器的创建核心逻辑：\n\n```java\ncontainerFactory.getEmbeddedServletContainer(getSelfInitializer());\n```\n\n先获取 Servlet 初始化器，然后创建 Servlet 容器\n\n```java\nprivate org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {\n   return new ServletContextInitializer() {\n      @Override\n      public void onStartup(ServletContext servletContext) throws ServletException {\n         selfInitialize(servletContext);\n      }\n   };\n}\n\nprivate void selfInitialize(ServletContext servletContext) throws ServletException {\n   // Servlet 容器准备\n   prepareEmbeddedWebApplicationContext(servletContext);\n   // 初始 scopes\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   ExistingWebApplicationScopes existingScopes = new ExistingWebApplicationScopes(\n         beanFactory);\n   WebApplicationContextUtils.registerWebApplicationScopes(beanFactory,\n         getServletContext());\n   existingScopes.restore();\n   // 注册 web 相关 bean\n   WebApplicationContextUtils.registerEnvironmentBeans(beanFactory,\n         getServletContext());\n   // 初始化 servlet, filter, Listener 并注册\n   for (ServletContextInitializer beans : getServletContextInitializerBeans()) {\n      beans.onStartup(servletContext);\n   }\n}\n\n// 获取 ServletContext 初始化 bean\nprotected Collection<ServletContextInitializer> getServletContextInitializerBeans() {\n\tnew ServletContextInitializerBeans(getBeanFactory());\n}\n```\n\n```java\npublic ServletContextInitializerBeans(ListableBeanFactory beanFactory) {\n   this.initializers = new LinkedMultiValueMap<Class<?>, ServletContextInitializer>();\n   // 添加 ServletContextInitializer 类型的 bean\n   addServletContextInitializerBeans(beanFactory);\n   addAdaptableBeans(beanFactory);\n   List<ServletContextInitializer> sortedInitializers = \n     new ArrayList<ServletContextInitializer>();\n   for (Map.Entry<?, List<ServletContextInitializer>> entry : this.initializers.entrySet()) {\n      AnnotationAwareOrderComparator.sort(entry.getValue());\n      sortedInitializers.addAll(entry.getValue());\n   }\n   this.sortedList = Collections.unmodifiableList(sortedInitializers);\n}\n\nprivate void addServletContextInitializerBeans(ListableBeanFactory beanFactory) {\n   for (Entry<String, ServletContextInitializer> initializerBean : getOrderedBeansOfType(\n         beanFactory, ServletContextInitializer.class)) {\n      addServletContextInitializerBean(initializerBean.getKey(),\n            initializerBean.getValue(), beanFactory);\n   }\n}\n\nprivate void addServletContextInitializerBean(String beanName,\n      ServletContextInitializer initializer, ListableBeanFactory beanFactory) {\n   if (initializer instanceof ServletRegistrationBean) {\n      // servlet\n      Servlet source = ((ServletRegistrationBean) initializer).getServlet();\n      addServletContextInitializerBean(Servlet.class, beanName, initializer,\n            beanFactory, source);\n   }\n   else if (initializer instanceof FilterRegistrationBean) {\n      // filter\n      Filter source = ((FilterRegistrationBean) initializer).getFilter();\n      addServletContextInitializerBean(Filter.class, beanName, initializer,\n            beanFactory, source);\n   }\n   else if (initializer instanceof DelegatingFilterProxyRegistrationBean) {\n      // filter\n      String source = ((DelegatingFilterProxyRegistrationBean) initializer)\n            .getTargetBeanName();\n      addServletContextInitializerBean(Filter.class, beanName, initializer,\n            beanFactory, source);\n   }\n   else if (initializer instanceof ServletListenerRegistrationBean) {\n      // listener\n      EventListener source = ((ServletListenerRegistrationBean<?>) initializer)\n            .getListener();\n      addServletContextInitializerBean(EventListener.class, beanName, initializer,\n            beanFactory, source);\n   }\n   else {\n      addServletContextInitializerBean(ServletContextInitializer.class, beanName,\n            initializer, beanFactory, initializer);\n   }\n}\n```\n\n### 创建 Servlet 容器\n\n以 TomcatEmbeddedServletContainerFactory 的创建容器方法为例：\n\n```java\n@Override\npublic EmbeddedServletContainer getEmbeddedServletContainer(\n      ServletContextInitializer... initializers) {\n   Tomcat tomcat = new Tomcat();\n   File baseDir = (this.baseDirectory != null ? this.baseDirectory\n         : createTempDir(\"tomcat\"));\n   tomcat.setBaseDir(baseDir.getAbsolutePath());\n   Connector connector = new Connector(this.protocol);\n   tomcat.getService().addConnector(connector);\n   customizeConnector(connector);\n   tomcat.setConnector(connector);\n   tomcat.getHost().setAutoDeploy(false);\n   configureEngine(tomcat.getEngine());\n   for (Connector additionalConnector : this.additionalTomcatConnectors) {\n      tomcat.getService().addConnector(additionalConnector);\n   }\n   prepareContext(tomcat.getHost(), initializers);\n   return getTomcatEmbeddedServletContainer(tomcat);\n}\n```\n\n上面的代码完成了 Servlet 容器启动前所有的创建，配置动作。\n\n## Servlet 容器启动\n\n```java\nprivate EmbeddedServletContainer startEmbeddedServletContainer() {\n   EmbeddedServletContainer localContainer = this.embeddedServletContainer;\n   if (localContainer != null) {\n      localContainer.start();\n   }\n   return localContainer;\n}\n```\n\n启动的逻辑并不复杂，直接调用 Servlet 容器的 start 方法。\n\n## 总结\n\nSpring Boot 使用的内嵌 Servlet 容器启动过程：\n\n1. 从 spring.factories 中读取并注册了 EmbeddedServletContainerAutoConfiguration 类\n2. EmbeddedServletContainerAutoConfiguration 注册了 Servlet 容器工厂类\n3. 在 Spring 容器生命周期的 onRefresh 方法中开始创建 Servlet 容器\n   1. 获取 Servlet 容器工厂\n   2. 获取 Servlet 相关初始化 bean\n   3. 配置并创建 Servlet 容器\n4. 在 Spring 容器生命周期的 finishRefresh 方法中调用 Servlet 容器的 start 方法启动容器\n\n\n","source":"_posts/【SpringBoot】Servlet容器.md","raw":"---\ntitle: 【SpringBoot】Servlet容器\ndate: 2017-08-31 21:25:12\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n\n记得自己看 Spring Boot 源码的初衷是对部署时不需要额外的 Servlet 容器的好奇，好像看着看着关注到了其他细节。挖了几个坑就跳过了，今天把之前关于 Spring Boot 与 Servlet 容器的坑填一下。\n\n先回（rang）顾（wo）一（xiang）下（xiang）之前与 Web 环境相关的内容：\n\n- [SpringBoot包文件执行分析](http://zhangh.tk/2017/06/20/SpringBoot%E5%8C%85%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90/)，这里说到开启了新线程调用应用入口，该线程设置了上下文类加载器 LaunchedURLClassLoader\n- [【SpringBoot】SpringApplication实例创建](http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91SpringApplication%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA/)，这里说到根据 CLASSPTH 的包含的类推断当前是否是 web 环境\n- [【SpringBoot】容器启动](http://zhangh.tk/2017/07/10/%E3%80%90SpringBoot%E3%80%91%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8/)，这里说到根据是否 web 环境创建做相关准备，创建处理 web 环境对应的 Spring容器\n- [【Spring容器刷新】](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/)，这里说到 Spring 容器生命周期的相关方法\n\n## Servlet 容器启动\n\n[【SpringBoot】容器启动 ](http://zhangh.tk/2017/07/10/%E3%80%90SpringBoot%E3%80%91%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8/)中提到的创建处理 web 环境对应的 Spring 容器实际创建的就是 AnnotationConfigEmbeddedWebApplicationContext，这个类是 ApplicationContext 的子类。其分别在 onRefresh 和 finishRefresh 方法中创建和启动 Servlet 容器：\n\n```java\n@Override\nprotected void onRefresh() {\n   super.onRefresh();\n   try {\n      createEmbeddedServletContainer();\n   }\n   catch (Throwable ex) {\n      throw new ApplicationContextException(\"Unable to start embedded container\", ex);\n   }\n}\n\n@Override\nprotected void finishRefresh() {\n  super.finishRefresh();\n  EmbeddedServletContainer localContainer = startEmbeddedServletContainer();\n  if (localContainer != null) {\n    publishEvent(\n\tnew EmbeddedServletContainerInitializedEvent(this, localContainer));\n  }\n}\n```\n\n在 Spring 容器生命周期里与 Servlet 容器相关的逻辑封装在以上两个方法，分别用以创建和启动 Servlet 容器。\n\n## Servlet 容器创建细节\n\n上面说到 AnnotationConfigEmbeddedWebApplicationContext 中创建 Servlet 容器，具体的细节如下：\n\n```java\n// AnnotationConfigEmbeddedWebApplicationContext\nprivate void createEmbeddedServletContainer() {\n   EmbeddedServletContainer localContainer = this.embeddedServletContainer;\n   ServletContext localServletContext = getServletContext();\n   if (localContainer == null && localServletContext == null) {\n      // 获取 Servlet 容器工厂\n      EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();\n      // 获取 Servlet 容器初始化器\n      // 使用 Servlet 容器初始化器创建 Servlet 容器\n      this.embeddedServletContainer = \n        containerFactory.getEmbeddedServletContainer(getSelfInitializer());\n   }\n   else if (localServletContext != null) {\n      try {\n         getSelfInitializer().onStartup(localServletContext);\n      }\n      catch (ServletException ex) {\n         throw new ApplicationContextException(\"Cannot initialize servlet context\",\n               ex);\n      }\n   }\n   initPropertySources();\n}\n```\n\n细节可以分为：\n\n1. 获取 Servlet 容器工厂\n2. 获取 Servlet 容器初始化器\n3. 创建 Servlet 容器\n\n### 获取 Servlet 容器工厂\n\n```java\n// AnnotationConfigEmbeddedWebApplicationContext\n\nprotected EmbeddedServletContainerFactory getEmbeddedServletContainerFactory() {\n   // Use bean names so that we don't consider the hierarchy\n   String[] beanNames = getBeanFactory()\n         .getBeanNamesForType(EmbeddedServletContainerFactory.class);\n   // 省略异常\n   return getBeanFactory().getBean(beanNames[0],\n         EmbeddedServletContainerFactory.class);\n}\n```\n\n直接从 Spring 容器里获取 Servlet 容器工厂。一时之间卡住了不知道 EmbeddedServletContainerFactory 这个类时怎么注册到 Spring 容器中的。在网上查了一下发现是 META-INF/spring.factories 里指定了 EmbeddedServletContainerAutoConfiguration 这个配置类。而 EmbeddedServletContainerFactory 是 EmbeddedServletContainerAutoConfiguration 这个自动化配置类中被注册到 Spring 容器中的，关于配置类的注册我又要挖坑了。EmbeddedServletContainerAutoConfiguration：\n\n```java\n@AutoConfigureOrder(-2147483648)\n@Configuration\n@ConditionalOnWebApplication  // 在Web环境下起作用\n@Import({EmbeddedServletContainerAutoConfiguration.BeanPostProcessorsRegistrar.class})\npublic class EmbeddedServletContainerAutoConfiguration {\n    public EmbeddedServletContainerAutoConfiguration() {\n    }\n    \n    // 在 import 中导入该类\n    // 主要作用是注册 EmbeddedServletContainerCustomizerBeanPostProcessor,\n    // ErrorPageRegistrarBeanPostProcessor\n    public static class BeanPostProcessorsRegistrar \n      implements ImportBeanDefinitionRegistrar, BeanFactoryAware {\n        // 省略\n        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,\n                                            BeanDefinitionRegistry registry) {\n            if(this.beanFactory != null) {\n                // 注册 EmbeddedServletContainerCustomizerBeanPostProcessor\n                this.registerSyntheticBeanIfMissing(\n                  registry, \"embeddedServletContainerCustomizerBeanPostProcessor\", \n                  EmbeddedServletContainerCustomizerBeanPostProcessor.class);\n                // 注册 ErrorPageRegistrarBeanPostProcessor\n                this.registerSyntheticBeanIfMissing(\n                  registry, \"errorPageRegistrarBeanPostProcessor\", \n                  ErrorPageRegistrarBeanPostProcessor.class);\n            }\n        }\n\n        private void registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry, \n                                                    String name, Class<?> beanClass) {\n            if(ObjectUtils.isEmpty(this.beanFactory.getBeanNamesForType(beanClass, \n                                                                        true, false))) {\n                RootBeanDefinition beanDefinition = new RootBeanDefinition(beanClass);\n                beanDefinition.setSynthetic(true);\n                registry.registerBeanDefinition(name, beanDefinition);\n            }\n\n        }\n    }\n\n    // 省略 Jetty，Undertow 配置\n\n    @Configuration\n    @ConditionalOnClass({Servlet.class, Tomcat.class})\n    @ConditionalOnMissingBean(\n        value = {EmbeddedServletContainerFactory.class},\n        search = SearchStrategy.CURRENT\n    )\n    public static class EmbeddedTomcat {\n        public EmbeddedTomcat() {\n        }\n\n        @Bean\n        public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {\n            // 注册 EmbeddedServletContainerFactory 的实现类\n            return new TomcatEmbeddedServletContainerFactory();\n        }\n    }\n}\n```\n\n当满足特定条件时会注册具体的 EmbeddedServletContainerFactory 实现类，例如 TomcatEmbeddedServletContainerFactory。\n\n这里还看到 注册了 EmbeddedServletContainerCustomizerBeanPostProcessor 和 ErrorPageRegistrarBeanPostProcessor 。简单看了一下 EmbeddedServletContainerCustomizerBeanPostProcessor，这是一个基本的 BeanPostProcessor，具体作用是对 EmbeddedServletContainerCustomizer 的实例进行定制，具体的实现包括：ErrorPageCustomizer，TomcatWebSocketContainerCustomizer，ServerProperties 等。\n\n```java\n// EmbeddedServletContainerCustomizerBeanPostProcessor \npublic class EmbeddedServletContainerCustomizerBeanPostProcessor\n      implements BeanPostProcessor, BeanFactoryAware {\n\n   private ListableBeanFactory beanFactory;\n\n   private List<EmbeddedServletContainerCustomizer> customizers;\n\n   @Override\n   public Object postProcessBeforeInitialization(Object bean, String beanName)\n         throws BeansException {\n      if (bean instanceof ConfigurableEmbeddedServletContainer) {\n         // 处理ConfigurableEmbeddedServletContainer类型的bean\n         postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);\n      }\n      return bean;\n   }\n\n   private void postProcessBeforeInitialization(\n         ConfigurableEmbeddedServletContainer bean) {\n      // 对ConfigurableEmbeddedServletContainer类型的bean定制化处理\n      for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {\n         customizer.customize(bean);\n      }\n   }\n\n   private Collection<EmbeddedServletContainerCustomizer> getCustomizers() {\n      if (this.customizers == null) {\n         // 从容器中找出所有EmbeddedServletContainerCustomizer类型的bean\n         this.customizers = new ArrayList<EmbeddedServletContainerCustomizer>(\n               this.beanFactory.getBeansOfType(EmbeddedServletContainerCustomizer.class,\n                                               false, false).values());\n         Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);\n         this.customizers = Collections.unmodifiableList(this.customizers);\n      }\n      return this.customizers;\n   }\n\n}\n```\n\n### Servlet 容器初始化器\n\n再回顾一下 Servlet 容器的创建核心逻辑：\n\n```java\ncontainerFactory.getEmbeddedServletContainer(getSelfInitializer());\n```\n\n先获取 Servlet 初始化器，然后创建 Servlet 容器\n\n```java\nprivate org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {\n   return new ServletContextInitializer() {\n      @Override\n      public void onStartup(ServletContext servletContext) throws ServletException {\n         selfInitialize(servletContext);\n      }\n   };\n}\n\nprivate void selfInitialize(ServletContext servletContext) throws ServletException {\n   // Servlet 容器准备\n   prepareEmbeddedWebApplicationContext(servletContext);\n   // 初始 scopes\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   ExistingWebApplicationScopes existingScopes = new ExistingWebApplicationScopes(\n         beanFactory);\n   WebApplicationContextUtils.registerWebApplicationScopes(beanFactory,\n         getServletContext());\n   existingScopes.restore();\n   // 注册 web 相关 bean\n   WebApplicationContextUtils.registerEnvironmentBeans(beanFactory,\n         getServletContext());\n   // 初始化 servlet, filter, Listener 并注册\n   for (ServletContextInitializer beans : getServletContextInitializerBeans()) {\n      beans.onStartup(servletContext);\n   }\n}\n\n// 获取 ServletContext 初始化 bean\nprotected Collection<ServletContextInitializer> getServletContextInitializerBeans() {\n\tnew ServletContextInitializerBeans(getBeanFactory());\n}\n```\n\n```java\npublic ServletContextInitializerBeans(ListableBeanFactory beanFactory) {\n   this.initializers = new LinkedMultiValueMap<Class<?>, ServletContextInitializer>();\n   // 添加 ServletContextInitializer 类型的 bean\n   addServletContextInitializerBeans(beanFactory);\n   addAdaptableBeans(beanFactory);\n   List<ServletContextInitializer> sortedInitializers = \n     new ArrayList<ServletContextInitializer>();\n   for (Map.Entry<?, List<ServletContextInitializer>> entry : this.initializers.entrySet()) {\n      AnnotationAwareOrderComparator.sort(entry.getValue());\n      sortedInitializers.addAll(entry.getValue());\n   }\n   this.sortedList = Collections.unmodifiableList(sortedInitializers);\n}\n\nprivate void addServletContextInitializerBeans(ListableBeanFactory beanFactory) {\n   for (Entry<String, ServletContextInitializer> initializerBean : getOrderedBeansOfType(\n         beanFactory, ServletContextInitializer.class)) {\n      addServletContextInitializerBean(initializerBean.getKey(),\n            initializerBean.getValue(), beanFactory);\n   }\n}\n\nprivate void addServletContextInitializerBean(String beanName,\n      ServletContextInitializer initializer, ListableBeanFactory beanFactory) {\n   if (initializer instanceof ServletRegistrationBean) {\n      // servlet\n      Servlet source = ((ServletRegistrationBean) initializer).getServlet();\n      addServletContextInitializerBean(Servlet.class, beanName, initializer,\n            beanFactory, source);\n   }\n   else if (initializer instanceof FilterRegistrationBean) {\n      // filter\n      Filter source = ((FilterRegistrationBean) initializer).getFilter();\n      addServletContextInitializerBean(Filter.class, beanName, initializer,\n            beanFactory, source);\n   }\n   else if (initializer instanceof DelegatingFilterProxyRegistrationBean) {\n      // filter\n      String source = ((DelegatingFilterProxyRegistrationBean) initializer)\n            .getTargetBeanName();\n      addServletContextInitializerBean(Filter.class, beanName, initializer,\n            beanFactory, source);\n   }\n   else if (initializer instanceof ServletListenerRegistrationBean) {\n      // listener\n      EventListener source = ((ServletListenerRegistrationBean<?>) initializer)\n            .getListener();\n      addServletContextInitializerBean(EventListener.class, beanName, initializer,\n            beanFactory, source);\n   }\n   else {\n      addServletContextInitializerBean(ServletContextInitializer.class, beanName,\n            initializer, beanFactory, initializer);\n   }\n}\n```\n\n### 创建 Servlet 容器\n\n以 TomcatEmbeddedServletContainerFactory 的创建容器方法为例：\n\n```java\n@Override\npublic EmbeddedServletContainer getEmbeddedServletContainer(\n      ServletContextInitializer... initializers) {\n   Tomcat tomcat = new Tomcat();\n   File baseDir = (this.baseDirectory != null ? this.baseDirectory\n         : createTempDir(\"tomcat\"));\n   tomcat.setBaseDir(baseDir.getAbsolutePath());\n   Connector connector = new Connector(this.protocol);\n   tomcat.getService().addConnector(connector);\n   customizeConnector(connector);\n   tomcat.setConnector(connector);\n   tomcat.getHost().setAutoDeploy(false);\n   configureEngine(tomcat.getEngine());\n   for (Connector additionalConnector : this.additionalTomcatConnectors) {\n      tomcat.getService().addConnector(additionalConnector);\n   }\n   prepareContext(tomcat.getHost(), initializers);\n   return getTomcatEmbeddedServletContainer(tomcat);\n}\n```\n\n上面的代码完成了 Servlet 容器启动前所有的创建，配置动作。\n\n## Servlet 容器启动\n\n```java\nprivate EmbeddedServletContainer startEmbeddedServletContainer() {\n   EmbeddedServletContainer localContainer = this.embeddedServletContainer;\n   if (localContainer != null) {\n      localContainer.start();\n   }\n   return localContainer;\n}\n```\n\n启动的逻辑并不复杂，直接调用 Servlet 容器的 start 方法。\n\n## 总结\n\nSpring Boot 使用的内嵌 Servlet 容器启动过程：\n\n1. 从 spring.factories 中读取并注册了 EmbeddedServletContainerAutoConfiguration 类\n2. EmbeddedServletContainerAutoConfiguration 注册了 Servlet 容器工厂类\n3. 在 Spring 容器生命周期的 onRefresh 方法中开始创建 Servlet 容器\n   1. 获取 Servlet 容器工厂\n   2. 获取 Servlet 相关初始化 bean\n   3. 配置并创建 Servlet 容器\n4. 在 Spring 容器生命周期的 finishRefresh 方法中调用 Servlet 容器的 start 方法启动容器\n\n\n","slug":"【SpringBoot】Servlet容器","published":1,"updated":"2017-08-31T13:27:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2qr002gd82epuxmi7iu","content":"<p>记得自己看 Spring Boot 源码的初衷是对部署时不需要额外的 Servlet 容器的好奇，好像看着看着关注到了其他细节。挖了几个坑就跳过了，今天把之前关于 Spring Boot 与 Servlet 容器的坑填一下。</p>\n<p>先回（rang）顾（wo）一（xiang）下（xiang）之前与 Web 环境相关的内容：</p>\n<ul>\n<li><a href=\"http://zhangh.tk/2017/06/20/SpringBoot%E5%8C%85%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"external\">SpringBoot包文件执行分析</a>，这里说到开启了新线程调用应用入口，该线程设置了上下文类加载器 LaunchedURLClassLoader</li>\n<li><a href=\"http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91SpringApplication%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA/\" target=\"_blank\" rel=\"external\">【SpringBoot】SpringApplication实例创建</a>，这里说到根据 CLASSPTH 的包含的类推断当前是否是 web 环境</li>\n<li><a href=\"http://zhangh.tk/2017/07/10/%E3%80%90SpringBoot%E3%80%91%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8/\" target=\"_blank\" rel=\"external\">【SpringBoot】容器启动</a>，这里说到根据是否 web 环境创建做相关准备，创建处理 web 环境对应的 Spring容器</li>\n<li><a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/\" target=\"_blank\" rel=\"external\">【Spring容器刷新】</a>，这里说到 Spring 容器生命周期的相关方法</li>\n</ul>\n<h2 id=\"Servlet-容器启动\"><a href=\"#Servlet-容器启动\" class=\"headerlink\" title=\"Servlet 容器启动\"></a>Servlet 容器启动</h2><p><a href=\"http://zhangh.tk/2017/07/10/%E3%80%90SpringBoot%E3%80%91%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8/\" target=\"_blank\" rel=\"external\">【SpringBoot】容器启动 </a>中提到的创建处理 web 环境对应的 Spring 容器实际创建的就是 AnnotationConfigEmbeddedWebApplicationContext，这个类是 ApplicationContext 的子类。其分别在 onRefresh 和 finishRefresh 方法中创建和启动 Servlet 容器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onRefresh</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">super</span>.onRefresh();</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      createEmbeddedServletContainer();</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">\"Unable to start embedded container\"</span>, ex);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finishRefresh</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">super</span>.finishRefresh();</div><div class=\"line\">  EmbeddedServletContainer localContainer = startEmbeddedServletContainer();</div><div class=\"line\">  <span class=\"keyword\">if</span> (localContainer != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    publishEvent(</div><div class=\"line\">\t<span class=\"keyword\">new</span> EmbeddedServletContainerInitializedEvent(<span class=\"keyword\">this</span>, localContainer));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 Spring 容器生命周期里与 Servlet 容器相关的逻辑封装在以上两个方法，分别用以创建和启动 Servlet 容器。</p>\n<h2 id=\"Servlet-容器创建细节\"><a href=\"#Servlet-容器创建细节\" class=\"headerlink\" title=\"Servlet 容器创建细节\"></a>Servlet 容器创建细节</h2><p>上面说到 AnnotationConfigEmbeddedWebApplicationContext 中创建 Servlet 容器，具体的细节如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AnnotationConfigEmbeddedWebApplicationContext</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createEmbeddedServletContainer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   EmbeddedServletContainer localContainer = <span class=\"keyword\">this</span>.embeddedServletContainer;</div><div class=\"line\">   ServletContext localServletContext = getServletContext();</div><div class=\"line\">   <span class=\"keyword\">if</span> (localContainer == <span class=\"keyword\">null</span> &amp;&amp; localServletContext == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 获取 Servlet 容器工厂</span></div><div class=\"line\">      EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</div><div class=\"line\">      <span class=\"comment\">// 获取 Servlet 容器初始化器</span></div><div class=\"line\">      <span class=\"comment\">// 使用 Servlet 容器初始化器创建 Servlet 容器</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.embeddedServletContainer = </div><div class=\"line\">        containerFactory.getEmbeddedServletContainer(getSelfInitializer());</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (localServletContext != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         getSelfInitializer().onStartup(localServletContext);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">catch</span> (ServletException ex) &#123;</div><div class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">\"Cannot initialize servlet context\"</span>,</div><div class=\"line\">               ex);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   initPropertySources();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>细节可以分为：</p>\n<ol>\n<li>获取 Servlet 容器工厂</li>\n<li>获取 Servlet 容器初始化器</li>\n<li>创建 Servlet 容器</li>\n</ol>\n<h3 id=\"获取-Servlet-容器工厂\"><a href=\"#获取-Servlet-容器工厂\" class=\"headerlink\" title=\"获取 Servlet 容器工厂\"></a>获取 Servlet 容器工厂</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AnnotationConfigEmbeddedWebApplicationContext</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> EmbeddedServletContainerFactory <span class=\"title\">getEmbeddedServletContainerFactory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// Use bean names so that we don't consider the hierarchy</span></div><div class=\"line\">   String[] beanNames = getBeanFactory()</div><div class=\"line\">         .getBeanNamesForType(EmbeddedServletContainerFactory.class);</div><div class=\"line\">   <span class=\"comment\">// 省略异常</span></div><div class=\"line\">   <span class=\"keyword\">return</span> getBeanFactory().getBean(beanNames[<span class=\"number\">0</span>],</div><div class=\"line\">         EmbeddedServletContainerFactory.class);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>直接从 Spring 容器里获取 Servlet 容器工厂。一时之间卡住了不知道 EmbeddedServletContainerFactory 这个类时怎么注册到 Spring 容器中的。在网上查了一下发现是 META-INF/spring.factories 里指定了 EmbeddedServletContainerAutoConfiguration 这个配置类。而 EmbeddedServletContainerFactory 是 EmbeddedServletContainerAutoConfiguration 这个自动化配置类中被注册到 Spring 容器中的，关于配置类的注册我又要挖坑了。EmbeddedServletContainerAutoConfiguration：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@AutoConfigureOrder</span>(-<span class=\"number\">2147483648</span>)</div><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ConditionalOnWebApplication</span>  <span class=\"comment\">// 在Web环境下起作用</span></div><div class=\"line\"><span class=\"meta\">@Import</span>(&#123;EmbeddedServletContainerAutoConfiguration.BeanPostProcessorsRegistrar.class&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EmbeddedServletContainerAutoConfiguration</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 在 import 中导入该类</span></div><div class=\"line\">    <span class=\"comment\">// 主要作用是注册 EmbeddedServletContainerCustomizerBeanPostProcessor,</span></div><div class=\"line\">    <span class=\"comment\">// ErrorPageRegistrarBeanPostProcessor</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanPostProcessorsRegistrar</span> </span></div><div class=\"line\">      <span class=\"keyword\">implements</span> <span class=\"title\">ImportBeanDefinitionRegistrar</span>, <span class=\"title\">BeanFactoryAware</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 省略</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata importingClassMetadata,</span></span></div><div class=\"line\">                                            BeanDefinitionRegistry registry) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.beanFactory != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// 注册 EmbeddedServletContainerCustomizerBeanPostProcessor</span></div><div class=\"line\">                <span class=\"keyword\">this</span>.registerSyntheticBeanIfMissing(</div><div class=\"line\">                  registry, <span class=\"string\">\"embeddedServletContainerCustomizerBeanPostProcessor\"</span>, </div><div class=\"line\">                  EmbeddedServletContainerCustomizerBeanPostProcessor.class);</div><div class=\"line\">                <span class=\"comment\">// 注册 ErrorPageRegistrarBeanPostProcessor</span></div><div class=\"line\">                <span class=\"keyword\">this</span>.registerSyntheticBeanIfMissing(</div><div class=\"line\">                  registry, <span class=\"string\">\"errorPageRegistrarBeanPostProcessor\"</span>, </div><div class=\"line\">                  ErrorPageRegistrarBeanPostProcessor.class);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">registerSyntheticBeanIfMissing</span><span class=\"params\">(BeanDefinitionRegistry registry, </span></span></div><div class=\"line\">                                                    String name, Class&lt;?&gt; beanClass) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(ObjectUtils.isEmpty(<span class=\"keyword\">this</span>.beanFactory.getBeanNamesForType(beanClass, </div><div class=\"line\">                                                                        <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>))) &#123;</div><div class=\"line\">                RootBeanDefinition beanDefinition = <span class=\"keyword\">new</span> RootBeanDefinition(beanClass);</div><div class=\"line\">                beanDefinition.setSynthetic(<span class=\"keyword\">true</span>);</div><div class=\"line\">                registry.registerBeanDefinition(name, beanDefinition);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 省略 Jetty，Undertow 配置</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Configuration</span></div><div class=\"line\">    <span class=\"meta\">@ConditionalOnClass</span>(&#123;Servlet.class, Tomcat.class&#125;)</div><div class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean</span>(</div><div class=\"line\">        value = &#123;EmbeddedServletContainerFactory.class&#125;,</div><div class=\"line\">        search = SearchStrategy.CURRENT</div><div class=\"line\">    )</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmbeddedTomcat</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EmbeddedTomcat</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Bean</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> TomcatEmbeddedServletContainerFactory <span class=\"title\">tomcatEmbeddedServletContainerFactory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 注册 EmbeddedServletContainerFactory 的实现类</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TomcatEmbeddedServletContainerFactory();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当满足特定条件时会注册具体的 EmbeddedServletContainerFactory 实现类，例如 TomcatEmbeddedServletContainerFactory。</p>\n<p>这里还看到 注册了 EmbeddedServletContainerCustomizerBeanPostProcessor 和 ErrorPageRegistrarBeanPostProcessor 。简单看了一下 EmbeddedServletContainerCustomizerBeanPostProcessor，这是一个基本的 BeanPostProcessor，具体作用是对 EmbeddedServletContainerCustomizer 的实例进行定制，具体的实现包括：ErrorPageCustomizer，TomcatWebSocketContainerCustomizer，ServerProperties 等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// EmbeddedServletContainerCustomizerBeanPostProcessor </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmbeddedServletContainerCustomizerBeanPostProcessor</span></span></div><div class=\"line\">      <span class=\"keyword\">implements</span> <span class=\"title\">BeanPostProcessor</span>, <span class=\"title\">BeanFactoryAware</span> &#123;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">private</span> ListableBeanFactory beanFactory;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">private</span> List&lt;EmbeddedServletContainerCustomizer&gt; customizers;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span></span></div><div class=\"line\">         <span class=\"keyword\">throws</span> BeansException &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (bean <span class=\"keyword\">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;</div><div class=\"line\">         <span class=\"comment\">// 处理ConfigurableEmbeddedServletContainer类型的bean</span></div><div class=\"line\">         postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> bean;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessBeforeInitialization</span><span class=\"params\">(</span></span></div><div class=\"line\">         ConfigurableEmbeddedServletContainer bean) &#123;</div><div class=\"line\">      <span class=\"comment\">// 对ConfigurableEmbeddedServletContainer类型的bean定制化处理</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;</div><div class=\"line\">         customizer.customize(bean);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class=\"title\">getCustomizers</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.customizers == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         <span class=\"comment\">// 从容器中找出所有EmbeddedServletContainerCustomizer类型的bean</span></div><div class=\"line\">         <span class=\"keyword\">this</span>.customizers = <span class=\"keyword\">new</span> ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(</div><div class=\"line\">               <span class=\"keyword\">this</span>.beanFactory.getBeansOfType(EmbeddedServletContainerCustomizer.class,</div><div class=\"line\">                                               <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>).values());</div><div class=\"line\">         Collections.sort(<span class=\"keyword\">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);</div><div class=\"line\">         <span class=\"keyword\">this</span>.customizers = Collections.unmodifiableList(<span class=\"keyword\">this</span>.customizers);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.customizers;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Servlet-容器初始化器\"><a href=\"#Servlet-容器初始化器\" class=\"headerlink\" title=\"Servlet 容器初始化器\"></a>Servlet 容器初始化器</h3><p>再回顾一下 Servlet 容器的创建核心逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">containerFactory.getEmbeddedServletContainer(getSelfInitializer());</div></pre></td></tr></table></figure>\n<p>先获取 Servlet 初始化器，然后创建 Servlet 容器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> org.springframework.boot.web.servlet.<span class=\"function\">ServletContextInitializer <span class=\"title\">getSelfInitializer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ServletContextInitializer() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStartup</span><span class=\"params\">(ServletContext servletContext)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</div><div class=\"line\">         selfInitialize(servletContext);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">selfInitialize</span><span class=\"params\">(ServletContext servletContext)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// Servlet 容器准备</span></div><div class=\"line\">   prepareEmbeddedWebApplicationContext(servletContext);</div><div class=\"line\">   <span class=\"comment\">// 初始 scopes</span></div><div class=\"line\">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class=\"line\">   ExistingWebApplicationScopes existingScopes = <span class=\"keyword\">new</span> ExistingWebApplicationScopes(</div><div class=\"line\">         beanFactory);</div><div class=\"line\">   WebApplicationContextUtils.registerWebApplicationScopes(beanFactory,</div><div class=\"line\">         getServletContext());</div><div class=\"line\">   existingScopes.restore();</div><div class=\"line\">   <span class=\"comment\">// 注册 web 相关 bean</span></div><div class=\"line\">   WebApplicationContextUtils.registerEnvironmentBeans(beanFactory,</div><div class=\"line\">         getServletContext());</div><div class=\"line\">   <span class=\"comment\">// 初始化 servlet, filter, Listener 并注册</span></div><div class=\"line\">   <span class=\"keyword\">for</span> (ServletContextInitializer beans : getServletContextInitializerBeans()) &#123;</div><div class=\"line\">      beans.onStartup(servletContext);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取 ServletContext 初始化 bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Collection&lt;ServletContextInitializer&gt; <span class=\"title\">getServletContextInitializerBeans</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">new</span> ServletContextInitializerBeans(getBeanFactory());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServletContextInitializerBeans</span><span class=\"params\">(ListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">this</span>.initializers = <span class=\"keyword\">new</span> LinkedMultiValueMap&lt;Class&lt;?&gt;, ServletContextInitializer&gt;();</div><div class=\"line\">   <span class=\"comment\">// 添加 ServletContextInitializer 类型的 bean</span></div><div class=\"line\">   addServletContextInitializerBeans(beanFactory);</div><div class=\"line\">   addAdaptableBeans(beanFactory);</div><div class=\"line\">   List&lt;ServletContextInitializer&gt; sortedInitializers = </div><div class=\"line\">     <span class=\"keyword\">new</span> ArrayList&lt;ServletContextInitializer&gt;();</div><div class=\"line\">   <span class=\"keyword\">for</span> (Map.Entry&lt;?, List&lt;ServletContextInitializer&gt;&gt; entry : <span class=\"keyword\">this</span>.initializers.entrySet()) &#123;</div><div class=\"line\">      AnnotationAwareOrderComparator.sort(entry.getValue());</div><div class=\"line\">      sortedInitializers.addAll(entry.getValue());</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">this</span>.sortedList = Collections.unmodifiableList(sortedInitializers);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addServletContextInitializerBeans</span><span class=\"params\">(ListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">for</span> (Entry&lt;String, ServletContextInitializer&gt; initializerBean : getOrderedBeansOfType(</div><div class=\"line\">         beanFactory, ServletContextInitializer.class)) &#123;</div><div class=\"line\">      addServletContextInitializerBean(initializerBean.getKey(),</div><div class=\"line\">            initializerBean.getValue(), beanFactory);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addServletContextInitializerBean</span><span class=\"params\">(String beanName,</span></span></div><div class=\"line\">      ServletContextInitializer initializer, ListableBeanFactory beanFactory) &#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (initializer <span class=\"keyword\">instanceof</span> ServletRegistrationBean) &#123;</div><div class=\"line\">      <span class=\"comment\">// servlet</span></div><div class=\"line\">      Servlet source = ((ServletRegistrationBean) initializer).getServlet();</div><div class=\"line\">      addServletContextInitializerBean(Servlet.class, beanName, initializer,</div><div class=\"line\">            beanFactory, source);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initializer <span class=\"keyword\">instanceof</span> FilterRegistrationBean) &#123;</div><div class=\"line\">      <span class=\"comment\">// filter</span></div><div class=\"line\">      Filter source = ((FilterRegistrationBean) initializer).getFilter();</div><div class=\"line\">      addServletContextInitializerBean(Filter.class, beanName, initializer,</div><div class=\"line\">            beanFactory, source);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initializer <span class=\"keyword\">instanceof</span> DelegatingFilterProxyRegistrationBean) &#123;</div><div class=\"line\">      <span class=\"comment\">// filter</span></div><div class=\"line\">      String source = ((DelegatingFilterProxyRegistrationBean) initializer)</div><div class=\"line\">            .getTargetBeanName();</div><div class=\"line\">      addServletContextInitializerBean(Filter.class, beanName, initializer,</div><div class=\"line\">            beanFactory, source);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initializer <span class=\"keyword\">instanceof</span> ServletListenerRegistrationBean) &#123;</div><div class=\"line\">      <span class=\"comment\">// listener</span></div><div class=\"line\">      EventListener source = ((ServletListenerRegistrationBean&lt;?&gt;) initializer)</div><div class=\"line\">            .getListener();</div><div class=\"line\">      addServletContextInitializerBean(EventListener.class, beanName, initializer,</div><div class=\"line\">            beanFactory, source);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      addServletContextInitializerBean(ServletContextInitializer.class, beanName,</div><div class=\"line\">            initializer, beanFactory, initializer);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"创建-Servlet-容器\"><a href=\"#创建-Servlet-容器\" class=\"headerlink\" title=\"创建 Servlet 容器\"></a>创建 Servlet 容器</h3><p>以 TomcatEmbeddedServletContainerFactory 的创建容器方法为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> EmbeddedServletContainer <span class=\"title\">getEmbeddedServletContainer</span><span class=\"params\">(</span></span></div><div class=\"line\">      ServletContextInitializer... initializers) &#123;</div><div class=\"line\">   Tomcat tomcat = <span class=\"keyword\">new</span> Tomcat();</div><div class=\"line\">   File baseDir = (<span class=\"keyword\">this</span>.baseDirectory != <span class=\"keyword\">null</span> ? <span class=\"keyword\">this</span>.baseDirectory</div><div class=\"line\">         : createTempDir(<span class=\"string\">\"tomcat\"</span>));</div><div class=\"line\">   tomcat.setBaseDir(baseDir.getAbsolutePath());</div><div class=\"line\">   Connector connector = <span class=\"keyword\">new</span> Connector(<span class=\"keyword\">this</span>.protocol);</div><div class=\"line\">   tomcat.getService().addConnector(connector);</div><div class=\"line\">   customizeConnector(connector);</div><div class=\"line\">   tomcat.setConnector(connector);</div><div class=\"line\">   tomcat.getHost().setAutoDeploy(<span class=\"keyword\">false</span>);</div><div class=\"line\">   configureEngine(tomcat.getEngine());</div><div class=\"line\">   <span class=\"keyword\">for</span> (Connector additionalConnector : <span class=\"keyword\">this</span>.additionalTomcatConnectors) &#123;</div><div class=\"line\">      tomcat.getService().addConnector(additionalConnector);</div><div class=\"line\">   &#125;</div><div class=\"line\">   prepareContext(tomcat.getHost(), initializers);</div><div class=\"line\">   <span class=\"keyword\">return</span> getTomcatEmbeddedServletContainer(tomcat);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码完成了 Servlet 容器启动前所有的创建，配置动作。</p>\n<h2 id=\"Servlet-容器启动-1\"><a href=\"#Servlet-容器启动-1\" class=\"headerlink\" title=\"Servlet 容器启动\"></a>Servlet 容器启动</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> EmbeddedServletContainer <span class=\"title\">startEmbeddedServletContainer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   EmbeddedServletContainer localContainer = <span class=\"keyword\">this</span>.embeddedServletContainer;</div><div class=\"line\">   <span class=\"keyword\">if</span> (localContainer != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      localContainer.start();</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> localContainer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>启动的逻辑并不复杂，直接调用 Servlet 容器的 start 方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Spring Boot 使用的内嵌 Servlet 容器启动过程：</p>\n<ol>\n<li>从 spring.factories 中读取并注册了 EmbeddedServletContainerAutoConfiguration 类</li>\n<li>EmbeddedServletContainerAutoConfiguration 注册了 Servlet 容器工厂类</li>\n<li>在 Spring 容器生命周期的 onRefresh 方法中开始创建 Servlet 容器<ol>\n<li>获取 Servlet 容器工厂</li>\n<li>获取 Servlet 相关初始化 bean</li>\n<li>配置并创建 Servlet 容器</li>\n</ol>\n</li>\n<li>在 Spring 容器生命周期的 finishRefresh 方法中调用 Servlet 容器的 start 方法启动容器</li>\n</ol>\n","excerpt":"","more":"<p>记得自己看 Spring Boot 源码的初衷是对部署时不需要额外的 Servlet 容器的好奇，好像看着看着关注到了其他细节。挖了几个坑就跳过了，今天把之前关于 Spring Boot 与 Servlet 容器的坑填一下。</p>\n<p>先回（rang）顾（wo）一（xiang）下（xiang）之前与 Web 环境相关的内容：</p>\n<ul>\n<li><a href=\"http://zhangh.tk/2017/06/20/SpringBoot%E5%8C%85%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90/\">SpringBoot包文件执行分析</a>，这里说到开启了新线程调用应用入口，该线程设置了上下文类加载器 LaunchedURLClassLoader</li>\n<li><a href=\"http://zhangh.tk/2017/07/05/%E3%80%90SpringBoot%E3%80%91SpringApplication%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA/\">【SpringBoot】SpringApplication实例创建</a>，这里说到根据 CLASSPTH 的包含的类推断当前是否是 web 环境</li>\n<li><a href=\"http://zhangh.tk/2017/07/10/%E3%80%90SpringBoot%E3%80%91%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8/\">【SpringBoot】容器启动</a>，这里说到根据是否 web 环境创建做相关准备，创建处理 web 环境对应的 Spring容器</li>\n<li><a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/\">【Spring容器刷新】</a>，这里说到 Spring 容器生命周期的相关方法</li>\n</ul>\n<h2 id=\"Servlet-容器启动\"><a href=\"#Servlet-容器启动\" class=\"headerlink\" title=\"Servlet 容器启动\"></a>Servlet 容器启动</h2><p><a href=\"http://zhangh.tk/2017/07/10/%E3%80%90SpringBoot%E3%80%91%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8/\">【SpringBoot】容器启动 </a>中提到的创建处理 web 环境对应的 Spring 容器实际创建的就是 AnnotationConfigEmbeddedWebApplicationContext，这个类是 ApplicationContext 的子类。其分别在 onRefresh 和 finishRefresh 方法中创建和启动 Servlet 容器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onRefresh</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">super</span>.onRefresh();</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      createEmbeddedServletContainer();</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">\"Unable to start embedded container\"</span>, ex);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finishRefresh</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">super</span>.finishRefresh();</div><div class=\"line\">  EmbeddedServletContainer localContainer = startEmbeddedServletContainer();</div><div class=\"line\">  <span class=\"keyword\">if</span> (localContainer != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    publishEvent(</div><div class=\"line\">\t<span class=\"keyword\">new</span> EmbeddedServletContainerInitializedEvent(<span class=\"keyword\">this</span>, localContainer));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 Spring 容器生命周期里与 Servlet 容器相关的逻辑封装在以上两个方法，分别用以创建和启动 Servlet 容器。</p>\n<h2 id=\"Servlet-容器创建细节\"><a href=\"#Servlet-容器创建细节\" class=\"headerlink\" title=\"Servlet 容器创建细节\"></a>Servlet 容器创建细节</h2><p>上面说到 AnnotationConfigEmbeddedWebApplicationContext 中创建 Servlet 容器，具体的细节如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AnnotationConfigEmbeddedWebApplicationContext</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createEmbeddedServletContainer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   EmbeddedServletContainer localContainer = <span class=\"keyword\">this</span>.embeddedServletContainer;</div><div class=\"line\">   ServletContext localServletContext = getServletContext();</div><div class=\"line\">   <span class=\"keyword\">if</span> (localContainer == <span class=\"keyword\">null</span> &amp;&amp; localServletContext == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 获取 Servlet 容器工厂</span></div><div class=\"line\">      EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</div><div class=\"line\">      <span class=\"comment\">// 获取 Servlet 容器初始化器</span></div><div class=\"line\">      <span class=\"comment\">// 使用 Servlet 容器初始化器创建 Servlet 容器</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.embeddedServletContainer = </div><div class=\"line\">        containerFactory.getEmbeddedServletContainer(getSelfInitializer());</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (localServletContext != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         getSelfInitializer().onStartup(localServletContext);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">catch</span> (ServletException ex) &#123;</div><div class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">\"Cannot initialize servlet context\"</span>,</div><div class=\"line\">               ex);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   initPropertySources();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>细节可以分为：</p>\n<ol>\n<li>获取 Servlet 容器工厂</li>\n<li>获取 Servlet 容器初始化器</li>\n<li>创建 Servlet 容器</li>\n</ol>\n<h3 id=\"获取-Servlet-容器工厂\"><a href=\"#获取-Servlet-容器工厂\" class=\"headerlink\" title=\"获取 Servlet 容器工厂\"></a>获取 Servlet 容器工厂</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AnnotationConfigEmbeddedWebApplicationContext</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> EmbeddedServletContainerFactory <span class=\"title\">getEmbeddedServletContainerFactory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// Use bean names so that we don't consider the hierarchy</span></div><div class=\"line\">   String[] beanNames = getBeanFactory()</div><div class=\"line\">         .getBeanNamesForType(EmbeddedServletContainerFactory.class);</div><div class=\"line\">   <span class=\"comment\">// 省略异常</span></div><div class=\"line\">   <span class=\"keyword\">return</span> getBeanFactory().getBean(beanNames[<span class=\"number\">0</span>],</div><div class=\"line\">         EmbeddedServletContainerFactory.class);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>直接从 Spring 容器里获取 Servlet 容器工厂。一时之间卡住了不知道 EmbeddedServletContainerFactory 这个类时怎么注册到 Spring 容器中的。在网上查了一下发现是 META-INF/spring.factories 里指定了 EmbeddedServletContainerAutoConfiguration 这个配置类。而 EmbeddedServletContainerFactory 是 EmbeddedServletContainerAutoConfiguration 这个自动化配置类中被注册到 Spring 容器中的，关于配置类的注册我又要挖坑了。EmbeddedServletContainerAutoConfiguration：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@AutoConfigureOrder</span>(-<span class=\"number\">2147483648</span>)</div><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ConditionalOnWebApplication</span>  <span class=\"comment\">// 在Web环境下起作用</span></div><div class=\"line\"><span class=\"meta\">@Import</span>(&#123;EmbeddedServletContainerAutoConfiguration.BeanPostProcessorsRegistrar.class&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EmbeddedServletContainerAutoConfiguration</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 在 import 中导入该类</span></div><div class=\"line\">    <span class=\"comment\">// 主要作用是注册 EmbeddedServletContainerCustomizerBeanPostProcessor,</span></div><div class=\"line\">    <span class=\"comment\">// ErrorPageRegistrarBeanPostProcessor</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanPostProcessorsRegistrar</span> </div><div class=\"line\">      <span class=\"keyword\">implements</span> <span class=\"title\">ImportBeanDefinitionRegistrar</span>, <span class=\"title\">BeanFactoryAware</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 省略</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata importingClassMetadata,</div><div class=\"line\">                                            BeanDefinitionRegistry registry)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.beanFactory != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// 注册 EmbeddedServletContainerCustomizerBeanPostProcessor</span></div><div class=\"line\">                <span class=\"keyword\">this</span>.registerSyntheticBeanIfMissing(</div><div class=\"line\">                  registry, <span class=\"string\">\"embeddedServletContainerCustomizerBeanPostProcessor\"</span>, </div><div class=\"line\">                  EmbeddedServletContainerCustomizerBeanPostProcessor.class);</div><div class=\"line\">                <span class=\"comment\">// 注册 ErrorPageRegistrarBeanPostProcessor</span></div><div class=\"line\">                <span class=\"keyword\">this</span>.registerSyntheticBeanIfMissing(</div><div class=\"line\">                  registry, <span class=\"string\">\"errorPageRegistrarBeanPostProcessor\"</span>, </div><div class=\"line\">                  ErrorPageRegistrarBeanPostProcessor.class);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">registerSyntheticBeanIfMissing</span><span class=\"params\">(BeanDefinitionRegistry registry, </div><div class=\"line\">                                                    String name, Class&lt;?&gt; beanClass)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(ObjectUtils.isEmpty(<span class=\"keyword\">this</span>.beanFactory.getBeanNamesForType(beanClass, </div><div class=\"line\">                                                                        <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>))) &#123;</div><div class=\"line\">                RootBeanDefinition beanDefinition = <span class=\"keyword\">new</span> RootBeanDefinition(beanClass);</div><div class=\"line\">                beanDefinition.setSynthetic(<span class=\"keyword\">true</span>);</div><div class=\"line\">                registry.registerBeanDefinition(name, beanDefinition);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 省略 Jetty，Undertow 配置</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Configuration</span></div><div class=\"line\">    <span class=\"meta\">@ConditionalOnClass</span>(&#123;Servlet.class, Tomcat.class&#125;)</div><div class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean</span>(</div><div class=\"line\">        value = &#123;EmbeddedServletContainerFactory.class&#125;,</div><div class=\"line\">        search = SearchStrategy.CURRENT</div><div class=\"line\">    )</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmbeddedTomcat</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EmbeddedTomcat</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Bean</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> TomcatEmbeddedServletContainerFactory <span class=\"title\">tomcatEmbeddedServletContainerFactory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 注册 EmbeddedServletContainerFactory 的实现类</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TomcatEmbeddedServletContainerFactory();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当满足特定条件时会注册具体的 EmbeddedServletContainerFactory 实现类，例如 TomcatEmbeddedServletContainerFactory。</p>\n<p>这里还看到 注册了 EmbeddedServletContainerCustomizerBeanPostProcessor 和 ErrorPageRegistrarBeanPostProcessor 。简单看了一下 EmbeddedServletContainerCustomizerBeanPostProcessor，这是一个基本的 BeanPostProcessor，具体作用是对 EmbeddedServletContainerCustomizer 的实例进行定制，具体的实现包括：ErrorPageCustomizer，TomcatWebSocketContainerCustomizer，ServerProperties 等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// EmbeddedServletContainerCustomizerBeanPostProcessor </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmbeddedServletContainerCustomizerBeanPostProcessor</span></div><div class=\"line\">      <span class=\"keyword\">implements</span> <span class=\"title\">BeanPostProcessor</span>, <span class=\"title\">BeanFactoryAware</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">private</span> ListableBeanFactory beanFactory;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">private</span> List&lt;EmbeddedServletContainerCustomizer&gt; customizers;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span></div><div class=\"line\">         <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (bean <span class=\"keyword\">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;</div><div class=\"line\">         <span class=\"comment\">// 处理ConfigurableEmbeddedServletContainer类型的bean</span></div><div class=\"line\">         postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> bean;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessBeforeInitialization</span><span class=\"params\">(</div><div class=\"line\">         ConfigurableEmbeddedServletContainer bean)</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 对ConfigurableEmbeddedServletContainer类型的bean定制化处理</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;</div><div class=\"line\">         customizer.customize(bean);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class=\"title\">getCustomizers</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.customizers == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         <span class=\"comment\">// 从容器中找出所有EmbeddedServletContainerCustomizer类型的bean</span></div><div class=\"line\">         <span class=\"keyword\">this</span>.customizers = <span class=\"keyword\">new</span> ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(</div><div class=\"line\">               <span class=\"keyword\">this</span>.beanFactory.getBeansOfType(EmbeddedServletContainerCustomizer.class,</div><div class=\"line\">                                               <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>).values());</div><div class=\"line\">         Collections.sort(<span class=\"keyword\">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);</div><div class=\"line\">         <span class=\"keyword\">this</span>.customizers = Collections.unmodifiableList(<span class=\"keyword\">this</span>.customizers);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.customizers;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Servlet-容器初始化器\"><a href=\"#Servlet-容器初始化器\" class=\"headerlink\" title=\"Servlet 容器初始化器\"></a>Servlet 容器初始化器</h3><p>再回顾一下 Servlet 容器的创建核心逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">containerFactory.getEmbeddedServletContainer(getSelfInitializer());</div></pre></td></tr></table></figure>\n<p>先获取 Servlet 初始化器，然后创建 Servlet 容器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> org.springframework.boot.web.servlet.<span class=\"function\">ServletContextInitializer <span class=\"title\">getSelfInitializer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ServletContextInitializer() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStartup</span><span class=\"params\">(ServletContext servletContext)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</div><div class=\"line\">         selfInitialize(servletContext);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">selfInitialize</span><span class=\"params\">(ServletContext servletContext)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// Servlet 容器准备</span></div><div class=\"line\">   prepareEmbeddedWebApplicationContext(servletContext);</div><div class=\"line\">   <span class=\"comment\">// 初始 scopes</span></div><div class=\"line\">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class=\"line\">   ExistingWebApplicationScopes existingScopes = <span class=\"keyword\">new</span> ExistingWebApplicationScopes(</div><div class=\"line\">         beanFactory);</div><div class=\"line\">   WebApplicationContextUtils.registerWebApplicationScopes(beanFactory,</div><div class=\"line\">         getServletContext());</div><div class=\"line\">   existingScopes.restore();</div><div class=\"line\">   <span class=\"comment\">// 注册 web 相关 bean</span></div><div class=\"line\">   WebApplicationContextUtils.registerEnvironmentBeans(beanFactory,</div><div class=\"line\">         getServletContext());</div><div class=\"line\">   <span class=\"comment\">// 初始化 servlet, filter, Listener 并注册</span></div><div class=\"line\">   <span class=\"keyword\">for</span> (ServletContextInitializer beans : getServletContextInitializerBeans()) &#123;</div><div class=\"line\">      beans.onStartup(servletContext);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取 ServletContext 初始化 bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Collection&lt;ServletContextInitializer&gt; <span class=\"title\">getServletContextInitializerBeans</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">new</span> ServletContextInitializerBeans(getBeanFactory());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServletContextInitializerBeans</span><span class=\"params\">(ListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">this</span>.initializers = <span class=\"keyword\">new</span> LinkedMultiValueMap&lt;Class&lt;?&gt;, ServletContextInitializer&gt;();</div><div class=\"line\">   <span class=\"comment\">// 添加 ServletContextInitializer 类型的 bean</span></div><div class=\"line\">   addServletContextInitializerBeans(beanFactory);</div><div class=\"line\">   addAdaptableBeans(beanFactory);</div><div class=\"line\">   List&lt;ServletContextInitializer&gt; sortedInitializers = </div><div class=\"line\">     <span class=\"keyword\">new</span> ArrayList&lt;ServletContextInitializer&gt;();</div><div class=\"line\">   <span class=\"keyword\">for</span> (Map.Entry&lt;?, List&lt;ServletContextInitializer&gt;&gt; entry : <span class=\"keyword\">this</span>.initializers.entrySet()) &#123;</div><div class=\"line\">      AnnotationAwareOrderComparator.sort(entry.getValue());</div><div class=\"line\">      sortedInitializers.addAll(entry.getValue());</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">this</span>.sortedList = Collections.unmodifiableList(sortedInitializers);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addServletContextInitializerBeans</span><span class=\"params\">(ListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">for</span> (Entry&lt;String, ServletContextInitializer&gt; initializerBean : getOrderedBeansOfType(</div><div class=\"line\">         beanFactory, ServletContextInitializer.class)) &#123;</div><div class=\"line\">      addServletContextInitializerBean(initializerBean.getKey(),</div><div class=\"line\">            initializerBean.getValue(), beanFactory);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addServletContextInitializerBean</span><span class=\"params\">(String beanName,</div><div class=\"line\">      ServletContextInitializer initializer, ListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (initializer <span class=\"keyword\">instanceof</span> ServletRegistrationBean) &#123;</div><div class=\"line\">      <span class=\"comment\">// servlet</span></div><div class=\"line\">      Servlet source = ((ServletRegistrationBean) initializer).getServlet();</div><div class=\"line\">      addServletContextInitializerBean(Servlet.class, beanName, initializer,</div><div class=\"line\">            beanFactory, source);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initializer <span class=\"keyword\">instanceof</span> FilterRegistrationBean) &#123;</div><div class=\"line\">      <span class=\"comment\">// filter</span></div><div class=\"line\">      Filter source = ((FilterRegistrationBean) initializer).getFilter();</div><div class=\"line\">      addServletContextInitializerBean(Filter.class, beanName, initializer,</div><div class=\"line\">            beanFactory, source);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initializer <span class=\"keyword\">instanceof</span> DelegatingFilterProxyRegistrationBean) &#123;</div><div class=\"line\">      <span class=\"comment\">// filter</span></div><div class=\"line\">      String source = ((DelegatingFilterProxyRegistrationBean) initializer)</div><div class=\"line\">            .getTargetBeanName();</div><div class=\"line\">      addServletContextInitializerBean(Filter.class, beanName, initializer,</div><div class=\"line\">            beanFactory, source);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initializer <span class=\"keyword\">instanceof</span> ServletListenerRegistrationBean) &#123;</div><div class=\"line\">      <span class=\"comment\">// listener</span></div><div class=\"line\">      EventListener source = ((ServletListenerRegistrationBean&lt;?&gt;) initializer)</div><div class=\"line\">            .getListener();</div><div class=\"line\">      addServletContextInitializerBean(EventListener.class, beanName, initializer,</div><div class=\"line\">            beanFactory, source);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      addServletContextInitializerBean(ServletContextInitializer.class, beanName,</div><div class=\"line\">            initializer, beanFactory, initializer);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"创建-Servlet-容器\"><a href=\"#创建-Servlet-容器\" class=\"headerlink\" title=\"创建 Servlet 容器\"></a>创建 Servlet 容器</h3><p>以 TomcatEmbeddedServletContainerFactory 的创建容器方法为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> EmbeddedServletContainer <span class=\"title\">getEmbeddedServletContainer</span><span class=\"params\">(</div><div class=\"line\">      ServletContextInitializer... initializers)</span> </span>&#123;</div><div class=\"line\">   Tomcat tomcat = <span class=\"keyword\">new</span> Tomcat();</div><div class=\"line\">   File baseDir = (<span class=\"keyword\">this</span>.baseDirectory != <span class=\"keyword\">null</span> ? <span class=\"keyword\">this</span>.baseDirectory</div><div class=\"line\">         : createTempDir(<span class=\"string\">\"tomcat\"</span>));</div><div class=\"line\">   tomcat.setBaseDir(baseDir.getAbsolutePath());</div><div class=\"line\">   Connector connector = <span class=\"keyword\">new</span> Connector(<span class=\"keyword\">this</span>.protocol);</div><div class=\"line\">   tomcat.getService().addConnector(connector);</div><div class=\"line\">   customizeConnector(connector);</div><div class=\"line\">   tomcat.setConnector(connector);</div><div class=\"line\">   tomcat.getHost().setAutoDeploy(<span class=\"keyword\">false</span>);</div><div class=\"line\">   configureEngine(tomcat.getEngine());</div><div class=\"line\">   <span class=\"keyword\">for</span> (Connector additionalConnector : <span class=\"keyword\">this</span>.additionalTomcatConnectors) &#123;</div><div class=\"line\">      tomcat.getService().addConnector(additionalConnector);</div><div class=\"line\">   &#125;</div><div class=\"line\">   prepareContext(tomcat.getHost(), initializers);</div><div class=\"line\">   <span class=\"keyword\">return</span> getTomcatEmbeddedServletContainer(tomcat);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码完成了 Servlet 容器启动前所有的创建，配置动作。</p>\n<h2 id=\"Servlet-容器启动-1\"><a href=\"#Servlet-容器启动-1\" class=\"headerlink\" title=\"Servlet 容器启动\"></a>Servlet 容器启动</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> EmbeddedServletContainer <span class=\"title\">startEmbeddedServletContainer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   EmbeddedServletContainer localContainer = <span class=\"keyword\">this</span>.embeddedServletContainer;</div><div class=\"line\">   <span class=\"keyword\">if</span> (localContainer != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      localContainer.start();</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> localContainer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>启动的逻辑并不复杂，直接调用 Servlet 容器的 start 方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Spring Boot 使用的内嵌 Servlet 容器启动过程：</p>\n<ol>\n<li>从 spring.factories 中读取并注册了 EmbeddedServletContainerAutoConfiguration 类</li>\n<li>EmbeddedServletContainerAutoConfiguration 注册了 Servlet 容器工厂类</li>\n<li>在 Spring 容器生命周期的 onRefresh 方法中开始创建 Servlet 容器<ol>\n<li>获取 Servlet 容器工厂</li>\n<li>获取 Servlet 相关初始化 bean</li>\n<li>配置并创建 Servlet 容器</li>\n</ol>\n</li>\n<li>在 Spring 容器生命周期的 finishRefresh 方法中调用 Servlet 容器的 start 方法启动容器</li>\n</ol>\n"},{"title":"【SpringBoot】SpringApplication实例创建","date":"2017-07-05T13:22:54.000Z","_content":"书接上文，上回说到 Spring Boot 启动的入口是`JarLauncher`的`main`方法。其中的主要逻辑是在加载完各种资源后，开启一个新的线程调用程序的入口。整个应用的启动就此缓缓展开，本文只说明从`SpringApplication`的静态方法`run`调用后，生成`SpringApplication`实例的过程。而后的其他启动步骤不在本文记录。\n\n上文说到`main`方法的调用：\n\n```java\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n静态的`run`方法是整个程序的入口，但最终还是实例化了`SpringApplication`对象：\n\n```java\n\tprivate final Set<Object> sources = new LinkedHashSet<Object>();\n\n\tpublic static ConfigurableApplicationContext run(Object source, String... args) {\n\t\treturn run(new Object[] { source }, args);\n\t}\n\n\tpublic static ConfigurableApplicationContext run(Object[] sources, String[] args) {\n\t\treturn new SpringApplication(sources).run(args);\n\t}\n\n\tpublic SpringApplication(Object... sources) {\n\t\tinitialize(sources);\n\t}\n```\n\n今天的目标就是`initialize`方法的实现了：\n\n```java\n\tprivate void initialize(Object[] sources) {\n\t\tif (sources != null && sources.length > 0) {\n\t\t\tthis.sources.addAll(Arrays.asList(sources));\n\t\t}\n      \t// 是否是web程序环境\n\t\tthis.webEnvironment = deduceWebEnvironment();\n        // 设置初始化器\n\t\tsetInitializers((Collection) getSpringFactoriesInstances(\n\t\t\t\tApplicationContextInitializer.class));\n        // 设置监听器\n\t\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n      \t// main方法所在类\n\t\tthis.mainApplicationClass = deduceMainApplicationClass();\n\t}\n```\n\n## 推断Web环境\n\n先看看web环境的判断：\n\n```java\n\t// org/springframework/boot/SpringApplication.java\n\tprivate static final String[] WEB_ENVIRONMENT_CLASSES = { \"javax.servlet.Servlet\",\n\t\t\t\"org.springframework.web.context.ConfigurableWebApplicationContext\" };\n\t\n\tprivate boolean deduceWebEnvironment() {\n\t\tfor (String className : WEB_ENVIRONMENT_CLASSES) {\n\t\t\tif (!ClassUtils.isPresent(className, null)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n```\n\n是通过判断给定的类加载器（null）是否可以加载给定的类（`WEB_ENVIRONMENT_CLASSES`）判断的。加载器给的是空，跟进去看到了为空时是有默认类加载器的：\n\n```java\n\t// org/springframework/util/ClassUtils.java\n\tpublic static ClassLoader getDefaultClassLoader() {\n\t\tClassLoader cl = null;\n\t\ttry {\n\t\t\tcl = Thread.currentThread().getContextClassLoader();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t}\n\t\tif (cl == null) {\n\t\t\tcl = ClassUtils.class.getClassLoader();\n\t\t\tif (cl == null) {\n\t\t\t\ttry {\n\t\t\t\t\tcl = ClassLoader.getSystemClassLoader();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cl;\n\t}\n```\n\n## 查找 Main 方法\n\n跳过其他方法先看`main`方法所在类的查找\n\n```java\n\tprivate Class<?> deduceMainApplicationClass() {\n\t\ttry {\n\t\t\tStackTraceElement[] stackTrace = new RuntimeException().getStackTrace();\n\t\t\tfor (StackTraceElement stackTraceElement : stackTrace) {\n\t\t\t\tif (\"main\".equals(stackTraceElement.getMethodName())) {\n\t\t\t\t\treturn Class.forName(stackTraceElement.getClassName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// Swallow and continue\n\t\t}\n\t\treturn null;\n\t}\n```\n\n这个`main`方法所在类的查找还是比较6的，万万没想到直接搞了个异常从堆栈里查找，也算是奇技淫巧吧。\n\n## 初始化器，监听器的加载、实例化\n\n下面重点看看`SpringApplication`实例化最重要的部分：初始化器和监听器的设置。\n\n两者的核心逻辑都是一样，只是参数有所区别：\n\n```java\n\tprivate <T> Collection<? extends T> getSpringFactoriesInstances(Class<T> type) {\n\t\treturn getSpringFactoriesInstances(type, new Class<?>[] {});\n\t}\n\n\tprivate <T> Collection<? extends T> getSpringFactoriesInstances(Class<T> type,\n\t\t\tClass<?>[] parameterTypes, Object... args) {\n\t\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        // 使用上下文类加载器，加载指定配置文件中的配置\n\t\tSet<String> names = new LinkedHashSet<String>(\n\t\t\t\tSpringFactoriesLoader.loadFactoryNames(type, classLoader));\n      \t// 反射创建，没什么特别的\n\t\tList<T> instances = createSpringFactoriesInstances(type, parameterTypes,\n\t\t\t\tclassLoader, args, names);\n\t\tAnnotationAwareOrderComparator.sort(instances);\n\t\treturn instances;\n\t}\n```\n\n```java\n\t// 加载的配置文件\n\tpublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n\t// 加载配置文件中key为factoryClass.getName()的项\n\tpublic static List<String> loadFactoryNames(Class<?> factoryClass, \n                                                ClassLoader classLoader) {\n\t\tString factoryClassName = factoryClass.getName();\n\t\ttry {\n\t\t\tEnumeration<URL> urls = (classLoader != null ?\n                                     classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n                                   ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n\t\t\tList<String> result = new ArrayList<String>();\n\t\t\twhile (urls.hasMoreElements()) {\n              \tURL url = urls.nextElement();\n\t\t\t\tProperties properties = \n                  PropertiesLoaderUtils.loadProperties(new UrlResource(url));\n\t\t\t\tString factoryClassNames = \n                  properties.getProperty(factoryClassName);\n              \tresult.addAll(Arrays.asList(\n                  StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load [\" + factoryClass.getName() +\n\t\t\t\t\t\"] factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex);\n\t\t}\n\t}\n```\n\n所有的初始化器和监听器都是从 CLASSPATH 下的`META-INF/spring.factories`文件中获取的，具体配置：\n\n```properties\n# Application Context Initializers\norg.springframework.context.ApplicationContextInitializer=\\\norg.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\\norg.springframework.boot.context.ContextIdApplicationContextInitializer,\\\norg.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\\norg.springframework.boot.context.embedded.ServerPortInfoApplicationContextInitializer\n\n# Application Listeners\norg.springframework.context.ApplicationListener=\\\norg.springframework.boot.ClearCachesApplicationListener,\\\norg.springframework.boot.builder.ParentContextCloserApplicationListener,\\\norg.springframework.boot.context.FileEncodingApplicationListener,\\\norg.springframework.boot.context.config.AnsiOutputApplicationListener,\\\norg.springframework.boot.context.config.ConfigFileApplicationListener,\\\norg.springframework.boot.context.config.DelegatingApplicationListener,\\\norg.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\\\norg.springframework.boot.logging.ClasspathLoggingApplicationListener,\\\norg.springframework.boot.logging.LoggingApplicationListener\n```\n\n---\n\n总结一下，SpringApplication的实例过程：\n\n1. 判断是否是 web 环境\n2. 加载初始化器和监听器并实例化\n3. 查找 main 方法所在类\n\n每个过程的特点：\n\n1. 判断 web 环境是根据 Spring 的默认加载器是否能够加载给定类\n2. 初始化器和监听器的加载都依据`META-INF/spring.factories`\n3. main方法所在类的查找是抛出异常在堆栈中查找的\n","source":"_posts/【SpringBoot】SpringApplication实例创建.md","raw":"---\ntitle: 【SpringBoot】SpringApplication实例创建\ndate: 2017-07-05 21:22:54\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n书接上文，上回说到 Spring Boot 启动的入口是`JarLauncher`的`main`方法。其中的主要逻辑是在加载完各种资源后，开启一个新的线程调用程序的入口。整个应用的启动就此缓缓展开，本文只说明从`SpringApplication`的静态方法`run`调用后，生成`SpringApplication`实例的过程。而后的其他启动步骤不在本文记录。\n\n上文说到`main`方法的调用：\n\n```java\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n静态的`run`方法是整个程序的入口，但最终还是实例化了`SpringApplication`对象：\n\n```java\n\tprivate final Set<Object> sources = new LinkedHashSet<Object>();\n\n\tpublic static ConfigurableApplicationContext run(Object source, String... args) {\n\t\treturn run(new Object[] { source }, args);\n\t}\n\n\tpublic static ConfigurableApplicationContext run(Object[] sources, String[] args) {\n\t\treturn new SpringApplication(sources).run(args);\n\t}\n\n\tpublic SpringApplication(Object... sources) {\n\t\tinitialize(sources);\n\t}\n```\n\n今天的目标就是`initialize`方法的实现了：\n\n```java\n\tprivate void initialize(Object[] sources) {\n\t\tif (sources != null && sources.length > 0) {\n\t\t\tthis.sources.addAll(Arrays.asList(sources));\n\t\t}\n      \t// 是否是web程序环境\n\t\tthis.webEnvironment = deduceWebEnvironment();\n        // 设置初始化器\n\t\tsetInitializers((Collection) getSpringFactoriesInstances(\n\t\t\t\tApplicationContextInitializer.class));\n        // 设置监听器\n\t\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n      \t// main方法所在类\n\t\tthis.mainApplicationClass = deduceMainApplicationClass();\n\t}\n```\n\n## 推断Web环境\n\n先看看web环境的判断：\n\n```java\n\t// org/springframework/boot/SpringApplication.java\n\tprivate static final String[] WEB_ENVIRONMENT_CLASSES = { \"javax.servlet.Servlet\",\n\t\t\t\"org.springframework.web.context.ConfigurableWebApplicationContext\" };\n\t\n\tprivate boolean deduceWebEnvironment() {\n\t\tfor (String className : WEB_ENVIRONMENT_CLASSES) {\n\t\t\tif (!ClassUtils.isPresent(className, null)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n```\n\n是通过判断给定的类加载器（null）是否可以加载给定的类（`WEB_ENVIRONMENT_CLASSES`）判断的。加载器给的是空，跟进去看到了为空时是有默认类加载器的：\n\n```java\n\t// org/springframework/util/ClassUtils.java\n\tpublic static ClassLoader getDefaultClassLoader() {\n\t\tClassLoader cl = null;\n\t\ttry {\n\t\t\tcl = Thread.currentThread().getContextClassLoader();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t}\n\t\tif (cl == null) {\n\t\t\tcl = ClassUtils.class.getClassLoader();\n\t\t\tif (cl == null) {\n\t\t\t\ttry {\n\t\t\t\t\tcl = ClassLoader.getSystemClassLoader();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cl;\n\t}\n```\n\n## 查找 Main 方法\n\n跳过其他方法先看`main`方法所在类的查找\n\n```java\n\tprivate Class<?> deduceMainApplicationClass() {\n\t\ttry {\n\t\t\tStackTraceElement[] stackTrace = new RuntimeException().getStackTrace();\n\t\t\tfor (StackTraceElement stackTraceElement : stackTrace) {\n\t\t\t\tif (\"main\".equals(stackTraceElement.getMethodName())) {\n\t\t\t\t\treturn Class.forName(stackTraceElement.getClassName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// Swallow and continue\n\t\t}\n\t\treturn null;\n\t}\n```\n\n这个`main`方法所在类的查找还是比较6的，万万没想到直接搞了个异常从堆栈里查找，也算是奇技淫巧吧。\n\n## 初始化器，监听器的加载、实例化\n\n下面重点看看`SpringApplication`实例化最重要的部分：初始化器和监听器的设置。\n\n两者的核心逻辑都是一样，只是参数有所区别：\n\n```java\n\tprivate <T> Collection<? extends T> getSpringFactoriesInstances(Class<T> type) {\n\t\treturn getSpringFactoriesInstances(type, new Class<?>[] {});\n\t}\n\n\tprivate <T> Collection<? extends T> getSpringFactoriesInstances(Class<T> type,\n\t\t\tClass<?>[] parameterTypes, Object... args) {\n\t\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        // 使用上下文类加载器，加载指定配置文件中的配置\n\t\tSet<String> names = new LinkedHashSet<String>(\n\t\t\t\tSpringFactoriesLoader.loadFactoryNames(type, classLoader));\n      \t// 反射创建，没什么特别的\n\t\tList<T> instances = createSpringFactoriesInstances(type, parameterTypes,\n\t\t\t\tclassLoader, args, names);\n\t\tAnnotationAwareOrderComparator.sort(instances);\n\t\treturn instances;\n\t}\n```\n\n```java\n\t// 加载的配置文件\n\tpublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n\t// 加载配置文件中key为factoryClass.getName()的项\n\tpublic static List<String> loadFactoryNames(Class<?> factoryClass, \n                                                ClassLoader classLoader) {\n\t\tString factoryClassName = factoryClass.getName();\n\t\ttry {\n\t\t\tEnumeration<URL> urls = (classLoader != null ?\n                                     classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n                                   ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n\t\t\tList<String> result = new ArrayList<String>();\n\t\t\twhile (urls.hasMoreElements()) {\n              \tURL url = urls.nextElement();\n\t\t\t\tProperties properties = \n                  PropertiesLoaderUtils.loadProperties(new UrlResource(url));\n\t\t\t\tString factoryClassNames = \n                  properties.getProperty(factoryClassName);\n              \tresult.addAll(Arrays.asList(\n                  StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load [\" + factoryClass.getName() +\n\t\t\t\t\t\"] factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex);\n\t\t}\n\t}\n```\n\n所有的初始化器和监听器都是从 CLASSPATH 下的`META-INF/spring.factories`文件中获取的，具体配置：\n\n```properties\n# Application Context Initializers\norg.springframework.context.ApplicationContextInitializer=\\\norg.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\\norg.springframework.boot.context.ContextIdApplicationContextInitializer,\\\norg.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\\norg.springframework.boot.context.embedded.ServerPortInfoApplicationContextInitializer\n\n# Application Listeners\norg.springframework.context.ApplicationListener=\\\norg.springframework.boot.ClearCachesApplicationListener,\\\norg.springframework.boot.builder.ParentContextCloserApplicationListener,\\\norg.springframework.boot.context.FileEncodingApplicationListener,\\\norg.springframework.boot.context.config.AnsiOutputApplicationListener,\\\norg.springframework.boot.context.config.ConfigFileApplicationListener,\\\norg.springframework.boot.context.config.DelegatingApplicationListener,\\\norg.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\\\norg.springframework.boot.logging.ClasspathLoggingApplicationListener,\\\norg.springframework.boot.logging.LoggingApplicationListener\n```\n\n---\n\n总结一下，SpringApplication的实例过程：\n\n1. 判断是否是 web 环境\n2. 加载初始化器和监听器并实例化\n3. 查找 main 方法所在类\n\n每个过程的特点：\n\n1. 判断 web 环境是根据 Spring 的默认加载器是否能够加载给定类\n2. 初始化器和监听器的加载都依据`META-INF/spring.factories`\n3. main方法所在类的查找是抛出异常在堆栈中查找的\n","slug":"【SpringBoot】SpringApplication实例创建","published":1,"updated":"2017-07-05T13:24:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2qt002hd82e63kikgmh","content":"<p>书接上文，上回说到 Spring Boot 启动的入口是<code>JarLauncher</code>的<code>main</code>方法。其中的主要逻辑是在加载完各种资源后，开启一个新的线程调用程序的入口。整个应用的启动就此缓缓展开，本文只说明从<code>SpringApplication</code>的静态方法<code>run</code>调用后，生成<code>SpringApplication</code>实例的过程。而后的其他启动步骤不在本文记录。</p>\n<p>上文说到<code>main</code>方法的调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@SpringBootApplication</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        SpringApplication.run(Application.class, args);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>静态的<code>run</code>方法是整个程序的入口，但最终还是实例化了<code>SpringApplication</code>对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;Object&gt; sources = <span class=\"keyword\">new</span> LinkedHashSet&lt;Object&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(Object source, String... args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> run(<span class=\"keyword\">new</span> Object[] &#123; source &#125;, args);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(Object[] sources, String[] args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SpringApplication(sources).run(args);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringApplication</span><span class=\"params\">(Object... sources)</span> </span>&#123;</div><div class=\"line\">\tinitialize(sources);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>今天的目标就是<code>initialize</code>方法的实现了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(Object[] sources)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (sources != <span class=\"keyword\">null</span> &amp;&amp; sources.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.sources.addAll(Arrays.asList(sources));</div><div class=\"line\">\t&#125;</div><div class=\"line\">     \t<span class=\"comment\">// 是否是web程序环境</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.webEnvironment = deduceWebEnvironment();</div><div class=\"line\">       <span class=\"comment\">// 设置初始化器</span></div><div class=\"line\">\tsetInitializers((Collection) getSpringFactoriesInstances(</div><div class=\"line\">\t\t\tApplicationContextInitializer.class));</div><div class=\"line\">       <span class=\"comment\">// 设置监听器</span></div><div class=\"line\">\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</div><div class=\"line\">     \t<span class=\"comment\">// main方法所在类</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.mainApplicationClass = deduceMainApplicationClass();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"推断Web环境\"><a href=\"#推断Web环境\" class=\"headerlink\" title=\"推断Web环境\"></a>推断Web环境</h2><p>先看看web环境的判断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// org/springframework/boot/SpringApplication.java</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] WEB_ENVIRONMENT_CLASSES = &#123; <span class=\"string\">\"javax.servlet.Servlet\"</span>,</div><div class=\"line\">\t\t<span class=\"string\">\"org.springframework.web.context.ConfigurableWebApplicationContext\"</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">deduceWebEnvironment</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (String className : WEB_ENVIRONMENT_CLASSES) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (!ClassUtils.isPresent(className, <span class=\"keyword\">null</span>)) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>是通过判断给定的类加载器（null）是否可以加载给定的类（<code>WEB_ENVIRONMENT_CLASSES</code>）判断的。加载器给的是空，跟进去看到了为空时是有默认类加载器的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// org/springframework/util/ClassUtils.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ClassLoader <span class=\"title\">getDefaultClassLoader</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\tClassLoader cl = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tcl = Thread.currentThread().getContextClassLoader();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (cl == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\tcl = ClassUtils.class.getClassLoader();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (cl == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tcl = ClassLoader.getSystemClassLoader();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> cl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"查找-Main-方法\"><a href=\"#查找-Main-方法\" class=\"headerlink\" title=\"查找 Main 方法\"></a>查找 Main 方法</h2><p>跳过其他方法先看<code>main</code>方法所在类的查找</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tStackTraceElement[] stackTrace = <span class=\"keyword\">new</span> RuntimeException().getStackTrace();</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"string\">\"main\"</span>.equals(stackTraceElement.getMethodName())) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Class.forName(stackTraceElement.getClassName());</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// Swallow and continue</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个<code>main</code>方法所在类的查找还是比较6的，万万没想到直接搞了个异常从堆栈里查找，也算是奇技淫巧吧。</p>\n<h2 id=\"初始化器，监听器的加载、实例化\"><a href=\"#初始化器，监听器的加载、实例化\" class=\"headerlink\" title=\"初始化器，监听器的加载、实例化\"></a>初始化器，监听器的加载、实例化</h2><p>下面重点看看<code>SpringApplication</code>实例化最重要的部分：初始化器和监听器的设置。</p>\n<p>两者的核心逻辑都是一样，只是参数有所区别：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> getSpringFactoriesInstances(type, <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123;&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</div><div class=\"line\">\t\tClass&lt;?&gt;[] parameterTypes, Object... args) &#123;</div><div class=\"line\">\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();</div><div class=\"line\">       <span class=\"comment\">// 使用上下文类加载器，加载指定配置文件中的配置</span></div><div class=\"line\">\tSet&lt;String&gt; names = <span class=\"keyword\">new</span> LinkedHashSet&lt;String&gt;(</div><div class=\"line\">\t\t\tSpringFactoriesLoader.loadFactoryNames(type, classLoader));</div><div class=\"line\">     \t<span class=\"comment\">// 反射创建，没什么特别的</span></div><div class=\"line\">\tList&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</div><div class=\"line\">\t\t\tclassLoader, args, names);</div><div class=\"line\">\tAnnotationAwareOrderComparator.sort(instances);</div><div class=\"line\">\t<span class=\"keyword\">return</span> instances;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 加载的配置文件</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String FACTORIES_RESOURCE_LOCATION = <span class=\"string\">\"META-INF/spring.factories\"</span>;</div><div class=\"line\"><span class=\"comment\">// 加载配置文件中key为factoryClass.getName()的项</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">loadFactoryNames</span><span class=\"params\">(Class&lt;?&gt; factoryClass, </span></span></div><div class=\"line\">                                               ClassLoader classLoader) &#123;</div><div class=\"line\">\tString factoryClassName = factoryClass.getName();</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tEnumeration&lt;URL&gt; urls = (classLoader != <span class=\"keyword\">null</span> ?</div><div class=\"line\">                                    classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</div><div class=\"line\">                                  ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</div><div class=\"line\">\t\tList&lt;String&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</div><div class=\"line\">             \tURL url = urls.nextElement();</div><div class=\"line\">\t\t\tProperties properties = </div><div class=\"line\">                 PropertiesLoaderUtils.loadProperties(<span class=\"keyword\">new</span> UrlResource(url));</div><div class=\"line\">\t\t\tString factoryClassNames = </div><div class=\"line\">                 properties.getProperty(factoryClassName);</div><div class=\"line\">             \tresult.addAll(Arrays.asList(</div><div class=\"line\">                 StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">catch</span> (IOException ex) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unable to load [\"</span> + factoryClass.getName() +</div><div class=\"line\">\t\t\t\t<span class=\"string\">\"] factories from location [\"</span> + FACTORIES_RESOURCE_LOCATION + <span class=\"string\">\"]\"</span>, ex);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所有的初始化器和监听器都是从 CLASSPATH 下的<code>META-INF/spring.factories</code>文件中获取的，具体配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Application Context Initializers</div><div class=\"line\">org.springframework.context.ApplicationContextInitializer=\\</div><div class=\"line\">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\</div><div class=\"line\">org.springframework.boot.context.ContextIdApplicationContextInitializer,\\</div><div class=\"line\">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\</div><div class=\"line\">org.springframework.boot.context.embedded.ServerPortInfoApplicationContextInitializer</div><div class=\"line\"></div><div class=\"line\"># Application Listeners</div><div class=\"line\">org.springframework.context.ApplicationListener=\\</div><div class=\"line\">org.springframework.boot.ClearCachesApplicationListener,\\</div><div class=\"line\">org.springframework.boot.builder.ParentContextCloserApplicationListener,\\</div><div class=\"line\">org.springframework.boot.context.FileEncodingApplicationListener,\\</div><div class=\"line\">org.springframework.boot.context.config.AnsiOutputApplicationListener,\\</div><div class=\"line\">org.springframework.boot.context.config.ConfigFileApplicationListener,\\</div><div class=\"line\">org.springframework.boot.context.config.DelegatingApplicationListener,\\</div><div class=\"line\">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\\</div><div class=\"line\">org.springframework.boot.logging.ClasspathLoggingApplicationListener,\\</div><div class=\"line\">org.springframework.boot.logging.LoggingApplicationListener</div></pre></td></tr></table></figure>\n<hr>\n<p>总结一下，SpringApplication的实例过程：</p>\n<ol>\n<li>判断是否是 web 环境</li>\n<li>加载初始化器和监听器并实例化</li>\n<li>查找 main 方法所在类</li>\n</ol>\n<p>每个过程的特点：</p>\n<ol>\n<li>判断 web 环境是根据 Spring 的默认加载器是否能够加载给定类</li>\n<li>初始化器和监听器的加载都依据<code>META-INF/spring.factories</code></li>\n<li>main方法所在类的查找是抛出异常在堆栈中查找的</li>\n</ol>\n","excerpt":"","more":"<p>书接上文，上回说到 Spring Boot 启动的入口是<code>JarLauncher</code>的<code>main</code>方法。其中的主要逻辑是在加载完各种资源后，开启一个新的线程调用程序的入口。整个应用的启动就此缓缓展开，本文只说明从<code>SpringApplication</code>的静态方法<code>run</code>调用后，生成<code>SpringApplication</code>实例的过程。而后的其他启动步骤不在本文记录。</p>\n<p>上文说到<code>main</code>方法的调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@SpringBootApplication</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        SpringApplication.run(Application.class, args);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>静态的<code>run</code>方法是整个程序的入口，但最终还是实例化了<code>SpringApplication</code>对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;Object&gt; sources = <span class=\"keyword\">new</span> LinkedHashSet&lt;Object&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(Object source, String... args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> run(<span class=\"keyword\">new</span> Object[] &#123; source &#125;, args);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(Object[] sources, String[] args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SpringApplication(sources).run(args);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringApplication</span><span class=\"params\">(Object... sources)</span> </span>&#123;</div><div class=\"line\">\tinitialize(sources);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>今天的目标就是<code>initialize</code>方法的实现了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(Object[] sources)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (sources != <span class=\"keyword\">null</span> &amp;&amp; sources.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.sources.addAll(Arrays.asList(sources));</div><div class=\"line\">\t&#125;</div><div class=\"line\">     \t<span class=\"comment\">// 是否是web程序环境</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.webEnvironment = deduceWebEnvironment();</div><div class=\"line\">       <span class=\"comment\">// 设置初始化器</span></div><div class=\"line\">\tsetInitializers((Collection) getSpringFactoriesInstances(</div><div class=\"line\">\t\t\tApplicationContextInitializer.class));</div><div class=\"line\">       <span class=\"comment\">// 设置监听器</span></div><div class=\"line\">\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</div><div class=\"line\">     \t<span class=\"comment\">// main方法所在类</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.mainApplicationClass = deduceMainApplicationClass();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"推断Web环境\"><a href=\"#推断Web环境\" class=\"headerlink\" title=\"推断Web环境\"></a>推断Web环境</h2><p>先看看web环境的判断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// org/springframework/boot/SpringApplication.java</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] WEB_ENVIRONMENT_CLASSES = &#123; <span class=\"string\">\"javax.servlet.Servlet\"</span>,</div><div class=\"line\">\t\t<span class=\"string\">\"org.springframework.web.context.ConfigurableWebApplicationContext\"</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">deduceWebEnvironment</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (String className : WEB_ENVIRONMENT_CLASSES) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (!ClassUtils.isPresent(className, <span class=\"keyword\">null</span>)) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>是通过判断给定的类加载器（null）是否可以加载给定的类（<code>WEB_ENVIRONMENT_CLASSES</code>）判断的。加载器给的是空，跟进去看到了为空时是有默认类加载器的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// org/springframework/util/ClassUtils.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ClassLoader <span class=\"title\">getDefaultClassLoader</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\tClassLoader cl = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tcl = Thread.currentThread().getContextClassLoader();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (cl == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\tcl = ClassUtils.class.getClassLoader();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (cl == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tcl = ClassLoader.getSystemClassLoader();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> cl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"查找-Main-方法\"><a href=\"#查找-Main-方法\" class=\"headerlink\" title=\"查找 Main 方法\"></a>查找 Main 方法</h2><p>跳过其他方法先看<code>main</code>方法所在类的查找</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tStackTraceElement[] stackTrace = <span class=\"keyword\">new</span> RuntimeException().getStackTrace();</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"string\">\"main\"</span>.equals(stackTraceElement.getMethodName())) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Class.forName(stackTraceElement.getClassName());</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// Swallow and continue</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个<code>main</code>方法所在类的查找还是比较6的，万万没想到直接搞了个异常从堆栈里查找，也算是奇技淫巧吧。</p>\n<h2 id=\"初始化器，监听器的加载、实例化\"><a href=\"#初始化器，监听器的加载、实例化\" class=\"headerlink\" title=\"初始化器，监听器的加载、实例化\"></a>初始化器，监听器的加载、实例化</h2><p>下面重点看看<code>SpringApplication</code>实例化最重要的部分：初始化器和监听器的设置。</p>\n<p>两者的核心逻辑都是一样，只是参数有所区别：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> getSpringFactoriesInstances(type, <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123;&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</div><div class=\"line\">\t\tClass&lt;?&gt;[] parameterTypes, Object... args) &#123;</div><div class=\"line\">\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();</div><div class=\"line\">       <span class=\"comment\">// 使用上下文类加载器，加载指定配置文件中的配置</span></div><div class=\"line\">\tSet&lt;String&gt; names = <span class=\"keyword\">new</span> LinkedHashSet&lt;String&gt;(</div><div class=\"line\">\t\t\tSpringFactoriesLoader.loadFactoryNames(type, classLoader));</div><div class=\"line\">     \t<span class=\"comment\">// 反射创建，没什么特别的</span></div><div class=\"line\">\tList&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</div><div class=\"line\">\t\t\tclassLoader, args, names);</div><div class=\"line\">\tAnnotationAwareOrderComparator.sort(instances);</div><div class=\"line\">\t<span class=\"keyword\">return</span> instances;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 加载的配置文件</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String FACTORIES_RESOURCE_LOCATION = <span class=\"string\">\"META-INF/spring.factories\"</span>;</div><div class=\"line\"><span class=\"comment\">// 加载配置文件中key为factoryClass.getName()的项</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">loadFactoryNames</span><span class=\"params\">(Class&lt;?&gt; factoryClass, </div><div class=\"line\">                                               ClassLoader classLoader)</span> </span>&#123;</div><div class=\"line\">\tString factoryClassName = factoryClass.getName();</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tEnumeration&lt;URL&gt; urls = (classLoader != <span class=\"keyword\">null</span> ?</div><div class=\"line\">                                    classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</div><div class=\"line\">                                  ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</div><div class=\"line\">\t\tList&lt;String&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</div><div class=\"line\">             \tURL url = urls.nextElement();</div><div class=\"line\">\t\t\tProperties properties = </div><div class=\"line\">                 PropertiesLoaderUtils.loadProperties(<span class=\"keyword\">new</span> UrlResource(url));</div><div class=\"line\">\t\t\tString factoryClassNames = </div><div class=\"line\">                 properties.getProperty(factoryClassName);</div><div class=\"line\">             \tresult.addAll(Arrays.asList(</div><div class=\"line\">                 StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">catch</span> (IOException ex) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unable to load [\"</span> + factoryClass.getName() +</div><div class=\"line\">\t\t\t\t<span class=\"string\">\"] factories from location [\"</span> + FACTORIES_RESOURCE_LOCATION + <span class=\"string\">\"]\"</span>, ex);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所有的初始化器和监听器都是从 CLASSPATH 下的<code>META-INF/spring.factories</code>文件中获取的，具体配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Application Context Initializers</div><div class=\"line\">org.springframework.context.ApplicationContextInitializer=\\</div><div class=\"line\">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\</div><div class=\"line\">org.springframework.boot.context.ContextIdApplicationContextInitializer,\\</div><div class=\"line\">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\</div><div class=\"line\">org.springframework.boot.context.embedded.ServerPortInfoApplicationContextInitializer</div><div class=\"line\"></div><div class=\"line\"># Application Listeners</div><div class=\"line\">org.springframework.context.ApplicationListener=\\</div><div class=\"line\">org.springframework.boot.ClearCachesApplicationListener,\\</div><div class=\"line\">org.springframework.boot.builder.ParentContextCloserApplicationListener,\\</div><div class=\"line\">org.springframework.boot.context.FileEncodingApplicationListener,\\</div><div class=\"line\">org.springframework.boot.context.config.AnsiOutputApplicationListener,\\</div><div class=\"line\">org.springframework.boot.context.config.ConfigFileApplicationListener,\\</div><div class=\"line\">org.springframework.boot.context.config.DelegatingApplicationListener,\\</div><div class=\"line\">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\\</div><div class=\"line\">org.springframework.boot.logging.ClasspathLoggingApplicationListener,\\</div><div class=\"line\">org.springframework.boot.logging.LoggingApplicationListener</div></pre></td></tr></table></figure>\n<hr>\n<p>总结一下，SpringApplication的实例过程：</p>\n<ol>\n<li>判断是否是 web 环境</li>\n<li>加载初始化器和监听器并实例化</li>\n<li>查找 main 方法所在类</li>\n</ol>\n<p>每个过程的特点：</p>\n<ol>\n<li>判断 web 环境是根据 Spring 的默认加载器是否能够加载给定类</li>\n<li>初始化器和监听器的加载都依据<code>META-INF/spring.factories</code></li>\n<li>main方法所在类的查找是抛出异常在堆栈中查找的</li>\n</ol>\n"},{"title":"【Netty】IO模型","date":"2017-07-16T16:14:18.000Z","_content":"## 网络 IO 模型\n\nUNIX 网络编程对 IO 模型分类， UNIX 提供 5 种 IO 模型\n\n在这 5 个 IO 模型之前，先看看这五个 IO 模型最后的关注点：\n\n### 用户 & 内核空间\n\n内核：操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，有访问底层硬件设备的所有权限\n\n为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。\n\n### 缓存 IO\n\n数据会先拷贝到操作系统内核的缓冲区，然后才从操作系统内核的缓冲区拷贝到应用程序的地址空间\n\n缺点：数据需要在应用程序空间和内核空间进行数据拷贝，影响效率\n\n有了上面几个基本概念下面看看网络 IO\n\n## 网络 IO\n\nIO 操作的本质是对数据的读写。因为 IO 缓存的缘故，一个 IO 操作需要分为两步，以读操作为例：\n\n1. 等待数据准备\n2. 将数据从内核空间拷贝到用户空间\n\n对网络 IO 而言，上面的两步可以更具象的表述为：\n\n1. 等待网络数据分组到达，然后将其复制到内核缓冲区\n2. 把数据从内核缓冲区复制到应用空间缓冲区\n\n由于网络传输的不确定性，第一步操作可能成为最耗时的过程（可能比后面的业务逻辑计算都更为耗时）。\n\n下面看 5 个 IO 模型是如何解决问题的，相关的图就不放了网上一大把：\n\n### 阻塞 IO 模型\n\n这个模型下，其实就是不解决任何问题，第一步，第二部都是阻塞的。\n\n以 socket 操作为例，进程空间调用 recvfrom，其系统调用会直到数据包到达并且复制到应用进程缓冲区才返回。\n\n### 非阻塞 IO 模型\n\n使用轮询操作，避免第一步操作完全被阻塞。\n\n进程调用 recvfrom，如果缓冲区没有数据立即返回一个 EWOULDBLOCK，通过轮询操作检查内核缓冲区是否有数据到来。\n\n### IO 复用模型\n\nLinux 提供系统调用，进程将文件描述符传递给系统调用，若第一步未就绪则阻塞在系统调用上。\n\nLinux对 IO 复用模型提供的系统调用：\n\n- select：顺序描述所有文件描述符，文件描述符最多持有 1024 个\n- poll：类似于select，只是去除了文件描述符数组长度的限制\n- epoll：利用mmap技术避免了这些复制和遍历操作\n\n**Java NIO多路复用器 Selector 就是基于 epoll 的多路复用技术实现的**\n\n### 信号驱动 IO 模型\n\n应用进程建立 SIGIO 信号处理程序，调用 sigaction 后返回。IO 第一步完成后通知程序。\n\n### 异步 IO\n\n告知内核启动某个操作，并让内核在整个操作完成后通知我们。\n\n### IO 模型对比\n\n![1486392482597_6.png](https://i.loli.net/2017/07/16/596b64fa04869.png)\n\n## Java 对于 IO 模型的实现\n\n### JDK 支持\n\n- JDK 1.0 ~ JDK 1.3：传统的 BIO，基于阻塞 IO 模型\n- JDK 1.4 ~ JDK 1.5：加入 NIO，基于 IO 复用模型\n  - JDK 1.4 ~ JDK 1.5 update10：Selector 基于 select/poll 模型实现\n  - JDK 1.5 update & Linux core 2.6 以上：Selector 使用 epoll 模型实现\n- JDK 1.7 ~ JDK 1.8（目前）：加入 NIO 2.0（AIO），增加异步套接字通道\n\n### 使用\n\n- [阻塞 IO](https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/bio)\n- [伪异步 IO](https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/paio)\n- [非阻塞 IO](https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/nio)\n- [异步 IO](https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/aio)\n\n---\n\n参考：\n\n1. 《Netty 权威指南》（第2版）：第1章，第2章\n2. [聊聊并发，Part 1：IO模型](http://blog.leanote.com/post/joesay/Concurrency-Model-Part-1-IO-Concurrency)\n3. [聊聊Linux 五种IO模型](http://www.jianshu.com/p/486b0965c296)\n","source":"_posts/【Netty】IO模型.md","raw":"---\ntitle: 【Netty】IO模型\ndate: 2017-07-17 00:14:18\ntags: \n  - Netty\n  - Java\ncategories: Netty\n---\n## 网络 IO 模型\n\nUNIX 网络编程对 IO 模型分类， UNIX 提供 5 种 IO 模型\n\n在这 5 个 IO 模型之前，先看看这五个 IO 模型最后的关注点：\n\n### 用户 & 内核空间\n\n内核：操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，有访问底层硬件设备的所有权限\n\n为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。\n\n### 缓存 IO\n\n数据会先拷贝到操作系统内核的缓冲区，然后才从操作系统内核的缓冲区拷贝到应用程序的地址空间\n\n缺点：数据需要在应用程序空间和内核空间进行数据拷贝，影响效率\n\n有了上面几个基本概念下面看看网络 IO\n\n## 网络 IO\n\nIO 操作的本质是对数据的读写。因为 IO 缓存的缘故，一个 IO 操作需要分为两步，以读操作为例：\n\n1. 等待数据准备\n2. 将数据从内核空间拷贝到用户空间\n\n对网络 IO 而言，上面的两步可以更具象的表述为：\n\n1. 等待网络数据分组到达，然后将其复制到内核缓冲区\n2. 把数据从内核缓冲区复制到应用空间缓冲区\n\n由于网络传输的不确定性，第一步操作可能成为最耗时的过程（可能比后面的业务逻辑计算都更为耗时）。\n\n下面看 5 个 IO 模型是如何解决问题的，相关的图就不放了网上一大把：\n\n### 阻塞 IO 模型\n\n这个模型下，其实就是不解决任何问题，第一步，第二部都是阻塞的。\n\n以 socket 操作为例，进程空间调用 recvfrom，其系统调用会直到数据包到达并且复制到应用进程缓冲区才返回。\n\n### 非阻塞 IO 模型\n\n使用轮询操作，避免第一步操作完全被阻塞。\n\n进程调用 recvfrom，如果缓冲区没有数据立即返回一个 EWOULDBLOCK，通过轮询操作检查内核缓冲区是否有数据到来。\n\n### IO 复用模型\n\nLinux 提供系统调用，进程将文件描述符传递给系统调用，若第一步未就绪则阻塞在系统调用上。\n\nLinux对 IO 复用模型提供的系统调用：\n\n- select：顺序描述所有文件描述符，文件描述符最多持有 1024 个\n- poll：类似于select，只是去除了文件描述符数组长度的限制\n- epoll：利用mmap技术避免了这些复制和遍历操作\n\n**Java NIO多路复用器 Selector 就是基于 epoll 的多路复用技术实现的**\n\n### 信号驱动 IO 模型\n\n应用进程建立 SIGIO 信号处理程序，调用 sigaction 后返回。IO 第一步完成后通知程序。\n\n### 异步 IO\n\n告知内核启动某个操作，并让内核在整个操作完成后通知我们。\n\n### IO 模型对比\n\n![1486392482597_6.png](https://i.loli.net/2017/07/16/596b64fa04869.png)\n\n## Java 对于 IO 模型的实现\n\n### JDK 支持\n\n- JDK 1.0 ~ JDK 1.3：传统的 BIO，基于阻塞 IO 模型\n- JDK 1.4 ~ JDK 1.5：加入 NIO，基于 IO 复用模型\n  - JDK 1.4 ~ JDK 1.5 update10：Selector 基于 select/poll 模型实现\n  - JDK 1.5 update & Linux core 2.6 以上：Selector 使用 epoll 模型实现\n- JDK 1.7 ~ JDK 1.8（目前）：加入 NIO 2.0（AIO），增加异步套接字通道\n\n### 使用\n\n- [阻塞 IO](https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/bio)\n- [伪异步 IO](https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/paio)\n- [非阻塞 IO](https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/nio)\n- [异步 IO](https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/aio)\n\n---\n\n参考：\n\n1. 《Netty 权威指南》（第2版）：第1章，第2章\n2. [聊聊并发，Part 1：IO模型](http://blog.leanote.com/post/joesay/Concurrency-Model-Part-1-IO-Concurrency)\n3. [聊聊Linux 五种IO模型](http://www.jianshu.com/p/486b0965c296)\n","slug":"【Netty】IO模型","published":1,"updated":"2017-07-16T16:24:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2qv002md82e2mwfozzw","content":"<h2 id=\"网络-IO-模型\"><a href=\"#网络-IO-模型\" class=\"headerlink\" title=\"网络 IO 模型\"></a>网络 IO 模型</h2><p>UNIX 网络编程对 IO 模型分类， UNIX 提供 5 种 IO 模型</p>\n<p>在这 5 个 IO 模型之前，先看看这五个 IO 模型最后的关注点：</p>\n<h3 id=\"用户-amp-内核空间\"><a href=\"#用户-amp-内核空间\" class=\"headerlink\" title=\"用户 &amp; 内核空间\"></a>用户 &amp; 内核空间</h3><p>内核：操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，有访问底层硬件设备的所有权限</p>\n<p>为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>\n<h3 id=\"缓存-IO\"><a href=\"#缓存-IO\" class=\"headerlink\" title=\"缓存 IO\"></a>缓存 IO</h3><p>数据会先拷贝到操作系统内核的缓冲区，然后才从操作系统内核的缓冲区拷贝到应用程序的地址空间</p>\n<p>缺点：数据需要在应用程序空间和内核空间进行数据拷贝，影响效率</p>\n<p>有了上面几个基本概念下面看看网络 IO</p>\n<h2 id=\"网络-IO\"><a href=\"#网络-IO\" class=\"headerlink\" title=\"网络 IO\"></a>网络 IO</h2><p>IO 操作的本质是对数据的读写。因为 IO 缓存的缘故，一个 IO 操作需要分为两步，以读操作为例：</p>\n<ol>\n<li>等待数据准备</li>\n<li>将数据从内核空间拷贝到用户空间</li>\n</ol>\n<p>对网络 IO 而言，上面的两步可以更具象的表述为：</p>\n<ol>\n<li>等待网络数据分组到达，然后将其复制到内核缓冲区</li>\n<li>把数据从内核缓冲区复制到应用空间缓冲区</li>\n</ol>\n<p>由于网络传输的不确定性，第一步操作可能成为最耗时的过程（可能比后面的业务逻辑计算都更为耗时）。</p>\n<p>下面看 5 个 IO 模型是如何解决问题的，相关的图就不放了网上一大把：</p>\n<h3 id=\"阻塞-IO-模型\"><a href=\"#阻塞-IO-模型\" class=\"headerlink\" title=\"阻塞 IO 模型\"></a>阻塞 IO 模型</h3><p>这个模型下，其实就是不解决任何问题，第一步，第二部都是阻塞的。</p>\n<p>以 socket 操作为例，进程空间调用 recvfrom，其系统调用会直到数据包到达并且复制到应用进程缓冲区才返回。</p>\n<h3 id=\"非阻塞-IO-模型\"><a href=\"#非阻塞-IO-模型\" class=\"headerlink\" title=\"非阻塞 IO 模型\"></a>非阻塞 IO 模型</h3><p>使用轮询操作，避免第一步操作完全被阻塞。</p>\n<p>进程调用 recvfrom，如果缓冲区没有数据立即返回一个 EWOULDBLOCK，通过轮询操作检查内核缓冲区是否有数据到来。</p>\n<h3 id=\"IO-复用模型\"><a href=\"#IO-复用模型\" class=\"headerlink\" title=\"IO 复用模型\"></a>IO 复用模型</h3><p>Linux 提供系统调用，进程将文件描述符传递给系统调用，若第一步未就绪则阻塞在系统调用上。</p>\n<p>Linux对 IO 复用模型提供的系统调用：</p>\n<ul>\n<li>select：顺序描述所有文件描述符，文件描述符最多持有 1024 个</li>\n<li>poll：类似于select，只是去除了文件描述符数组长度的限制</li>\n<li>epoll：利用mmap技术避免了这些复制和遍历操作</li>\n</ul>\n<p><strong>Java NIO多路复用器 Selector 就是基于 epoll 的多路复用技术实现的</strong></p>\n<h3 id=\"信号驱动-IO-模型\"><a href=\"#信号驱动-IO-模型\" class=\"headerlink\" title=\"信号驱动 IO 模型\"></a>信号驱动 IO 模型</h3><p>应用进程建立 SIGIO 信号处理程序，调用 sigaction 后返回。IO 第一步完成后通知程序。</p>\n<h3 id=\"异步-IO\"><a href=\"#异步-IO\" class=\"headerlink\" title=\"异步 IO\"></a>异步 IO</h3><p>告知内核启动某个操作，并让内核在整个操作完成后通知我们。</p>\n<h3 id=\"IO-模型对比\"><a href=\"#IO-模型对比\" class=\"headerlink\" title=\"IO 模型对比\"></a>IO 模型对比</h3><p><img src=\"https://i.loli.net/2017/07/16/596b64fa04869.png\" alt=\"1486392482597_6.png\"></p>\n<h2 id=\"Java-对于-IO-模型的实现\"><a href=\"#Java-对于-IO-模型的实现\" class=\"headerlink\" title=\"Java 对于 IO 模型的实现\"></a>Java 对于 IO 模型的实现</h2><h3 id=\"JDK-支持\"><a href=\"#JDK-支持\" class=\"headerlink\" title=\"JDK 支持\"></a>JDK 支持</h3><ul>\n<li>JDK 1.0 ~ JDK 1.3：传统的 BIO，基于阻塞 IO 模型</li>\n<li>JDK 1.4 ~ JDK 1.5：加入 NIO，基于 IO 复用模型<ul>\n<li>JDK 1.4 ~ JDK 1.5 update10：Selector 基于 select/poll 模型实现</li>\n<li>JDK 1.5 update &amp; Linux core 2.6 以上：Selector 使用 epoll 模型实现</li>\n</ul>\n</li>\n<li>JDK 1.7 ~ JDK 1.8（目前）：加入 NIO 2.0（AIO），增加异步套接字通道</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li><a href=\"https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/bio\" target=\"_blank\" rel=\"external\">阻塞 IO</a></li>\n<li><a href=\"https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/paio\" target=\"_blank\" rel=\"external\">伪异步 IO</a></li>\n<li><a href=\"https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/nio\" target=\"_blank\" rel=\"external\">非阻塞 IO</a></li>\n<li><a href=\"https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/aio\" target=\"_blank\" rel=\"external\">异步 IO</a></li>\n</ul>\n<hr>\n<p>参考：</p>\n<ol>\n<li>《Netty 权威指南》（第2版）：第1章，第2章</li>\n<li><a href=\"http://blog.leanote.com/post/joesay/Concurrency-Model-Part-1-IO-Concurrency\" target=\"_blank\" rel=\"external\">聊聊并发，Part 1：IO模型</a></li>\n<li><a href=\"http://www.jianshu.com/p/486b0965c296\" target=\"_blank\" rel=\"external\">聊聊Linux 五种IO模型</a></li>\n</ol>\n","excerpt":"","more":"<h2 id=\"网络-IO-模型\"><a href=\"#网络-IO-模型\" class=\"headerlink\" title=\"网络 IO 模型\"></a>网络 IO 模型</h2><p>UNIX 网络编程对 IO 模型分类， UNIX 提供 5 种 IO 模型</p>\n<p>在这 5 个 IO 模型之前，先看看这五个 IO 模型最后的关注点：</p>\n<h3 id=\"用户-amp-内核空间\"><a href=\"#用户-amp-内核空间\" class=\"headerlink\" title=\"用户 &amp; 内核空间\"></a>用户 &amp; 内核空间</h3><p>内核：操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，有访问底层硬件设备的所有权限</p>\n<p>为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>\n<h3 id=\"缓存-IO\"><a href=\"#缓存-IO\" class=\"headerlink\" title=\"缓存 IO\"></a>缓存 IO</h3><p>数据会先拷贝到操作系统内核的缓冲区，然后才从操作系统内核的缓冲区拷贝到应用程序的地址空间</p>\n<p>缺点：数据需要在应用程序空间和内核空间进行数据拷贝，影响效率</p>\n<p>有了上面几个基本概念下面看看网络 IO</p>\n<h2 id=\"网络-IO\"><a href=\"#网络-IO\" class=\"headerlink\" title=\"网络 IO\"></a>网络 IO</h2><p>IO 操作的本质是对数据的读写。因为 IO 缓存的缘故，一个 IO 操作需要分为两步，以读操作为例：</p>\n<ol>\n<li>等待数据准备</li>\n<li>将数据从内核空间拷贝到用户空间</li>\n</ol>\n<p>对网络 IO 而言，上面的两步可以更具象的表述为：</p>\n<ol>\n<li>等待网络数据分组到达，然后将其复制到内核缓冲区</li>\n<li>把数据从内核缓冲区复制到应用空间缓冲区</li>\n</ol>\n<p>由于网络传输的不确定性，第一步操作可能成为最耗时的过程（可能比后面的业务逻辑计算都更为耗时）。</p>\n<p>下面看 5 个 IO 模型是如何解决问题的，相关的图就不放了网上一大把：</p>\n<h3 id=\"阻塞-IO-模型\"><a href=\"#阻塞-IO-模型\" class=\"headerlink\" title=\"阻塞 IO 模型\"></a>阻塞 IO 模型</h3><p>这个模型下，其实就是不解决任何问题，第一步，第二部都是阻塞的。</p>\n<p>以 socket 操作为例，进程空间调用 recvfrom，其系统调用会直到数据包到达并且复制到应用进程缓冲区才返回。</p>\n<h3 id=\"非阻塞-IO-模型\"><a href=\"#非阻塞-IO-模型\" class=\"headerlink\" title=\"非阻塞 IO 模型\"></a>非阻塞 IO 模型</h3><p>使用轮询操作，避免第一步操作完全被阻塞。</p>\n<p>进程调用 recvfrom，如果缓冲区没有数据立即返回一个 EWOULDBLOCK，通过轮询操作检查内核缓冲区是否有数据到来。</p>\n<h3 id=\"IO-复用模型\"><a href=\"#IO-复用模型\" class=\"headerlink\" title=\"IO 复用模型\"></a>IO 复用模型</h3><p>Linux 提供系统调用，进程将文件描述符传递给系统调用，若第一步未就绪则阻塞在系统调用上。</p>\n<p>Linux对 IO 复用模型提供的系统调用：</p>\n<ul>\n<li>select：顺序描述所有文件描述符，文件描述符最多持有 1024 个</li>\n<li>poll：类似于select，只是去除了文件描述符数组长度的限制</li>\n<li>epoll：利用mmap技术避免了这些复制和遍历操作</li>\n</ul>\n<p><strong>Java NIO多路复用器 Selector 就是基于 epoll 的多路复用技术实现的</strong></p>\n<h3 id=\"信号驱动-IO-模型\"><a href=\"#信号驱动-IO-模型\" class=\"headerlink\" title=\"信号驱动 IO 模型\"></a>信号驱动 IO 模型</h3><p>应用进程建立 SIGIO 信号处理程序，调用 sigaction 后返回。IO 第一步完成后通知程序。</p>\n<h3 id=\"异步-IO\"><a href=\"#异步-IO\" class=\"headerlink\" title=\"异步 IO\"></a>异步 IO</h3><p>告知内核启动某个操作，并让内核在整个操作完成后通知我们。</p>\n<h3 id=\"IO-模型对比\"><a href=\"#IO-模型对比\" class=\"headerlink\" title=\"IO 模型对比\"></a>IO 模型对比</h3><p><img src=\"https://i.loli.net/2017/07/16/596b64fa04869.png\" alt=\"1486392482597_6.png\"></p>\n<h2 id=\"Java-对于-IO-模型的实现\"><a href=\"#Java-对于-IO-模型的实现\" class=\"headerlink\" title=\"Java 对于 IO 模型的实现\"></a>Java 对于 IO 模型的实现</h2><h3 id=\"JDK-支持\"><a href=\"#JDK-支持\" class=\"headerlink\" title=\"JDK 支持\"></a>JDK 支持</h3><ul>\n<li>JDK 1.0 ~ JDK 1.3：传统的 BIO，基于阻塞 IO 模型</li>\n<li>JDK 1.4 ~ JDK 1.5：加入 NIO，基于 IO 复用模型<ul>\n<li>JDK 1.4 ~ JDK 1.5 update10：Selector 基于 select/poll 模型实现</li>\n<li>JDK 1.5 update &amp; Linux core 2.6 以上：Selector 使用 epoll 模型实现</li>\n</ul>\n</li>\n<li>JDK 1.7 ~ JDK 1.8（目前）：加入 NIO 2.0（AIO），增加异步套接字通道</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li><a href=\"https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/bio\">阻塞 IO</a></li>\n<li><a href=\"https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/paio\">伪异步 IO</a></li>\n<li><a href=\"https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/nio\">非阻塞 IO</a></li>\n<li><a href=\"https://github.com/zhanghTK/netty/tree/master/src/main/java/tk/zhangh/netty/ch1/aio\">异步 IO</a></li>\n</ul>\n<hr>\n<p>参考：</p>\n<ol>\n<li>《Netty 权威指南》（第2版）：第1章，第2章</li>\n<li><a href=\"http://blog.leanote.com/post/joesay/Concurrency-Model-Part-1-IO-Concurrency\">聊聊并发，Part 1：IO模型</a></li>\n<li><a href=\"http://www.jianshu.com/p/486b0965c296\">聊聊Linux 五种IO模型</a></li>\n</ol>\n"},{"title":"【MQ】镜像队列","date":"2017-12-08T13:57:51.000Z","_content":"\n前面提到持久化和消息确认可以确保消息的可靠，但在默认情况下 MQ 的可靠性完全没有保障，通过集群的方式确保服务的可靠往往是高可用的第一步。本文记录一下 Rabbit MQ 的集群和镜像。\n\n## 集群\n\n集群能够带来的好处主要有两点：\n\n1. 允许消费者和生产者在 Rabbit MQ 节点崩溃的情况下继续运行\n2. 通过添加更多节点线性的扩展消息通信吞吐量\n\n### 模式\n\n在介绍集群之前先看看从单节点到集群的模式异同：\n\n- 相同：任何模式下节点内部都需要维护基本元数据信息：队列元数据、交换器元数据、绑定元数据、vhost 元数据。不同模式\n\n- 差异：\n\n  - 单一节点模式：\n\n    默认基本元数据信息存储在内存，被标记持久化的队列和交换器已经它们的绑定存储到磁盘\n\n  - 普通集群模式\n\n    ![cluster.PNG](https://i.loli.net/2017/08/23/599ce92322b59.png)\n\n    ![cluster.PNG](https://i.loli.net/2017/08/23/599ce7656d746.png)\n\n    除了基本元数据，还有集群相关元数据。与单一节点模式的不同主要在集群对队列，交换器，数据存储的差异。\n\n    队列：只会在单个节点而不是所有节点上创建完整队列信息，其余节点只保存队列的元数据。虽然只在一个节点保存完整队列，但消息可以在不同节点之间临时传输（消费者感知到每个节点都有完整的队列）。如果保存队列的单个节点挂了，则消费者对其订阅丢失，即将投递到该队列的信息消息也丢失。如果挂掉的队列是持久化队列则无法重新创建队列，必须恢复该队列\n\n    交换器：交换器实质是一张查询表（消息的转发路由是由信道完成），集群内所有的节点拥有所有交换器的信息\n\n    数据存储：分为内存节点和硬盘节点，硬盘节点防止重启后元数据信息丢失。元数据的创建更新在集群所有节点操作完成后才返回。集群下要求任何时刻集群中至少有一个磁盘节点，如果唯一的磁盘节点挂了，集群只能路由消息但不能创建更新元数据\n\n  - 镜像队列\n\n    ![image_queues.PNG](https://i.loli.net/2017/08/23/599ce8d6ae6a3.png)\n\n    镜像不在单独存在在唯一节点，而是冗余在多个节点\n\n## 镜像队列\n\n因为普通集群模式相对基础，而镜像队列复杂，这里重点讨论一下镜像队列。\n\n### 概述\n\n队列镜像通常包括一个 master 节点和多个 slave 节点，每个节点都复制队列数据。当一个节点失效时，可以自动切换到另一个节点确保可用。在镜像队列模式下，除了 publish 外的所有动作都只会向 master 发送，然后 master 将命令执行的结果广播为所有 slave，publish 到镜像的所有消息总是被直接 publish 到所有 slave 之上（类似与 fanout 交换器）。\n\n### 原理\n\n#### 普通队列结构\n\n普通队列由两部分组成：\n\n- AMQQueue：主要负责 AMQP 协议的逻辑功能\n- BackingQueue：存储消息\n\n对于 BackingQueue 又由五个子队列组成：Q1, Q1, Delta, Q3, Q4，MQ 的消息进入队列后会随着系统负载在队列中流动，BackingQueue 中的消息可以分为四个状态：\n\n- Alpha：消息的内容和索引都在内存中，Q1 和 Q4 的状态\n- Beta：消息的内容在硬盘，消息的索引在内存，Q2 和 Q3 的状态\n- Gamma：消息内容在硬盘，消息的索引在硬盘和内存都有，Q2 和 Q3 的状态\n- Delta：消息的内容和消息的索引都在硬盘上，Delta 状态\n\n对于持久化的消息，消息内容和消息索引都必须先保存到磁盘上，才会处于上述状态中的一种，而Gamma状态的消息只有持久化的消息才会有该状态。\n\n从 Q1 到 Q4，基本的经历是由内存到硬盘再到内存的设计，分层的好处使得整个队列有很好的弹性:\n\n- 当队列负载很高的情况下，能够通过将一部分消息由磁盘保存来节省内存空间\n- 当负载降低的时候，这部分消息又渐渐回到内存，被消费者获取\n\n引起消息流动的两种情况：消费者获取消息，内存不足\n\n当系统处于正常负载，对消息的消费速度不小于接收速度，对于非消息极可能只会有 Alpha 状态。对于持久化消息一定会进入 gamma 状态。如果开启 confirm 机制，只有到了这个阶段才会确认消息已经被接受，当消费足够快且内存充足消息不会继续走到下一状态。\n\n当系统处于高负载，已接受的消息不能很快被消费，这些消息就会进入很深的队列中去，增加处理每个消息的平均开销。因为平均开销增加，处理速度更慢，由此恶性循环，使得系统的处理能力大大降低。\n\n改善措施：\n\n1. 进行流程控制\n2. 增加 prefetch 的值，一次发送更多消息给消费者\n3. 采用 multiple ack\n\n#### 镜像队列结构\n\n在镜像队列中 AMQQueue 仍旧负责 AMQP 协议的逻辑功能，而 backing_queue 已不是简单的单节点 backing_queue 了。\n\nbacking_queue 是由 master 和 slave 节点组成的特殊 backing_queue，所有对 mirror_queue_master 的操作，会通过 GM 同步到 slave 节点，slave 节点上 mirror_queue_slave 负责回调，master 节点上 coordinato 负责回调。\n\n镜像队列对消息的操作：\n\n- basic.publish 操作：操作直接同步到所有节点\n- 其他操作：通过 master 操作，由 master 将结果给 slave\n\n##### GM\n\nGM(Guarenteed Multicast)，实现可靠组播通讯协议的模块，确保组播消息的原子性：\n\n- 将所有节点形成一个收尾相连的循环链表\n- 当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上\n- 当有节点失效时，相邻的节点会接管保证本次广播的消息会复制到所有节点\n- 消息从master节点对应的gm发出后，顺着链表依次传送到所有节点\n\n### 镜像队列细节备忘\n\n镜像队列细节太多，这里整理网上一个注意事项：\n\n1. 镜像队列不能作为负载均衡使用，因为每个操作在所有节点都要做一遍\n\n2. ha-mode 参数与 durable, declare 对 exclusive 队列都不生效。exclusive队列是连接独占的，当连接断开，队列自动删除，这两个参数对exclusive队列没有意义\n\n3. 将新节点加入已存在的镜像队列时，默认情况下 ha-sync-mode=manual，镜像队列中的消息不会主动同步到新节点，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行操作，直到同步完毕。当 ha-sync-mode=automatic 时，新加入节点时会默认同步已知的镜像队列。由于同步过程的限制，所以不建议在生产环境的active队列(有生产消费消息)中操作\n\n4. 每当一个节点加入或者重新加入(例如从网络分区中恢复回来)镜像队列，之前保存的队列内容会被清空\n\n5. 镜像队列有主从之分，一个主节点(master)，0个或多个从节点(slave)。当 master 宕掉后，会在 slave中 选举新的master。选举算法为最早启动的节点\n\n6. 当所有slave都处在(与master)未同步状态时，并且 ha-promote-on-shutdown policy 设置为 when-syned(默认) 时，如果 master 因为主动的原因停掉，比如是通过 rabbitmqctl stop 命令停止或者优雅关闭 OS，那么slave不会接管 master，也就是说此时镜像队列不可用\n\n   但是如果master因为被动原因停掉，比如 VM 或者 OS crash了，那么 slave 会接管 master。这个配置项隐含的价值取向是优先保证消息可靠不丢失，放弃可用性。\n\n   如果 ha-promote-on-shutdown policy 设置为 alway，那么不论 master 因为何种原因停止，slave 都会接管 master，优先保证可用性\n\n7. 镜像队列中最后一个停止的节点会是 master，启动顺序必须是 master 先起，如果 slave 先起，它会有 30 秒的等待时间，等待 master 启动，然后加入 cluster。\n\n   当所有节点因故(断电等)同时离线时，每个节点都认为自己不是最后一个停止的节点。要恢复镜像队列，可以尝试在 30 秒之内同时启动所有节点\n\n8. 对于镜像队列，客户端basic.publish操作会同步到所有节点；而其他操作则是通过master中转，再由master将操作作用于salve。比如一个basic.get操作，假如客户端与slave建立了TCP连接，首先是slave将basic.get请求发送至master，由master备好数据，返回至slave，投递给消费者\n\n9. 当 slave 宕掉时，除了与 slave 相连的客户端连接全部断开之外，没有其他影响。\n\n   当 master 宕掉时，会有以下连锁反应：\n\n   1. 与 master 相连的客户端连接全部断开。\n   2. 选举最老的 slave 为 master。若此时所有 slave 处于未同步状态，则未同步部分消息丢失。\n   3. 新的 master 节点 requeue 所有 unack 消息，因为这个新节点无法区分这些 unack 消息是否已经到达客户端，亦或是 ack 消息丢失在到老master的通路上，亦或是丢在老 master 组播 ack 消息到所有 slave 的通路上。所以处于消息可靠性的考虑，requeue 所有 unack 的消息。此时客户端可能受到重复消息。\n   4. 如果客户端连着 slave，并且 basic.consume 消息时指定了x-cancel-on-ha-failover参数，那么客户端会收到一个 Consumer Cancellation Notification 通知，Java SDK中会回调 Consumer 接口的handleCancel() 方法，故需覆盖此方法。如果不指定 x-cancel-on-ha-failover 参数，那么消费者就无法感知 master 宕机，会一直等待下去\n\n### 镜像队列的恢复\n\n前提：两个节点 A 和 B 组成以镜像队列\n\n- 场景一：A 先停，B 后停\n\n  该场景下 B 是 master，只要先启动 B，再启动 A 即可。或者先启动 A，再在 30s 之内启动 B 即可恢复镜像队列。如果没有在 30s 内恢复 B，那么 A 自己就停掉自己\n\n- 场景二：A，B 同时停\n\n  该场景可能是由掉电等原因造成，只需在 30s 之内连续启动 A 和 B 即可恢复镜像队列\n\n- 场景三：A 先停，B 后停，且 A 无法恢复\n\n  因为 B 是 master，所以等 B 起来后，在 B 节点上调用 rabbitmqctl forget_cluster_node A 以解除 A 的 cluster 关系，再将新的 slave 节点加入 B 即可重新恢复镜像队列\n\n- 场景四：A 先停，B 后停，且 B 无法恢复\n\n  此时 B 是 master，所以直接启动 A 是不行的，当 A 无法启动时，也就没办法在 A 节点上调用 rabbitmqctl forget_cluster_node B。新版本中，forget_cluster_node 支持 --offline 参数，offline 参数允许 rabbitmqctl 在离线节点上执行 forget_cluster_node 命令，迫使 RabbitMQ 在未启动的 slave 节点中选择一个作为 master。当在 A 节点执行 rabbitmqctl forget_cluster_node --offline B 时，RabbitMQ 会 mock 一个节点代表 A，执行 forget_cluster_node 命令将 B 剔出 cluster，然后 A 就能正常启动了。最后将新的 slave 节点加入 A 即可重新恢复镜像队列\n\n- 场景五：A 先停，B 后停，且 A 和 B 均无法恢复，但是能得到 A 或 B 的磁盘文件\n\n  这个场景更加难以处理。将A或B的数据库文件（$RabbitMQ_HOME/var/lib目录中）copy至新节点C的目录下，再将 C 的 hostname 改成 A 或者 B 的 hostname。如果 copy 过来的是 A 节点磁盘文件，按场景四处理，如果拷贝过来的是 B 节点的磁盘文件，按场景三处理。最后将新的 slave 节点加入 C 即可重新恢复镜像队列\n\n- 场景六：A 先停，B 后停，且 A 和 B 均无法恢复，且无法得到 A 和 B 的磁盘文件\n\n  跑路吧\n\n---\n\n参考：\n\n[RabbitMQ分布式集群架构和高可用性（HA）](http://chyufly.github.io/blog/2016/04/10/rabbitmq-cluster/)\n\n[rabbitmq——镜像队列](https://my.oschina.net/hncscwc/blog/186350)\n\n[RabbitMQ源码分析 - 队列机制](http://jzhihui.iteye.com/blog/1582294)\n\n[RabbitMQ系列三 （深入消息队列）](http://backend.blog.163.com/blog/static/202294126201322511327882/)\n\n[RabbitMQ镜像队列的故障恢复](http://fengchj.com/?p=2273)\n\n\n","source":"_posts/【MQ】镜像队列.md","raw":"---\ntitle: 【MQ】镜像队列\ndate: 2017-12-08 21:57:51\ntags: MQ\ncategories: MQ\n---\n\n前面提到持久化和消息确认可以确保消息的可靠，但在默认情况下 MQ 的可靠性完全没有保障，通过集群的方式确保服务的可靠往往是高可用的第一步。本文记录一下 Rabbit MQ 的集群和镜像。\n\n## 集群\n\n集群能够带来的好处主要有两点：\n\n1. 允许消费者和生产者在 Rabbit MQ 节点崩溃的情况下继续运行\n2. 通过添加更多节点线性的扩展消息通信吞吐量\n\n### 模式\n\n在介绍集群之前先看看从单节点到集群的模式异同：\n\n- 相同：任何模式下节点内部都需要维护基本元数据信息：队列元数据、交换器元数据、绑定元数据、vhost 元数据。不同模式\n\n- 差异：\n\n  - 单一节点模式：\n\n    默认基本元数据信息存储在内存，被标记持久化的队列和交换器已经它们的绑定存储到磁盘\n\n  - 普通集群模式\n\n    ![cluster.PNG](https://i.loli.net/2017/08/23/599ce92322b59.png)\n\n    ![cluster.PNG](https://i.loli.net/2017/08/23/599ce7656d746.png)\n\n    除了基本元数据，还有集群相关元数据。与单一节点模式的不同主要在集群对队列，交换器，数据存储的差异。\n\n    队列：只会在单个节点而不是所有节点上创建完整队列信息，其余节点只保存队列的元数据。虽然只在一个节点保存完整队列，但消息可以在不同节点之间临时传输（消费者感知到每个节点都有完整的队列）。如果保存队列的单个节点挂了，则消费者对其订阅丢失，即将投递到该队列的信息消息也丢失。如果挂掉的队列是持久化队列则无法重新创建队列，必须恢复该队列\n\n    交换器：交换器实质是一张查询表（消息的转发路由是由信道完成），集群内所有的节点拥有所有交换器的信息\n\n    数据存储：分为内存节点和硬盘节点，硬盘节点防止重启后元数据信息丢失。元数据的创建更新在集群所有节点操作完成后才返回。集群下要求任何时刻集群中至少有一个磁盘节点，如果唯一的磁盘节点挂了，集群只能路由消息但不能创建更新元数据\n\n  - 镜像队列\n\n    ![image_queues.PNG](https://i.loli.net/2017/08/23/599ce8d6ae6a3.png)\n\n    镜像不在单独存在在唯一节点，而是冗余在多个节点\n\n## 镜像队列\n\n因为普通集群模式相对基础，而镜像队列复杂，这里重点讨论一下镜像队列。\n\n### 概述\n\n队列镜像通常包括一个 master 节点和多个 slave 节点，每个节点都复制队列数据。当一个节点失效时，可以自动切换到另一个节点确保可用。在镜像队列模式下，除了 publish 外的所有动作都只会向 master 发送，然后 master 将命令执行的结果广播为所有 slave，publish 到镜像的所有消息总是被直接 publish 到所有 slave 之上（类似与 fanout 交换器）。\n\n### 原理\n\n#### 普通队列结构\n\n普通队列由两部分组成：\n\n- AMQQueue：主要负责 AMQP 协议的逻辑功能\n- BackingQueue：存储消息\n\n对于 BackingQueue 又由五个子队列组成：Q1, Q1, Delta, Q3, Q4，MQ 的消息进入队列后会随着系统负载在队列中流动，BackingQueue 中的消息可以分为四个状态：\n\n- Alpha：消息的内容和索引都在内存中，Q1 和 Q4 的状态\n- Beta：消息的内容在硬盘，消息的索引在内存，Q2 和 Q3 的状态\n- Gamma：消息内容在硬盘，消息的索引在硬盘和内存都有，Q2 和 Q3 的状态\n- Delta：消息的内容和消息的索引都在硬盘上，Delta 状态\n\n对于持久化的消息，消息内容和消息索引都必须先保存到磁盘上，才会处于上述状态中的一种，而Gamma状态的消息只有持久化的消息才会有该状态。\n\n从 Q1 到 Q4，基本的经历是由内存到硬盘再到内存的设计，分层的好处使得整个队列有很好的弹性:\n\n- 当队列负载很高的情况下，能够通过将一部分消息由磁盘保存来节省内存空间\n- 当负载降低的时候，这部分消息又渐渐回到内存，被消费者获取\n\n引起消息流动的两种情况：消费者获取消息，内存不足\n\n当系统处于正常负载，对消息的消费速度不小于接收速度，对于非消息极可能只会有 Alpha 状态。对于持久化消息一定会进入 gamma 状态。如果开启 confirm 机制，只有到了这个阶段才会确认消息已经被接受，当消费足够快且内存充足消息不会继续走到下一状态。\n\n当系统处于高负载，已接受的消息不能很快被消费，这些消息就会进入很深的队列中去，增加处理每个消息的平均开销。因为平均开销增加，处理速度更慢，由此恶性循环，使得系统的处理能力大大降低。\n\n改善措施：\n\n1. 进行流程控制\n2. 增加 prefetch 的值，一次发送更多消息给消费者\n3. 采用 multiple ack\n\n#### 镜像队列结构\n\n在镜像队列中 AMQQueue 仍旧负责 AMQP 协议的逻辑功能，而 backing_queue 已不是简单的单节点 backing_queue 了。\n\nbacking_queue 是由 master 和 slave 节点组成的特殊 backing_queue，所有对 mirror_queue_master 的操作，会通过 GM 同步到 slave 节点，slave 节点上 mirror_queue_slave 负责回调，master 节点上 coordinato 负责回调。\n\n镜像队列对消息的操作：\n\n- basic.publish 操作：操作直接同步到所有节点\n- 其他操作：通过 master 操作，由 master 将结果给 slave\n\n##### GM\n\nGM(Guarenteed Multicast)，实现可靠组播通讯协议的模块，确保组播消息的原子性：\n\n- 将所有节点形成一个收尾相连的循环链表\n- 当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上\n- 当有节点失效时，相邻的节点会接管保证本次广播的消息会复制到所有节点\n- 消息从master节点对应的gm发出后，顺着链表依次传送到所有节点\n\n### 镜像队列细节备忘\n\n镜像队列细节太多，这里整理网上一个注意事项：\n\n1. 镜像队列不能作为负载均衡使用，因为每个操作在所有节点都要做一遍\n\n2. ha-mode 参数与 durable, declare 对 exclusive 队列都不生效。exclusive队列是连接独占的，当连接断开，队列自动删除，这两个参数对exclusive队列没有意义\n\n3. 将新节点加入已存在的镜像队列时，默认情况下 ha-sync-mode=manual，镜像队列中的消息不会主动同步到新节点，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行操作，直到同步完毕。当 ha-sync-mode=automatic 时，新加入节点时会默认同步已知的镜像队列。由于同步过程的限制，所以不建议在生产环境的active队列(有生产消费消息)中操作\n\n4. 每当一个节点加入或者重新加入(例如从网络分区中恢复回来)镜像队列，之前保存的队列内容会被清空\n\n5. 镜像队列有主从之分，一个主节点(master)，0个或多个从节点(slave)。当 master 宕掉后，会在 slave中 选举新的master。选举算法为最早启动的节点\n\n6. 当所有slave都处在(与master)未同步状态时，并且 ha-promote-on-shutdown policy 设置为 when-syned(默认) 时，如果 master 因为主动的原因停掉，比如是通过 rabbitmqctl stop 命令停止或者优雅关闭 OS，那么slave不会接管 master，也就是说此时镜像队列不可用\n\n   但是如果master因为被动原因停掉，比如 VM 或者 OS crash了，那么 slave 会接管 master。这个配置项隐含的价值取向是优先保证消息可靠不丢失，放弃可用性。\n\n   如果 ha-promote-on-shutdown policy 设置为 alway，那么不论 master 因为何种原因停止，slave 都会接管 master，优先保证可用性\n\n7. 镜像队列中最后一个停止的节点会是 master，启动顺序必须是 master 先起，如果 slave 先起，它会有 30 秒的等待时间，等待 master 启动，然后加入 cluster。\n\n   当所有节点因故(断电等)同时离线时，每个节点都认为自己不是最后一个停止的节点。要恢复镜像队列，可以尝试在 30 秒之内同时启动所有节点\n\n8. 对于镜像队列，客户端basic.publish操作会同步到所有节点；而其他操作则是通过master中转，再由master将操作作用于salve。比如一个basic.get操作，假如客户端与slave建立了TCP连接，首先是slave将basic.get请求发送至master，由master备好数据，返回至slave，投递给消费者\n\n9. 当 slave 宕掉时，除了与 slave 相连的客户端连接全部断开之外，没有其他影响。\n\n   当 master 宕掉时，会有以下连锁反应：\n\n   1. 与 master 相连的客户端连接全部断开。\n   2. 选举最老的 slave 为 master。若此时所有 slave 处于未同步状态，则未同步部分消息丢失。\n   3. 新的 master 节点 requeue 所有 unack 消息，因为这个新节点无法区分这些 unack 消息是否已经到达客户端，亦或是 ack 消息丢失在到老master的通路上，亦或是丢在老 master 组播 ack 消息到所有 slave 的通路上。所以处于消息可靠性的考虑，requeue 所有 unack 的消息。此时客户端可能受到重复消息。\n   4. 如果客户端连着 slave，并且 basic.consume 消息时指定了x-cancel-on-ha-failover参数，那么客户端会收到一个 Consumer Cancellation Notification 通知，Java SDK中会回调 Consumer 接口的handleCancel() 方法，故需覆盖此方法。如果不指定 x-cancel-on-ha-failover 参数，那么消费者就无法感知 master 宕机，会一直等待下去\n\n### 镜像队列的恢复\n\n前提：两个节点 A 和 B 组成以镜像队列\n\n- 场景一：A 先停，B 后停\n\n  该场景下 B 是 master，只要先启动 B，再启动 A 即可。或者先启动 A，再在 30s 之内启动 B 即可恢复镜像队列。如果没有在 30s 内恢复 B，那么 A 自己就停掉自己\n\n- 场景二：A，B 同时停\n\n  该场景可能是由掉电等原因造成，只需在 30s 之内连续启动 A 和 B 即可恢复镜像队列\n\n- 场景三：A 先停，B 后停，且 A 无法恢复\n\n  因为 B 是 master，所以等 B 起来后，在 B 节点上调用 rabbitmqctl forget_cluster_node A 以解除 A 的 cluster 关系，再将新的 slave 节点加入 B 即可重新恢复镜像队列\n\n- 场景四：A 先停，B 后停，且 B 无法恢复\n\n  此时 B 是 master，所以直接启动 A 是不行的，当 A 无法启动时，也就没办法在 A 节点上调用 rabbitmqctl forget_cluster_node B。新版本中，forget_cluster_node 支持 --offline 参数，offline 参数允许 rabbitmqctl 在离线节点上执行 forget_cluster_node 命令，迫使 RabbitMQ 在未启动的 slave 节点中选择一个作为 master。当在 A 节点执行 rabbitmqctl forget_cluster_node --offline B 时，RabbitMQ 会 mock 一个节点代表 A，执行 forget_cluster_node 命令将 B 剔出 cluster，然后 A 就能正常启动了。最后将新的 slave 节点加入 A 即可重新恢复镜像队列\n\n- 场景五：A 先停，B 后停，且 A 和 B 均无法恢复，但是能得到 A 或 B 的磁盘文件\n\n  这个场景更加难以处理。将A或B的数据库文件（$RabbitMQ_HOME/var/lib目录中）copy至新节点C的目录下，再将 C 的 hostname 改成 A 或者 B 的 hostname。如果 copy 过来的是 A 节点磁盘文件，按场景四处理，如果拷贝过来的是 B 节点的磁盘文件，按场景三处理。最后将新的 slave 节点加入 C 即可重新恢复镜像队列\n\n- 场景六：A 先停，B 后停，且 A 和 B 均无法恢复，且无法得到 A 和 B 的磁盘文件\n\n  跑路吧\n\n---\n\n参考：\n\n[RabbitMQ分布式集群架构和高可用性（HA）](http://chyufly.github.io/blog/2016/04/10/rabbitmq-cluster/)\n\n[rabbitmq——镜像队列](https://my.oschina.net/hncscwc/blog/186350)\n\n[RabbitMQ源码分析 - 队列机制](http://jzhihui.iteye.com/blog/1582294)\n\n[RabbitMQ系列三 （深入消息队列）](http://backend.blog.163.com/blog/static/202294126201322511327882/)\n\n[RabbitMQ镜像队列的故障恢复](http://fengchj.com/?p=2273)\n\n\n","slug":"【MQ】镜像队列","published":1,"updated":"2017-12-08T13:59:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2qw002pd82eenk4ocs5","content":"<p>前面提到持久化和消息确认可以确保消息的可靠，但在默认情况下 MQ 的可靠性完全没有保障，通过集群的方式确保服务的可靠往往是高可用的第一步。本文记录一下 Rabbit MQ 的集群和镜像。</p>\n<h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><p>集群能够带来的好处主要有两点：</p>\n<ol>\n<li>允许消费者和生产者在 Rabbit MQ 节点崩溃的情况下继续运行</li>\n<li>通过添加更多节点线性的扩展消息通信吞吐量</li>\n</ol>\n<h3 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h3><p>在介绍集群之前先看看从单节点到集群的模式异同：</p>\n<ul>\n<li><p>相同：任何模式下节点内部都需要维护基本元数据信息：队列元数据、交换器元数据、绑定元数据、vhost 元数据。不同模式</p>\n</li>\n<li><p>差异：</p>\n<ul>\n<li><p>单一节点模式：</p>\n<p>默认基本元数据信息存储在内存，被标记持久化的队列和交换器已经它们的绑定存储到磁盘</p>\n</li>\n<li><p>普通集群模式</p>\n<p><img src=\"https://i.loli.net/2017/08/23/599ce92322b59.png\" alt=\"cluster.PNG\"></p>\n<p><img src=\"https://i.loli.net/2017/08/23/599ce7656d746.png\" alt=\"cluster.PNG\"></p>\n<p>除了基本元数据，还有集群相关元数据。与单一节点模式的不同主要在集群对队列，交换器，数据存储的差异。</p>\n<p>队列：只会在单个节点而不是所有节点上创建完整队列信息，其余节点只保存队列的元数据。虽然只在一个节点保存完整队列，但消息可以在不同节点之间临时传输（消费者感知到每个节点都有完整的队列）。如果保存队列的单个节点挂了，则消费者对其订阅丢失，即将投递到该队列的信息消息也丢失。如果挂掉的队列是持久化队列则无法重新创建队列，必须恢复该队列</p>\n<p>交换器：交换器实质是一张查询表（消息的转发路由是由信道完成），集群内所有的节点拥有所有交换器的信息</p>\n<p>数据存储：分为内存节点和硬盘节点，硬盘节点防止重启后元数据信息丢失。元数据的创建更新在集群所有节点操作完成后才返回。集群下要求任何时刻集群中至少有一个磁盘节点，如果唯一的磁盘节点挂了，集群只能路由消息但不能创建更新元数据</p>\n</li>\n<li><p>镜像队列</p>\n<p><img src=\"https://i.loli.net/2017/08/23/599ce8d6ae6a3.png\" alt=\"image_queues.PNG\"></p>\n<p>镜像不在单独存在在唯一节点，而是冗余在多个节点</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"镜像队列\"><a href=\"#镜像队列\" class=\"headerlink\" title=\"镜像队列\"></a>镜像队列</h2><p>因为普通集群模式相对基础，而镜像队列复杂，这里重点讨论一下镜像队列。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>队列镜像通常包括一个 master 节点和多个 slave 节点，每个节点都复制队列数据。当一个节点失效时，可以自动切换到另一个节点确保可用。在镜像队列模式下，除了 publish 外的所有动作都只会向 master 发送，然后 master 将命令执行的结果广播为所有 slave，publish 到镜像的所有消息总是被直接 publish 到所有 slave 之上（类似与 fanout 交换器）。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><h4 id=\"普通队列结构\"><a href=\"#普通队列结构\" class=\"headerlink\" title=\"普通队列结构\"></a>普通队列结构</h4><p>普通队列由两部分组成：</p>\n<ul>\n<li>AMQQueue：主要负责 AMQP 协议的逻辑功能</li>\n<li>BackingQueue：存储消息</li>\n</ul>\n<p>对于 BackingQueue 又由五个子队列组成：Q1, Q1, Delta, Q3, Q4，MQ 的消息进入队列后会随着系统负载在队列中流动，BackingQueue 中的消息可以分为四个状态：</p>\n<ul>\n<li>Alpha：消息的内容和索引都在内存中，Q1 和 Q4 的状态</li>\n<li>Beta：消息的内容在硬盘，消息的索引在内存，Q2 和 Q3 的状态</li>\n<li>Gamma：消息内容在硬盘，消息的索引在硬盘和内存都有，Q2 和 Q3 的状态</li>\n<li>Delta：消息的内容和消息的索引都在硬盘上，Delta 状态</li>\n</ul>\n<p>对于持久化的消息，消息内容和消息索引都必须先保存到磁盘上，才会处于上述状态中的一种，而Gamma状态的消息只有持久化的消息才会有该状态。</p>\n<p>从 Q1 到 Q4，基本的经历是由内存到硬盘再到内存的设计，分层的好处使得整个队列有很好的弹性:</p>\n<ul>\n<li>当队列负载很高的情况下，能够通过将一部分消息由磁盘保存来节省内存空间</li>\n<li>当负载降低的时候，这部分消息又渐渐回到内存，被消费者获取</li>\n</ul>\n<p>引起消息流动的两种情况：消费者获取消息，内存不足</p>\n<p>当系统处于正常负载，对消息的消费速度不小于接收速度，对于非消息极可能只会有 Alpha 状态。对于持久化消息一定会进入 gamma 状态。如果开启 confirm 机制，只有到了这个阶段才会确认消息已经被接受，当消费足够快且内存充足消息不会继续走到下一状态。</p>\n<p>当系统处于高负载，已接受的消息不能很快被消费，这些消息就会进入很深的队列中去，增加处理每个消息的平均开销。因为平均开销增加，处理速度更慢，由此恶性循环，使得系统的处理能力大大降低。</p>\n<p>改善措施：</p>\n<ol>\n<li>进行流程控制</li>\n<li>增加 prefetch 的值，一次发送更多消息给消费者</li>\n<li>采用 multiple ack</li>\n</ol>\n<h4 id=\"镜像队列结构\"><a href=\"#镜像队列结构\" class=\"headerlink\" title=\"镜像队列结构\"></a>镜像队列结构</h4><p>在镜像队列中 AMQQueue 仍旧负责 AMQP 协议的逻辑功能，而 backing_queue 已不是简单的单节点 backing_queue 了。</p>\n<p>backing_queue 是由 master 和 slave 节点组成的特殊 backing_queue，所有对 mirror_queue_master 的操作，会通过 GM 同步到 slave 节点，slave 节点上 mirror_queue_slave 负责回调，master 节点上 coordinato 负责回调。</p>\n<p>镜像队列对消息的操作：</p>\n<ul>\n<li>basic.publish 操作：操作直接同步到所有节点</li>\n<li>其他操作：通过 master 操作，由 master 将结果给 slave</li>\n</ul>\n<h5 id=\"GM\"><a href=\"#GM\" class=\"headerlink\" title=\"GM\"></a>GM</h5><p>GM(Guarenteed Multicast)，实现可靠组播通讯协议的模块，确保组播消息的原子性：</p>\n<ul>\n<li>将所有节点形成一个收尾相连的循环链表</li>\n<li>当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上</li>\n<li>当有节点失效时，相邻的节点会接管保证本次广播的消息会复制到所有节点</li>\n<li>消息从master节点对应的gm发出后，顺着链表依次传送到所有节点</li>\n</ul>\n<h3 id=\"镜像队列细节备忘\"><a href=\"#镜像队列细节备忘\" class=\"headerlink\" title=\"镜像队列细节备忘\"></a>镜像队列细节备忘</h3><p>镜像队列细节太多，这里整理网上一个注意事项：</p>\n<ol>\n<li><p>镜像队列不能作为负载均衡使用，因为每个操作在所有节点都要做一遍</p>\n</li>\n<li><p>ha-mode 参数与 durable, declare 对 exclusive 队列都不生效。exclusive队列是连接独占的，当连接断开，队列自动删除，这两个参数对exclusive队列没有意义</p>\n</li>\n<li><p>将新节点加入已存在的镜像队列时，默认情况下 ha-sync-mode=manual，镜像队列中的消息不会主动同步到新节点，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行操作，直到同步完毕。当 ha-sync-mode=automatic 时，新加入节点时会默认同步已知的镜像队列。由于同步过程的限制，所以不建议在生产环境的active队列(有生产消费消息)中操作</p>\n</li>\n<li><p>每当一个节点加入或者重新加入(例如从网络分区中恢复回来)镜像队列，之前保存的队列内容会被清空</p>\n</li>\n<li><p>镜像队列有主从之分，一个主节点(master)，0个或多个从节点(slave)。当 master 宕掉后，会在 slave中 选举新的master。选举算法为最早启动的节点</p>\n</li>\n<li><p>当所有slave都处在(与master)未同步状态时，并且 ha-promote-on-shutdown policy 设置为 when-syned(默认) 时，如果 master 因为主动的原因停掉，比如是通过 rabbitmqctl stop 命令停止或者优雅关闭 OS，那么slave不会接管 master，也就是说此时镜像队列不可用</p>\n<p>但是如果master因为被动原因停掉，比如 VM 或者 OS crash了，那么 slave 会接管 master。这个配置项隐含的价值取向是优先保证消息可靠不丢失，放弃可用性。</p>\n<p>如果 ha-promote-on-shutdown policy 设置为 alway，那么不论 master 因为何种原因停止，slave 都会接管 master，优先保证可用性</p>\n</li>\n<li><p>镜像队列中最后一个停止的节点会是 master，启动顺序必须是 master 先起，如果 slave 先起，它会有 30 秒的等待时间，等待 master 启动，然后加入 cluster。</p>\n<p>当所有节点因故(断电等)同时离线时，每个节点都认为自己不是最后一个停止的节点。要恢复镜像队列，可以尝试在 30 秒之内同时启动所有节点</p>\n</li>\n<li><p>对于镜像队列，客户端basic.publish操作会同步到所有节点；而其他操作则是通过master中转，再由master将操作作用于salve。比如一个basic.get操作，假如客户端与slave建立了TCP连接，首先是slave将basic.get请求发送至master，由master备好数据，返回至slave，投递给消费者</p>\n</li>\n<li><p>当 slave 宕掉时，除了与 slave 相连的客户端连接全部断开之外，没有其他影响。</p>\n<p>当 master 宕掉时，会有以下连锁反应：</p>\n<ol>\n<li>与 master 相连的客户端连接全部断开。</li>\n<li>选举最老的 slave 为 master。若此时所有 slave 处于未同步状态，则未同步部分消息丢失。</li>\n<li>新的 master 节点 requeue 所有 unack 消息，因为这个新节点无法区分这些 unack 消息是否已经到达客户端，亦或是 ack 消息丢失在到老master的通路上，亦或是丢在老 master 组播 ack 消息到所有 slave 的通路上。所以处于消息可靠性的考虑，requeue 所有 unack 的消息。此时客户端可能受到重复消息。</li>\n<li>如果客户端连着 slave，并且 basic.consume 消息时指定了x-cancel-on-ha-failover参数，那么客户端会收到一个 Consumer Cancellation Notification 通知，Java SDK中会回调 Consumer 接口的handleCancel() 方法，故需覆盖此方法。如果不指定 x-cancel-on-ha-failover 参数，那么消费者就无法感知 master 宕机，会一直等待下去</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"镜像队列的恢复\"><a href=\"#镜像队列的恢复\" class=\"headerlink\" title=\"镜像队列的恢复\"></a>镜像队列的恢复</h3><p>前提：两个节点 A 和 B 组成以镜像队列</p>\n<ul>\n<li><p>场景一：A 先停，B 后停</p>\n<p>该场景下 B 是 master，只要先启动 B，再启动 A 即可。或者先启动 A，再在 30s 之内启动 B 即可恢复镜像队列。如果没有在 30s 内恢复 B，那么 A 自己就停掉自己</p>\n</li>\n<li><p>场景二：A，B 同时停</p>\n<p>该场景可能是由掉电等原因造成，只需在 30s 之内连续启动 A 和 B 即可恢复镜像队列</p>\n</li>\n<li><p>场景三：A 先停，B 后停，且 A 无法恢复</p>\n<p>因为 B 是 master，所以等 B 起来后，在 B 节点上调用 rabbitmqctl forget_cluster_node A 以解除 A 的 cluster 关系，再将新的 slave 节点加入 B 即可重新恢复镜像队列</p>\n</li>\n<li><p>场景四：A 先停，B 后停，且 B 无法恢复</p>\n<p>此时 B 是 master，所以直接启动 A 是不行的，当 A 无法启动时，也就没办法在 A 节点上调用 rabbitmqctl forget_cluster_node B。新版本中，forget_cluster_node 支持 –offline 参数，offline 参数允许 rabbitmqctl 在离线节点上执行 forget_cluster_node 命令，迫使 RabbitMQ 在未启动的 slave 节点中选择一个作为 master。当在 A 节点执行 rabbitmqctl forget_cluster_node –offline B 时，RabbitMQ 会 mock 一个节点代表 A，执行 forget_cluster_node 命令将 B 剔出 cluster，然后 A 就能正常启动了。最后将新的 slave 节点加入 A 即可重新恢复镜像队列</p>\n</li>\n<li><p>场景五：A 先停，B 后停，且 A 和 B 均无法恢复，但是能得到 A 或 B 的磁盘文件</p>\n<p>这个场景更加难以处理。将A或B的数据库文件（$RabbitMQ_HOME/var/lib目录中）copy至新节点C的目录下，再将 C 的 hostname 改成 A 或者 B 的 hostname。如果 copy 过来的是 A 节点磁盘文件，按场景四处理，如果拷贝过来的是 B 节点的磁盘文件，按场景三处理。最后将新的 slave 节点加入 C 即可重新恢复镜像队列</p>\n</li>\n<li><p>场景六：A 先停，B 后停，且 A 和 B 均无法恢复，且无法得到 A 和 B 的磁盘文件</p>\n<p>跑路吧</p>\n</li>\n</ul>\n<hr>\n<p>参考：</p>\n<p><a href=\"http://chyufly.github.io/blog/2016/04/10/rabbitmq-cluster/\" target=\"_blank\" rel=\"external\">RabbitMQ分布式集群架构和高可用性（HA）</a></p>\n<p><a href=\"https://my.oschina.net/hncscwc/blog/186350\" target=\"_blank\" rel=\"external\">rabbitmq——镜像队列</a></p>\n<p><a href=\"http://jzhihui.iteye.com/blog/1582294\" target=\"_blank\" rel=\"external\">RabbitMQ源码分析 - 队列机制</a></p>\n<p><a href=\"http://backend.blog.163.com/blog/static/202294126201322511327882/\" target=\"_blank\" rel=\"external\">RabbitMQ系列三 （深入消息队列）</a></p>\n<p><a href=\"http://fengchj.com/?p=2273\" target=\"_blank\" rel=\"external\">RabbitMQ镜像队列的故障恢复</a></p>\n","excerpt":"","more":"<p>前面提到持久化和消息确认可以确保消息的可靠，但在默认情况下 MQ 的可靠性完全没有保障，通过集群的方式确保服务的可靠往往是高可用的第一步。本文记录一下 Rabbit MQ 的集群和镜像。</p>\n<h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><p>集群能够带来的好处主要有两点：</p>\n<ol>\n<li>允许消费者和生产者在 Rabbit MQ 节点崩溃的情况下继续运行</li>\n<li>通过添加更多节点线性的扩展消息通信吞吐量</li>\n</ol>\n<h3 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h3><p>在介绍集群之前先看看从单节点到集群的模式异同：</p>\n<ul>\n<li><p>相同：任何模式下节点内部都需要维护基本元数据信息：队列元数据、交换器元数据、绑定元数据、vhost 元数据。不同模式</p>\n</li>\n<li><p>差异：</p>\n<ul>\n<li><p>单一节点模式：</p>\n<p>默认基本元数据信息存储在内存，被标记持久化的队列和交换器已经它们的绑定存储到磁盘</p>\n</li>\n<li><p>普通集群模式</p>\n<p><img src=\"https://i.loli.net/2017/08/23/599ce92322b59.png\" alt=\"cluster.PNG\"></p>\n<p><img src=\"https://i.loli.net/2017/08/23/599ce7656d746.png\" alt=\"cluster.PNG\"></p>\n<p>除了基本元数据，还有集群相关元数据。与单一节点模式的不同主要在集群对队列，交换器，数据存储的差异。</p>\n<p>队列：只会在单个节点而不是所有节点上创建完整队列信息，其余节点只保存队列的元数据。虽然只在一个节点保存完整队列，但消息可以在不同节点之间临时传输（消费者感知到每个节点都有完整的队列）。如果保存队列的单个节点挂了，则消费者对其订阅丢失，即将投递到该队列的信息消息也丢失。如果挂掉的队列是持久化队列则无法重新创建队列，必须恢复该队列</p>\n<p>交换器：交换器实质是一张查询表（消息的转发路由是由信道完成），集群内所有的节点拥有所有交换器的信息</p>\n<p>数据存储：分为内存节点和硬盘节点，硬盘节点防止重启后元数据信息丢失。元数据的创建更新在集群所有节点操作完成后才返回。集群下要求任何时刻集群中至少有一个磁盘节点，如果唯一的磁盘节点挂了，集群只能路由消息但不能创建更新元数据</p>\n</li>\n<li><p>镜像队列</p>\n<p><img src=\"https://i.loli.net/2017/08/23/599ce8d6ae6a3.png\" alt=\"image_queues.PNG\"></p>\n<p>镜像不在单独存在在唯一节点，而是冗余在多个节点</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"镜像队列\"><a href=\"#镜像队列\" class=\"headerlink\" title=\"镜像队列\"></a>镜像队列</h2><p>因为普通集群模式相对基础，而镜像队列复杂，这里重点讨论一下镜像队列。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>队列镜像通常包括一个 master 节点和多个 slave 节点，每个节点都复制队列数据。当一个节点失效时，可以自动切换到另一个节点确保可用。在镜像队列模式下，除了 publish 外的所有动作都只会向 master 发送，然后 master 将命令执行的结果广播为所有 slave，publish 到镜像的所有消息总是被直接 publish 到所有 slave 之上（类似与 fanout 交换器）。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><h4 id=\"普通队列结构\"><a href=\"#普通队列结构\" class=\"headerlink\" title=\"普通队列结构\"></a>普通队列结构</h4><p>普通队列由两部分组成：</p>\n<ul>\n<li>AMQQueue：主要负责 AMQP 协议的逻辑功能</li>\n<li>BackingQueue：存储消息</li>\n</ul>\n<p>对于 BackingQueue 又由五个子队列组成：Q1, Q1, Delta, Q3, Q4，MQ 的消息进入队列后会随着系统负载在队列中流动，BackingQueue 中的消息可以分为四个状态：</p>\n<ul>\n<li>Alpha：消息的内容和索引都在内存中，Q1 和 Q4 的状态</li>\n<li>Beta：消息的内容在硬盘，消息的索引在内存，Q2 和 Q3 的状态</li>\n<li>Gamma：消息内容在硬盘，消息的索引在硬盘和内存都有，Q2 和 Q3 的状态</li>\n<li>Delta：消息的内容和消息的索引都在硬盘上，Delta 状态</li>\n</ul>\n<p>对于持久化的消息，消息内容和消息索引都必须先保存到磁盘上，才会处于上述状态中的一种，而Gamma状态的消息只有持久化的消息才会有该状态。</p>\n<p>从 Q1 到 Q4，基本的经历是由内存到硬盘再到内存的设计，分层的好处使得整个队列有很好的弹性:</p>\n<ul>\n<li>当队列负载很高的情况下，能够通过将一部分消息由磁盘保存来节省内存空间</li>\n<li>当负载降低的时候，这部分消息又渐渐回到内存，被消费者获取</li>\n</ul>\n<p>引起消息流动的两种情况：消费者获取消息，内存不足</p>\n<p>当系统处于正常负载，对消息的消费速度不小于接收速度，对于非消息极可能只会有 Alpha 状态。对于持久化消息一定会进入 gamma 状态。如果开启 confirm 机制，只有到了这个阶段才会确认消息已经被接受，当消费足够快且内存充足消息不会继续走到下一状态。</p>\n<p>当系统处于高负载，已接受的消息不能很快被消费，这些消息就会进入很深的队列中去，增加处理每个消息的平均开销。因为平均开销增加，处理速度更慢，由此恶性循环，使得系统的处理能力大大降低。</p>\n<p>改善措施：</p>\n<ol>\n<li>进行流程控制</li>\n<li>增加 prefetch 的值，一次发送更多消息给消费者</li>\n<li>采用 multiple ack</li>\n</ol>\n<h4 id=\"镜像队列结构\"><a href=\"#镜像队列结构\" class=\"headerlink\" title=\"镜像队列结构\"></a>镜像队列结构</h4><p>在镜像队列中 AMQQueue 仍旧负责 AMQP 协议的逻辑功能，而 backing_queue 已不是简单的单节点 backing_queue 了。</p>\n<p>backing_queue 是由 master 和 slave 节点组成的特殊 backing_queue，所有对 mirror_queue_master 的操作，会通过 GM 同步到 slave 节点，slave 节点上 mirror_queue_slave 负责回调，master 节点上 coordinato 负责回调。</p>\n<p>镜像队列对消息的操作：</p>\n<ul>\n<li>basic.publish 操作：操作直接同步到所有节点</li>\n<li>其他操作：通过 master 操作，由 master 将结果给 slave</li>\n</ul>\n<h5 id=\"GM\"><a href=\"#GM\" class=\"headerlink\" title=\"GM\"></a>GM</h5><p>GM(Guarenteed Multicast)，实现可靠组播通讯协议的模块，确保组播消息的原子性：</p>\n<ul>\n<li>将所有节点形成一个收尾相连的循环链表</li>\n<li>当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上</li>\n<li>当有节点失效时，相邻的节点会接管保证本次广播的消息会复制到所有节点</li>\n<li>消息从master节点对应的gm发出后，顺着链表依次传送到所有节点</li>\n</ul>\n<h3 id=\"镜像队列细节备忘\"><a href=\"#镜像队列细节备忘\" class=\"headerlink\" title=\"镜像队列细节备忘\"></a>镜像队列细节备忘</h3><p>镜像队列细节太多，这里整理网上一个注意事项：</p>\n<ol>\n<li><p>镜像队列不能作为负载均衡使用，因为每个操作在所有节点都要做一遍</p>\n</li>\n<li><p>ha-mode 参数与 durable, declare 对 exclusive 队列都不生效。exclusive队列是连接独占的，当连接断开，队列自动删除，这两个参数对exclusive队列没有意义</p>\n</li>\n<li><p>将新节点加入已存在的镜像队列时，默认情况下 ha-sync-mode=manual，镜像队列中的消息不会主动同步到新节点，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行操作，直到同步完毕。当 ha-sync-mode=automatic 时，新加入节点时会默认同步已知的镜像队列。由于同步过程的限制，所以不建议在生产环境的active队列(有生产消费消息)中操作</p>\n</li>\n<li><p>每当一个节点加入或者重新加入(例如从网络分区中恢复回来)镜像队列，之前保存的队列内容会被清空</p>\n</li>\n<li><p>镜像队列有主从之分，一个主节点(master)，0个或多个从节点(slave)。当 master 宕掉后，会在 slave中 选举新的master。选举算法为最早启动的节点</p>\n</li>\n<li><p>当所有slave都处在(与master)未同步状态时，并且 ha-promote-on-shutdown policy 设置为 when-syned(默认) 时，如果 master 因为主动的原因停掉，比如是通过 rabbitmqctl stop 命令停止或者优雅关闭 OS，那么slave不会接管 master，也就是说此时镜像队列不可用</p>\n<p>但是如果master因为被动原因停掉，比如 VM 或者 OS crash了，那么 slave 会接管 master。这个配置项隐含的价值取向是优先保证消息可靠不丢失，放弃可用性。</p>\n<p>如果 ha-promote-on-shutdown policy 设置为 alway，那么不论 master 因为何种原因停止，slave 都会接管 master，优先保证可用性</p>\n</li>\n<li><p>镜像队列中最后一个停止的节点会是 master，启动顺序必须是 master 先起，如果 slave 先起，它会有 30 秒的等待时间，等待 master 启动，然后加入 cluster。</p>\n<p>当所有节点因故(断电等)同时离线时，每个节点都认为自己不是最后一个停止的节点。要恢复镜像队列，可以尝试在 30 秒之内同时启动所有节点</p>\n</li>\n<li><p>对于镜像队列，客户端basic.publish操作会同步到所有节点；而其他操作则是通过master中转，再由master将操作作用于salve。比如一个basic.get操作，假如客户端与slave建立了TCP连接，首先是slave将basic.get请求发送至master，由master备好数据，返回至slave，投递给消费者</p>\n</li>\n<li><p>当 slave 宕掉时，除了与 slave 相连的客户端连接全部断开之外，没有其他影响。</p>\n<p>当 master 宕掉时，会有以下连锁反应：</p>\n<ol>\n<li>与 master 相连的客户端连接全部断开。</li>\n<li>选举最老的 slave 为 master。若此时所有 slave 处于未同步状态，则未同步部分消息丢失。</li>\n<li>新的 master 节点 requeue 所有 unack 消息，因为这个新节点无法区分这些 unack 消息是否已经到达客户端，亦或是 ack 消息丢失在到老master的通路上，亦或是丢在老 master 组播 ack 消息到所有 slave 的通路上。所以处于消息可靠性的考虑，requeue 所有 unack 的消息。此时客户端可能受到重复消息。</li>\n<li>如果客户端连着 slave，并且 basic.consume 消息时指定了x-cancel-on-ha-failover参数，那么客户端会收到一个 Consumer Cancellation Notification 通知，Java SDK中会回调 Consumer 接口的handleCancel() 方法，故需覆盖此方法。如果不指定 x-cancel-on-ha-failover 参数，那么消费者就无法感知 master 宕机，会一直等待下去</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"镜像队列的恢复\"><a href=\"#镜像队列的恢复\" class=\"headerlink\" title=\"镜像队列的恢复\"></a>镜像队列的恢复</h3><p>前提：两个节点 A 和 B 组成以镜像队列</p>\n<ul>\n<li><p>场景一：A 先停，B 后停</p>\n<p>该场景下 B 是 master，只要先启动 B，再启动 A 即可。或者先启动 A，再在 30s 之内启动 B 即可恢复镜像队列。如果没有在 30s 内恢复 B，那么 A 自己就停掉自己</p>\n</li>\n<li><p>场景二：A，B 同时停</p>\n<p>该场景可能是由掉电等原因造成，只需在 30s 之内连续启动 A 和 B 即可恢复镜像队列</p>\n</li>\n<li><p>场景三：A 先停，B 后停，且 A 无法恢复</p>\n<p>因为 B 是 master，所以等 B 起来后，在 B 节点上调用 rabbitmqctl forget_cluster_node A 以解除 A 的 cluster 关系，再将新的 slave 节点加入 B 即可重新恢复镜像队列</p>\n</li>\n<li><p>场景四：A 先停，B 后停，且 B 无法恢复</p>\n<p>此时 B 是 master，所以直接启动 A 是不行的，当 A 无法启动时，也就没办法在 A 节点上调用 rabbitmqctl forget_cluster_node B。新版本中，forget_cluster_node 支持 –offline 参数，offline 参数允许 rabbitmqctl 在离线节点上执行 forget_cluster_node 命令，迫使 RabbitMQ 在未启动的 slave 节点中选择一个作为 master。当在 A 节点执行 rabbitmqctl forget_cluster_node –offline B 时，RabbitMQ 会 mock 一个节点代表 A，执行 forget_cluster_node 命令将 B 剔出 cluster，然后 A 就能正常启动了。最后将新的 slave 节点加入 A 即可重新恢复镜像队列</p>\n</li>\n<li><p>场景五：A 先停，B 后停，且 A 和 B 均无法恢复，但是能得到 A 或 B 的磁盘文件</p>\n<p>这个场景更加难以处理。将A或B的数据库文件（$RabbitMQ_HOME/var/lib目录中）copy至新节点C的目录下，再将 C 的 hostname 改成 A 或者 B 的 hostname。如果 copy 过来的是 A 节点磁盘文件，按场景四处理，如果拷贝过来的是 B 节点的磁盘文件，按场景三处理。最后将新的 slave 节点加入 C 即可重新恢复镜像队列</p>\n</li>\n<li><p>场景六：A 先停，B 后停，且 A 和 B 均无法恢复，且无法得到 A 和 B 的磁盘文件</p>\n<p>跑路吧</p>\n</li>\n</ul>\n<hr>\n<p>参考：</p>\n<p><a href=\"http://chyufly.github.io/blog/2016/04/10/rabbitmq-cluster/\">RabbitMQ分布式集群架构和高可用性（HA）</a></p>\n<p><a href=\"https://my.oschina.net/hncscwc/blog/186350\">rabbitmq——镜像队列</a></p>\n<p><a href=\"http://jzhihui.iteye.com/blog/1582294\">RabbitMQ源码分析 - 队列机制</a></p>\n<p><a href=\"http://backend.blog.163.com/blog/static/202294126201322511327882/\">RabbitMQ系列三 （深入消息队列）</a></p>\n<p><a href=\"http://fengchj.com/?p=2273\">RabbitMQ镜像队列的故障恢复</a></p>\n"},{"title":"【SpringBoot】容器启动","date":"2017-07-10T12:24:11.000Z","_content":"Spring Boot 的启动前面说到了：\n\n- 包文件启动：从`JarLauncher`的`main`方法启动，加载各种资源后，开启一个新的线程调用程序的`main`方法\n- `SpringApplication`实例创建：判断是否是web环境，加载并实例化初始化器和监听器，查找`main`方法所在类\n- 启动监听器：创建`SpringApplicationRunListeners`实例统一管理监听器。在启动过程中调用不同容器生命周期通知，创建不同的事件类型，由`ApplicationEventMulticaster`广播对应事件给`ApplicationListener`\n\n前面做了各种准备工作就是为了最后的容器提供服务，本文以注释的形式记录一下 Spring Boot 容器的启动过程：\n\n```java\n\tpublic ConfigurableApplicationContext run(String... args) {\n\t\t// ...\n\t\ttry {\n          \t// 封装应用启动参数\n\t\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n\t\t\t// 准备环境\n          \tConfigurableEnvironment environment = prepareEnvironment(listeners,\n\t\t\t\t\tapplicationArguments);\n\t\t\tBanner printedBanner = printBanner(environment);\n          \t// 创建容器\n\t\t\tcontext = createApplicationContext();\n\t\t\tanalyzers = new FailureAnalyzers(context);\n          \t// 准备容器\n\t\t\tprepareContext(context, environment, listeners, applicationArguments,\n\t\t\t\t\tprintedBanner);\n          \t// 刷新容器\n\t\t\trefreshContext(context);\n          \t// 运行runner\n\t\t\tafterRefresh(context, applicationArguments);\n\t\t\tlisteners.finished(context, null);\n\t\t\tstopWatch.stop();\n\t\t\tif (this.logStartupInfo) {\n\t\t\t\tnew StartupInfoLogger(this.mainApplicationClass)\n\t\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);\n\t\t\t}\n\t\t\treturn context;\n\t\t}\n\t\tcatch (Throwable ex) {\n          \t// ...\n\t\t}\n\t}\n```\n\n## 准备环境\n\n```java\n\tprivate ConfigurableEnvironment prepareEnvironment(\n\t\t\tSpringApplicationRunListeners listeners,\n\t\t\tApplicationArguments applicationArguments) {\n      \t// 创建环境\n\t\tConfigurableEnvironment environment = getOrCreateEnvironment();\n      \t// 配置环境\n\t\tconfigureEnvironment(environment, applicationArguments.getSourceArgs());\n      \t// 监听器通知事件\n\t\tlisteners.environmentPrepared(environment);\n      \t// 处理非web环境\n\t\tif (isWebEnvironment(environment) && !this.webEnvironment) {\n\t\t\tenvironment = convertToStandardEnvironment(environment);\n\t\t}\n\t\treturn environment;\n\t}\n\n\tprivate ConfigurableEnvironment getOrCreateEnvironment() {\n\t\tif (this.environment != null) {\n\t\t\treturn this.environment;\n\t\t}\n\t\tif (this.webEnvironment) {\n\t\t\treturn new StandardServletEnvironment();\n\t\t}\n\t\treturn new StandardEnvironment();\n\t}\n\n\tprotected void configureEnvironment(ConfigurableEnvironment environment,\n\t\t\tString[] args) {\n      \t// 配置property\n\t\tconfigurePropertySources(environment, args);\n        // 配置profiles\n\t\tconfigureProfiles(environment, args);\n\t}\n\n\tpublic static final String COMMAND_LINE_PROPERTY_SOURCE_NAME = \"commandLineArgs\";\n\n\tprotected void configurePropertySources(ConfigurableEnvironment environment,\n\t\t\tString[] args) {\n\t\tMutablePropertySources sources = environment.getPropertySources();\n      \t// 判断defaultProperties是否为空\n\t\tif (this.defaultProperties != null && !this.defaultProperties.isEmpty()) {\n          \t// MutablePropertySources内部维护一个list<PropertySource<?>>集合\n          \t// addLast先removeIfPresent()然后把defaultProperties加到最后\n\t\t\tsources.addLast(\n\t\t\t\t\tnew MapPropertySource(\"defaultProperties\", this.defaultProperties));\n\t\t}\n      \t// 判断addCommandLineProperties ==true 和 args的长度\n\t\tif (this.addCommandLineProperties && args.length > 0) {\n          \t// name=commandLineArgs\n\t\t\tString name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;\n\t\t\tif (sources.contains(name)) {\n              \t// 如果列表中包含，替换\n\t\t\t\tPropertySource<?> source = sources.get(name);\n\t\t\t\tCompositePropertySource composite = new CompositePropertySource(name);\n\t\t\t\tcomposite.addPropertySource(new SimpleCommandLinePropertySource(\n\t\t\t\t\t\tname + \"-\" + args.hashCode(), args));\n\t\t\t\tcomposite.addPropertySource(source);\n\t\t\t\tsources.replace(name, composite);\n\t\t\t}\n\t\t\telse {\n              \t// 如果列表中不包含\n              \t// 将配置信息添加在最前面，优先执行\n\t\t\t\tsources.addFirst(new SimpleCommandLinePropertySource(args));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void configureProfiles(ConfigurableEnvironment environment, String[] args) {\n\t\t// spring.active.profile值\n      \tenvironment.getActiveProfiles();\n\t\t// But these ones should go first (last wins in a property key clash)\n\t\tSet<String> profiles = new LinkedHashSet<String>(this.additionalProfiles);\n\t\tprofiles.addAll(Arrays.asList(environment.getActiveProfiles()));\n      \t// 将additionalProfiles和getActiveProfiles的值加到一起设置到环境中\n\t\tenvironment.setActiveProfiles(profiles.toArray(new String[profiles.size()]));\n\t}\n```\n\n注释比较详细的说明了代码的作用了：\n\n1. 创建环境\n2. 配置环境\n3. 监听器通知环境准备完毕\n4. 对异常环境处理\n\n上面代码注释跳过了web环境相关的配置，猜测里面会有servlet容器相关配置，这里跳过另开一文记录。\n\n## 创建容器\n\n```java\npublic static final String DEFAULT_WEB_CONTEXT_CLASS = \"org.springframework.\"\n\t\t\t+ \"boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext\";\n\npublic static final String DEFAULT_CONTEXT_CLASS = \"org.springframework.context.\"\n\t\t\t+ \"annotation.AnnotationConfigApplicationContext\";\n\nprotected ConfigurableApplicationContext createApplicationContext() {\n   Class<?> contextClass = this.applicationContextClass;\n   if (contextClass == null) {\n      try {\n         contextClass = Class.forName(this.webEnvironment\n               ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);\n      }\n      catch (ClassNotFoundException ex) {\n         throw new IllegalStateException(\n               \"Unable create a default ApplicationContext, \"\n                     + \"please specify an ApplicationContextClass\",\n               ex);\n      }\n   }\n   return (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);\n}\n```\n\n这部分没什么可说的，就是根据环境通过反射直接创建对应的容器的实例。\n\n## 准备容器\n\n```java\nprivate void prepareContext(ConfigurableApplicationContext context,\n      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,\n      ApplicationArguments applicationArguments, Banner printedBanner) {\n   context.setEnvironment(environment);\n   postProcessApplicationContext(context);\n   applyInitializers(context);\n   listeners.contextPrepared(context);\n   if (this.logStartupInfo) {\n      logStartupInfo(context.getParent() == null);\n      logStartupProfileInfo(context);\n   }\n\n   // Add boot specific singleton beans\n   context.getBeanFactory().registerSingleton(\"springApplicationArguments\",\n         applicationArguments);\n   if (printedBanner != null) {\n      context.getBeanFactory().registerSingleton(\"springBootBanner\", printedBanner);\n   }\n\n   // Load the sources\n   Set<Object> sources = getSources();\n   Assert.notEmpty(sources, \"Sources must not be empty\");\n   load(context, sources.toArray(new Object[sources.size()]));\n   listeners.contextLoaded(context);\n}\n\nprotected void postProcessApplicationContext(ConfigurableApplicationContext context) {\n   //  beanNameGenerator不为空，注册\n   if (this.beanNameGenerator != null) {\n      context.getBeanFactory().registerSingleton(\n            AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,\n            this.beanNameGenerator);\n   }\n   // resourceLoader不为空，注册\n   if (this.resourceLoader != null) {\n      if (context instanceof GenericApplicationContext) {\n         ((GenericApplicationContext) context)\n               .setResourceLoader(this.resourceLoader);\n      }\n      if (context instanceof DefaultResourceLoader) {\n         ((DefaultResourceLoader) context)\n               .setClassLoader(this.resourceLoader.getClassLoader());\n      }\n   }\n}\n\nprotected void applyInitializers(ConfigurableApplicationContext context) {\n   // 容器使用初始化器\n   for (ApplicationContextInitializer initializer : getInitializers()) {\n      Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(\n            initializer.getClass(), ApplicationContextInitializer.class);\n      Assert.isInstanceOf(requiredType, context, \"Unable to call initializer.\");\n      initializer.initialize(context);\n   }\n}\n\n// 加载各种bean到容器中\nprotected void load(ApplicationContext context, Object[] sources) {\n   if (logger.isDebugEnabled()) {\n      logger.debug(\n            \"Loading source \" + StringUtils.arrayToCommaDelimitedString(sources));\n   }\n   BeanDefinitionLoader loader = createBeanDefinitionLoader(\n         getBeanDefinitionRegistry(context), sources);\n   if (this.beanNameGenerator != null) {\n      loader.setBeanNameGenerator(this.beanNameGenerator);\n   }\n   if (this.resourceLoader != null) {\n      loader.setResourceLoader(this.resourceLoader);\n   }\n   if (this.environment != null) {\n      loader.setEnvironment(this.environment);\n   }\n   loader.load();\n}\n```\n\n容器的准备阶段的操作：\n\n1. 为容器设置环境信息\n2. 容器的预设置\n3. 生效初始化器\n4. 监听器通知容器准备完毕\n5. 加载各种bean到容器中\n6. 监听器通知容器加载完毕\n\n## 刷新容器\n\n```java\nprivate void refreshContext(ConfigurableApplicationContext context) {\n   refresh(context);\n   if (this.registerShutdownHook) {\n      try {\n         context.registerShutdownHook();\n      }\n      catch (AccessControlException ex) {\n         // Not allowed in some environments.\n      }\n   }\n}\n\nprotected void refresh(ApplicationContext applicationContext) {\n   Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);\n   ((AbstractApplicationContext) applicationContext).refresh();\n}\n```\n\n最后这个`((AbstractApplicationContext) applicationContext).refresh();`就厉害了，终于把 Spring 容器整合到一起了，这里不详细分析，说起来话有点多，还是再开一篇文章介绍。\n\n## Runner\n\n```java\nprotected void afterRefresh(ConfigurableApplicationContext context,\n      ApplicationArguments args) {\n   callRunners(context, args);\n}\n\nprivate void callRunners(ApplicationContext context, ApplicationArguments args) {\n   List<Object> runners = new ArrayList<Object>();\n   // 找出Spring容器中ApplicationRunner接口的实现类\n   runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());\n   // 找出Spring容器中CommandLineRunner接口的实现类\n   runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());\n   AnnotationAwareOrderComparator.sort(runners);\n   for (Object runner : new LinkedHashSet<Object>(runners)) {\n      if (runner instanceof ApplicationRunner) {\n         callRunner((ApplicationRunner) runner, args);\n      }\n      if (runner instanceof CommandLineRunner) {\n         callRunner((CommandLineRunner) runner, args);\n      }\n   }\n}\n\nprivate void callRunner(ApplicationRunner runner, ApplicationArguments args) {\n   try {\n      (runner).run(args);\n   }\n   catch (Exception ex) {\n      throw new IllegalStateException(\"Failed to execute ApplicationRunner\", ex);\n   }\n}\n\nprivate void callRunner(CommandLineRunner runner, ApplicationArguments args) {\n   try {\n      (runner).run(args.getSourceArgs());\n   }\n   catch (Exception ex) {\n      throw new IllegalStateException(\"Failed to execute CommandLineRunner\", ex);\n   }\n}\n```\n\n刷新完容器后，Spring 容器的启动就全部完成，最后这个`afterRefresh`方法是调用程序中的`ApplicationRunner`和`CommandLineRunner`，没有什么特别的。\n\n---\n\n总结一下，整个容器的启动步骤：\n\n1. 准备环境\n   1. 创建环境\n   2. 配置环境\n   3. 对异常环境处理\n2. 创建容器\n   1. 根据环境通过反射直接创建对应的容器的实例\n3. 刷新容器\n   1. `AbstractApplicationContext.refresh()`\n4. 运行runner\n   1. 调用程序中的`ApplicationRunner`和`CommandLineRunner`\n\n监听器穿插在以上步骤中，根据容器的启动、运行状态广播对应的事件。\n\n上述步骤当中忽略了两个关键的具体实现：\n\n1. 容器的创建，根据环境创建容器：\n\n   web环境：`AnnotationConfigEmbeddedWebApplicationContext`\n\n   非web环境：``AnnotationConfigApplicationContext`\n\n2. 容器的创建完成后的刷新\n\n这两部分内容较多，挖坑以后填写。\n","source":"_posts/【SpringBoot】容器启动.md","raw":"---\ntitle: 【SpringBoot】容器启动\ndate: 2017-07-10 20:24:11\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\nSpring Boot 的启动前面说到了：\n\n- 包文件启动：从`JarLauncher`的`main`方法启动，加载各种资源后，开启一个新的线程调用程序的`main`方法\n- `SpringApplication`实例创建：判断是否是web环境，加载并实例化初始化器和监听器，查找`main`方法所在类\n- 启动监听器：创建`SpringApplicationRunListeners`实例统一管理监听器。在启动过程中调用不同容器生命周期通知，创建不同的事件类型，由`ApplicationEventMulticaster`广播对应事件给`ApplicationListener`\n\n前面做了各种准备工作就是为了最后的容器提供服务，本文以注释的形式记录一下 Spring Boot 容器的启动过程：\n\n```java\n\tpublic ConfigurableApplicationContext run(String... args) {\n\t\t// ...\n\t\ttry {\n          \t// 封装应用启动参数\n\t\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n\t\t\t// 准备环境\n          \tConfigurableEnvironment environment = prepareEnvironment(listeners,\n\t\t\t\t\tapplicationArguments);\n\t\t\tBanner printedBanner = printBanner(environment);\n          \t// 创建容器\n\t\t\tcontext = createApplicationContext();\n\t\t\tanalyzers = new FailureAnalyzers(context);\n          \t// 准备容器\n\t\t\tprepareContext(context, environment, listeners, applicationArguments,\n\t\t\t\t\tprintedBanner);\n          \t// 刷新容器\n\t\t\trefreshContext(context);\n          \t// 运行runner\n\t\t\tafterRefresh(context, applicationArguments);\n\t\t\tlisteners.finished(context, null);\n\t\t\tstopWatch.stop();\n\t\t\tif (this.logStartupInfo) {\n\t\t\t\tnew StartupInfoLogger(this.mainApplicationClass)\n\t\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);\n\t\t\t}\n\t\t\treturn context;\n\t\t}\n\t\tcatch (Throwable ex) {\n          \t// ...\n\t\t}\n\t}\n```\n\n## 准备环境\n\n```java\n\tprivate ConfigurableEnvironment prepareEnvironment(\n\t\t\tSpringApplicationRunListeners listeners,\n\t\t\tApplicationArguments applicationArguments) {\n      \t// 创建环境\n\t\tConfigurableEnvironment environment = getOrCreateEnvironment();\n      \t// 配置环境\n\t\tconfigureEnvironment(environment, applicationArguments.getSourceArgs());\n      \t// 监听器通知事件\n\t\tlisteners.environmentPrepared(environment);\n      \t// 处理非web环境\n\t\tif (isWebEnvironment(environment) && !this.webEnvironment) {\n\t\t\tenvironment = convertToStandardEnvironment(environment);\n\t\t}\n\t\treturn environment;\n\t}\n\n\tprivate ConfigurableEnvironment getOrCreateEnvironment() {\n\t\tif (this.environment != null) {\n\t\t\treturn this.environment;\n\t\t}\n\t\tif (this.webEnvironment) {\n\t\t\treturn new StandardServletEnvironment();\n\t\t}\n\t\treturn new StandardEnvironment();\n\t}\n\n\tprotected void configureEnvironment(ConfigurableEnvironment environment,\n\t\t\tString[] args) {\n      \t// 配置property\n\t\tconfigurePropertySources(environment, args);\n        // 配置profiles\n\t\tconfigureProfiles(environment, args);\n\t}\n\n\tpublic static final String COMMAND_LINE_PROPERTY_SOURCE_NAME = \"commandLineArgs\";\n\n\tprotected void configurePropertySources(ConfigurableEnvironment environment,\n\t\t\tString[] args) {\n\t\tMutablePropertySources sources = environment.getPropertySources();\n      \t// 判断defaultProperties是否为空\n\t\tif (this.defaultProperties != null && !this.defaultProperties.isEmpty()) {\n          \t// MutablePropertySources内部维护一个list<PropertySource<?>>集合\n          \t// addLast先removeIfPresent()然后把defaultProperties加到最后\n\t\t\tsources.addLast(\n\t\t\t\t\tnew MapPropertySource(\"defaultProperties\", this.defaultProperties));\n\t\t}\n      \t// 判断addCommandLineProperties ==true 和 args的长度\n\t\tif (this.addCommandLineProperties && args.length > 0) {\n          \t// name=commandLineArgs\n\t\t\tString name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;\n\t\t\tif (sources.contains(name)) {\n              \t// 如果列表中包含，替换\n\t\t\t\tPropertySource<?> source = sources.get(name);\n\t\t\t\tCompositePropertySource composite = new CompositePropertySource(name);\n\t\t\t\tcomposite.addPropertySource(new SimpleCommandLinePropertySource(\n\t\t\t\t\t\tname + \"-\" + args.hashCode(), args));\n\t\t\t\tcomposite.addPropertySource(source);\n\t\t\t\tsources.replace(name, composite);\n\t\t\t}\n\t\t\telse {\n              \t// 如果列表中不包含\n              \t// 将配置信息添加在最前面，优先执行\n\t\t\t\tsources.addFirst(new SimpleCommandLinePropertySource(args));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void configureProfiles(ConfigurableEnvironment environment, String[] args) {\n\t\t// spring.active.profile值\n      \tenvironment.getActiveProfiles();\n\t\t// But these ones should go first (last wins in a property key clash)\n\t\tSet<String> profiles = new LinkedHashSet<String>(this.additionalProfiles);\n\t\tprofiles.addAll(Arrays.asList(environment.getActiveProfiles()));\n      \t// 将additionalProfiles和getActiveProfiles的值加到一起设置到环境中\n\t\tenvironment.setActiveProfiles(profiles.toArray(new String[profiles.size()]));\n\t}\n```\n\n注释比较详细的说明了代码的作用了：\n\n1. 创建环境\n2. 配置环境\n3. 监听器通知环境准备完毕\n4. 对异常环境处理\n\n上面代码注释跳过了web环境相关的配置，猜测里面会有servlet容器相关配置，这里跳过另开一文记录。\n\n## 创建容器\n\n```java\npublic static final String DEFAULT_WEB_CONTEXT_CLASS = \"org.springframework.\"\n\t\t\t+ \"boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext\";\n\npublic static final String DEFAULT_CONTEXT_CLASS = \"org.springframework.context.\"\n\t\t\t+ \"annotation.AnnotationConfigApplicationContext\";\n\nprotected ConfigurableApplicationContext createApplicationContext() {\n   Class<?> contextClass = this.applicationContextClass;\n   if (contextClass == null) {\n      try {\n         contextClass = Class.forName(this.webEnvironment\n               ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);\n      }\n      catch (ClassNotFoundException ex) {\n         throw new IllegalStateException(\n               \"Unable create a default ApplicationContext, \"\n                     + \"please specify an ApplicationContextClass\",\n               ex);\n      }\n   }\n   return (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);\n}\n```\n\n这部分没什么可说的，就是根据环境通过反射直接创建对应的容器的实例。\n\n## 准备容器\n\n```java\nprivate void prepareContext(ConfigurableApplicationContext context,\n      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,\n      ApplicationArguments applicationArguments, Banner printedBanner) {\n   context.setEnvironment(environment);\n   postProcessApplicationContext(context);\n   applyInitializers(context);\n   listeners.contextPrepared(context);\n   if (this.logStartupInfo) {\n      logStartupInfo(context.getParent() == null);\n      logStartupProfileInfo(context);\n   }\n\n   // Add boot specific singleton beans\n   context.getBeanFactory().registerSingleton(\"springApplicationArguments\",\n         applicationArguments);\n   if (printedBanner != null) {\n      context.getBeanFactory().registerSingleton(\"springBootBanner\", printedBanner);\n   }\n\n   // Load the sources\n   Set<Object> sources = getSources();\n   Assert.notEmpty(sources, \"Sources must not be empty\");\n   load(context, sources.toArray(new Object[sources.size()]));\n   listeners.contextLoaded(context);\n}\n\nprotected void postProcessApplicationContext(ConfigurableApplicationContext context) {\n   //  beanNameGenerator不为空，注册\n   if (this.beanNameGenerator != null) {\n      context.getBeanFactory().registerSingleton(\n            AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,\n            this.beanNameGenerator);\n   }\n   // resourceLoader不为空，注册\n   if (this.resourceLoader != null) {\n      if (context instanceof GenericApplicationContext) {\n         ((GenericApplicationContext) context)\n               .setResourceLoader(this.resourceLoader);\n      }\n      if (context instanceof DefaultResourceLoader) {\n         ((DefaultResourceLoader) context)\n               .setClassLoader(this.resourceLoader.getClassLoader());\n      }\n   }\n}\n\nprotected void applyInitializers(ConfigurableApplicationContext context) {\n   // 容器使用初始化器\n   for (ApplicationContextInitializer initializer : getInitializers()) {\n      Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(\n            initializer.getClass(), ApplicationContextInitializer.class);\n      Assert.isInstanceOf(requiredType, context, \"Unable to call initializer.\");\n      initializer.initialize(context);\n   }\n}\n\n// 加载各种bean到容器中\nprotected void load(ApplicationContext context, Object[] sources) {\n   if (logger.isDebugEnabled()) {\n      logger.debug(\n            \"Loading source \" + StringUtils.arrayToCommaDelimitedString(sources));\n   }\n   BeanDefinitionLoader loader = createBeanDefinitionLoader(\n         getBeanDefinitionRegistry(context), sources);\n   if (this.beanNameGenerator != null) {\n      loader.setBeanNameGenerator(this.beanNameGenerator);\n   }\n   if (this.resourceLoader != null) {\n      loader.setResourceLoader(this.resourceLoader);\n   }\n   if (this.environment != null) {\n      loader.setEnvironment(this.environment);\n   }\n   loader.load();\n}\n```\n\n容器的准备阶段的操作：\n\n1. 为容器设置环境信息\n2. 容器的预设置\n3. 生效初始化器\n4. 监听器通知容器准备完毕\n5. 加载各种bean到容器中\n6. 监听器通知容器加载完毕\n\n## 刷新容器\n\n```java\nprivate void refreshContext(ConfigurableApplicationContext context) {\n   refresh(context);\n   if (this.registerShutdownHook) {\n      try {\n         context.registerShutdownHook();\n      }\n      catch (AccessControlException ex) {\n         // Not allowed in some environments.\n      }\n   }\n}\n\nprotected void refresh(ApplicationContext applicationContext) {\n   Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);\n   ((AbstractApplicationContext) applicationContext).refresh();\n}\n```\n\n最后这个`((AbstractApplicationContext) applicationContext).refresh();`就厉害了，终于把 Spring 容器整合到一起了，这里不详细分析，说起来话有点多，还是再开一篇文章介绍。\n\n## Runner\n\n```java\nprotected void afterRefresh(ConfigurableApplicationContext context,\n      ApplicationArguments args) {\n   callRunners(context, args);\n}\n\nprivate void callRunners(ApplicationContext context, ApplicationArguments args) {\n   List<Object> runners = new ArrayList<Object>();\n   // 找出Spring容器中ApplicationRunner接口的实现类\n   runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());\n   // 找出Spring容器中CommandLineRunner接口的实现类\n   runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());\n   AnnotationAwareOrderComparator.sort(runners);\n   for (Object runner : new LinkedHashSet<Object>(runners)) {\n      if (runner instanceof ApplicationRunner) {\n         callRunner((ApplicationRunner) runner, args);\n      }\n      if (runner instanceof CommandLineRunner) {\n         callRunner((CommandLineRunner) runner, args);\n      }\n   }\n}\n\nprivate void callRunner(ApplicationRunner runner, ApplicationArguments args) {\n   try {\n      (runner).run(args);\n   }\n   catch (Exception ex) {\n      throw new IllegalStateException(\"Failed to execute ApplicationRunner\", ex);\n   }\n}\n\nprivate void callRunner(CommandLineRunner runner, ApplicationArguments args) {\n   try {\n      (runner).run(args.getSourceArgs());\n   }\n   catch (Exception ex) {\n      throw new IllegalStateException(\"Failed to execute CommandLineRunner\", ex);\n   }\n}\n```\n\n刷新完容器后，Spring 容器的启动就全部完成，最后这个`afterRefresh`方法是调用程序中的`ApplicationRunner`和`CommandLineRunner`，没有什么特别的。\n\n---\n\n总结一下，整个容器的启动步骤：\n\n1. 准备环境\n   1. 创建环境\n   2. 配置环境\n   3. 对异常环境处理\n2. 创建容器\n   1. 根据环境通过反射直接创建对应的容器的实例\n3. 刷新容器\n   1. `AbstractApplicationContext.refresh()`\n4. 运行runner\n   1. 调用程序中的`ApplicationRunner`和`CommandLineRunner`\n\n监听器穿插在以上步骤中，根据容器的启动、运行状态广播对应的事件。\n\n上述步骤当中忽略了两个关键的具体实现：\n\n1. 容器的创建，根据环境创建容器：\n\n   web环境：`AnnotationConfigEmbeddedWebApplicationContext`\n\n   非web环境：``AnnotationConfigApplicationContext`\n\n2. 容器的创建完成后的刷新\n\n这两部分内容较多，挖坑以后填写。\n","slug":"【SpringBoot】容器启动","published":1,"updated":"2017-07-18T12:27:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2r1002td82e9gf8nwa1","content":"<p>Spring Boot 的启动前面说到了：</p>\n<ul>\n<li>包文件启动：从<code>JarLauncher</code>的<code>main</code>方法启动，加载各种资源后，开启一个新的线程调用程序的<code>main</code>方法</li>\n<li><code>SpringApplication</code>实例创建：判断是否是web环境，加载并实例化初始化器和监听器，查找<code>main</code>方法所在类</li>\n<li>启动监听器：创建<code>SpringApplicationRunListeners</code>实例统一管理监听器。在启动过程中调用不同容器生命周期通知，创建不同的事件类型，由<code>ApplicationEventMulticaster</code>广播对应事件给<code>ApplicationListener</code></li>\n</ul>\n<p>前面做了各种准备工作就是为了最后的容器提供服务，本文以注释的形式记录一下 Spring Boot 容器的启动过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// ...</span></div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         \t<span class=\"comment\">// 封装应用启动参数</span></div><div class=\"line\">\t\tApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(args);</div><div class=\"line\">\t\t<span class=\"comment\">// 准备环境</span></div><div class=\"line\">         \tConfigurableEnvironment environment = prepareEnvironment(listeners,</div><div class=\"line\">\t\t\t\tapplicationArguments);</div><div class=\"line\">\t\tBanner printedBanner = printBanner(environment);</div><div class=\"line\">         \t<span class=\"comment\">// 创建容器</span></div><div class=\"line\">\t\tcontext = createApplicationContext();</div><div class=\"line\">\t\tanalyzers = <span class=\"keyword\">new</span> FailureAnalyzers(context);</div><div class=\"line\">         \t<span class=\"comment\">// 准备容器</span></div><div class=\"line\">\t\tprepareContext(context, environment, listeners, applicationArguments,</div><div class=\"line\">\t\t\t\tprintedBanner);</div><div class=\"line\">         \t<span class=\"comment\">// 刷新容器</span></div><div class=\"line\">\t\trefreshContext(context);</div><div class=\"line\">         \t<span class=\"comment\">// 运行runner</span></div><div class=\"line\">\t\tafterRefresh(context, applicationArguments);</div><div class=\"line\">\t\tlisteners.finished(context, <span class=\"keyword\">null</span>);</div><div class=\"line\">\t\tstopWatch.stop();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass)</div><div class=\"line\">\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> context;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">         \t<span class=\"comment\">// ...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ConfigurableEnvironment <span class=\"title\">prepareEnvironment</span><span class=\"params\">(</span></span></div><div class=\"line\">\t\tSpringApplicationRunListeners listeners,</div><div class=\"line\">\t\tApplicationArguments applicationArguments) &#123;</div><div class=\"line\">     \t<span class=\"comment\">// 创建环境</span></div><div class=\"line\">\tConfigurableEnvironment environment = getOrCreateEnvironment();</div><div class=\"line\">     \t<span class=\"comment\">// 配置环境</span></div><div class=\"line\">\tconfigureEnvironment(environment, applicationArguments.getSourceArgs());</div><div class=\"line\">     \t<span class=\"comment\">// 监听器通知事件</span></div><div class=\"line\">\tlisteners.environmentPrepared(environment);</div><div class=\"line\">     \t<span class=\"comment\">// 处理非web环境</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (isWebEnvironment(environment) &amp;&amp; !<span class=\"keyword\">this</span>.webEnvironment) &#123;</div><div class=\"line\">\t\tenvironment = convertToStandardEnvironment(environment);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> environment;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ConfigurableEnvironment <span class=\"title\">getOrCreateEnvironment</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.environment != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.environment;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.webEnvironment) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StandardServletEnvironment();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StandardEnvironment();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configureEnvironment</span><span class=\"params\">(ConfigurableEnvironment environment,</span></span></div><div class=\"line\">\t\tString[] args) &#123;</div><div class=\"line\">     \t<span class=\"comment\">// 配置property</span></div><div class=\"line\">\tconfigurePropertySources(environment, args);</div><div class=\"line\">       <span class=\"comment\">// 配置profiles</span></div><div class=\"line\">\tconfigureProfiles(environment, args);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String COMMAND_LINE_PROPERTY_SOURCE_NAME = <span class=\"string\">\"commandLineArgs\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configurePropertySources</span><span class=\"params\">(ConfigurableEnvironment environment,</span></span></div><div class=\"line\">\t\tString[] args) &#123;</div><div class=\"line\">\tMutablePropertySources sources = environment.getPropertySources();</div><div class=\"line\">     \t<span class=\"comment\">// 判断defaultProperties是否为空</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultProperties != <span class=\"keyword\">null</span> &amp;&amp; !<span class=\"keyword\">this</span>.defaultProperties.isEmpty()) &#123;</div><div class=\"line\">         \t<span class=\"comment\">// MutablePropertySources内部维护一个list&lt;PropertySource&lt;?&gt;&gt;集合</span></div><div class=\"line\">         \t<span class=\"comment\">// addLast先removeIfPresent()然后把defaultProperties加到最后</span></div><div class=\"line\">\t\tsources.addLast(</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> MapPropertySource(<span class=\"string\">\"defaultProperties\"</span>, <span class=\"keyword\">this</span>.defaultProperties));</div><div class=\"line\">\t&#125;</div><div class=\"line\">     \t<span class=\"comment\">// 判断addCommandLineProperties ==true 和 args的长度</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.addCommandLineProperties &amp;&amp; args.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">         \t<span class=\"comment\">// name=commandLineArgs</span></div><div class=\"line\">\t\tString name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (sources.contains(name)) &#123;</div><div class=\"line\">             \t<span class=\"comment\">// 如果列表中包含，替换</span></div><div class=\"line\">\t\t\tPropertySource&lt;?&gt; source = sources.get(name);</div><div class=\"line\">\t\t\tCompositePropertySource composite = <span class=\"keyword\">new</span> CompositePropertySource(name);</div><div class=\"line\">\t\t\tcomposite.addPropertySource(<span class=\"keyword\">new</span> SimpleCommandLinePropertySource(</div><div class=\"line\">\t\t\t\t\tname + <span class=\"string\">\"-\"</span> + args.hashCode(), args));</div><div class=\"line\">\t\t\tcomposite.addPropertySource(source);</div><div class=\"line\">\t\t\tsources.replace(name, composite);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">             \t<span class=\"comment\">// 如果列表中不包含</span></div><div class=\"line\">             \t<span class=\"comment\">// 将配置信息添加在最前面，优先执行</span></div><div class=\"line\">\t\t\tsources.addFirst(<span class=\"keyword\">new</span> SimpleCommandLinePropertySource(args));</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configureProfiles</span><span class=\"params\">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// spring.active.profile值</span></div><div class=\"line\">     \tenvironment.getActiveProfiles();</div><div class=\"line\">\t<span class=\"comment\">// But these ones should go first (last wins in a property key clash)</span></div><div class=\"line\">\tSet&lt;String&gt; profiles = <span class=\"keyword\">new</span> LinkedHashSet&lt;String&gt;(<span class=\"keyword\">this</span>.additionalProfiles);</div><div class=\"line\">\tprofiles.addAll(Arrays.asList(environment.getActiveProfiles()));</div><div class=\"line\">     \t<span class=\"comment\">// 将additionalProfiles和getActiveProfiles的值加到一起设置到环境中</span></div><div class=\"line\">\tenvironment.setActiveProfiles(profiles.toArray(<span class=\"keyword\">new</span> String[profiles.size()]));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注释比较详细的说明了代码的作用了：</p>\n<ol>\n<li>创建环境</li>\n<li>配置环境</li>\n<li>监听器通知环境准备完毕</li>\n<li>对异常环境处理</li>\n</ol>\n<p>上面代码注释跳过了web环境相关的配置，猜测里面会有servlet容器相关配置，这里跳过另开一文记录。</p>\n<h2 id=\"创建容器\"><a href=\"#创建容器\" class=\"headerlink\" title=\"创建容器\"></a>创建容器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_WEB_CONTEXT_CLASS = <span class=\"string\">\"org.springframework.\"</span></div><div class=\"line\">\t\t\t+ <span class=\"string\">\"boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_CONTEXT_CLASS = <span class=\"string\">\"org.springframework.context.\"</span></div><div class=\"line\">\t\t\t+ <span class=\"string\">\"annotation.AnnotationConfigApplicationContext\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ConfigurableApplicationContext <span class=\"title\">createApplicationContext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   Class&lt;?&gt; contextClass = <span class=\"keyword\">this</span>.applicationContextClass;</div><div class=\"line\">   <span class=\"keyword\">if</span> (contextClass == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         contextClass = Class.forName(<span class=\"keyword\">this</span>.webEnvironment</div><div class=\"line\">               ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</div><div class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">               <span class=\"string\">\"Unable create a default ApplicationContext, \"</span></div><div class=\"line\">                     + <span class=\"string\">\"please specify an ApplicationContextClass\"</span>,</div><div class=\"line\">               ex);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分没什么可说的，就是根据环境通过反射直接创建对应的容器的实例。</p>\n<h2 id=\"准备容器\"><a href=\"#准备容器\" class=\"headerlink\" title=\"准备容器\"></a>准备容器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareContext</span><span class=\"params\">(ConfigurableApplicationContext context,</span></span></div><div class=\"line\">      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</div><div class=\"line\">      ApplicationArguments applicationArguments, Banner printedBanner) &#123;</div><div class=\"line\">   context.setEnvironment(environment);</div><div class=\"line\">   postProcessApplicationContext(context);</div><div class=\"line\">   applyInitializers(context);</div><div class=\"line\">   listeners.contextPrepared(context);</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</div><div class=\"line\">      logStartupInfo(context.getParent() == <span class=\"keyword\">null</span>);</div><div class=\"line\">      logStartupProfileInfo(context);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Add boot specific singleton beans</span></div><div class=\"line\">   context.getBeanFactory().registerSingleton(<span class=\"string\">\"springApplicationArguments\"</span>,</div><div class=\"line\">         applicationArguments);</div><div class=\"line\">   <span class=\"keyword\">if</span> (printedBanner != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      context.getBeanFactory().registerSingleton(<span class=\"string\">\"springBootBanner\"</span>, printedBanner);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Load the sources</span></div><div class=\"line\">   Set&lt;Object&gt; sources = getSources();</div><div class=\"line\">   Assert.notEmpty(sources, <span class=\"string\">\"Sources must not be empty\"</span>);</div><div class=\"line\">   load(context, sources.toArray(<span class=\"keyword\">new</span> Object[sources.size()]));</div><div class=\"line\">   listeners.contextLoaded(context);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessApplicationContext</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">//  beanNameGenerator不为空，注册</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      context.getBeanFactory().registerSingleton(</div><div class=\"line\">            AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,</div><div class=\"line\">            <span class=\"keyword\">this</span>.beanNameGenerator);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// resourceLoader不为空，注册</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> GenericApplicationContext) &#123;</div><div class=\"line\">         ((GenericApplicationContext) context)</div><div class=\"line\">               .setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> DefaultResourceLoader) &#123;</div><div class=\"line\">         ((DefaultResourceLoader) context)</div><div class=\"line\">               .setClassLoader(<span class=\"keyword\">this</span>.resourceLoader.getClassLoader());</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">applyInitializers</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 容器使用初始化器</span></div><div class=\"line\">   <span class=\"keyword\">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</div><div class=\"line\">      Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(</div><div class=\"line\">            initializer.getClass(), ApplicationContextInitializer.class);</div><div class=\"line\">      Assert.isInstanceOf(requiredType, context, <span class=\"string\">\"Unable to call initializer.\"</span>);</div><div class=\"line\">      initializer.initialize(context);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载各种bean到容器中</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">(ApplicationContext context, Object[] sources)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">      logger.debug(</div><div class=\"line\">            <span class=\"string\">\"Loading source \"</span> + StringUtils.arrayToCommaDelimitedString(sources));</div><div class=\"line\">   &#125;</div><div class=\"line\">   BeanDefinitionLoader loader = createBeanDefinitionLoader(</div><div class=\"line\">         getBeanDefinitionRegistry(context), sources);</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      loader.setBeanNameGenerator(<span class=\"keyword\">this</span>.beanNameGenerator);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      loader.setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.environment != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      loader.setEnvironment(<span class=\"keyword\">this</span>.environment);</div><div class=\"line\">   &#125;</div><div class=\"line\">   loader.load();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>容器的准备阶段的操作：</p>\n<ol>\n<li>为容器设置环境信息</li>\n<li>容器的预设置</li>\n<li>生效初始化器</li>\n<li>监听器通知容器准备完毕</li>\n<li>加载各种bean到容器中</li>\n<li>监听器通知容器加载完毕</li>\n</ol>\n<h2 id=\"刷新容器\"><a href=\"#刷新容器\" class=\"headerlink\" title=\"刷新容器\"></a>刷新容器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">refreshContext</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</div><div class=\"line\">   refresh(context);</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.registerShutdownHook) &#123;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         context.registerShutdownHook();</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">catch</span> (AccessControlException ex) &#123;</div><div class=\"line\">         <span class=\"comment\">// Not allowed in some environments.</span></div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">(ApplicationContext applicationContext)</span> </span>&#123;</div><div class=\"line\">   Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</div><div class=\"line\">   ((AbstractApplicationContext) applicationContext).refresh();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后这个<code>((AbstractApplicationContext) applicationContext).refresh();</code>就厉害了，终于把 Spring 容器整合到一起了，这里不详细分析，说起来话有点多，还是再开一篇文章介绍。</p>\n<h2 id=\"Runner\"><a href=\"#Runner\" class=\"headerlink\" title=\"Runner\"></a>Runner</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">afterRefresh</span><span class=\"params\">(ConfigurableApplicationContext context,</span></span></div><div class=\"line\">      ApplicationArguments args) &#123;</div><div class=\"line\">   callRunners(context, args);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callRunners</span><span class=\"params\">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</div><div class=\"line\">   List&lt;Object&gt; runners = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</div><div class=\"line\">   <span class=\"comment\">// 找出Spring容器中ApplicationRunner接口的实现类</span></div><div class=\"line\">   runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</div><div class=\"line\">   <span class=\"comment\">// 找出Spring容器中CommandLineRunner接口的实现类</span></div><div class=\"line\">   runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</div><div class=\"line\">   AnnotationAwareOrderComparator.sort(runners);</div><div class=\"line\">   <span class=\"keyword\">for</span> (Object runner : <span class=\"keyword\">new</span> LinkedHashSet&lt;Object&gt;(runners)) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (runner <span class=\"keyword\">instanceof</span> ApplicationRunner) &#123;</div><div class=\"line\">         callRunner((ApplicationRunner) runner, args);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (runner <span class=\"keyword\">instanceof</span> CommandLineRunner) &#123;</div><div class=\"line\">         callRunner((CommandLineRunner) runner, args);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callRunner</span><span class=\"params\">(ApplicationRunner runner, ApplicationArguments args)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      (runner).run(args);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Failed to execute ApplicationRunner\"</span>, ex);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callRunner</span><span class=\"params\">(CommandLineRunner runner, ApplicationArguments args)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      (runner).run(args.getSourceArgs());</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Failed to execute CommandLineRunner\"</span>, ex);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>刷新完容器后，Spring 容器的启动就全部完成，最后这个<code>afterRefresh</code>方法是调用程序中的<code>ApplicationRunner</code>和<code>CommandLineRunner</code>，没有什么特别的。</p>\n<hr>\n<p>总结一下，整个容器的启动步骤：</p>\n<ol>\n<li>准备环境<ol>\n<li>创建环境</li>\n<li>配置环境</li>\n<li>对异常环境处理</li>\n</ol>\n</li>\n<li>创建容器<ol>\n<li>根据环境通过反射直接创建对应的容器的实例</li>\n</ol>\n</li>\n<li>刷新容器<ol>\n<li><code>AbstractApplicationContext.refresh()</code></li>\n</ol>\n</li>\n<li>运行runner<ol>\n<li>调用程序中的<code>ApplicationRunner</code>和<code>CommandLineRunner</code></li>\n</ol>\n</li>\n</ol>\n<p>监听器穿插在以上步骤中，根据容器的启动、运行状态广播对应的事件。</p>\n<p>上述步骤当中忽略了两个关键的具体实现：</p>\n<ol>\n<li><p>容器的创建，根据环境创建容器：</p>\n<p>web环境：<code>AnnotationConfigEmbeddedWebApplicationContext</code></p>\n<p>非web环境：<code>`AnnotationConfigApplicationContext</code></p>\n</li>\n<li><p>容器的创建完成后的刷新</p>\n</li>\n</ol>\n<p>这两部分内容较多，挖坑以后填写。</p>\n","excerpt":"","more":"<p>Spring Boot 的启动前面说到了：</p>\n<ul>\n<li>包文件启动：从<code>JarLauncher</code>的<code>main</code>方法启动，加载各种资源后，开启一个新的线程调用程序的<code>main</code>方法</li>\n<li><code>SpringApplication</code>实例创建：判断是否是web环境，加载并实例化初始化器和监听器，查找<code>main</code>方法所在类</li>\n<li>启动监听器：创建<code>SpringApplicationRunListeners</code>实例统一管理监听器。在启动过程中调用不同容器生命周期通知，创建不同的事件类型，由<code>ApplicationEventMulticaster</code>广播对应事件给<code>ApplicationListener</code></li>\n</ul>\n<p>前面做了各种准备工作就是为了最后的容器提供服务，本文以注释的形式记录一下 Spring Boot 容器的启动过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// ...</span></div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         \t<span class=\"comment\">// 封装应用启动参数</span></div><div class=\"line\">\t\tApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(args);</div><div class=\"line\">\t\t<span class=\"comment\">// 准备环境</span></div><div class=\"line\">         \tConfigurableEnvironment environment = prepareEnvironment(listeners,</div><div class=\"line\">\t\t\t\tapplicationArguments);</div><div class=\"line\">\t\tBanner printedBanner = printBanner(environment);</div><div class=\"line\">         \t<span class=\"comment\">// 创建容器</span></div><div class=\"line\">\t\tcontext = createApplicationContext();</div><div class=\"line\">\t\tanalyzers = <span class=\"keyword\">new</span> FailureAnalyzers(context);</div><div class=\"line\">         \t<span class=\"comment\">// 准备容器</span></div><div class=\"line\">\t\tprepareContext(context, environment, listeners, applicationArguments,</div><div class=\"line\">\t\t\t\tprintedBanner);</div><div class=\"line\">         \t<span class=\"comment\">// 刷新容器</span></div><div class=\"line\">\t\trefreshContext(context);</div><div class=\"line\">         \t<span class=\"comment\">// 运行runner</span></div><div class=\"line\">\t\tafterRefresh(context, applicationArguments);</div><div class=\"line\">\t\tlisteners.finished(context, <span class=\"keyword\">null</span>);</div><div class=\"line\">\t\tstopWatch.stop();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass)</div><div class=\"line\">\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> context;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">         \t<span class=\"comment\">// ...</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ConfigurableEnvironment <span class=\"title\">prepareEnvironment</span><span class=\"params\">(</div><div class=\"line\">\t\tSpringApplicationRunListeners listeners,</div><div class=\"line\">\t\tApplicationArguments applicationArguments)</span> </span>&#123;</div><div class=\"line\">     \t<span class=\"comment\">// 创建环境</span></div><div class=\"line\">\tConfigurableEnvironment environment = getOrCreateEnvironment();</div><div class=\"line\">     \t<span class=\"comment\">// 配置环境</span></div><div class=\"line\">\tconfigureEnvironment(environment, applicationArguments.getSourceArgs());</div><div class=\"line\">     \t<span class=\"comment\">// 监听器通知事件</span></div><div class=\"line\">\tlisteners.environmentPrepared(environment);</div><div class=\"line\">     \t<span class=\"comment\">// 处理非web环境</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (isWebEnvironment(environment) &amp;&amp; !<span class=\"keyword\">this</span>.webEnvironment) &#123;</div><div class=\"line\">\t\tenvironment = convertToStandardEnvironment(environment);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> environment;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ConfigurableEnvironment <span class=\"title\">getOrCreateEnvironment</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.environment != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.environment;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.webEnvironment) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StandardServletEnvironment();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StandardEnvironment();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configureEnvironment</span><span class=\"params\">(ConfigurableEnvironment environment,</div><div class=\"line\">\t\tString[] args)</span> </span>&#123;</div><div class=\"line\">     \t<span class=\"comment\">// 配置property</span></div><div class=\"line\">\tconfigurePropertySources(environment, args);</div><div class=\"line\">       <span class=\"comment\">// 配置profiles</span></div><div class=\"line\">\tconfigureProfiles(environment, args);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String COMMAND_LINE_PROPERTY_SOURCE_NAME = <span class=\"string\">\"commandLineArgs\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configurePropertySources</span><span class=\"params\">(ConfigurableEnvironment environment,</div><div class=\"line\">\t\tString[] args)</span> </span>&#123;</div><div class=\"line\">\tMutablePropertySources sources = environment.getPropertySources();</div><div class=\"line\">     \t<span class=\"comment\">// 判断defaultProperties是否为空</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultProperties != <span class=\"keyword\">null</span> &amp;&amp; !<span class=\"keyword\">this</span>.defaultProperties.isEmpty()) &#123;</div><div class=\"line\">         \t<span class=\"comment\">// MutablePropertySources内部维护一个list&lt;PropertySource&lt;?&gt;&gt;集合</span></div><div class=\"line\">         \t<span class=\"comment\">// addLast先removeIfPresent()然后把defaultProperties加到最后</span></div><div class=\"line\">\t\tsources.addLast(</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> MapPropertySource(<span class=\"string\">\"defaultProperties\"</span>, <span class=\"keyword\">this</span>.defaultProperties));</div><div class=\"line\">\t&#125;</div><div class=\"line\">     \t<span class=\"comment\">// 判断addCommandLineProperties ==true 和 args的长度</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.addCommandLineProperties &amp;&amp; args.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">         \t<span class=\"comment\">// name=commandLineArgs</span></div><div class=\"line\">\t\tString name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (sources.contains(name)) &#123;</div><div class=\"line\">             \t<span class=\"comment\">// 如果列表中包含，替换</span></div><div class=\"line\">\t\t\tPropertySource&lt;?&gt; source = sources.get(name);</div><div class=\"line\">\t\t\tCompositePropertySource composite = <span class=\"keyword\">new</span> CompositePropertySource(name);</div><div class=\"line\">\t\t\tcomposite.addPropertySource(<span class=\"keyword\">new</span> SimpleCommandLinePropertySource(</div><div class=\"line\">\t\t\t\t\tname + <span class=\"string\">\"-\"</span> + args.hashCode(), args));</div><div class=\"line\">\t\t\tcomposite.addPropertySource(source);</div><div class=\"line\">\t\t\tsources.replace(name, composite);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">             \t<span class=\"comment\">// 如果列表中不包含</span></div><div class=\"line\">             \t<span class=\"comment\">// 将配置信息添加在最前面，优先执行</span></div><div class=\"line\">\t\t\tsources.addFirst(<span class=\"keyword\">new</span> SimpleCommandLinePropertySource(args));</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configureProfiles</span><span class=\"params\">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// spring.active.profile值</span></div><div class=\"line\">     \tenvironment.getActiveProfiles();</div><div class=\"line\">\t<span class=\"comment\">// But these ones should go first (last wins in a property key clash)</span></div><div class=\"line\">\tSet&lt;String&gt; profiles = <span class=\"keyword\">new</span> LinkedHashSet&lt;String&gt;(<span class=\"keyword\">this</span>.additionalProfiles);</div><div class=\"line\">\tprofiles.addAll(Arrays.asList(environment.getActiveProfiles()));</div><div class=\"line\">     \t<span class=\"comment\">// 将additionalProfiles和getActiveProfiles的值加到一起设置到环境中</span></div><div class=\"line\">\tenvironment.setActiveProfiles(profiles.toArray(<span class=\"keyword\">new</span> String[profiles.size()]));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注释比较详细的说明了代码的作用了：</p>\n<ol>\n<li>创建环境</li>\n<li>配置环境</li>\n<li>监听器通知环境准备完毕</li>\n<li>对异常环境处理</li>\n</ol>\n<p>上面代码注释跳过了web环境相关的配置，猜测里面会有servlet容器相关配置，这里跳过另开一文记录。</p>\n<h2 id=\"创建容器\"><a href=\"#创建容器\" class=\"headerlink\" title=\"创建容器\"></a>创建容器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_WEB_CONTEXT_CLASS = <span class=\"string\">\"org.springframework.\"</span></div><div class=\"line\">\t\t\t+ <span class=\"string\">\"boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_CONTEXT_CLASS = <span class=\"string\">\"org.springframework.context.\"</span></div><div class=\"line\">\t\t\t+ <span class=\"string\">\"annotation.AnnotationConfigApplicationContext\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ConfigurableApplicationContext <span class=\"title\">createApplicationContext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   Class&lt;?&gt; contextClass = <span class=\"keyword\">this</span>.applicationContextClass;</div><div class=\"line\">   <span class=\"keyword\">if</span> (contextClass == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         contextClass = Class.forName(<span class=\"keyword\">this</span>.webEnvironment</div><div class=\"line\">               ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</div><div class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">               <span class=\"string\">\"Unable create a default ApplicationContext, \"</span></div><div class=\"line\">                     + <span class=\"string\">\"please specify an ApplicationContextClass\"</span>,</div><div class=\"line\">               ex);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这部分没什么可说的，就是根据环境通过反射直接创建对应的容器的实例。</p>\n<h2 id=\"准备容器\"><a href=\"#准备容器\" class=\"headerlink\" title=\"准备容器\"></a>准备容器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareContext</span><span class=\"params\">(ConfigurableApplicationContext context,</div><div class=\"line\">      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</div><div class=\"line\">      ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</div><div class=\"line\">   context.setEnvironment(environment);</div><div class=\"line\">   postProcessApplicationContext(context);</div><div class=\"line\">   applyInitializers(context);</div><div class=\"line\">   listeners.contextPrepared(context);</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</div><div class=\"line\">      logStartupInfo(context.getParent() == <span class=\"keyword\">null</span>);</div><div class=\"line\">      logStartupProfileInfo(context);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Add boot specific singleton beans</span></div><div class=\"line\">   context.getBeanFactory().registerSingleton(<span class=\"string\">\"springApplicationArguments\"</span>,</div><div class=\"line\">         applicationArguments);</div><div class=\"line\">   <span class=\"keyword\">if</span> (printedBanner != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      context.getBeanFactory().registerSingleton(<span class=\"string\">\"springBootBanner\"</span>, printedBanner);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Load the sources</span></div><div class=\"line\">   Set&lt;Object&gt; sources = getSources();</div><div class=\"line\">   Assert.notEmpty(sources, <span class=\"string\">\"Sources must not be empty\"</span>);</div><div class=\"line\">   load(context, sources.toArray(<span class=\"keyword\">new</span> Object[sources.size()]));</div><div class=\"line\">   listeners.contextLoaded(context);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessApplicationContext</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">//  beanNameGenerator不为空，注册</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      context.getBeanFactory().registerSingleton(</div><div class=\"line\">            AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,</div><div class=\"line\">            <span class=\"keyword\">this</span>.beanNameGenerator);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// resourceLoader不为空，注册</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> GenericApplicationContext) &#123;</div><div class=\"line\">         ((GenericApplicationContext) context)</div><div class=\"line\">               .setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> DefaultResourceLoader) &#123;</div><div class=\"line\">         ((DefaultResourceLoader) context)</div><div class=\"line\">               .setClassLoader(<span class=\"keyword\">this</span>.resourceLoader.getClassLoader());</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">applyInitializers</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 容器使用初始化器</span></div><div class=\"line\">   <span class=\"keyword\">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</div><div class=\"line\">      Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(</div><div class=\"line\">            initializer.getClass(), ApplicationContextInitializer.class);</div><div class=\"line\">      Assert.isInstanceOf(requiredType, context, <span class=\"string\">\"Unable to call initializer.\"</span>);</div><div class=\"line\">      initializer.initialize(context);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 加载各种bean到容器中</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">(ApplicationContext context, Object[] sources)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">      logger.debug(</div><div class=\"line\">            <span class=\"string\">\"Loading source \"</span> + StringUtils.arrayToCommaDelimitedString(sources));</div><div class=\"line\">   &#125;</div><div class=\"line\">   BeanDefinitionLoader loader = createBeanDefinitionLoader(</div><div class=\"line\">         getBeanDefinitionRegistry(context), sources);</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      loader.setBeanNameGenerator(<span class=\"keyword\">this</span>.beanNameGenerator);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      loader.setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.environment != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      loader.setEnvironment(<span class=\"keyword\">this</span>.environment);</div><div class=\"line\">   &#125;</div><div class=\"line\">   loader.load();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>容器的准备阶段的操作：</p>\n<ol>\n<li>为容器设置环境信息</li>\n<li>容器的预设置</li>\n<li>生效初始化器</li>\n<li>监听器通知容器准备完毕</li>\n<li>加载各种bean到容器中</li>\n<li>监听器通知容器加载完毕</li>\n</ol>\n<h2 id=\"刷新容器\"><a href=\"#刷新容器\" class=\"headerlink\" title=\"刷新容器\"></a>刷新容器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">refreshContext</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</div><div class=\"line\">   refresh(context);</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.registerShutdownHook) &#123;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         context.registerShutdownHook();</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">catch</span> (AccessControlException ex) &#123;</div><div class=\"line\">         <span class=\"comment\">// Not allowed in some environments.</span></div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">(ApplicationContext applicationContext)</span> </span>&#123;</div><div class=\"line\">   Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</div><div class=\"line\">   ((AbstractApplicationContext) applicationContext).refresh();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后这个<code>((AbstractApplicationContext) applicationContext).refresh();</code>就厉害了，终于把 Spring 容器整合到一起了，这里不详细分析，说起来话有点多，还是再开一篇文章介绍。</p>\n<h2 id=\"Runner\"><a href=\"#Runner\" class=\"headerlink\" title=\"Runner\"></a>Runner</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">afterRefresh</span><span class=\"params\">(ConfigurableApplicationContext context,</div><div class=\"line\">      ApplicationArguments args)</span> </span>&#123;</div><div class=\"line\">   callRunners(context, args);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callRunners</span><span class=\"params\">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</div><div class=\"line\">   List&lt;Object&gt; runners = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</div><div class=\"line\">   <span class=\"comment\">// 找出Spring容器中ApplicationRunner接口的实现类</span></div><div class=\"line\">   runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</div><div class=\"line\">   <span class=\"comment\">// 找出Spring容器中CommandLineRunner接口的实现类</span></div><div class=\"line\">   runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</div><div class=\"line\">   AnnotationAwareOrderComparator.sort(runners);</div><div class=\"line\">   <span class=\"keyword\">for</span> (Object runner : <span class=\"keyword\">new</span> LinkedHashSet&lt;Object&gt;(runners)) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (runner <span class=\"keyword\">instanceof</span> ApplicationRunner) &#123;</div><div class=\"line\">         callRunner((ApplicationRunner) runner, args);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (runner <span class=\"keyword\">instanceof</span> CommandLineRunner) &#123;</div><div class=\"line\">         callRunner((CommandLineRunner) runner, args);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callRunner</span><span class=\"params\">(ApplicationRunner runner, ApplicationArguments args)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      (runner).run(args);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Failed to execute ApplicationRunner\"</span>, ex);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">callRunner</span><span class=\"params\">(CommandLineRunner runner, ApplicationArguments args)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      (runner).run(args.getSourceArgs());</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> (Exception ex) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Failed to execute CommandLineRunner\"</span>, ex);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>刷新完容器后，Spring 容器的启动就全部完成，最后这个<code>afterRefresh</code>方法是调用程序中的<code>ApplicationRunner</code>和<code>CommandLineRunner</code>，没有什么特别的。</p>\n<hr>\n<p>总结一下，整个容器的启动步骤：</p>\n<ol>\n<li>准备环境<ol>\n<li>创建环境</li>\n<li>配置环境</li>\n<li>对异常环境处理</li>\n</ol>\n</li>\n<li>创建容器<ol>\n<li>根据环境通过反射直接创建对应的容器的实例</li>\n</ol>\n</li>\n<li>刷新容器<ol>\n<li><code>AbstractApplicationContext.refresh()</code></li>\n</ol>\n</li>\n<li>运行runner<ol>\n<li>调用程序中的<code>ApplicationRunner</code>和<code>CommandLineRunner</code></li>\n</ol>\n</li>\n</ol>\n<p>监听器穿插在以上步骤中，根据容器的启动、运行状态广播对应的事件。</p>\n<p>上述步骤当中忽略了两个关键的具体实现：</p>\n<ol>\n<li><p>容器的创建，根据环境创建容器：</p>\n<p>web环境：<code>AnnotationConfigEmbeddedWebApplicationContext</code></p>\n<p>非web环境：<code>`AnnotationConfigApplicationContext</code></p>\n</li>\n<li><p>容器的创建完成后的刷新</p>\n</li>\n</ol>\n<p>这两部分内容较多，挖坑以后填写。</p>\n"},{"title":"【SpringBoot】条件注解","date":"2017-12-08T12:45:21.000Z","_content":"## 条件注解\n\n### ConditionOnClass\n\n以 ConditionOnClass 为例分析：\n\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnClassCondition.class)\npublic @interface ConditionalOnClass {\n\n   // The classes that must be present.\n   Class<?>[] value() default {};\n\n   // The classes names that must be present.\n   String[] name() default {};\n\n}\n```\n\nConditionOnClass 注解使用 Conditional 注解修饰：\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Conditional {\n  \n   // All Conditions that must match in order for the component to be registered.\n   Class<? extends Condition>[] value();\n}\n```\n\nConditional 定义了一个条件数组 Condition[]，条件的定义：\n\n```java\npublic interface Condition {\n   boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);\n}\n```\n\n看一下上面 Conditional 注解使用的 OnClassCondition。\n\n首先其继承于 SpringBootCondition，SpringBoot 中条件注解都继承这个抽象类：\n\n```java\npublic abstract class SpringBootCondition implements Condition {\n\n   @Override\n   public final boolean matches(ConditionContext context,\n         AnnotatedTypeMetadata metadata) {\n      // 得到类名或者方法名(条件注解可以作用的类或者方法上)\n      String classOrMethodName = getClassOrMethodName(metadata);\n      try {\n         // 抽象方法，具体子类实现\n         // ConditionOutcome记录了匹配结果boolean和log信息\n         ConditionOutcome outcome = getMatchOutcome(context, metadata);\n         // log记录一下匹配信息\n         logOutcome(classOrMethodName, outcome);\n         // 报告记录一下匹配信息\n         recordEvaluation(context, classOrMethodName, outcome);\n         return outcome.isMatch();\n      }\n      catch (...) {\n        // ...\n      }\n   }\n\n   // 省略其他\n}\n```\n\nOnClassCondition 实现：\n\n```java\n@Override\npublic ConditionOutcome getMatchOutcome(ConditionContext context,\n      AnnotatedTypeMetadata metadata) {\n   ClassLoader classLoader = context.getClassLoader();\n   ConditionMessage matchMessage = ConditionMessage.empty();\n   // 得到 @ConditionalOnClass 注解的类\n   List<String> onClasses = getCandidates(metadata, ConditionalOnClass.class);\n   if (onClasses != null) {\n      // 如果类存在\n      // 得到在类加载器中不存在的类\n      List<String> missing = getMatches(onClasses, MatchType.MISSING, classLoader);\n      if (!missing.isEmpty()) {\n         // 如果存在类加载器中不存在对应的类，返回一个匹配失败的 ConditionalOutcome\n         return ConditionOutcome\n               .noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)\n                     .didNotFind(\"required class\", \"required classes\")\n                     .items(Style.QUOTE, missing));\n      }\n      // 如果类加载器中有所有的对应类，匹配信息进行记录\n      matchMessage = matchMessage.andCondition(ConditionalOnClass.class)\n            .found(\"required class\", \"required classes\").items(Style.QUOTE,\n                  getMatches(onClasses, MatchType.PRESENT, classLoader));\n   }\n   // 对@ConditionalOnMissingClass注解做相同的逻辑处理\n   // @ConditionalOnClass和@ConditionalOnMissingClass可以一起使用\n   List<String> onMissingClasses = getCandidates(metadata,\n         ConditionalOnMissingClass.class);\n   if (onMissingClasses != null) {\n      List<String> present = getMatches(onMissingClasses, MatchType.PRESENT,\n            classLoader);\n      if (!present.isEmpty()) {\n         return ConditionOutcome.noMatch(\n               ConditionMessage.forCondition(ConditionalOnMissingClass.class)\n                     .found(\"unwanted class\", \"unwanted classes\")\n                     .items(Style.QUOTE, present));\n      }\n      matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)\n            .didNotFind(\"unwanted class\", \"unwanted classes\").items(Style.QUOTE,\n                  getMatches(onMissingClasses, MatchType.MISSING, classLoader));\n   }\n   return ConditionOutcome.match(matchMessage);\n}\n```\n\n### ConditionalOnBean\n\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnBeanCondition.class)\npublic @interface ConditionalOnBean {\n   // 匹配的bean类型\n   Class<?>[] value() default {};\n\n   // 匹配的bean类型的类名\n   String[] type() default {};\n\n   // 匹配的bean注解\n   Class<? extends Annotation>[] annotation() default {};\n\n   // 匹配的bean的名字\n   String[] name() default {};\n\n   // 搜索策略\n   // CURRENT(只在当前容器中找)\n   // PARENTS(只在所有的父容器中找；但是不包括当前容器)\n   // ALL(CURRENT和PARENTS的组合)\n   SearchStrategy search() default SearchStrategy.ALL;\n}\n```\n\nOnBeanCondition 实现：\n\n```java\n@Override\npublic ConditionOutcome getMatchOutcome(ConditionContext context,\n      AnnotatedTypeMetadata metadata) {\n   ConditionMessage matchMessage = ConditionMessage.empty();\n   if (metadata.isAnnotated(ConditionalOnBean.class.getName())) {\n      // 针对 @ConditionalOnBean 注解\n      // 构造一个BeanSearchSpec，会从@ConditionalOnBean注解中获取属性，然后设置到BeanSearchSpec中\n      BeanSearchSpec spec = new BeanSearchSpec(context, metadata,\n            ConditionalOnBean.class);\n      // 从BeanFactory中根据策略找出所有匹配的bean\n      List<String> matching = getMatchingBeans(context, spec);\n      if (matching.isEmpty()) {\n         // 如果没有匹配的bean，返回一个没有匹配成功的ConditionalOutcome\n         return ConditionOutcome.noMatch(\n               ConditionMessage.forCondition(ConditionalOnBean.class, spec)\n                     .didNotFind(\"any beans\").atAll());\n      }\n      // 如果找到匹配的bean，匹配信息进行记录\n      matchMessage = matchMessage.andCondition(ConditionalOnBean.class, spec)\n            .found(\"bean\", \"beans\").items(Style.QUOTE, matching);\n   }\n   if (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) {\n      // 相同的逻辑，针对@ConditionalOnSingleCandidate注解\n      BeanSearchSpec spec = new SingleCandidateBeanSearchSpec(context, metadata,\n            ConditionalOnSingleCandidate.class);\n      List<String> matching = getMatchingBeans(context, spec);\n      if (matching.isEmpty()) {\n         return ConditionOutcome.noMatch(ConditionMessage\n               .forCondition(ConditionalOnSingleCandidate.class, spec)\n               .didNotFind(\"any beans\").atAll());\n      }\n      else if (!hasSingleAutowireCandidate(context.getBeanFactory(), matching,\n            spec.getStrategy() == SearchStrategy.ALL)) {\n         // 多了一层判断，判断是否只有一个bean\n         return ConditionOutcome.noMatch(ConditionMessage\n               .forCondition(ConditionalOnSingleCandidate.class, spec)\n               .didNotFind(\"a primary bean from beans\")\n               .items(Style.QUOTE, matching));\n      }\n      matchMessage = matchMessage\n            .andCondition(ConditionalOnSingleCandidate.class, spec)\n            .found(\"a primary bean from beans\").items(Style.QUOTE, matching);\n   }\n   if (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) {\n      // 相同的逻辑，针对 @ConditionalOnMissingBean 注解\n      BeanSearchSpec spec = new BeanSearchSpec(context, metadata,\n            ConditionalOnMissingBean.class);\n      List<String> matching = getMatchingBeans(context, spec);\n      if (!matching.isEmpty()) {\n         return ConditionOutcome.noMatch(ConditionMessage\n               .forCondition(ConditionalOnMissingBean.class, spec)\n               .found(\"bean\", \"beans\").items(Style.QUOTE, matching));\n      }\n      matchMessage = matchMessage.andCondition(ConditionalOnMissingBean.class, spec)\n            .didNotFind(\"any beans\").atAll();\n   }\n   return ConditionOutcome.match(matchMessage);\n}\n```\n\n## 条件注解激活\n\n[【Spring】容器刷新 ](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/) 中 invokeBeanFactoryPostProcessors 方法会处理 BeanDefinitionRegistryPostProcessor 和 BeanDefinitionRegistryPostProcessor 的实现。其中 ConfigurationClassPostProcessor 是最低优先级执行的 BeanDefinitionRegistryPostProcessor。\n\nConfigurationClassPostProcessor 会使用 ConfigurationClassParser 的 ConditionEvaluator 解析所有 @Configuration 注解的bean。\n\nConfigurationClassParser 使用 ConditionEvaluator 解析：\n\n```java\nif (this.conditionEvaluator.shouldSkip(configClass.getMetadata(),\n                                       ConfigurationPhase.PARSE_CONFIGURATION)) {\n  return;\n}\n```\n\nConditionEvaluator的 shouldSkip 方法：\n\n```java\npublic boolean shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase) {\n   // 如果这个类没有被@Conditional注解所修饰，不会skip\n   if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {\n      return false;\n   }\n   // 如果参数中沒有设置条件注解的生效阶段\n   if (phase == null) {\n      // 是配置类的话直接使用PARSE_CONFIGURATION阶段\n      if (metadata instanceof AnnotationMetadata &&\n            ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) {\n         return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);\n      }\n      // 否则使用REGISTER_BEAN阶段\n      return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);\n   }\n   // 获取配置类的条件注解得到条件数据，并添加到集合中\n   List<Condition> conditions = new ArrayList<Condition>();\n   for (String[] conditionClasses : getConditionClasses(metadata)) {\n      for (String conditionClass : conditionClasses) {\n         Condition condition = getCondition(conditionClass, this.context.getClassLoader());\n         conditions.add(condition);\n      }\n   }\n   // 对条件集合做个排序\n   AnnotationAwareOrderComparator.sort(conditions);\n   // 遍历条件集合\n   for (Condition condition : conditions) {\n      ConfigurationPhase requiredPhase = null;\n      if (condition instanceof ConfigurationCondition) {\n         requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();\n      }\n      // 没有这个解析类不需要阶段的判断或者解析类和参数中的阶段一致才会继续进行\n      if (requiredPhase == null || requiredPhase == phase) {\n         // 不满足条件返回 true\n         if (!condition.matches(this.context, metadata)) {\n            return true;\n         }\n      }\n   }\n   return false;\n}\n```\n\n条件注入激活还是在容器 refresh 过程中，更具体是在 invokeBeanFactoryPostProcessors 方法中解析配置类时，会跳过不满足条件的类。\n\n---\n\n注解条件使用的 demo：[SpringBoot源码分析之条件注解的底层实现](http://fangjian0423.github.io/2017/05/16/springboot-condition-annotation/)\n\n\n","source":"_posts/【SpringBoot】条件注解.md","raw":"---\ntitle: 【SpringBoot】条件注解\ndate: 2017-12-08 20:45:21\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n## 条件注解\n\n### ConditionOnClass\n\n以 ConditionOnClass 为例分析：\n\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnClassCondition.class)\npublic @interface ConditionalOnClass {\n\n   // The classes that must be present.\n   Class<?>[] value() default {};\n\n   // The classes names that must be present.\n   String[] name() default {};\n\n}\n```\n\nConditionOnClass 注解使用 Conditional 注解修饰：\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Conditional {\n  \n   // All Conditions that must match in order for the component to be registered.\n   Class<? extends Condition>[] value();\n}\n```\n\nConditional 定义了一个条件数组 Condition[]，条件的定义：\n\n```java\npublic interface Condition {\n   boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);\n}\n```\n\n看一下上面 Conditional 注解使用的 OnClassCondition。\n\n首先其继承于 SpringBootCondition，SpringBoot 中条件注解都继承这个抽象类：\n\n```java\npublic abstract class SpringBootCondition implements Condition {\n\n   @Override\n   public final boolean matches(ConditionContext context,\n         AnnotatedTypeMetadata metadata) {\n      // 得到类名或者方法名(条件注解可以作用的类或者方法上)\n      String classOrMethodName = getClassOrMethodName(metadata);\n      try {\n         // 抽象方法，具体子类实现\n         // ConditionOutcome记录了匹配结果boolean和log信息\n         ConditionOutcome outcome = getMatchOutcome(context, metadata);\n         // log记录一下匹配信息\n         logOutcome(classOrMethodName, outcome);\n         // 报告记录一下匹配信息\n         recordEvaluation(context, classOrMethodName, outcome);\n         return outcome.isMatch();\n      }\n      catch (...) {\n        // ...\n      }\n   }\n\n   // 省略其他\n}\n```\n\nOnClassCondition 实现：\n\n```java\n@Override\npublic ConditionOutcome getMatchOutcome(ConditionContext context,\n      AnnotatedTypeMetadata metadata) {\n   ClassLoader classLoader = context.getClassLoader();\n   ConditionMessage matchMessage = ConditionMessage.empty();\n   // 得到 @ConditionalOnClass 注解的类\n   List<String> onClasses = getCandidates(metadata, ConditionalOnClass.class);\n   if (onClasses != null) {\n      // 如果类存在\n      // 得到在类加载器中不存在的类\n      List<String> missing = getMatches(onClasses, MatchType.MISSING, classLoader);\n      if (!missing.isEmpty()) {\n         // 如果存在类加载器中不存在对应的类，返回一个匹配失败的 ConditionalOutcome\n         return ConditionOutcome\n               .noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)\n                     .didNotFind(\"required class\", \"required classes\")\n                     .items(Style.QUOTE, missing));\n      }\n      // 如果类加载器中有所有的对应类，匹配信息进行记录\n      matchMessage = matchMessage.andCondition(ConditionalOnClass.class)\n            .found(\"required class\", \"required classes\").items(Style.QUOTE,\n                  getMatches(onClasses, MatchType.PRESENT, classLoader));\n   }\n   // 对@ConditionalOnMissingClass注解做相同的逻辑处理\n   // @ConditionalOnClass和@ConditionalOnMissingClass可以一起使用\n   List<String> onMissingClasses = getCandidates(metadata,\n         ConditionalOnMissingClass.class);\n   if (onMissingClasses != null) {\n      List<String> present = getMatches(onMissingClasses, MatchType.PRESENT,\n            classLoader);\n      if (!present.isEmpty()) {\n         return ConditionOutcome.noMatch(\n               ConditionMessage.forCondition(ConditionalOnMissingClass.class)\n                     .found(\"unwanted class\", \"unwanted classes\")\n                     .items(Style.QUOTE, present));\n      }\n      matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)\n            .didNotFind(\"unwanted class\", \"unwanted classes\").items(Style.QUOTE,\n                  getMatches(onMissingClasses, MatchType.MISSING, classLoader));\n   }\n   return ConditionOutcome.match(matchMessage);\n}\n```\n\n### ConditionalOnBean\n\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnBeanCondition.class)\npublic @interface ConditionalOnBean {\n   // 匹配的bean类型\n   Class<?>[] value() default {};\n\n   // 匹配的bean类型的类名\n   String[] type() default {};\n\n   // 匹配的bean注解\n   Class<? extends Annotation>[] annotation() default {};\n\n   // 匹配的bean的名字\n   String[] name() default {};\n\n   // 搜索策略\n   // CURRENT(只在当前容器中找)\n   // PARENTS(只在所有的父容器中找；但是不包括当前容器)\n   // ALL(CURRENT和PARENTS的组合)\n   SearchStrategy search() default SearchStrategy.ALL;\n}\n```\n\nOnBeanCondition 实现：\n\n```java\n@Override\npublic ConditionOutcome getMatchOutcome(ConditionContext context,\n      AnnotatedTypeMetadata metadata) {\n   ConditionMessage matchMessage = ConditionMessage.empty();\n   if (metadata.isAnnotated(ConditionalOnBean.class.getName())) {\n      // 针对 @ConditionalOnBean 注解\n      // 构造一个BeanSearchSpec，会从@ConditionalOnBean注解中获取属性，然后设置到BeanSearchSpec中\n      BeanSearchSpec spec = new BeanSearchSpec(context, metadata,\n            ConditionalOnBean.class);\n      // 从BeanFactory中根据策略找出所有匹配的bean\n      List<String> matching = getMatchingBeans(context, spec);\n      if (matching.isEmpty()) {\n         // 如果没有匹配的bean，返回一个没有匹配成功的ConditionalOutcome\n         return ConditionOutcome.noMatch(\n               ConditionMessage.forCondition(ConditionalOnBean.class, spec)\n                     .didNotFind(\"any beans\").atAll());\n      }\n      // 如果找到匹配的bean，匹配信息进行记录\n      matchMessage = matchMessage.andCondition(ConditionalOnBean.class, spec)\n            .found(\"bean\", \"beans\").items(Style.QUOTE, matching);\n   }\n   if (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) {\n      // 相同的逻辑，针对@ConditionalOnSingleCandidate注解\n      BeanSearchSpec spec = new SingleCandidateBeanSearchSpec(context, metadata,\n            ConditionalOnSingleCandidate.class);\n      List<String> matching = getMatchingBeans(context, spec);\n      if (matching.isEmpty()) {\n         return ConditionOutcome.noMatch(ConditionMessage\n               .forCondition(ConditionalOnSingleCandidate.class, spec)\n               .didNotFind(\"any beans\").atAll());\n      }\n      else if (!hasSingleAutowireCandidate(context.getBeanFactory(), matching,\n            spec.getStrategy() == SearchStrategy.ALL)) {\n         // 多了一层判断，判断是否只有一个bean\n         return ConditionOutcome.noMatch(ConditionMessage\n               .forCondition(ConditionalOnSingleCandidate.class, spec)\n               .didNotFind(\"a primary bean from beans\")\n               .items(Style.QUOTE, matching));\n      }\n      matchMessage = matchMessage\n            .andCondition(ConditionalOnSingleCandidate.class, spec)\n            .found(\"a primary bean from beans\").items(Style.QUOTE, matching);\n   }\n   if (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) {\n      // 相同的逻辑，针对 @ConditionalOnMissingBean 注解\n      BeanSearchSpec spec = new BeanSearchSpec(context, metadata,\n            ConditionalOnMissingBean.class);\n      List<String> matching = getMatchingBeans(context, spec);\n      if (!matching.isEmpty()) {\n         return ConditionOutcome.noMatch(ConditionMessage\n               .forCondition(ConditionalOnMissingBean.class, spec)\n               .found(\"bean\", \"beans\").items(Style.QUOTE, matching));\n      }\n      matchMessage = matchMessage.andCondition(ConditionalOnMissingBean.class, spec)\n            .didNotFind(\"any beans\").atAll();\n   }\n   return ConditionOutcome.match(matchMessage);\n}\n```\n\n## 条件注解激活\n\n[【Spring】容器刷新 ](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/) 中 invokeBeanFactoryPostProcessors 方法会处理 BeanDefinitionRegistryPostProcessor 和 BeanDefinitionRegistryPostProcessor 的实现。其中 ConfigurationClassPostProcessor 是最低优先级执行的 BeanDefinitionRegistryPostProcessor。\n\nConfigurationClassPostProcessor 会使用 ConfigurationClassParser 的 ConditionEvaluator 解析所有 @Configuration 注解的bean。\n\nConfigurationClassParser 使用 ConditionEvaluator 解析：\n\n```java\nif (this.conditionEvaluator.shouldSkip(configClass.getMetadata(),\n                                       ConfigurationPhase.PARSE_CONFIGURATION)) {\n  return;\n}\n```\n\nConditionEvaluator的 shouldSkip 方法：\n\n```java\npublic boolean shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase) {\n   // 如果这个类没有被@Conditional注解所修饰，不会skip\n   if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {\n      return false;\n   }\n   // 如果参数中沒有设置条件注解的生效阶段\n   if (phase == null) {\n      // 是配置类的话直接使用PARSE_CONFIGURATION阶段\n      if (metadata instanceof AnnotationMetadata &&\n            ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) {\n         return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);\n      }\n      // 否则使用REGISTER_BEAN阶段\n      return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);\n   }\n   // 获取配置类的条件注解得到条件数据，并添加到集合中\n   List<Condition> conditions = new ArrayList<Condition>();\n   for (String[] conditionClasses : getConditionClasses(metadata)) {\n      for (String conditionClass : conditionClasses) {\n         Condition condition = getCondition(conditionClass, this.context.getClassLoader());\n         conditions.add(condition);\n      }\n   }\n   // 对条件集合做个排序\n   AnnotationAwareOrderComparator.sort(conditions);\n   // 遍历条件集合\n   for (Condition condition : conditions) {\n      ConfigurationPhase requiredPhase = null;\n      if (condition instanceof ConfigurationCondition) {\n         requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();\n      }\n      // 没有这个解析类不需要阶段的判断或者解析类和参数中的阶段一致才会继续进行\n      if (requiredPhase == null || requiredPhase == phase) {\n         // 不满足条件返回 true\n         if (!condition.matches(this.context, metadata)) {\n            return true;\n         }\n      }\n   }\n   return false;\n}\n```\n\n条件注入激活还是在容器 refresh 过程中，更具体是在 invokeBeanFactoryPostProcessors 方法中解析配置类时，会跳过不满足条件的类。\n\n---\n\n注解条件使用的 demo：[SpringBoot源码分析之条件注解的底层实现](http://fangjian0423.github.io/2017/05/16/springboot-condition-annotation/)\n\n\n","slug":"【SpringBoot】条件注解","published":1,"updated":"2017-12-08T13:46:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2r3002vd82ek1r4ao13","content":"<h2 id=\"条件注解\"><a href=\"#条件注解\" class=\"headerlink\" title=\"条件注解\"></a>条件注解</h2><h3 id=\"ConditionOnClass\"><a href=\"#ConditionOnClass\" class=\"headerlink\" title=\"ConditionOnClass\"></a>ConditionOnClass</h3><p>以 ConditionOnClass 为例分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"meta\">@Conditional</span>(OnClassCondition.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ConditionalOnClass &#123;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// The classes that must be present.</span></div><div class=\"line\">   Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// The classes names that must be present.</span></div><div class=\"line\">   String[] name() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ConditionOnClass 注解使用 Conditional 注解修饰：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Conditional &#123;</div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// All Conditions that must match in order for the component to be registered.</span></div><div class=\"line\">   Class&lt;? extends Condition&gt;[] value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Conditional 定义了一个条件数组 Condition[]，条件的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Condition</span> </span>&#123;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一下上面 Conditional 注解使用的 OnClassCondition。</p>\n<p>首先其继承于 SpringBootCondition，SpringBoot 中条件注解都继承这个抽象类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringBootCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context,</span></span></div><div class=\"line\">         AnnotatedTypeMetadata metadata) &#123;</div><div class=\"line\">      <span class=\"comment\">// 得到类名或者方法名(条件注解可以作用的类或者方法上)</span></div><div class=\"line\">      String classOrMethodName = getClassOrMethodName(metadata);</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         <span class=\"comment\">// 抽象方法，具体子类实现</span></div><div class=\"line\">         <span class=\"comment\">// ConditionOutcome记录了匹配结果boolean和log信息</span></div><div class=\"line\">         ConditionOutcome outcome = getMatchOutcome(context, metadata);</div><div class=\"line\">         <span class=\"comment\">// log记录一下匹配信息</span></div><div class=\"line\">         logOutcome(classOrMethodName, outcome);</div><div class=\"line\">         <span class=\"comment\">// 报告记录一下匹配信息</span></div><div class=\"line\">         recordEvaluation(context, classOrMethodName, outcome);</div><div class=\"line\">         <span class=\"keyword\">return</span> outcome.isMatch();</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">catch</span> (...) &#123;</div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 省略其他</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>OnClassCondition 实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConditionOutcome <span class=\"title\">getMatchOutcome</span><span class=\"params\">(ConditionContext context,</span></span></div><div class=\"line\">      AnnotatedTypeMetadata metadata) &#123;</div><div class=\"line\">   ClassLoader classLoader = context.getClassLoader();</div><div class=\"line\">   ConditionMessage matchMessage = ConditionMessage.empty();</div><div class=\"line\">   <span class=\"comment\">// 得到 @ConditionalOnClass 注解的类</span></div><div class=\"line\">   List&lt;String&gt; onClasses = getCandidates(metadata, ConditionalOnClass.class);</div><div class=\"line\">   <span class=\"keyword\">if</span> (onClasses != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果类存在</span></div><div class=\"line\">      <span class=\"comment\">// 得到在类加载器中不存在的类</span></div><div class=\"line\">      List&lt;String&gt; missing = getMatches(onClasses, MatchType.MISSING, classLoader);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!missing.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"comment\">// 如果存在类加载器中不存在对应的类，返回一个匹配失败的 ConditionalOutcome</span></div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome</div><div class=\"line\">               .noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)</div><div class=\"line\">                     .didNotFind(<span class=\"string\">\"required class\"</span>, <span class=\"string\">\"required classes\"</span>)</div><div class=\"line\">                     .items(Style.QUOTE, missing));</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 如果类加载器中有所有的对应类，匹配信息进行记录</span></div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnClass.class)</div><div class=\"line\">            .found(<span class=\"string\">\"required class\"</span>, <span class=\"string\">\"required classes\"</span>).items(Style.QUOTE,</div><div class=\"line\">                  getMatches(onClasses, MatchType.PRESENT, classLoader));</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 对@ConditionalOnMissingClass注解做相同的逻辑处理</span></div><div class=\"line\">   <span class=\"comment\">// @ConditionalOnClass和@ConditionalOnMissingClass可以一起使用</span></div><div class=\"line\">   List&lt;String&gt; onMissingClasses = getCandidates(metadata,</div><div class=\"line\">         ConditionalOnMissingClass.class);</div><div class=\"line\">   <span class=\"keyword\">if</span> (onMissingClasses != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      List&lt;String&gt; present = getMatches(onMissingClasses, MatchType.PRESENT,</div><div class=\"line\">            classLoader);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!present.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(</div><div class=\"line\">               ConditionMessage.forCondition(ConditionalOnMissingClass.class)</div><div class=\"line\">                     .found(<span class=\"string\">\"unwanted class\"</span>, <span class=\"string\">\"unwanted classes\"</span>)</div><div class=\"line\">                     .items(Style.QUOTE, present));</div><div class=\"line\">      &#125;</div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)</div><div class=\"line\">            .didNotFind(<span class=\"string\">\"unwanted class\"</span>, <span class=\"string\">\"unwanted classes\"</span>).items(Style.QUOTE,</div><div class=\"line\">                  getMatches(onMissingClasses, MatchType.MISSING, classLoader));</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> ConditionOutcome.match(matchMessage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ConditionalOnBean\"><a href=\"#ConditionalOnBean\" class=\"headerlink\" title=\"ConditionalOnBean\"></a>ConditionalOnBean</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"meta\">@Conditional</span>(OnBeanCondition.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ConditionalOnBean &#123;</div><div class=\"line\">   <span class=\"comment\">// 匹配的bean类型</span></div><div class=\"line\">   Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 匹配的bean类型的类名</span></div><div class=\"line\">   String[] type() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 匹配的bean注解</span></div><div class=\"line\">   Class&lt;? extends Annotation&gt;[] annotation() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 匹配的bean的名字</span></div><div class=\"line\">   String[] name() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 搜索策略</span></div><div class=\"line\">   <span class=\"comment\">// CURRENT(只在当前容器中找)</span></div><div class=\"line\">   <span class=\"comment\">// PARENTS(只在所有的父容器中找；但是不包括当前容器)</span></div><div class=\"line\">   <span class=\"comment\">// ALL(CURRENT和PARENTS的组合)</span></div><div class=\"line\">   <span class=\"function\">SearchStrategy <span class=\"title\">search</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> SearchStrategy.ALL</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>OnBeanCondition 实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConditionOutcome <span class=\"title\">getMatchOutcome</span><span class=\"params\">(ConditionContext context,</span></span></div><div class=\"line\">      AnnotatedTypeMetadata metadata) &#123;</div><div class=\"line\">   ConditionMessage matchMessage = ConditionMessage.empty();</div><div class=\"line\">   <span class=\"keyword\">if</span> (metadata.isAnnotated(ConditionalOnBean.class.getName())) &#123;</div><div class=\"line\">      <span class=\"comment\">// 针对 @ConditionalOnBean 注解</span></div><div class=\"line\">      <span class=\"comment\">// 构造一个BeanSearchSpec，会从@ConditionalOnBean注解中获取属性，然后设置到BeanSearchSpec中</span></div><div class=\"line\">      BeanSearchSpec spec = <span class=\"keyword\">new</span> BeanSearchSpec(context, metadata,</div><div class=\"line\">            ConditionalOnBean.class);</div><div class=\"line\">      <span class=\"comment\">// 从BeanFactory中根据策略找出所有匹配的bean</span></div><div class=\"line\">      List&lt;String&gt; matching = getMatchingBeans(context, spec);</div><div class=\"line\">      <span class=\"keyword\">if</span> (matching.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"comment\">// 如果没有匹配的bean，返回一个没有匹配成功的ConditionalOutcome</span></div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(</div><div class=\"line\">               ConditionMessage.forCondition(ConditionalOnBean.class, spec)</div><div class=\"line\">                     .didNotFind(<span class=\"string\">\"any beans\"</span>).atAll());</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 如果找到匹配的bean，匹配信息进行记录</span></div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnBean.class, spec)</div><div class=\"line\">            .found(<span class=\"string\">\"bean\"</span>, <span class=\"string\">\"beans\"</span>).items(Style.QUOTE, matching);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) &#123;</div><div class=\"line\">      <span class=\"comment\">// 相同的逻辑，针对@ConditionalOnSingleCandidate注解</span></div><div class=\"line\">      BeanSearchSpec spec = <span class=\"keyword\">new</span> SingleCandidateBeanSearchSpec(context, metadata,</div><div class=\"line\">            ConditionalOnSingleCandidate.class);</div><div class=\"line\">      List&lt;String&gt; matching = getMatchingBeans(context, spec);</div><div class=\"line\">      <span class=\"keyword\">if</span> (matching.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(ConditionMessage</div><div class=\"line\">               .forCondition(ConditionalOnSingleCandidate.class, spec)</div><div class=\"line\">               .didNotFind(<span class=\"string\">\"any beans\"</span>).atAll());</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasSingleAutowireCandidate(context.getBeanFactory(), matching,</div><div class=\"line\">            spec.getStrategy() == SearchStrategy.ALL)) &#123;</div><div class=\"line\">         <span class=\"comment\">// 多了一层判断，判断是否只有一个bean</span></div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(ConditionMessage</div><div class=\"line\">               .forCondition(ConditionalOnSingleCandidate.class, spec)</div><div class=\"line\">               .didNotFind(<span class=\"string\">\"a primary bean from beans\"</span>)</div><div class=\"line\">               .items(Style.QUOTE, matching));</div><div class=\"line\">      &#125;</div><div class=\"line\">      matchMessage = matchMessage</div><div class=\"line\">            .andCondition(ConditionalOnSingleCandidate.class, spec)</div><div class=\"line\">            .found(<span class=\"string\">\"a primary bean from beans\"</span>).items(Style.QUOTE, matching);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) &#123;</div><div class=\"line\">      <span class=\"comment\">// 相同的逻辑，针对 @ConditionalOnMissingBean 注解</span></div><div class=\"line\">      BeanSearchSpec spec = <span class=\"keyword\">new</span> BeanSearchSpec(context, metadata,</div><div class=\"line\">            ConditionalOnMissingBean.class);</div><div class=\"line\">      List&lt;String&gt; matching = getMatchingBeans(context, spec);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!matching.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(ConditionMessage</div><div class=\"line\">               .forCondition(ConditionalOnMissingBean.class, spec)</div><div class=\"line\">               .found(<span class=\"string\">\"bean\"</span>, <span class=\"string\">\"beans\"</span>).items(Style.QUOTE, matching));</div><div class=\"line\">      &#125;</div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnMissingBean.class, spec)</div><div class=\"line\">            .didNotFind(<span class=\"string\">\"any beans\"</span>).atAll();</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> ConditionOutcome.match(matchMessage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"条件注解激活\"><a href=\"#条件注解激活\" class=\"headerlink\" title=\"条件注解激活\"></a>条件注解激活</h2><p><a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/\" target=\"_blank\" rel=\"external\">【Spring】容器刷新 </a> 中 invokeBeanFactoryPostProcessors 方法会处理 BeanDefinitionRegistryPostProcessor 和 BeanDefinitionRegistryPostProcessor 的实现。其中 ConfigurationClassPostProcessor 是最低优先级执行的 BeanDefinitionRegistryPostProcessor。</p>\n<p>ConfigurationClassPostProcessor 会使用 ConfigurationClassParser 的 ConditionEvaluator 解析所有 @Configuration 注解的bean。</p>\n<p>ConfigurationClassParser 使用 ConditionEvaluator 解析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(),</div><div class=\"line\">                                       ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ConditionEvaluator的 shouldSkip 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldSkip</span><span class=\"params\">(AnnotatedTypeMetadata metadata, ConfigurationPhase phase)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 如果这个类没有被@Conditional注解所修饰，不会skip</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (metadata == <span class=\"keyword\">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 如果参数中沒有设置条件注解的生效阶段</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (phase == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 是配置类的话直接使用PARSE_CONFIGURATION阶段</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (metadata <span class=\"keyword\">instanceof</span> AnnotationMetadata &amp;&amp;</div><div class=\"line\">            ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 否则使用REGISTER_BEAN阶段</span></div><div class=\"line\">      <span class=\"keyword\">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 获取配置类的条件注解得到条件数据，并添加到集合中</span></div><div class=\"line\">   List&lt;Condition&gt; conditions = <span class=\"keyword\">new</span> ArrayList&lt;Condition&gt;();</div><div class=\"line\">   <span class=\"keyword\">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (String conditionClass : conditionClasses) &#123;</div><div class=\"line\">         Condition condition = getCondition(conditionClass, <span class=\"keyword\">this</span>.context.getClassLoader());</div><div class=\"line\">         conditions.add(condition);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 对条件集合做个排序</span></div><div class=\"line\">   AnnotationAwareOrderComparator.sort(conditions);</div><div class=\"line\">   <span class=\"comment\">// 遍历条件集合</span></div><div class=\"line\">   <span class=\"keyword\">for</span> (Condition condition : conditions) &#123;</div><div class=\"line\">      ConfigurationPhase requiredPhase = <span class=\"keyword\">null</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span> (condition <span class=\"keyword\">instanceof</span> ConfigurationCondition) &#123;</div><div class=\"line\">         requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 没有这个解析类不需要阶段的判断或者解析类和参数中的阶段一致才会继续进行</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (requiredPhase == <span class=\"keyword\">null</span> || requiredPhase == phase) &#123;</div><div class=\"line\">         <span class=\"comment\">// 不满足条件返回 true</span></div><div class=\"line\">         <span class=\"keyword\">if</span> (!condition.matches(<span class=\"keyword\">this</span>.context, metadata)) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>条件注入激活还是在容器 refresh 过程中，更具体是在 invokeBeanFactoryPostProcessors 方法中解析配置类时，会跳过不满足条件的类。</p>\n<hr>\n<p>注解条件使用的 demo：<a href=\"http://fangjian0423.github.io/2017/05/16/springboot-condition-annotation/\" target=\"_blank\" rel=\"external\">SpringBoot源码分析之条件注解的底层实现</a></p>\n","excerpt":"","more":"<h2 id=\"条件注解\"><a href=\"#条件注解\" class=\"headerlink\" title=\"条件注解\"></a>条件注解</h2><h3 id=\"ConditionOnClass\"><a href=\"#ConditionOnClass\" class=\"headerlink\" title=\"ConditionOnClass\"></a>ConditionOnClass</h3><p>以 ConditionOnClass 为例分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"meta\">@Conditional</span>(OnClassCondition.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ConditionalOnClass &#123;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// The classes that must be present.</span></div><div class=\"line\">   Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// The classes names that must be present.</span></div><div class=\"line\">   String[] name() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ConditionOnClass 注解使用 Conditional 注解修饰：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Conditional &#123;</div><div class=\"line\">  </div><div class=\"line\">   <span class=\"comment\">// All Conditions that must match in order for the component to be registered.</span></div><div class=\"line\">   Class&lt;? extends Condition&gt;[] value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Conditional 定义了一个条件数组 Condition[]，条件的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Condition</span> </span>&#123;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一下上面 Conditional 注解使用的 OnClassCondition。</p>\n<p>首先其继承于 SpringBootCondition，SpringBoot 中条件注解都继承这个抽象类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringBootCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context,</div><div class=\"line\">         AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 得到类名或者方法名(条件注解可以作用的类或者方法上)</span></div><div class=\"line\">      String classOrMethodName = getClassOrMethodName(metadata);</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         <span class=\"comment\">// 抽象方法，具体子类实现</span></div><div class=\"line\">         <span class=\"comment\">// ConditionOutcome记录了匹配结果boolean和log信息</span></div><div class=\"line\">         ConditionOutcome outcome = getMatchOutcome(context, metadata);</div><div class=\"line\">         <span class=\"comment\">// log记录一下匹配信息</span></div><div class=\"line\">         logOutcome(classOrMethodName, outcome);</div><div class=\"line\">         <span class=\"comment\">// 报告记录一下匹配信息</span></div><div class=\"line\">         recordEvaluation(context, classOrMethodName, outcome);</div><div class=\"line\">         <span class=\"keyword\">return</span> outcome.isMatch();</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">catch</span> (...) &#123;</div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 省略其他</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>OnClassCondition 实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConditionOutcome <span class=\"title\">getMatchOutcome</span><span class=\"params\">(ConditionContext context,</div><div class=\"line\">      AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class=\"line\">   ClassLoader classLoader = context.getClassLoader();</div><div class=\"line\">   ConditionMessage matchMessage = ConditionMessage.empty();</div><div class=\"line\">   <span class=\"comment\">// 得到 @ConditionalOnClass 注解的类</span></div><div class=\"line\">   List&lt;String&gt; onClasses = getCandidates(metadata, ConditionalOnClass.class);</div><div class=\"line\">   <span class=\"keyword\">if</span> (onClasses != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果类存在</span></div><div class=\"line\">      <span class=\"comment\">// 得到在类加载器中不存在的类</span></div><div class=\"line\">      List&lt;String&gt; missing = getMatches(onClasses, MatchType.MISSING, classLoader);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!missing.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"comment\">// 如果存在类加载器中不存在对应的类，返回一个匹配失败的 ConditionalOutcome</span></div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome</div><div class=\"line\">               .noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)</div><div class=\"line\">                     .didNotFind(<span class=\"string\">\"required class\"</span>, <span class=\"string\">\"required classes\"</span>)</div><div class=\"line\">                     .items(Style.QUOTE, missing));</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 如果类加载器中有所有的对应类，匹配信息进行记录</span></div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnClass.class)</div><div class=\"line\">            .found(<span class=\"string\">\"required class\"</span>, <span class=\"string\">\"required classes\"</span>).items(Style.QUOTE,</div><div class=\"line\">                  getMatches(onClasses, MatchType.PRESENT, classLoader));</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 对@ConditionalOnMissingClass注解做相同的逻辑处理</span></div><div class=\"line\">   <span class=\"comment\">// @ConditionalOnClass和@ConditionalOnMissingClass可以一起使用</span></div><div class=\"line\">   List&lt;String&gt; onMissingClasses = getCandidates(metadata,</div><div class=\"line\">         ConditionalOnMissingClass.class);</div><div class=\"line\">   <span class=\"keyword\">if</span> (onMissingClasses != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      List&lt;String&gt; present = getMatches(onMissingClasses, MatchType.PRESENT,</div><div class=\"line\">            classLoader);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!present.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(</div><div class=\"line\">               ConditionMessage.forCondition(ConditionalOnMissingClass.class)</div><div class=\"line\">                     .found(<span class=\"string\">\"unwanted class\"</span>, <span class=\"string\">\"unwanted classes\"</span>)</div><div class=\"line\">                     .items(Style.QUOTE, present));</div><div class=\"line\">      &#125;</div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)</div><div class=\"line\">            .didNotFind(<span class=\"string\">\"unwanted class\"</span>, <span class=\"string\">\"unwanted classes\"</span>).items(Style.QUOTE,</div><div class=\"line\">                  getMatches(onMissingClasses, MatchType.MISSING, classLoader));</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> ConditionOutcome.match(matchMessage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ConditionalOnBean\"><a href=\"#ConditionalOnBean\" class=\"headerlink\" title=\"ConditionalOnBean\"></a>ConditionalOnBean</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"meta\">@Conditional</span>(OnBeanCondition.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ConditionalOnBean &#123;</div><div class=\"line\">   <span class=\"comment\">// 匹配的bean类型</span></div><div class=\"line\">   Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 匹配的bean类型的类名</span></div><div class=\"line\">   String[] type() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 匹配的bean注解</span></div><div class=\"line\">   Class&lt;? extends Annotation&gt;[] annotation() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 匹配的bean的名字</span></div><div class=\"line\">   String[] name() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 搜索策略</span></div><div class=\"line\">   <span class=\"comment\">// CURRENT(只在当前容器中找)</span></div><div class=\"line\">   <span class=\"comment\">// PARENTS(只在所有的父容器中找；但是不包括当前容器)</span></div><div class=\"line\">   <span class=\"comment\">// ALL(CURRENT和PARENTS的组合)</span></div><div class=\"line\">   <span class=\"function\">SearchStrategy <span class=\"title\">search</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> SearchStrategy.ALL</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>OnBeanCondition 实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConditionOutcome <span class=\"title\">getMatchOutcome</span><span class=\"params\">(ConditionContext context,</div><div class=\"line\">      AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class=\"line\">   ConditionMessage matchMessage = ConditionMessage.empty();</div><div class=\"line\">   <span class=\"keyword\">if</span> (metadata.isAnnotated(ConditionalOnBean.class.getName())) &#123;</div><div class=\"line\">      <span class=\"comment\">// 针对 @ConditionalOnBean 注解</span></div><div class=\"line\">      <span class=\"comment\">// 构造一个BeanSearchSpec，会从@ConditionalOnBean注解中获取属性，然后设置到BeanSearchSpec中</span></div><div class=\"line\">      BeanSearchSpec spec = <span class=\"keyword\">new</span> BeanSearchSpec(context, metadata,</div><div class=\"line\">            ConditionalOnBean.class);</div><div class=\"line\">      <span class=\"comment\">// 从BeanFactory中根据策略找出所有匹配的bean</span></div><div class=\"line\">      List&lt;String&gt; matching = getMatchingBeans(context, spec);</div><div class=\"line\">      <span class=\"keyword\">if</span> (matching.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"comment\">// 如果没有匹配的bean，返回一个没有匹配成功的ConditionalOutcome</span></div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(</div><div class=\"line\">               ConditionMessage.forCondition(ConditionalOnBean.class, spec)</div><div class=\"line\">                     .didNotFind(<span class=\"string\">\"any beans\"</span>).atAll());</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 如果找到匹配的bean，匹配信息进行记录</span></div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnBean.class, spec)</div><div class=\"line\">            .found(<span class=\"string\">\"bean\"</span>, <span class=\"string\">\"beans\"</span>).items(Style.QUOTE, matching);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) &#123;</div><div class=\"line\">      <span class=\"comment\">// 相同的逻辑，针对@ConditionalOnSingleCandidate注解</span></div><div class=\"line\">      BeanSearchSpec spec = <span class=\"keyword\">new</span> SingleCandidateBeanSearchSpec(context, metadata,</div><div class=\"line\">            ConditionalOnSingleCandidate.class);</div><div class=\"line\">      List&lt;String&gt; matching = getMatchingBeans(context, spec);</div><div class=\"line\">      <span class=\"keyword\">if</span> (matching.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(ConditionMessage</div><div class=\"line\">               .forCondition(ConditionalOnSingleCandidate.class, spec)</div><div class=\"line\">               .didNotFind(<span class=\"string\">\"any beans\"</span>).atAll());</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasSingleAutowireCandidate(context.getBeanFactory(), matching,</div><div class=\"line\">            spec.getStrategy() == SearchStrategy.ALL)) &#123;</div><div class=\"line\">         <span class=\"comment\">// 多了一层判断，判断是否只有一个bean</span></div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(ConditionMessage</div><div class=\"line\">               .forCondition(ConditionalOnSingleCandidate.class, spec)</div><div class=\"line\">               .didNotFind(<span class=\"string\">\"a primary bean from beans\"</span>)</div><div class=\"line\">               .items(Style.QUOTE, matching));</div><div class=\"line\">      &#125;</div><div class=\"line\">      matchMessage = matchMessage</div><div class=\"line\">            .andCondition(ConditionalOnSingleCandidate.class, spec)</div><div class=\"line\">            .found(<span class=\"string\">\"a primary bean from beans\"</span>).items(Style.QUOTE, matching);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) &#123;</div><div class=\"line\">      <span class=\"comment\">// 相同的逻辑，针对 @ConditionalOnMissingBean 注解</span></div><div class=\"line\">      BeanSearchSpec spec = <span class=\"keyword\">new</span> BeanSearchSpec(context, metadata,</div><div class=\"line\">            ConditionalOnMissingBean.class);</div><div class=\"line\">      List&lt;String&gt; matching = getMatchingBeans(context, spec);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!matching.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(ConditionMessage</div><div class=\"line\">               .forCondition(ConditionalOnMissingBean.class, spec)</div><div class=\"line\">               .found(<span class=\"string\">\"bean\"</span>, <span class=\"string\">\"beans\"</span>).items(Style.QUOTE, matching));</div><div class=\"line\">      &#125;</div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnMissingBean.class, spec)</div><div class=\"line\">            .didNotFind(<span class=\"string\">\"any beans\"</span>).atAll();</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> ConditionOutcome.match(matchMessage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"条件注解激活\"><a href=\"#条件注解激活\" class=\"headerlink\" title=\"条件注解激活\"></a>条件注解激活</h2><p><a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/\">【Spring】容器刷新 </a> 中 invokeBeanFactoryPostProcessors 方法会处理 BeanDefinitionRegistryPostProcessor 和 BeanDefinitionRegistryPostProcessor 的实现。其中 ConfigurationClassPostProcessor 是最低优先级执行的 BeanDefinitionRegistryPostProcessor。</p>\n<p>ConfigurationClassPostProcessor 会使用 ConfigurationClassParser 的 ConditionEvaluator 解析所有 @Configuration 注解的bean。</p>\n<p>ConfigurationClassParser 使用 ConditionEvaluator 解析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(),</div><div class=\"line\">                                       ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ConditionEvaluator的 shouldSkip 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldSkip</span><span class=\"params\">(AnnotatedTypeMetadata metadata, ConfigurationPhase phase)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 如果这个类没有被@Conditional注解所修饰，不会skip</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (metadata == <span class=\"keyword\">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 如果参数中沒有设置条件注解的生效阶段</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (phase == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 是配置类的话直接使用PARSE_CONFIGURATION阶段</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (metadata <span class=\"keyword\">instanceof</span> AnnotationMetadata &amp;&amp;</div><div class=\"line\">            ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 否则使用REGISTER_BEAN阶段</span></div><div class=\"line\">      <span class=\"keyword\">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 获取配置类的条件注解得到条件数据，并添加到集合中</span></div><div class=\"line\">   List&lt;Condition&gt; conditions = <span class=\"keyword\">new</span> ArrayList&lt;Condition&gt;();</div><div class=\"line\">   <span class=\"keyword\">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (String conditionClass : conditionClasses) &#123;</div><div class=\"line\">         Condition condition = getCondition(conditionClass, <span class=\"keyword\">this</span>.context.getClassLoader());</div><div class=\"line\">         conditions.add(condition);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 对条件集合做个排序</span></div><div class=\"line\">   AnnotationAwareOrderComparator.sort(conditions);</div><div class=\"line\">   <span class=\"comment\">// 遍历条件集合</span></div><div class=\"line\">   <span class=\"keyword\">for</span> (Condition condition : conditions) &#123;</div><div class=\"line\">      ConfigurationPhase requiredPhase = <span class=\"keyword\">null</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span> (condition <span class=\"keyword\">instanceof</span> ConfigurationCondition) &#123;</div><div class=\"line\">         requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 没有这个解析类不需要阶段的判断或者解析类和参数中的阶段一致才会继续进行</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (requiredPhase == <span class=\"keyword\">null</span> || requiredPhase == phase) &#123;</div><div class=\"line\">         <span class=\"comment\">// 不满足条件返回 true</span></div><div class=\"line\">         <span class=\"keyword\">if</span> (!condition.matches(<span class=\"keyword\">this</span>.context, metadata)) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>条件注入激活还是在容器 refresh 过程中，更具体是在 invokeBeanFactoryPostProcessors 方法中解析配置类时，会跳过不满足条件的类。</p>\n<hr>\n<p>注解条件使用的 demo：<a href=\"http://fangjian0423.github.io/2017/05/16/springboot-condition-annotation/\">SpringBoot源码分析之条件注解的底层实现</a></p>\n"},{"title":"【SpringBoot】监听器篇","date":"2017-07-05T13:26:09.000Z","_content":"还是先回顾前文：\n\n- 包文件启动：从`JarLauncher`的`main`方法启动，加载各种资源后，开启一个新的线程调用程序的`main`方法\n- `SpringApplication`实例创建：判断是否是web环境，加载并实例化初始化器和监听器，查找`main`方法所在类\n\n至此终于可以运行`SpringApplication`的非静态`run`方法了：\n\n```java\n\tpublic ConfigurableApplicationContext run(String... args) {\n\t\tStopWatch stopWatch = new StopWatch();\n\t\tstopWatch.start();\n\t\tConfigurableApplicationContext context = null;\n\t\tFailureAnalyzers analyzers = null;\n\t\tconfigureHeadlessProperty();\n\t\tSpringApplicationRunListeners listeners = getRunListeners(args);\n\t\tlisteners.starting();\n\t\ttry {\n\t\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(\n\t\t\t\t\targs);\n\t\t\tConfigurableEnvironment environment = prepareEnvironment(listeners,\n\t\t\t\t\tapplicationArguments);\n\t\t\tBanner printedBanner = printBanner(environment);\n\t\t\tcontext = createApplicationContext();\n\t\t\tanalyzers = new FailureAnalyzers(context);\n\t\t\tprepareContext(context, environment, listeners, applicationArguments,\n\t\t\t\t\tprintedBanner);\n\t\t\trefreshContext(context);\n\t\t\tafterRefresh(context, applicationArguments);\n\t\t\tlisteners.finished(context, null);\n\t\t\tstopWatch.stop();\n\t\t\tif (this.logStartupInfo) {\n\t\t\t\tnew StartupInfoLogger(this.mainApplicationClass)\n\t\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);\n\t\t\t}\n\t\t\treturn context;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleRunFailure(context, listeners, analyzers, ex);\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}\n```\n\n整个方法中间穿插着listener的各种操作，本文就先看看listen的操作。\n\n## 监听器加载、实例化\n\n```java\n\tpublic ConfigurableApplicationContext run(String... args) {\n\t\t// ...\n\t\tSpringApplicationRunListeners listeners = getRunListeners(args);\n    \t// ...\n    }  \n\n\tprivate SpringApplicationRunListeners getRunListeners(String[] args) {\n\t\tClass<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };\n\t\treturn new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(\n\t\t\t\tSpringApplicationRunListener.class, types, this, args));\n\t}\n```\n\n加载的逻辑和上一篇文章提到的初始化器加载方式一致，都是从配置文件`META-INF/spring.factories`中加载：\n\n```properties\n# Run Listeners\norg.springframework.boot.SpringApplicationRunListener=\\\norg.springframework.boot.context.event.EventPublishingRunListener\n```\n\n加载并实例化`EventPublishingRunListener`之后，与`logger`实例一起创建了`SpringApplicationRunListeners`，其类图：\n\n![SpringApplicationRunListeners](https://ooo.0o0.ooo/2017/06/23/594cbdc2572ef.png)\n\n### 监听器实现\n\n上面配置文件中的两个类`SpringApplicationRunListener`和`EventPublishingRunListener`分别就是监听器的接口和实现。\n\n接口中定义了五个方法都是围绕着容器的生命周期的：\n\n1. `starting`：run方法首次调用\n2. `environmentPrepared`：`ApplicationContext`创建之前并且环境信息准备好的时候调用\n3. `contextPrepared`：`ApplicationContext`创建好并且在source加载之前调用一次\n4. `contextLoaded`：`ApplicationContext`创建并加载之后并在refresh之前调用\n5. `finished`：`run`方法结束之前调用\n\n`EventPublishingRunListener`的实例创建：\n\n```java\n\tpublic EventPublishingRunListener(SpringApplication application, String[] args) {\n\t\tthis.application = application;\n\t\tthis.args = args;\n\t\tthis.initialMulticaster = new SimpleApplicationEventMulticaster();\n\t\tfor (ApplicationListener<?> listener : application.getListeners()) {\n\t\t\tthis.initialMulticaster.addApplicationListener(listener);\n\t\t}\n\t}\n```\n\n实例的创建过程中创建了一个`SimpleApplicationEventMulticaster`实例，并且从上文创建的`SpringApplication`的实例中获取了所有的监听器并追加到了`SimpleApplicationEventMulticaster`实例。\n\n`SimpleApplicationEventMulticaster`是一个 Spring 事件体系的一员，用于将事件广播给监听者。\n\n这里就是讲事件广播给上一篇文章提及的加载并实例化的监听器。\n\n因此`EventPublishingRunListener`的实现类似与：\n\n```java\n@Override\n@SuppressWarnings(\"deprecation\")\npublic void starting() {\n    // 构造事件，使用事件广播者发送事件\n\tthis.initialMulticaster\n\t\t\t.multicastEvent(new ApplicationStartedEvent(this.application, this.args));\n}\n```\n\n从调用顺序上：\n\n![监听事件](https://ooo.0o0.ooo/2017/06/23/594cbe5e3a355.jpg)\n\n`SpringApplication`持有了`SpringApplicationRunListeners`就间接掌管了所有的`ApplicationListener`了，想执行哪个`applicationListener`只要调用对应的`applicationListener`所监听的事件就可以了。\n\n这里再看看上一篇文章初始化的监听器，例如`LiquibaseServiceLocatorApplicationListener`，其在实现`ApplicationListener`接口的同时，还指定了泛型，用于限定具体的事件类型：\n\n```java\npublic class LiquibaseServiceLocatorApplicationListener\n\t\timplements ApplicationListener<ApplicationStartingEvent> {\n\t//...\n\t@Override\n\tpublic void onApplicationEvent(ApplicationStartingEvent event) {\n\t\tif (ClassUtils.isPresent(\"liquibase.servicelocator.ServiceLocator\", null)) {\n\t\t\tnew LiquibasePresent().replaceServiceLocator();\n\t\t}\n\t}\n\t//...\n}\n```\n\n## 事件发布\n\n上面已经看到 Spring Boot 是如何加载，实例化事件的了。除了 Spring Boot 内部定义的时间，也可以自定义事件\n\n### 事件类型\n\nSpring Boot支持的事件类型：\n\n- ApplicationStartingEvent\n- ApplicationEnvironmentPreparedEvent\n- ApplicationFailedEvent\n- ApplicationPreparedEvent\n\n### 自定义事件\n\n使用泛型指定具体的事件类型，例如（以T代表具体的事件类型）：\n\n```java\n\tpublic class MyApplicationStartedEventListener implements ApplicationListener<T> {\n    \t@Override\n    \tpublic void onApplicationEvent(T event) {\n    \t}\n\t}\n```\n\n### 发布事件\n\n- 使用 API 发布\n\n  ```java\n  public static void main(String[] args) {\n      SpringApplication app = new SpringApplication(ListenerApplication.class);\n      app.addListeners(\n              new MyApplicationStartedEventListener(),\n              new MyApplicationEnvironmentPreparedEventListener(),\n              new MyApplicationPreparedEventListener(),\n              new MyApplicationFailedEventListener());\n      app.run(args);\n  }\n  ```\n\n- 配置文件\n\n  如加载事件的过程分析，可以在工程下添加`META-INF/spring.factories`文件，在文件内指自定义事件：\n\n  ```properties\n  org.springframework.context.ApplicationListener=\n  ```\n","source":"_posts/【SpringBoot】监听器篇.md","raw":"---\ntitle: 【SpringBoot】监听器篇\ndate: 2017-07-05 21:26:09\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n还是先回顾前文：\n\n- 包文件启动：从`JarLauncher`的`main`方法启动，加载各种资源后，开启一个新的线程调用程序的`main`方法\n- `SpringApplication`实例创建：判断是否是web环境，加载并实例化初始化器和监听器，查找`main`方法所在类\n\n至此终于可以运行`SpringApplication`的非静态`run`方法了：\n\n```java\n\tpublic ConfigurableApplicationContext run(String... args) {\n\t\tStopWatch stopWatch = new StopWatch();\n\t\tstopWatch.start();\n\t\tConfigurableApplicationContext context = null;\n\t\tFailureAnalyzers analyzers = null;\n\t\tconfigureHeadlessProperty();\n\t\tSpringApplicationRunListeners listeners = getRunListeners(args);\n\t\tlisteners.starting();\n\t\ttry {\n\t\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(\n\t\t\t\t\targs);\n\t\t\tConfigurableEnvironment environment = prepareEnvironment(listeners,\n\t\t\t\t\tapplicationArguments);\n\t\t\tBanner printedBanner = printBanner(environment);\n\t\t\tcontext = createApplicationContext();\n\t\t\tanalyzers = new FailureAnalyzers(context);\n\t\t\tprepareContext(context, environment, listeners, applicationArguments,\n\t\t\t\t\tprintedBanner);\n\t\t\trefreshContext(context);\n\t\t\tafterRefresh(context, applicationArguments);\n\t\t\tlisteners.finished(context, null);\n\t\t\tstopWatch.stop();\n\t\t\tif (this.logStartupInfo) {\n\t\t\t\tnew StartupInfoLogger(this.mainApplicationClass)\n\t\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);\n\t\t\t}\n\t\t\treturn context;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleRunFailure(context, listeners, analyzers, ex);\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}\n```\n\n整个方法中间穿插着listener的各种操作，本文就先看看listen的操作。\n\n## 监听器加载、实例化\n\n```java\n\tpublic ConfigurableApplicationContext run(String... args) {\n\t\t// ...\n\t\tSpringApplicationRunListeners listeners = getRunListeners(args);\n    \t// ...\n    }  \n\n\tprivate SpringApplicationRunListeners getRunListeners(String[] args) {\n\t\tClass<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };\n\t\treturn new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(\n\t\t\t\tSpringApplicationRunListener.class, types, this, args));\n\t}\n```\n\n加载的逻辑和上一篇文章提到的初始化器加载方式一致，都是从配置文件`META-INF/spring.factories`中加载：\n\n```properties\n# Run Listeners\norg.springframework.boot.SpringApplicationRunListener=\\\norg.springframework.boot.context.event.EventPublishingRunListener\n```\n\n加载并实例化`EventPublishingRunListener`之后，与`logger`实例一起创建了`SpringApplicationRunListeners`，其类图：\n\n![SpringApplicationRunListeners](https://ooo.0o0.ooo/2017/06/23/594cbdc2572ef.png)\n\n### 监听器实现\n\n上面配置文件中的两个类`SpringApplicationRunListener`和`EventPublishingRunListener`分别就是监听器的接口和实现。\n\n接口中定义了五个方法都是围绕着容器的生命周期的：\n\n1. `starting`：run方法首次调用\n2. `environmentPrepared`：`ApplicationContext`创建之前并且环境信息准备好的时候调用\n3. `contextPrepared`：`ApplicationContext`创建好并且在source加载之前调用一次\n4. `contextLoaded`：`ApplicationContext`创建并加载之后并在refresh之前调用\n5. `finished`：`run`方法结束之前调用\n\n`EventPublishingRunListener`的实例创建：\n\n```java\n\tpublic EventPublishingRunListener(SpringApplication application, String[] args) {\n\t\tthis.application = application;\n\t\tthis.args = args;\n\t\tthis.initialMulticaster = new SimpleApplicationEventMulticaster();\n\t\tfor (ApplicationListener<?> listener : application.getListeners()) {\n\t\t\tthis.initialMulticaster.addApplicationListener(listener);\n\t\t}\n\t}\n```\n\n实例的创建过程中创建了一个`SimpleApplicationEventMulticaster`实例，并且从上文创建的`SpringApplication`的实例中获取了所有的监听器并追加到了`SimpleApplicationEventMulticaster`实例。\n\n`SimpleApplicationEventMulticaster`是一个 Spring 事件体系的一员，用于将事件广播给监听者。\n\n这里就是讲事件广播给上一篇文章提及的加载并实例化的监听器。\n\n因此`EventPublishingRunListener`的实现类似与：\n\n```java\n@Override\n@SuppressWarnings(\"deprecation\")\npublic void starting() {\n    // 构造事件，使用事件广播者发送事件\n\tthis.initialMulticaster\n\t\t\t.multicastEvent(new ApplicationStartedEvent(this.application, this.args));\n}\n```\n\n从调用顺序上：\n\n![监听事件](https://ooo.0o0.ooo/2017/06/23/594cbe5e3a355.jpg)\n\n`SpringApplication`持有了`SpringApplicationRunListeners`就间接掌管了所有的`ApplicationListener`了，想执行哪个`applicationListener`只要调用对应的`applicationListener`所监听的事件就可以了。\n\n这里再看看上一篇文章初始化的监听器，例如`LiquibaseServiceLocatorApplicationListener`，其在实现`ApplicationListener`接口的同时，还指定了泛型，用于限定具体的事件类型：\n\n```java\npublic class LiquibaseServiceLocatorApplicationListener\n\t\timplements ApplicationListener<ApplicationStartingEvent> {\n\t//...\n\t@Override\n\tpublic void onApplicationEvent(ApplicationStartingEvent event) {\n\t\tif (ClassUtils.isPresent(\"liquibase.servicelocator.ServiceLocator\", null)) {\n\t\t\tnew LiquibasePresent().replaceServiceLocator();\n\t\t}\n\t}\n\t//...\n}\n```\n\n## 事件发布\n\n上面已经看到 Spring Boot 是如何加载，实例化事件的了。除了 Spring Boot 内部定义的时间，也可以自定义事件\n\n### 事件类型\n\nSpring Boot支持的事件类型：\n\n- ApplicationStartingEvent\n- ApplicationEnvironmentPreparedEvent\n- ApplicationFailedEvent\n- ApplicationPreparedEvent\n\n### 自定义事件\n\n使用泛型指定具体的事件类型，例如（以T代表具体的事件类型）：\n\n```java\n\tpublic class MyApplicationStartedEventListener implements ApplicationListener<T> {\n    \t@Override\n    \tpublic void onApplicationEvent(T event) {\n    \t}\n\t}\n```\n\n### 发布事件\n\n- 使用 API 发布\n\n  ```java\n  public static void main(String[] args) {\n      SpringApplication app = new SpringApplication(ListenerApplication.class);\n      app.addListeners(\n              new MyApplicationStartedEventListener(),\n              new MyApplicationEnvironmentPreparedEventListener(),\n              new MyApplicationPreparedEventListener(),\n              new MyApplicationFailedEventListener());\n      app.run(args);\n  }\n  ```\n\n- 配置文件\n\n  如加载事件的过程分析，可以在工程下添加`META-INF/spring.factories`文件，在文件内指自定义事件：\n\n  ```properties\n  org.springframework.context.ApplicationListener=\n  ```\n","slug":"【SpringBoot】监听器篇","published":1,"updated":"2017-07-05T13:27:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2r90030d82eijwsipvj","content":"<p>还是先回顾前文：</p>\n<ul>\n<li>包文件启动：从<code>JarLauncher</code>的<code>main</code>方法启动，加载各种资源后，开启一个新的线程调用程序的<code>main</code>方法</li>\n<li><code>SpringApplication</code>实例创建：判断是否是web环境，加载并实例化初始化器和监听器，查找<code>main</code>方法所在类</li>\n</ul>\n<p>至此终于可以运行<code>SpringApplication</code>的非静态<code>run</code>方法了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</div><div class=\"line\">\tStopWatch stopWatch = <span class=\"keyword\">new</span> StopWatch();</div><div class=\"line\">\tstopWatch.start();</div><div class=\"line\">\tConfigurableApplicationContext context = <span class=\"keyword\">null</span>;</div><div class=\"line\">\tFailureAnalyzers analyzers = <span class=\"keyword\">null</span>;</div><div class=\"line\">\tconfigureHeadlessProperty();</div><div class=\"line\">\tSpringApplicationRunListeners listeners = getRunListeners(args);</div><div class=\"line\">\tlisteners.starting();</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(</div><div class=\"line\">\t\t\t\targs);</div><div class=\"line\">\t\tConfigurableEnvironment environment = prepareEnvironment(listeners,</div><div class=\"line\">\t\t\t\tapplicationArguments);</div><div class=\"line\">\t\tBanner printedBanner = printBanner(environment);</div><div class=\"line\">\t\tcontext = createApplicationContext();</div><div class=\"line\">\t\tanalyzers = <span class=\"keyword\">new</span> FailureAnalyzers(context);</div><div class=\"line\">\t\tprepareContext(context, environment, listeners, applicationArguments,</div><div class=\"line\">\t\t\t\tprintedBanner);</div><div class=\"line\">\t\trefreshContext(context);</div><div class=\"line\">\t\tafterRefresh(context, applicationArguments);</div><div class=\"line\">\t\tlisteners.finished(context, <span class=\"keyword\">null</span>);</div><div class=\"line\">\t\tstopWatch.stop();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass)</div><div class=\"line\">\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> context;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">\t\thandleRunFailure(context, listeners, analyzers, ex);</div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>整个方法中间穿插着listener的各种操作，本文就先看看listen的操作。</p>\n<h2 id=\"监听器加载、实例化\"><a href=\"#监听器加载、实例化\" class=\"headerlink\" title=\"监听器加载、实例化\"></a>监听器加载、实例化</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// ...</span></div><div class=\"line\">\tSpringApplicationRunListeners listeners = getRunListeners(args);</div><div class=\"line\">   \t<span class=\"comment\">// ...</span></div><div class=\"line\">   &#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SpringApplicationRunListeners <span class=\"title\">getRunListeners</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tClass&lt;?&gt;[] types = <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</div><div class=\"line\">\t\t\tSpringApplicationRunListener.class, types, <span class=\"keyword\">this</span>, args));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>加载的逻辑和上一篇文章提到的初始化器加载方式一致，都是从配置文件<code>META-INF/spring.factories</code>中加载：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Run Listeners</div><div class=\"line\">org.springframework.boot.SpringApplicationRunListener=\\</div><div class=\"line\">org.springframework.boot.context.event.EventPublishingRunListener</div></pre></td></tr></table></figure>\n<p>加载并实例化<code>EventPublishingRunListener</code>之后，与<code>logger</code>实例一起创建了<code>SpringApplicationRunListeners</code>，其类图：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/23/594cbdc2572ef.png\" alt=\"SpringApplicationRunListeners\"></p>\n<h3 id=\"监听器实现\"><a href=\"#监听器实现\" class=\"headerlink\" title=\"监听器实现\"></a>监听器实现</h3><p>上面配置文件中的两个类<code>SpringApplicationRunListener</code>和<code>EventPublishingRunListener</code>分别就是监听器的接口和实现。</p>\n<p>接口中定义了五个方法都是围绕着容器的生命周期的：</p>\n<ol>\n<li><code>starting</code>：run方法首次调用</li>\n<li><code>environmentPrepared</code>：<code>ApplicationContext</code>创建之前并且环境信息准备好的时候调用</li>\n<li><code>contextPrepared</code>：<code>ApplicationContext</code>创建好并且在source加载之前调用一次</li>\n<li><code>contextLoaded</code>：<code>ApplicationContext</code>创建并加载之后并在refresh之前调用</li>\n<li><code>finished</code>：<code>run</code>方法结束之前调用</li>\n</ol>\n<p><code>EventPublishingRunListener</code>的实例创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EventPublishingRunListener</span><span class=\"params\">(SpringApplication application, String[] args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.application = application;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.args = args;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.initialMulticaster = <span class=\"keyword\">new</span> SimpleApplicationEventMulticaster();</div><div class=\"line\">\t<span class=\"keyword\">for</span> (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.initialMulticaster.addApplicationListener(listener);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实例的创建过程中创建了一个<code>SimpleApplicationEventMulticaster</code>实例，并且从上文创建的<code>SpringApplication</code>的实例中获取了所有的监听器并追加到了<code>SimpleApplicationEventMulticaster</code>实例。</p>\n<p><code>SimpleApplicationEventMulticaster</code>是一个 Spring 事件体系的一员，用于将事件广播给监听者。</p>\n<p>这里就是讲事件广播给上一篇文章提及的加载并实例化的监听器。</p>\n<p>因此<code>EventPublishingRunListener</code>的实现类似与：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"deprecation\"</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">starting</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 构造事件，使用事件广播者发送事件</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.initialMulticaster</div><div class=\"line\">\t\t\t.multicastEvent(<span class=\"keyword\">new</span> ApplicationStartedEvent(<span class=\"keyword\">this</span>.application, <span class=\"keyword\">this</span>.args));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从调用顺序上：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/23/594cbe5e3a355.jpg\" alt=\"监听事件\"></p>\n<p><code>SpringApplication</code>持有了<code>SpringApplicationRunListeners</code>就间接掌管了所有的<code>ApplicationListener</code>了，想执行哪个<code>applicationListener</code>只要调用对应的<code>applicationListener</code>所监听的事件就可以了。</p>\n<p>这里再看看上一篇文章初始化的监听器，例如<code>LiquibaseServiceLocatorApplicationListener</code>，其在实现<code>ApplicationListener</code>接口的同时，还指定了泛型，用于限定具体的事件类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiquibaseServiceLocatorApplicationListener</span></span></div><div class=\"line\">\t\t<span class=\"keyword\">implements</span> <span class=\"title\">ApplicationListener</span>&lt;<span class=\"title\">ApplicationStartingEvent</span>&gt; &#123;</div><div class=\"line\">\t<span class=\"comment\">//...</span></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(ApplicationStartingEvent event)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (ClassUtils.isPresent(<span class=\"string\">\"liquibase.servicelocator.ServiceLocator\"</span>, <span class=\"keyword\">null</span>)) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">new</span> LiquibasePresent().replaceServiceLocator();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"事件发布\"><a href=\"#事件发布\" class=\"headerlink\" title=\"事件发布\"></a>事件发布</h2><p>上面已经看到 Spring Boot 是如何加载，实例化事件的了。除了 Spring Boot 内部定义的时间，也可以自定义事件</p>\n<h3 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h3><p>Spring Boot支持的事件类型：</p>\n<ul>\n<li>ApplicationStartingEvent</li>\n<li>ApplicationEnvironmentPreparedEvent</li>\n<li>ApplicationFailedEvent</li>\n<li>ApplicationPreparedEvent</li>\n</ul>\n<h3 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h3><p>使用泛型指定具体的事件类型，例如（以T代表具体的事件类型）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplicationStartedEventListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationListener</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">   \t<span class=\"meta\">@Override</span></div><div class=\"line\">   \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(T event)</span> </span>&#123;</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"发布事件\"><a href=\"#发布事件\" class=\"headerlink\" title=\"发布事件\"></a>发布事件</h3><ul>\n<li><p>使用 API 发布</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    SpringApplication app = <span class=\"keyword\">new</span> SpringApplication(ListenerApplication.class);</div><div class=\"line\">    app.addListeners(</div><div class=\"line\">            <span class=\"keyword\">new</span> MyApplicationStartedEventListener(),</div><div class=\"line\">            <span class=\"keyword\">new</span> MyApplicationEnvironmentPreparedEventListener(),</div><div class=\"line\">            <span class=\"keyword\">new</span> MyApplicationPreparedEventListener(),</div><div class=\"line\">            <span class=\"keyword\">new</span> MyApplicationFailedEventListener());</div><div class=\"line\">    app.run(args);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>配置文件</p>\n<p>如加载事件的过程分析，可以在工程下添加<code>META-INF/spring.factories</code>文件，在文件内指自定义事件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">org.springframework.context.ApplicationListener=</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","excerpt":"","more":"<p>还是先回顾前文：</p>\n<ul>\n<li>包文件启动：从<code>JarLauncher</code>的<code>main</code>方法启动，加载各种资源后，开启一个新的线程调用程序的<code>main</code>方法</li>\n<li><code>SpringApplication</code>实例创建：判断是否是web环境，加载并实例化初始化器和监听器，查找<code>main</code>方法所在类</li>\n</ul>\n<p>至此终于可以运行<code>SpringApplication</code>的非静态<code>run</code>方法了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</div><div class=\"line\">\tStopWatch stopWatch = <span class=\"keyword\">new</span> StopWatch();</div><div class=\"line\">\tstopWatch.start();</div><div class=\"line\">\tConfigurableApplicationContext context = <span class=\"keyword\">null</span>;</div><div class=\"line\">\tFailureAnalyzers analyzers = <span class=\"keyword\">null</span>;</div><div class=\"line\">\tconfigureHeadlessProperty();</div><div class=\"line\">\tSpringApplicationRunListeners listeners = getRunListeners(args);</div><div class=\"line\">\tlisteners.starting();</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(</div><div class=\"line\">\t\t\t\targs);</div><div class=\"line\">\t\tConfigurableEnvironment environment = prepareEnvironment(listeners,</div><div class=\"line\">\t\t\t\tapplicationArguments);</div><div class=\"line\">\t\tBanner printedBanner = printBanner(environment);</div><div class=\"line\">\t\tcontext = createApplicationContext();</div><div class=\"line\">\t\tanalyzers = <span class=\"keyword\">new</span> FailureAnalyzers(context);</div><div class=\"line\">\t\tprepareContext(context, environment, listeners, applicationArguments,</div><div class=\"line\">\t\t\t\tprintedBanner);</div><div class=\"line\">\t\trefreshContext(context);</div><div class=\"line\">\t\tafterRefresh(context, applicationArguments);</div><div class=\"line\">\t\tlisteners.finished(context, <span class=\"keyword\">null</span>);</div><div class=\"line\">\t\tstopWatch.stop();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass)</div><div class=\"line\">\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> context;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">\t\thandleRunFailure(context, listeners, analyzers, ex);</div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>整个方法中间穿插着listener的各种操作，本文就先看看listen的操作。</p>\n<h2 id=\"监听器加载、实例化\"><a href=\"#监听器加载、实例化\" class=\"headerlink\" title=\"监听器加载、实例化\"></a>监听器加载、实例化</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// ...</span></div><div class=\"line\">\tSpringApplicationRunListeners listeners = getRunListeners(args);</div><div class=\"line\">   \t<span class=\"comment\">// ...</span></div><div class=\"line\">   &#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SpringApplicationRunListeners <span class=\"title\">getRunListeners</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tClass&lt;?&gt;[] types = <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</div><div class=\"line\">\t\t\tSpringApplicationRunListener.class, types, <span class=\"keyword\">this</span>, args));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>加载的逻辑和上一篇文章提到的初始化器加载方式一致，都是从配置文件<code>META-INF/spring.factories</code>中加载：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Run Listeners</div><div class=\"line\">org.springframework.boot.SpringApplicationRunListener=\\</div><div class=\"line\">org.springframework.boot.context.event.EventPublishingRunListener</div></pre></td></tr></table></figure>\n<p>加载并实例化<code>EventPublishingRunListener</code>之后，与<code>logger</code>实例一起创建了<code>SpringApplicationRunListeners</code>，其类图：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/23/594cbdc2572ef.png\" alt=\"SpringApplicationRunListeners\"></p>\n<h3 id=\"监听器实现\"><a href=\"#监听器实现\" class=\"headerlink\" title=\"监听器实现\"></a>监听器实现</h3><p>上面配置文件中的两个类<code>SpringApplicationRunListener</code>和<code>EventPublishingRunListener</code>分别就是监听器的接口和实现。</p>\n<p>接口中定义了五个方法都是围绕着容器的生命周期的：</p>\n<ol>\n<li><code>starting</code>：run方法首次调用</li>\n<li><code>environmentPrepared</code>：<code>ApplicationContext</code>创建之前并且环境信息准备好的时候调用</li>\n<li><code>contextPrepared</code>：<code>ApplicationContext</code>创建好并且在source加载之前调用一次</li>\n<li><code>contextLoaded</code>：<code>ApplicationContext</code>创建并加载之后并在refresh之前调用</li>\n<li><code>finished</code>：<code>run</code>方法结束之前调用</li>\n</ol>\n<p><code>EventPublishingRunListener</code>的实例创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EventPublishingRunListener</span><span class=\"params\">(SpringApplication application, String[] args)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.application = application;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.args = args;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.initialMulticaster = <span class=\"keyword\">new</span> SimpleApplicationEventMulticaster();</div><div class=\"line\">\t<span class=\"keyword\">for</span> (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.initialMulticaster.addApplicationListener(listener);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实例的创建过程中创建了一个<code>SimpleApplicationEventMulticaster</code>实例，并且从上文创建的<code>SpringApplication</code>的实例中获取了所有的监听器并追加到了<code>SimpleApplicationEventMulticaster</code>实例。</p>\n<p><code>SimpleApplicationEventMulticaster</code>是一个 Spring 事件体系的一员，用于将事件广播给监听者。</p>\n<p>这里就是讲事件广播给上一篇文章提及的加载并实例化的监听器。</p>\n<p>因此<code>EventPublishingRunListener</code>的实现类似与：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"deprecation\"</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">starting</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 构造事件，使用事件广播者发送事件</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.initialMulticaster</div><div class=\"line\">\t\t\t.multicastEvent(<span class=\"keyword\">new</span> ApplicationStartedEvent(<span class=\"keyword\">this</span>.application, <span class=\"keyword\">this</span>.args));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从调用顺序上：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/23/594cbe5e3a355.jpg\" alt=\"监听事件\"></p>\n<p><code>SpringApplication</code>持有了<code>SpringApplicationRunListeners</code>就间接掌管了所有的<code>ApplicationListener</code>了，想执行哪个<code>applicationListener</code>只要调用对应的<code>applicationListener</code>所监听的事件就可以了。</p>\n<p>这里再看看上一篇文章初始化的监听器，例如<code>LiquibaseServiceLocatorApplicationListener</code>，其在实现<code>ApplicationListener</code>接口的同时，还指定了泛型，用于限定具体的事件类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiquibaseServiceLocatorApplicationListener</span></div><div class=\"line\">\t\t<span class=\"keyword\">implements</span> <span class=\"title\">ApplicationListener</span>&lt;<span class=\"title\">ApplicationStartingEvent</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//...</span></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(ApplicationStartingEvent event)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (ClassUtils.isPresent(<span class=\"string\">\"liquibase.servicelocator.ServiceLocator\"</span>, <span class=\"keyword\">null</span>)) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">new</span> LiquibasePresent().replaceServiceLocator();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"事件发布\"><a href=\"#事件发布\" class=\"headerlink\" title=\"事件发布\"></a>事件发布</h2><p>上面已经看到 Spring Boot 是如何加载，实例化事件的了。除了 Spring Boot 内部定义的时间，也可以自定义事件</p>\n<h3 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h3><p>Spring Boot支持的事件类型：</p>\n<ul>\n<li>ApplicationStartingEvent</li>\n<li>ApplicationEnvironmentPreparedEvent</li>\n<li>ApplicationFailedEvent</li>\n<li>ApplicationPreparedEvent</li>\n</ul>\n<h3 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h3><p>使用泛型指定具体的事件类型，例如（以T代表具体的事件类型）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplicationStartedEventListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationListener</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">   \t<span class=\"meta\">@Override</span></div><div class=\"line\">   \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(T event)</span> </span>&#123;</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"发布事件\"><a href=\"#发布事件\" class=\"headerlink\" title=\"发布事件\"></a>发布事件</h3><ul>\n<li><p>使用 API 发布</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">    SpringApplication app = <span class=\"keyword\">new</span> SpringApplication(ListenerApplication.class);</div><div class=\"line\">    app.addListeners(</div><div class=\"line\">            <span class=\"keyword\">new</span> MyApplicationStartedEventListener(),</div><div class=\"line\">            <span class=\"keyword\">new</span> MyApplicationEnvironmentPreparedEventListener(),</div><div class=\"line\">            <span class=\"keyword\">new</span> MyApplicationPreparedEventListener(),</div><div class=\"line\">            <span class=\"keyword\">new</span> MyApplicationFailedEventListener());</div><div class=\"line\">    app.run(args);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>配置文件</p>\n<p>如加载事件的过程分析，可以在工程下添加<code>META-INF/spring.factories</code>文件，在文件内指自定义事件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">org.springframework.context.ApplicationListener=</div></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"【SpringBoot】配置加载","date":"2017-09-18T14:14:15.000Z","_content":"\n前面的文章已经基本讲清楚从 Spring Boot 应用完整的启动过程了，不过中间过程缺少自动配置相关的功能实现说明。\n\n我把功能配置分为两个部分：\n\n- 自动化配置\n- 条件注解\n\n以上两个功能极大的简化了 Spring Boot 应用的配置\n\n## 自动化配置\n\n要弄清自动化配置的起源就得从入口类的 SpringBootApplication 注解说起：\n\n```java\n@EnableAutoConfiguration\npublic @interface SpringBootApplication {\n  // 省略注解的字段，别名\n}\n```\n\nSpringBootApplication 作为一个组合注解，配置的功能是其核心功能，这部分功能由 EnableAutoConfiguration 注解实现。 EnableAutoConfiguration  也是个符合注解：\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import({EnableAutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n    Class<?>[] exclude() default {};\n    String[] excludeName() default {};\n}\n```\n\nEnableAutoConfiguration 的关键是导入了 EnableAutoConfigurationImportSelector ，这类继承自 AutoConfigurationImportSelector。在 Spring 容器刷新的过程中的 invokeBeanFactoryPostProcessors 方法会调用到 EnableAutoConfigurationImportSelector 的逻辑：\n\n```java\n// EnableAutoConfigurationImportSelector\n@Override\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n   if (!isEnabled(annotationMetadata)) {\n      return NO_IMPORTS;\n   }\n   try {\n      // 获取注解属性\n      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n            .loadMetadata(this.beanClassLoader);\n      AnnotationAttributes attributes = getAttributes(annotationMetadata);\n      // 读取spring.factories属性文件中的数据\n      List<String> configurations = getCandidateConfigurations(annotationMetadata,\n            attributes);\n      // 删除重复的配置类\n      configurations = removeDuplicates(configurations);\n      configurations = sort(configurations, autoConfigurationMetadata);\n      // 找到@EnableAutoConfiguration注解中定义的需要被过滤的配置类\n      Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n      checkExcludedClasses(configurations, exclusions);\n      // 删除这些需要被过滤的配置类\n      configurations.removeAll(exclusions);\n      configurations = filter(configurations, autoConfigurationMetadata);\n      fireAutoConfigurationImportListeners(configurations, exclusions);\n      // 返回最终得到的自动化配置类\n      return configurations.toArray(new String[configurations.size()]);\n   }\n   catch (IOException ex) {\n      throw new IllegalStateException(ex);\n   }\n}\n\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata,\n      AnnotationAttributes attributes) {\n   // 调用SpringFactoriesLoader的loadFactoryNames静态方法\n   // getSpringFactoriesLoaderFactoryClass方法返回的是EnableAutoConfiguration类对象\n   List<String> configurations = SpringFactoriesLoader.loadFactoryNames(\n         getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());\n   Assert.notEmpty(configurations,\n         \"No auto configuration classes found in META-INF/spring.factories. If you \"\n               + \"are using a custom packaging, make sure that file is correct.\");\n   return configurations;\n}\n```\n\nEnableAutoConfigurationImportSelector 会使用 SpringFactoriesLoader 加载相应的配置\n\n```java\n// SpringFactoriesLoader \npublic static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n   // 解析出properties文件中需要的key值\n   String factoryClassName = factoryClass.getName();\n   try {\n      // 常量FACTORIES_RESOURCE_LOCATION的值为META-INF/spring.factories\n      // 使用类加载器找META-INF/spring.factories资源\n      Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n      List<String> result = new ArrayList<String>();\n      while (urls.hasMoreElements()) {\n         URL url = urls.nextElement();\n         Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));\n         String factoryClassNames = properties.getProperty(factoryClassName);\n         result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\n      }\n      return result;\n   }\n   catch (IOException ex) {\n      throw new IllegalArgumentException(\"Unable to load [\" + factoryClass.getName() +\n            \"] factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex);\n   }\n}\n```\n\n## 条件注解\n\n### 条件注解实现\n\n以常见的 ConditionalOnClass 注解为例：\n\n```\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnClassCondition.class)\npublic @interface ConditionalOnClass {\n   Class<?>[] value() default {};  // 要匹配的类\n   String[] name() default {};  // 要匹配的类名\n}\n```\n\n必要重要的是 Conditional 注解：\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface Conditional {\n   Class<? extends Condition>[] value();\n}\n```\n\n从命名可以看出 Conditional 注解的  value 属性是具体的 Condition 实现，Spring Boot 提供了通用的 Condition 抽象类： SpringBootCondition，其完成了具体匹配逻辑之外的其他模板：\n\n```java\n// SpringBootCondition\n\n@Override\npublic final boolean matches(ConditionContext context,\n      AnnotatedTypeMetadata metadata) {\n   // 获得类名或方法名\n   String classOrMethodName = getClassOrMethodName(metadata);\n   try {\n      // 抽象方法由子类实现匹配逻辑\n      // 返回结构包装了匹配结果和log信息\n      ConditionOutcome outcome = getMatchOutcome(context, metadata);\n      // log\n      logOutcome(classOrMethodName, outcome);\n      // 报告一下\n      recordEvaluation(context, classOrMethodName, outcome);\n      // 返回匹配结果\n      return outcome.isMatch();\n   }\n   catch // 省略异常处理\n}\n```\n\n具体到 ConditionalOnClass 使用的是 OnClassCondition：\n\n```java\n@Override\npublic ConditionOutcome getMatchOutcome(ConditionContext context,\n      AnnotatedTypeMetadata metadata) {\n   ClassLoader classLoader = context.getClassLoader();\n   ConditionMessage matchMessage = ConditionMessage.empty();\n   // 获得 ConditionalOnClass 注解的属性\n   List<String> onClasses = getCandidates(metadata, ConditionalOnClass.class);\n   if (onClasses != null) {\n      // 属性不为空\n      // 获取具体缺失的类\n      List<String> missing = getMatches(onClasses, MatchType.MISSING, classLoader);\n      if (!missing.isEmpty()) {\n         return ConditionOutcome\n               .noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)\n                     .didNotFind(\"required class\", \"required classes\")\n                     .items(Style.QUOTE, missing));\n      }\n      matchMessage = matchMessage.andCondition(ConditionalOnClass.class)\n            .found(\"required class\", \"required classes\").items(Style.QUOTE,\n                  getMatches(onClasses, MatchType.PRESENT, classLoader));\n   }\n   // 获得 ConditionalOnMissingClass 注解的属性\n   List<String> onMissingClasses = getCandidates(metadata,\n         ConditionalOnMissingClass.class);\n   if (onMissingClasses != null) {\n      List<String> present = getMatches(onMissingClasses, MatchType.PRESENT,\n            classLoader);\n      if (!present.isEmpty()) {\n         return ConditionOutcome.noMatch(\n               ConditionMessage.forCondition(ConditionalOnMissingClass.class)\n                     .found(\"unwanted class\", \"unwanted classes\")\n                     .items(Style.QUOTE, present));\n      }\n      matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)\n            .didNotFind(\"unwanted class\", \"unwanted classes\").items(Style.QUOTE,\n                  getMatches(onMissingClasses, MatchType.MISSING, classLoader));\n   }\n   // 返回全部匹配成功的ConditionalOutcome\n   return ConditionOutcome.match(matchMessage);\n}\n```\n\n### 条件注解激活\n\n这里又要从 Spring 容器的 refresh 方法说起了，这个方法太重要了。其中的 invokeBeanFactoryPostProcessors 方法调用 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor 的处理逻辑，在 bean 实例化阶段开始之前，对注册到容器的 BeanDefinition 保存的原始数据做出修改。与条件注解激活有关的 posstProcessor 是 ConfigurationClassPostProcessor，其实现自 BeanFactoryPostProcessor 。\n\nConfigurationClassPostProcessor 会从 BeanFactory 中找出所有被 @Configuration 直接或间接注解的类（包括 @Component, @ComponentScan, @Import, @ImportResource 修饰的类）进行解析。对解析的结果使用 ConditionEvaluator 进行过滤判断。判断逻辑：\n\n```java\npublic boolean shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase) {\n   // \n   if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {\n      return false;\n   }\n\n   if (phase == null) {\n      if (metadata instanceof AnnotationMetadata &&\n            ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) {\n         return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);\n      }\n      return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);\n   }\n\n   List<Condition> conditions = new ArrayList<Condition>();\n   for (String[] conditionClasses : getConditionClasses(metadata)) {\n      for (String conditionClass : conditionClasses) {\n         Condition condition = getCondition(conditionClass, this.context.getClassLoader());\n         conditions.add(condition);\n      }\n   }\n\n   AnnotationAwareOrderComparator.sort(conditions);\n\n   for (Condition condition : conditions) {\n      ConfigurationPhase requiredPhase = null;\n      if (condition instanceof ConfigurationCondition) {\n         requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();\n      }\n      if (requiredPhase == null || requiredPhase == phase) {\n         if (!condition.matches(this.context, metadata)) {\n            return true;\n         }\n      }\n   }\n\n   return false;\n}\n```\n\n其中 ConfigurationCondition 是 Condition 的子接口，内部主要定义了枚举类型表示条件注解生效的阶段：\n\n```java\npublic interface ConfigurationCondition extends Condition {\n   ConfigurationPhase getConfigurationPhase();\n   enum ConfigurationPhase {\n      PARSE_CONFIGURATION,\n      REGISTER_BEAN\n   }\n}\n```\n\n完整的 ConfigurationClassPostProcessor 处理逻辑：\n\n![configuration-annotation-process.png](https://i.loli.net/2017/08/29/59a4d381568f6.png)\n\n---\n\n参考：[SpringBoot源码分析之Spring容器的refresh过程](http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/)\n","source":"_posts/【SpringBoot】配置加载.md","raw":"---\ntitle: 【SpringBoot】配置加载\ndate: 2017-09-18 22:14:15\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n\n前面的文章已经基本讲清楚从 Spring Boot 应用完整的启动过程了，不过中间过程缺少自动配置相关的功能实现说明。\n\n我把功能配置分为两个部分：\n\n- 自动化配置\n- 条件注解\n\n以上两个功能极大的简化了 Spring Boot 应用的配置\n\n## 自动化配置\n\n要弄清自动化配置的起源就得从入口类的 SpringBootApplication 注解说起：\n\n```java\n@EnableAutoConfiguration\npublic @interface SpringBootApplication {\n  // 省略注解的字段，别名\n}\n```\n\nSpringBootApplication 作为一个组合注解，配置的功能是其核心功能，这部分功能由 EnableAutoConfiguration 注解实现。 EnableAutoConfiguration  也是个符合注解：\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import({EnableAutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n    Class<?>[] exclude() default {};\n    String[] excludeName() default {};\n}\n```\n\nEnableAutoConfiguration 的关键是导入了 EnableAutoConfigurationImportSelector ，这类继承自 AutoConfigurationImportSelector。在 Spring 容器刷新的过程中的 invokeBeanFactoryPostProcessors 方法会调用到 EnableAutoConfigurationImportSelector 的逻辑：\n\n```java\n// EnableAutoConfigurationImportSelector\n@Override\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n   if (!isEnabled(annotationMetadata)) {\n      return NO_IMPORTS;\n   }\n   try {\n      // 获取注解属性\n      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n            .loadMetadata(this.beanClassLoader);\n      AnnotationAttributes attributes = getAttributes(annotationMetadata);\n      // 读取spring.factories属性文件中的数据\n      List<String> configurations = getCandidateConfigurations(annotationMetadata,\n            attributes);\n      // 删除重复的配置类\n      configurations = removeDuplicates(configurations);\n      configurations = sort(configurations, autoConfigurationMetadata);\n      // 找到@EnableAutoConfiguration注解中定义的需要被过滤的配置类\n      Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n      checkExcludedClasses(configurations, exclusions);\n      // 删除这些需要被过滤的配置类\n      configurations.removeAll(exclusions);\n      configurations = filter(configurations, autoConfigurationMetadata);\n      fireAutoConfigurationImportListeners(configurations, exclusions);\n      // 返回最终得到的自动化配置类\n      return configurations.toArray(new String[configurations.size()]);\n   }\n   catch (IOException ex) {\n      throw new IllegalStateException(ex);\n   }\n}\n\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata,\n      AnnotationAttributes attributes) {\n   // 调用SpringFactoriesLoader的loadFactoryNames静态方法\n   // getSpringFactoriesLoaderFactoryClass方法返回的是EnableAutoConfiguration类对象\n   List<String> configurations = SpringFactoriesLoader.loadFactoryNames(\n         getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());\n   Assert.notEmpty(configurations,\n         \"No auto configuration classes found in META-INF/spring.factories. If you \"\n               + \"are using a custom packaging, make sure that file is correct.\");\n   return configurations;\n}\n```\n\nEnableAutoConfigurationImportSelector 会使用 SpringFactoriesLoader 加载相应的配置\n\n```java\n// SpringFactoriesLoader \npublic static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n   // 解析出properties文件中需要的key值\n   String factoryClassName = factoryClass.getName();\n   try {\n      // 常量FACTORIES_RESOURCE_LOCATION的值为META-INF/spring.factories\n      // 使用类加载器找META-INF/spring.factories资源\n      Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n      List<String> result = new ArrayList<String>();\n      while (urls.hasMoreElements()) {\n         URL url = urls.nextElement();\n         Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));\n         String factoryClassNames = properties.getProperty(factoryClassName);\n         result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\n      }\n      return result;\n   }\n   catch (IOException ex) {\n      throw new IllegalArgumentException(\"Unable to load [\" + factoryClass.getName() +\n            \"] factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex);\n   }\n}\n```\n\n## 条件注解\n\n### 条件注解实现\n\n以常见的 ConditionalOnClass 注解为例：\n\n```\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnClassCondition.class)\npublic @interface ConditionalOnClass {\n   Class<?>[] value() default {};  // 要匹配的类\n   String[] name() default {};  // 要匹配的类名\n}\n```\n\n必要重要的是 Conditional 注解：\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface Conditional {\n   Class<? extends Condition>[] value();\n}\n```\n\n从命名可以看出 Conditional 注解的  value 属性是具体的 Condition 实现，Spring Boot 提供了通用的 Condition 抽象类： SpringBootCondition，其完成了具体匹配逻辑之外的其他模板：\n\n```java\n// SpringBootCondition\n\n@Override\npublic final boolean matches(ConditionContext context,\n      AnnotatedTypeMetadata metadata) {\n   // 获得类名或方法名\n   String classOrMethodName = getClassOrMethodName(metadata);\n   try {\n      // 抽象方法由子类实现匹配逻辑\n      // 返回结构包装了匹配结果和log信息\n      ConditionOutcome outcome = getMatchOutcome(context, metadata);\n      // log\n      logOutcome(classOrMethodName, outcome);\n      // 报告一下\n      recordEvaluation(context, classOrMethodName, outcome);\n      // 返回匹配结果\n      return outcome.isMatch();\n   }\n   catch // 省略异常处理\n}\n```\n\n具体到 ConditionalOnClass 使用的是 OnClassCondition：\n\n```java\n@Override\npublic ConditionOutcome getMatchOutcome(ConditionContext context,\n      AnnotatedTypeMetadata metadata) {\n   ClassLoader classLoader = context.getClassLoader();\n   ConditionMessage matchMessage = ConditionMessage.empty();\n   // 获得 ConditionalOnClass 注解的属性\n   List<String> onClasses = getCandidates(metadata, ConditionalOnClass.class);\n   if (onClasses != null) {\n      // 属性不为空\n      // 获取具体缺失的类\n      List<String> missing = getMatches(onClasses, MatchType.MISSING, classLoader);\n      if (!missing.isEmpty()) {\n         return ConditionOutcome\n               .noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)\n                     .didNotFind(\"required class\", \"required classes\")\n                     .items(Style.QUOTE, missing));\n      }\n      matchMessage = matchMessage.andCondition(ConditionalOnClass.class)\n            .found(\"required class\", \"required classes\").items(Style.QUOTE,\n                  getMatches(onClasses, MatchType.PRESENT, classLoader));\n   }\n   // 获得 ConditionalOnMissingClass 注解的属性\n   List<String> onMissingClasses = getCandidates(metadata,\n         ConditionalOnMissingClass.class);\n   if (onMissingClasses != null) {\n      List<String> present = getMatches(onMissingClasses, MatchType.PRESENT,\n            classLoader);\n      if (!present.isEmpty()) {\n         return ConditionOutcome.noMatch(\n               ConditionMessage.forCondition(ConditionalOnMissingClass.class)\n                     .found(\"unwanted class\", \"unwanted classes\")\n                     .items(Style.QUOTE, present));\n      }\n      matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)\n            .didNotFind(\"unwanted class\", \"unwanted classes\").items(Style.QUOTE,\n                  getMatches(onMissingClasses, MatchType.MISSING, classLoader));\n   }\n   // 返回全部匹配成功的ConditionalOutcome\n   return ConditionOutcome.match(matchMessage);\n}\n```\n\n### 条件注解激活\n\n这里又要从 Spring 容器的 refresh 方法说起了，这个方法太重要了。其中的 invokeBeanFactoryPostProcessors 方法调用 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor 的处理逻辑，在 bean 实例化阶段开始之前，对注册到容器的 BeanDefinition 保存的原始数据做出修改。与条件注解激活有关的 posstProcessor 是 ConfigurationClassPostProcessor，其实现自 BeanFactoryPostProcessor 。\n\nConfigurationClassPostProcessor 会从 BeanFactory 中找出所有被 @Configuration 直接或间接注解的类（包括 @Component, @ComponentScan, @Import, @ImportResource 修饰的类）进行解析。对解析的结果使用 ConditionEvaluator 进行过滤判断。判断逻辑：\n\n```java\npublic boolean shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase) {\n   // \n   if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {\n      return false;\n   }\n\n   if (phase == null) {\n      if (metadata instanceof AnnotationMetadata &&\n            ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) {\n         return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);\n      }\n      return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);\n   }\n\n   List<Condition> conditions = new ArrayList<Condition>();\n   for (String[] conditionClasses : getConditionClasses(metadata)) {\n      for (String conditionClass : conditionClasses) {\n         Condition condition = getCondition(conditionClass, this.context.getClassLoader());\n         conditions.add(condition);\n      }\n   }\n\n   AnnotationAwareOrderComparator.sort(conditions);\n\n   for (Condition condition : conditions) {\n      ConfigurationPhase requiredPhase = null;\n      if (condition instanceof ConfigurationCondition) {\n         requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();\n      }\n      if (requiredPhase == null || requiredPhase == phase) {\n         if (!condition.matches(this.context, metadata)) {\n            return true;\n         }\n      }\n   }\n\n   return false;\n}\n```\n\n其中 ConfigurationCondition 是 Condition 的子接口，内部主要定义了枚举类型表示条件注解生效的阶段：\n\n```java\npublic interface ConfigurationCondition extends Condition {\n   ConfigurationPhase getConfigurationPhase();\n   enum ConfigurationPhase {\n      PARSE_CONFIGURATION,\n      REGISTER_BEAN\n   }\n}\n```\n\n完整的 ConfigurationClassPostProcessor 处理逻辑：\n\n![configuration-annotation-process.png](https://i.loli.net/2017/08/29/59a4d381568f6.png)\n\n---\n\n参考：[SpringBoot源码分析之Spring容器的refresh过程](http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/)\n","slug":"【SpringBoot】配置加载","published":1,"updated":"2017-09-18T14:15:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2rc0033d82exdtw77y5","content":"<p>前面的文章已经基本讲清楚从 Spring Boot 应用完整的启动过程了，不过中间过程缺少自动配置相关的功能实现说明。</p>\n<p>我把功能配置分为两个部分：</p>\n<ul>\n<li>自动化配置</li>\n<li>条件注解</li>\n</ul>\n<p>以上两个功能极大的简化了 Spring Boot 应用的配置</p>\n<h2 id=\"自动化配置\"><a href=\"#自动化配置\" class=\"headerlink\" title=\"自动化配置\"></a>自动化配置</h2><p>要弄清自动化配置的起源就得从入口类的 SpringBootApplication 注解说起：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</div><div class=\"line\">  <span class=\"comment\">// 省略注解的字段，别名</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>SpringBootApplication 作为一个组合注解，配置的功能是其核心功能，这部分功能由 EnableAutoConfiguration 注解实现。 EnableAutoConfiguration  也是个符合注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"meta\">@Inherited</span></div><div class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></div><div class=\"line\"><span class=\"meta\">@Import</span>(&#123;EnableAutoConfigurationImportSelector.class&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</div><div class=\"line\">    String ENABLED_OVERRIDE_PROPERTY = <span class=\"string\">\"spring.boot.enableautoconfiguration\"</span>;</div><div class=\"line\">    Class&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\">    String[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>EnableAutoConfiguration 的关键是导入了 EnableAutoConfigurationImportSelector ，这类继承自 AutoConfigurationImportSelector。在 Spring 容器刷新的过程中的 invokeBeanFactoryPostProcessors 方法会调用到 EnableAutoConfigurationImportSelector 的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// EnableAutoConfigurationImportSelector</span></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (!isEnabled(annotationMetadata)) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> NO_IMPORTS;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 获取注解属性</span></div><div class=\"line\">      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</div><div class=\"line\">            .loadMetadata(<span class=\"keyword\">this</span>.beanClassLoader);</div><div class=\"line\">      AnnotationAttributes attributes = getAttributes(annotationMetadata);</div><div class=\"line\">      <span class=\"comment\">// 读取spring.factories属性文件中的数据</span></div><div class=\"line\">      List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</div><div class=\"line\">            attributes);</div><div class=\"line\">      <span class=\"comment\">// 删除重复的配置类</span></div><div class=\"line\">      configurations = removeDuplicates(configurations);</div><div class=\"line\">      configurations = sort(configurations, autoConfigurationMetadata);</div><div class=\"line\">      <span class=\"comment\">// 找到@EnableAutoConfiguration注解中定义的需要被过滤的配置类</span></div><div class=\"line\">      Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</div><div class=\"line\">      checkExcludedClasses(configurations, exclusions);</div><div class=\"line\">      <span class=\"comment\">// 删除这些需要被过滤的配置类</span></div><div class=\"line\">      configurations.removeAll(exclusions);</div><div class=\"line\">      configurations = filter(configurations, autoConfigurationMetadata);</div><div class=\"line\">      fireAutoConfigurationImportListeners(configurations, exclusions);</div><div class=\"line\">      <span class=\"comment\">// 返回最终得到的自动化配置类</span></div><div class=\"line\">      <span class=\"keyword\">return</span> configurations.toArray(<span class=\"keyword\">new</span> String[configurations.size()]);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> (IOException ex) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> List&lt;String&gt; <span class=\"title\">getCandidateConfigurations</span><span class=\"params\">(AnnotationMetadata metadata,</span></span></div><div class=\"line\">      AnnotationAttributes attributes) &#123;</div><div class=\"line\">   <span class=\"comment\">// 调用SpringFactoriesLoader的loadFactoryNames静态方法</span></div><div class=\"line\">   <span class=\"comment\">// getSpringFactoriesLoaderFactoryClass方法返回的是EnableAutoConfiguration类对象</span></div><div class=\"line\">   List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</div><div class=\"line\">         getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</div><div class=\"line\">   Assert.notEmpty(configurations,</div><div class=\"line\">         <span class=\"string\">\"No auto configuration classes found in META-INF/spring.factories. If you \"</span></div><div class=\"line\">               + <span class=\"string\">\"are using a custom packaging, make sure that file is correct.\"</span>);</div><div class=\"line\">   <span class=\"keyword\">return</span> configurations;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>EnableAutoConfigurationImportSelector 会使用 SpringFactoriesLoader 加载相应的配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// SpringFactoriesLoader </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">loadFactoryNames</span><span class=\"params\">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 解析出properties文件中需要的key值</span></div><div class=\"line\">   String factoryClassName = factoryClass.getName();</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 常量FACTORIES_RESOURCE_LOCATION的值为META-INF/spring.factories</span></div><div class=\"line\">      <span class=\"comment\">// 使用类加载器找META-INF/spring.factories资源</span></div><div class=\"line\">      Enumeration&lt;URL&gt; urls = (classLoader != <span class=\"keyword\">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</div><div class=\"line\">            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</div><div class=\"line\">      List&lt;String&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\">      <span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</div><div class=\"line\">         URL url = urls.nextElement();</div><div class=\"line\">         Properties properties = PropertiesLoaderUtils.loadProperties(<span class=\"keyword\">new</span> UrlResource(url));</div><div class=\"line\">         String factoryClassNames = properties.getProperty(factoryClassName);</div><div class=\"line\">         result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> result;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> (IOException ex) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unable to load [\"</span> + factoryClass.getName() +</div><div class=\"line\">            <span class=\"string\">\"] factories from location [\"</span> + FACTORIES_RESOURCE_LOCATION + <span class=\"string\">\"]\"</span>, ex);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"条件注解\"><a href=\"#条件注解\" class=\"headerlink\" title=\"条件注解\"></a>条件注解</h2><h3 id=\"条件注解实现\"><a href=\"#条件注解实现\" class=\"headerlink\" title=\"条件注解实现\"></a>条件注解实现</h3><p>以常见的 ConditionalOnClass 注解为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@Documented</div><div class=\"line\">@Conditional(OnClassCondition.class)</div><div class=\"line\">public @interface ConditionalOnClass &#123;</div><div class=\"line\">   Class&lt;?&gt;[] value() default &#123;&#125;;  // 要匹配的类</div><div class=\"line\">   String[] name() default &#123;&#125;;  // 要匹配的类名</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>必要重要的是 Conditional 注解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class=\"line\">public @interface Conditional &#123;</div><div class=\"line\">   Class&lt;? extends Condition&gt;[] value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从命名可以看出 Conditional 注解的  value 属性是具体的 Condition 实现，Spring Boot 提供了通用的 Condition 抽象类： SpringBootCondition，其完成了具体匹配逻辑之外的其他模板：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// SpringBootCondition</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context,</span></span></div><div class=\"line\">      AnnotatedTypeMetadata metadata) &#123;</div><div class=\"line\">   <span class=\"comment\">// 获得类名或方法名</span></div><div class=\"line\">   String classOrMethodName = getClassOrMethodName(metadata);</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 抽象方法由子类实现匹配逻辑</span></div><div class=\"line\">      <span class=\"comment\">// 返回结构包装了匹配结果和log信息</span></div><div class=\"line\">      ConditionOutcome outcome = getMatchOutcome(context, metadata);</div><div class=\"line\">      <span class=\"comment\">// log</span></div><div class=\"line\">      logOutcome(classOrMethodName, outcome);</div><div class=\"line\">      <span class=\"comment\">// 报告一下</span></div><div class=\"line\">      recordEvaluation(context, classOrMethodName, outcome);</div><div class=\"line\">      <span class=\"comment\">// 返回匹配结果</span></div><div class=\"line\">      <span class=\"keyword\">return</span> outcome.isMatch();</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> <span class=\"comment\">// 省略异常处理</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体到 ConditionalOnClass 使用的是 OnClassCondition：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConditionOutcome <span class=\"title\">getMatchOutcome</span><span class=\"params\">(ConditionContext context,</span></span></div><div class=\"line\">      AnnotatedTypeMetadata metadata) &#123;</div><div class=\"line\">   ClassLoader classLoader = context.getClassLoader();</div><div class=\"line\">   ConditionMessage matchMessage = ConditionMessage.empty();</div><div class=\"line\">   <span class=\"comment\">// 获得 ConditionalOnClass 注解的属性</span></div><div class=\"line\">   List&lt;String&gt; onClasses = getCandidates(metadata, ConditionalOnClass.class);</div><div class=\"line\">   <span class=\"keyword\">if</span> (onClasses != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 属性不为空</span></div><div class=\"line\">      <span class=\"comment\">// 获取具体缺失的类</span></div><div class=\"line\">      List&lt;String&gt; missing = getMatches(onClasses, MatchType.MISSING, classLoader);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!missing.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome</div><div class=\"line\">               .noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)</div><div class=\"line\">                     .didNotFind(<span class=\"string\">\"required class\"</span>, <span class=\"string\">\"required classes\"</span>)</div><div class=\"line\">                     .items(Style.QUOTE, missing));</div><div class=\"line\">      &#125;</div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnClass.class)</div><div class=\"line\">            .found(<span class=\"string\">\"required class\"</span>, <span class=\"string\">\"required classes\"</span>).items(Style.QUOTE,</div><div class=\"line\">                  getMatches(onClasses, MatchType.PRESENT, classLoader));</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 获得 ConditionalOnMissingClass 注解的属性</span></div><div class=\"line\">   List&lt;String&gt; onMissingClasses = getCandidates(metadata,</div><div class=\"line\">         ConditionalOnMissingClass.class);</div><div class=\"line\">   <span class=\"keyword\">if</span> (onMissingClasses != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      List&lt;String&gt; present = getMatches(onMissingClasses, MatchType.PRESENT,</div><div class=\"line\">            classLoader);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!present.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(</div><div class=\"line\">               ConditionMessage.forCondition(ConditionalOnMissingClass.class)</div><div class=\"line\">                     .found(<span class=\"string\">\"unwanted class\"</span>, <span class=\"string\">\"unwanted classes\"</span>)</div><div class=\"line\">                     .items(Style.QUOTE, present));</div><div class=\"line\">      &#125;</div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)</div><div class=\"line\">            .didNotFind(<span class=\"string\">\"unwanted class\"</span>, <span class=\"string\">\"unwanted classes\"</span>).items(Style.QUOTE,</div><div class=\"line\">                  getMatches(onMissingClasses, MatchType.MISSING, classLoader));</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 返回全部匹配成功的ConditionalOutcome</span></div><div class=\"line\">   <span class=\"keyword\">return</span> ConditionOutcome.match(matchMessage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"条件注解激活\"><a href=\"#条件注解激活\" class=\"headerlink\" title=\"条件注解激活\"></a>条件注解激活</h3><p>这里又要从 Spring 容器的 refresh 方法说起了，这个方法太重要了。其中的 invokeBeanFactoryPostProcessors 方法调用 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor 的处理逻辑，在 bean 实例化阶段开始之前，对注册到容器的 BeanDefinition 保存的原始数据做出修改。与条件注解激活有关的 posstProcessor 是 ConfigurationClassPostProcessor，其实现自 BeanFactoryPostProcessor 。</p>\n<p>ConfigurationClassPostProcessor 会从 BeanFactory 中找出所有被 @Configuration 直接或间接注解的类（包括 @Component, @ComponentScan, @Import, @ImportResource 修饰的类）进行解析。对解析的结果使用 ConditionEvaluator 进行过滤判断。判断逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldSkip</span><span class=\"params\">(AnnotatedTypeMetadata metadata, ConfigurationPhase phase)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// </span></div><div class=\"line\">   <span class=\"keyword\">if</span> (metadata == <span class=\"keyword\">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">if</span> (phase == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (metadata <span class=\"keyword\">instanceof</span> AnnotationMetadata &amp;&amp;</div><div class=\"line\">            ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   List&lt;Condition&gt; conditions = <span class=\"keyword\">new</span> ArrayList&lt;Condition&gt;();</div><div class=\"line\">   <span class=\"keyword\">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (String conditionClass : conditionClasses) &#123;</div><div class=\"line\">         Condition condition = getCondition(conditionClass, <span class=\"keyword\">this</span>.context.getClassLoader());</div><div class=\"line\">         conditions.add(condition);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   AnnotationAwareOrderComparator.sort(conditions);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">for</span> (Condition condition : conditions) &#123;</div><div class=\"line\">      ConfigurationPhase requiredPhase = <span class=\"keyword\">null</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span> (condition <span class=\"keyword\">instanceof</span> ConfigurationCondition) &#123;</div><div class=\"line\">         requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (requiredPhase == <span class=\"keyword\">null</span> || requiredPhase == phase) &#123;</div><div class=\"line\">         <span class=\"keyword\">if</span> (!condition.matches(<span class=\"keyword\">this</span>.context, metadata)) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中 ConfigurationCondition 是 Condition 的子接口，内部主要定义了枚举类型表示条件注解生效的阶段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConfigurationCondition</span> <span class=\"keyword\">extends</span> <span class=\"title\">Condition</span> </span>&#123;</div><div class=\"line\">   <span class=\"function\">ConfigurationPhase <span class=\"title\">getConfigurationPhase</span><span class=\"params\">()</span></span>;</div><div class=\"line\">   <span class=\"keyword\">enum</span> ConfigurationPhase &#123;</div><div class=\"line\">      PARSE_CONFIGURATION,</div><div class=\"line\">      REGISTER_BEAN</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>完整的 ConfigurationClassPostProcessor 处理逻辑：</p>\n<p><img src=\"https://i.loli.net/2017/08/29/59a4d381568f6.png\" alt=\"configuration-annotation-process.png\"></p>\n<hr>\n<p>参考：<a href=\"http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/\" target=\"_blank\" rel=\"external\">SpringBoot源码分析之Spring容器的refresh过程</a></p>\n","excerpt":"","more":"<p>前面的文章已经基本讲清楚从 Spring Boot 应用完整的启动过程了，不过中间过程缺少自动配置相关的功能实现说明。</p>\n<p>我把功能配置分为两个部分：</p>\n<ul>\n<li>自动化配置</li>\n<li>条件注解</li>\n</ul>\n<p>以上两个功能极大的简化了 Spring Boot 应用的配置</p>\n<h2 id=\"自动化配置\"><a href=\"#自动化配置\" class=\"headerlink\" title=\"自动化配置\"></a>自动化配置</h2><p>要弄清自动化配置的起源就得从入口类的 SpringBootApplication 注解说起：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</div><div class=\"line\">  <span class=\"comment\">// 省略注解的字段，别名</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>SpringBootApplication 作为一个组合注解，配置的功能是其核心功能，这部分功能由 EnableAutoConfiguration 注解实现。 EnableAutoConfiguration  也是个符合注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Documented</span></div><div class=\"line\"><span class=\"meta\">@Inherited</span></div><div class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></div><div class=\"line\"><span class=\"meta\">@Import</span>(&#123;EnableAutoConfigurationImportSelector.class&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</div><div class=\"line\">    String ENABLED_OVERRIDE_PROPERTY = <span class=\"string\">\"spring.boot.enableautoconfiguration\"</span>;</div><div class=\"line\">    Class&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\">    String[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>EnableAutoConfiguration 的关键是导入了 EnableAutoConfigurationImportSelector ，这类继承自 AutoConfigurationImportSelector。在 Spring 容器刷新的过程中的 invokeBeanFactoryPostProcessors 方法会调用到 EnableAutoConfigurationImportSelector 的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// EnableAutoConfigurationImportSelector</span></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (!isEnabled(annotationMetadata)) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> NO_IMPORTS;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 获取注解属性</span></div><div class=\"line\">      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</div><div class=\"line\">            .loadMetadata(<span class=\"keyword\">this</span>.beanClassLoader);</div><div class=\"line\">      AnnotationAttributes attributes = getAttributes(annotationMetadata);</div><div class=\"line\">      <span class=\"comment\">// 读取spring.factories属性文件中的数据</span></div><div class=\"line\">      List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</div><div class=\"line\">            attributes);</div><div class=\"line\">      <span class=\"comment\">// 删除重复的配置类</span></div><div class=\"line\">      configurations = removeDuplicates(configurations);</div><div class=\"line\">      configurations = sort(configurations, autoConfigurationMetadata);</div><div class=\"line\">      <span class=\"comment\">// 找到@EnableAutoConfiguration注解中定义的需要被过滤的配置类</span></div><div class=\"line\">      Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</div><div class=\"line\">      checkExcludedClasses(configurations, exclusions);</div><div class=\"line\">      <span class=\"comment\">// 删除这些需要被过滤的配置类</span></div><div class=\"line\">      configurations.removeAll(exclusions);</div><div class=\"line\">      configurations = filter(configurations, autoConfigurationMetadata);</div><div class=\"line\">      fireAutoConfigurationImportListeners(configurations, exclusions);</div><div class=\"line\">      <span class=\"comment\">// 返回最终得到的自动化配置类</span></div><div class=\"line\">      <span class=\"keyword\">return</span> configurations.toArray(<span class=\"keyword\">new</span> String[configurations.size()]);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> (IOException ex) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> List&lt;String&gt; <span class=\"title\">getCandidateConfigurations</span><span class=\"params\">(AnnotationMetadata metadata,</div><div class=\"line\">      AnnotationAttributes attributes)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 调用SpringFactoriesLoader的loadFactoryNames静态方法</span></div><div class=\"line\">   <span class=\"comment\">// getSpringFactoriesLoaderFactoryClass方法返回的是EnableAutoConfiguration类对象</span></div><div class=\"line\">   List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</div><div class=\"line\">         getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</div><div class=\"line\">   Assert.notEmpty(configurations,</div><div class=\"line\">         <span class=\"string\">\"No auto configuration classes found in META-INF/spring.factories. If you \"</span></div><div class=\"line\">               + <span class=\"string\">\"are using a custom packaging, make sure that file is correct.\"</span>);</div><div class=\"line\">   <span class=\"keyword\">return</span> configurations;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>EnableAutoConfigurationImportSelector 会使用 SpringFactoriesLoader 加载相应的配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// SpringFactoriesLoader </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title\">loadFactoryNames</span><span class=\"params\">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 解析出properties文件中需要的key值</span></div><div class=\"line\">   String factoryClassName = factoryClass.getName();</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 常量FACTORIES_RESOURCE_LOCATION的值为META-INF/spring.factories</span></div><div class=\"line\">      <span class=\"comment\">// 使用类加载器找META-INF/spring.factories资源</span></div><div class=\"line\">      Enumeration&lt;URL&gt; urls = (classLoader != <span class=\"keyword\">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</div><div class=\"line\">            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</div><div class=\"line\">      List&lt;String&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\">      <span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</div><div class=\"line\">         URL url = urls.nextElement();</div><div class=\"line\">         Properties properties = PropertiesLoaderUtils.loadProperties(<span class=\"keyword\">new</span> UrlResource(url));</div><div class=\"line\">         String factoryClassNames = properties.getProperty(factoryClassName);</div><div class=\"line\">         result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> result;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> (IOException ex) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unable to load [\"</span> + factoryClass.getName() +</div><div class=\"line\">            <span class=\"string\">\"] factories from location [\"</span> + FACTORIES_RESOURCE_LOCATION + <span class=\"string\">\"]\"</span>, ex);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"条件注解\"><a href=\"#条件注解\" class=\"headerlink\" title=\"条件注解\"></a>条件注解</h2><h3 id=\"条件注解实现\"><a href=\"#条件注解实现\" class=\"headerlink\" title=\"条件注解实现\"></a>条件注解实现</h3><p>以常见的 ConditionalOnClass 注解为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@Documented</div><div class=\"line\">@Conditional(OnClassCondition.class)</div><div class=\"line\">public @interface ConditionalOnClass &#123;</div><div class=\"line\">   Class&lt;?&gt;[] value() default &#123;&#125;;  // 要匹配的类</div><div class=\"line\">   String[] name() default &#123;&#125;;  // 要匹配的类名</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>必要重要的是 Conditional 注解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class=\"line\">public @interface Conditional &#123;</div><div class=\"line\">   Class&lt;? extends Condition&gt;[] value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从命名可以看出 Conditional 注解的  value 属性是具体的 Condition 实现，Spring Boot 提供了通用的 Condition 抽象类： SpringBootCondition，其完成了具体匹配逻辑之外的其他模板：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// SpringBootCondition</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context,</div><div class=\"line\">      AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 获得类名或方法名</span></div><div class=\"line\">   String classOrMethodName = getClassOrMethodName(metadata);</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 抽象方法由子类实现匹配逻辑</span></div><div class=\"line\">      <span class=\"comment\">// 返回结构包装了匹配结果和log信息</span></div><div class=\"line\">      ConditionOutcome outcome = getMatchOutcome(context, metadata);</div><div class=\"line\">      <span class=\"comment\">// log</span></div><div class=\"line\">      logOutcome(classOrMethodName, outcome);</div><div class=\"line\">      <span class=\"comment\">// 报告一下</span></div><div class=\"line\">      recordEvaluation(context, classOrMethodName, outcome);</div><div class=\"line\">      <span class=\"comment\">// 返回匹配结果</span></div><div class=\"line\">      <span class=\"keyword\">return</span> outcome.isMatch();</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">catch</span> <span class=\"comment\">// 省略异常处理</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体到 ConditionalOnClass 使用的是 OnClassCondition：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConditionOutcome <span class=\"title\">getMatchOutcome</span><span class=\"params\">(ConditionContext context,</div><div class=\"line\">      AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class=\"line\">   ClassLoader classLoader = context.getClassLoader();</div><div class=\"line\">   ConditionMessage matchMessage = ConditionMessage.empty();</div><div class=\"line\">   <span class=\"comment\">// 获得 ConditionalOnClass 注解的属性</span></div><div class=\"line\">   List&lt;String&gt; onClasses = getCandidates(metadata, ConditionalOnClass.class);</div><div class=\"line\">   <span class=\"keyword\">if</span> (onClasses != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 属性不为空</span></div><div class=\"line\">      <span class=\"comment\">// 获取具体缺失的类</span></div><div class=\"line\">      List&lt;String&gt; missing = getMatches(onClasses, MatchType.MISSING, classLoader);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!missing.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome</div><div class=\"line\">               .noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)</div><div class=\"line\">                     .didNotFind(<span class=\"string\">\"required class\"</span>, <span class=\"string\">\"required classes\"</span>)</div><div class=\"line\">                     .items(Style.QUOTE, missing));</div><div class=\"line\">      &#125;</div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnClass.class)</div><div class=\"line\">            .found(<span class=\"string\">\"required class\"</span>, <span class=\"string\">\"required classes\"</span>).items(Style.QUOTE,</div><div class=\"line\">                  getMatches(onClasses, MatchType.PRESENT, classLoader));</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 获得 ConditionalOnMissingClass 注解的属性</span></div><div class=\"line\">   List&lt;String&gt; onMissingClasses = getCandidates(metadata,</div><div class=\"line\">         ConditionalOnMissingClass.class);</div><div class=\"line\">   <span class=\"keyword\">if</span> (onMissingClasses != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      List&lt;String&gt; present = getMatches(onMissingClasses, MatchType.PRESENT,</div><div class=\"line\">            classLoader);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!present.isEmpty()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> ConditionOutcome.noMatch(</div><div class=\"line\">               ConditionMessage.forCondition(ConditionalOnMissingClass.class)</div><div class=\"line\">                     .found(<span class=\"string\">\"unwanted class\"</span>, <span class=\"string\">\"unwanted classes\"</span>)</div><div class=\"line\">                     .items(Style.QUOTE, present));</div><div class=\"line\">      &#125;</div><div class=\"line\">      matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)</div><div class=\"line\">            .didNotFind(<span class=\"string\">\"unwanted class\"</span>, <span class=\"string\">\"unwanted classes\"</span>).items(Style.QUOTE,</div><div class=\"line\">                  getMatches(onMissingClasses, MatchType.MISSING, classLoader));</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// 返回全部匹配成功的ConditionalOutcome</span></div><div class=\"line\">   <span class=\"keyword\">return</span> ConditionOutcome.match(matchMessage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"条件注解激活\"><a href=\"#条件注解激活\" class=\"headerlink\" title=\"条件注解激活\"></a>条件注解激活</h3><p>这里又要从 Spring 容器的 refresh 方法说起了，这个方法太重要了。其中的 invokeBeanFactoryPostProcessors 方法调用 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor 的处理逻辑，在 bean 实例化阶段开始之前，对注册到容器的 BeanDefinition 保存的原始数据做出修改。与条件注解激活有关的 posstProcessor 是 ConfigurationClassPostProcessor，其实现自 BeanFactoryPostProcessor 。</p>\n<p>ConfigurationClassPostProcessor 会从 BeanFactory 中找出所有被 @Configuration 直接或间接注解的类（包括 @Component, @ComponentScan, @Import, @ImportResource 修饰的类）进行解析。对解析的结果使用 ConditionEvaluator 进行过滤判断。判断逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldSkip</span><span class=\"params\">(AnnotatedTypeMetadata metadata, ConfigurationPhase phase)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// </span></div><div class=\"line\">   <span class=\"keyword\">if</span> (metadata == <span class=\"keyword\">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">if</span> (phase == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (metadata <span class=\"keyword\">instanceof</span> AnnotationMetadata &amp;&amp;</div><div class=\"line\">            ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   List&lt;Condition&gt; conditions = <span class=\"keyword\">new</span> ArrayList&lt;Condition&gt;();</div><div class=\"line\">   <span class=\"keyword\">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (String conditionClass : conditionClasses) &#123;</div><div class=\"line\">         Condition condition = getCondition(conditionClass, <span class=\"keyword\">this</span>.context.getClassLoader());</div><div class=\"line\">         conditions.add(condition);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   AnnotationAwareOrderComparator.sort(conditions);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">for</span> (Condition condition : conditions) &#123;</div><div class=\"line\">      ConfigurationPhase requiredPhase = <span class=\"keyword\">null</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span> (condition <span class=\"keyword\">instanceof</span> ConfigurationCondition) &#123;</div><div class=\"line\">         requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (requiredPhase == <span class=\"keyword\">null</span> || requiredPhase == phase) &#123;</div><div class=\"line\">         <span class=\"keyword\">if</span> (!condition.matches(<span class=\"keyword\">this</span>.context, metadata)) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中 ConfigurationCondition 是 Condition 的子接口，内部主要定义了枚举类型表示条件注解生效的阶段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConfigurationCondition</span> <span class=\"keyword\">extends</span> <span class=\"title\">Condition</span> </span>&#123;</div><div class=\"line\">   <span class=\"function\">ConfigurationPhase <span class=\"title\">getConfigurationPhase</span><span class=\"params\">()</span></span>;</div><div class=\"line\">   <span class=\"keyword\">enum</span> ConfigurationPhase &#123;</div><div class=\"line\">      PARSE_CONFIGURATION,</div><div class=\"line\">      REGISTER_BEAN</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>完整的 ConfigurationClassPostProcessor 处理逻辑：</p>\n<p><img src=\"https://i.loli.net/2017/08/29/59a4d381568f6.png\" alt=\"configuration-annotation-process.png\"></p>\n<hr>\n<p>参考：<a href=\"http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/\">SpringBoot源码分析之Spring容器的refresh过程</a></p>\n"},{"title":"【翻译】《OSGI官方指南》首页","date":"2017-01-25T01:58:59.000Z","_content":"\n说明：本翻译原计划发布于并发编程网，但因个人原因拖延，导致其他网友先于发布，在此仅作记录。督促自己改善拖延问题。\n\n---\n\n# 开发者\n\n开始OSGI之旅，你将得到：复用组件构建管理高度复杂的系统，让编写代码更容易，管理动态部署，更早的发现错误，远程部署，发现并解决你现在可以不知道的问题。\n\n如果你正在使用Java开发软件，OSGi应该在你的工具箱。\n\n## 为什么选择OSGi\n\nOSGI提供一个模块化构建用方式用于现代大规模分布式系统以及小型系统，嵌入式应用和设备网络。从内部和现成模块构建的系统明显增加了软件产品和解决方案的复用，并延长了其生命周期，减小了开发和维护的费用。OSGi编程模型确保实现基于组件的系统。\n\nOSGi技术是成功的，因为它提供了一个非常成熟的组件系统，并在大量的环境中使用。OSGi组件系统被用于构建高度复杂的应用程序，例如IDE，应用服务器，应用程序框架，电信和服务解决方案，工业自动化，住宅网关，车载远程信息处理系统等。\n\n## 为OSGi工作\n\n垂直和跨行业需要“专家组”提供定制，以不影响OSGi服务平台架构的完整性。当前专家组包括企业专家组，住宅专家组和核心平台专家组。成员在OSGi董事会批准的情况下提议并建立新EG的章程。\n\n你希望OSGi使用你的协议吗？作为会员的好处，OSGi成员有资格为新协议创建[规范](https://www.osgi.org/developer/specifications/)。专家组正在开发OSGi设备抽象层，以扩展OSGi的覆盖范围，与其他行业联盟合作。成员正在致力于物联网和云计算。 那么你对OSGi的议程是什么？\n\n## 开始\n\n联盟提供了许多资源来探索OSGi，并开始在您的开发项目中使用OSGi。[enRoute](https://www.osgi.org/enroute/)是一个实用和高效的资源用于构建和实现模块化应用程序。\n\n## 认证\n证明您的OSGi专业知识。获得认证。 OSGi成员提供培训课程，联盟提供[OSGi认证](https://www.osgi.org/osgi-certification/developer-certification/)测试。\n","source":"_posts/【翻译】《OSGI官方指南》首页.md","raw":"---\ntitle: 【翻译】《OSGI官方指南》首页\ndate: 2017-01-25 09:58:59\ntags:\n  - 翻译\ncategories: 翻译\n---\n\n说明：本翻译原计划发布于并发编程网，但因个人原因拖延，导致其他网友先于发布，在此仅作记录。督促自己改善拖延问题。\n\n---\n\n# 开发者\n\n开始OSGI之旅，你将得到：复用组件构建管理高度复杂的系统，让编写代码更容易，管理动态部署，更早的发现错误，远程部署，发现并解决你现在可以不知道的问题。\n\n如果你正在使用Java开发软件，OSGi应该在你的工具箱。\n\n## 为什么选择OSGi\n\nOSGI提供一个模块化构建用方式用于现代大规模分布式系统以及小型系统，嵌入式应用和设备网络。从内部和现成模块构建的系统明显增加了软件产品和解决方案的复用，并延长了其生命周期，减小了开发和维护的费用。OSGi编程模型确保实现基于组件的系统。\n\nOSGi技术是成功的，因为它提供了一个非常成熟的组件系统，并在大量的环境中使用。OSGi组件系统被用于构建高度复杂的应用程序，例如IDE，应用服务器，应用程序框架，电信和服务解决方案，工业自动化，住宅网关，车载远程信息处理系统等。\n\n## 为OSGi工作\n\n垂直和跨行业需要“专家组”提供定制，以不影响OSGi服务平台架构的完整性。当前专家组包括企业专家组，住宅专家组和核心平台专家组。成员在OSGi董事会批准的情况下提议并建立新EG的章程。\n\n你希望OSGi使用你的协议吗？作为会员的好处，OSGi成员有资格为新协议创建[规范](https://www.osgi.org/developer/specifications/)。专家组正在开发OSGi设备抽象层，以扩展OSGi的覆盖范围，与其他行业联盟合作。成员正在致力于物联网和云计算。 那么你对OSGi的议程是什么？\n\n## 开始\n\n联盟提供了许多资源来探索OSGi，并开始在您的开发项目中使用OSGi。[enRoute](https://www.osgi.org/enroute/)是一个实用和高效的资源用于构建和实现模块化应用程序。\n\n## 认证\n证明您的OSGi专业知识。获得认证。 OSGi成员提供培训课程，联盟提供[OSGi认证](https://www.osgi.org/osgi-certification/developer-certification/)测试。\n","slug":"【翻译】《OSGI官方指南》首页","published":1,"updated":"2017-01-25T02:06:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2re0038d82ekv1o59hj","content":"<p>说明：本翻译原计划发布于并发编程网，但因个人原因拖延，导致其他网友先于发布，在此仅作记录。督促自己改善拖延问题。</p>\n<hr>\n<h1 id=\"开发者\"><a href=\"#开发者\" class=\"headerlink\" title=\"开发者\"></a>开发者</h1><p>开始OSGI之旅，你将得到：复用组件构建管理高度复杂的系统，让编写代码更容易，管理动态部署，更早的发现错误，远程部署，发现并解决你现在可以不知道的问题。</p>\n<p>如果你正在使用Java开发软件，OSGi应该在你的工具箱。</p>\n<h2 id=\"为什么选择OSGi\"><a href=\"#为什么选择OSGi\" class=\"headerlink\" title=\"为什么选择OSGi\"></a>为什么选择OSGi</h2><p>OSGI提供一个模块化构建用方式用于现代大规模分布式系统以及小型系统，嵌入式应用和设备网络。从内部和现成模块构建的系统明显增加了软件产品和解决方案的复用，并延长了其生命周期，减小了开发和维护的费用。OSGi编程模型确保实现基于组件的系统。</p>\n<p>OSGi技术是成功的，因为它提供了一个非常成熟的组件系统，并在大量的环境中使用。OSGi组件系统被用于构建高度复杂的应用程序，例如IDE，应用服务器，应用程序框架，电信和服务解决方案，工业自动化，住宅网关，车载远程信息处理系统等。</p>\n<h2 id=\"为OSGi工作\"><a href=\"#为OSGi工作\" class=\"headerlink\" title=\"为OSGi工作\"></a>为OSGi工作</h2><p>垂直和跨行业需要“专家组”提供定制，以不影响OSGi服务平台架构的完整性。当前专家组包括企业专家组，住宅专家组和核心平台专家组。成员在OSGi董事会批准的情况下提议并建立新EG的章程。</p>\n<p>你希望OSGi使用你的协议吗？作为会员的好处，OSGi成员有资格为新协议创建<a href=\"https://www.osgi.org/developer/specifications/\" target=\"_blank\" rel=\"external\">规范</a>。专家组正在开发OSGi设备抽象层，以扩展OSGi的覆盖范围，与其他行业联盟合作。成员正在致力于物联网和云计算。 那么你对OSGi的议程是什么？</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>联盟提供了许多资源来探索OSGi，并开始在您的开发项目中使用OSGi。<a href=\"https://www.osgi.org/enroute/\" target=\"_blank\" rel=\"external\">enRoute</a>是一个实用和高效的资源用于构建和实现模块化应用程序。</p>\n<h2 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h2><p>证明您的OSGi专业知识。获得认证。 OSGi成员提供培训课程，联盟提供<a href=\"https://www.osgi.org/osgi-certification/developer-certification/\" target=\"_blank\" rel=\"external\">OSGi认证</a>测试。</p>\n","excerpt":"","more":"<p>说明：本翻译原计划发布于并发编程网，但因个人原因拖延，导致其他网友先于发布，在此仅作记录。督促自己改善拖延问题。</p>\n<hr>\n<h1 id=\"开发者\"><a href=\"#开发者\" class=\"headerlink\" title=\"开发者\"></a>开发者</h1><p>开始OSGI之旅，你将得到：复用组件构建管理高度复杂的系统，让编写代码更容易，管理动态部署，更早的发现错误，远程部署，发现并解决你现在可以不知道的问题。</p>\n<p>如果你正在使用Java开发软件，OSGi应该在你的工具箱。</p>\n<h2 id=\"为什么选择OSGi\"><a href=\"#为什么选择OSGi\" class=\"headerlink\" title=\"为什么选择OSGi\"></a>为什么选择OSGi</h2><p>OSGI提供一个模块化构建用方式用于现代大规模分布式系统以及小型系统，嵌入式应用和设备网络。从内部和现成模块构建的系统明显增加了软件产品和解决方案的复用，并延长了其生命周期，减小了开发和维护的费用。OSGi编程模型确保实现基于组件的系统。</p>\n<p>OSGi技术是成功的，因为它提供了一个非常成熟的组件系统，并在大量的环境中使用。OSGi组件系统被用于构建高度复杂的应用程序，例如IDE，应用服务器，应用程序框架，电信和服务解决方案，工业自动化，住宅网关，车载远程信息处理系统等。</p>\n<h2 id=\"为OSGi工作\"><a href=\"#为OSGi工作\" class=\"headerlink\" title=\"为OSGi工作\"></a>为OSGi工作</h2><p>垂直和跨行业需要“专家组”提供定制，以不影响OSGi服务平台架构的完整性。当前专家组包括企业专家组，住宅专家组和核心平台专家组。成员在OSGi董事会批准的情况下提议并建立新EG的章程。</p>\n<p>你希望OSGi使用你的协议吗？作为会员的好处，OSGi成员有资格为新协议创建<a href=\"https://www.osgi.org/developer/specifications/\">规范</a>。专家组正在开发OSGi设备抽象层，以扩展OSGi的覆盖范围，与其他行业联盟合作。成员正在致力于物联网和云计算。 那么你对OSGi的议程是什么？</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>联盟提供了许多资源来探索OSGi，并开始在您的开发项目中使用OSGi。<a href=\"https://www.osgi.org/enroute/\">enRoute</a>是一个实用和高效的资源用于构建和实现模块化应用程序。</p>\n<h2 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h2><p>证明您的OSGi专业知识。获得认证。 OSGi成员提供培训课程，联盟提供<a href=\"https://www.osgi.org/osgi-certification/developer-certification/\">OSGi认证</a>测试。</p>\n"},{"title":"【重拾网络】DNS","date":"2017-07-20T13:55:21.000Z","_content":"\n## DNS 是什么\n\n了解网络的同学应该都是知道 DNS的，它提供最基本的从域名到 IP 地址的转换服务。简单可以把 DNS 理解成一个翻译官，这位翻译官每天默默地为我们处理上网请求时域名到 IP 的转换。\n\n上网时每次对域名的请求使用的是 HTTP 协议，而作为翻译官 DNS 发生在HTTP 真实请求之前。尽管 DNS 协议执行在 HTTP 请求之前，但与 HTTP 一样，DNS 也是 TP/IP 协议模型中应用层协议。更具体一点默认使用的是 UDP 的传输方式，端口号为 53 。\n\n补充一下，除了基本的域名到 IP 的转换服务， DNS 还可以提供主机别名，邮件服务器别名，负载均衡功能。\n\n## DNS 结构\n\n从功能上来看，DNS 只提供了非常简单的字符串到字符串的转换服务。类似于程序语言中的字典结构就可以完成映射转换。所以在很多网络结构图中 DNS 服务往往被描述成一台服务器，在客户端与服务器请求之前，首先在 DNS 服务器上查询服务器对应的 IP 即可。我们日常的使用中 DNS 也确实扮演了这样一个默默无闻的角色，运行的过程对用户非常透明。\n\n为了使 DNS 可以做到全球范围的高可用，一台简单的服务器肯定是无法满足的。实际上DNS 根据域名的层级也划分出不同的 DNS 层级。\n\n### 域名层级\n\n域名层级的划分示意：\n\n![Name_schema.jpg](https://ooo.0o0.ooo/2017/07/05/595c6d4dc5144.jpg)\n\n域名的层级结构：\n\n```\n主机名.次级域名.顶级域名.根域名\n\nhost.sld.tld.root\n```\n\n以  www.example.com 域名为例，看看域名的划分：\n\n|    域名     |          值           |         备注         |\n| :-------: | :------------------: | :----------------: |\n|   使用的域名   |   www.example.com    |     日常真实使用的域名      |\n|   真正的域名   | www.example.com.root |     .root通常省略      |\n|    根域名    |        .root         |       对所有域名        |\n|   顶级域名    |         .com         |                    |\n|   次顶级域名   |       .example       |       用户可注册的       |\n| 三级域名（主机名） |         www          | 用户在自己的域里面为服务器分配的名称 |\n\n### DNS 层级\n\n域名层级结构对应的 DNS 服务结构划分： \n\n![Structure_DNS.jpg](https://ooo.0o0.ooo/2017/07/05/595c6c612da55.jpg)\n\n上面 DNS 的层级结构很明显是一个树型的结构，解析的过程就是从根到叶子节点的访问过程。作为基础的网络服务，单节点肯定是不可靠的，所以上图的节点实际中不是孤立存在的，而是由一组服务器构成。例如根节点就对应了全世界 13 台根服务器。\n\n## DNS 查询过程\n\n既然树型的 DNS 的结构不能一步获取到最终查询结果，这里就有两种方式处理处理查询过程了：\n\n- 递归查询\n\n  客户端发出查询请求后，只接受一个准确的查询结果，而不能是查询的中间过程\n\n- 迭代查询\n\n  客户端发出查询请求后，DNS 服务器不直接回复查询结果，而是告诉客户端另一台 DNS 服务器地址，客户端再向这台 DNS 服务器请求解析，依此循环直到返回查询的结果\n\n两者各有利弊，通常是将两者结合在一起，一个 DNS 的解析大致可以分两个部分：\n\n1. 客户端向 Local DNS 的请求，通常这部分使用递归请求\n2. Local DNS 的请求，通常这部分使用迭代请求\n\n按照上述规则一个基本的 DNS 解析过程：\n\n![dn-sresolution.png](https://ooo.0o0.ooo/2017/07/05/595c5beaef747.png)\n\n1.  发出域名解析请求\n2.  本机的域名解析器 resolver 程序查询本地缓存和 host 文件中是否为域名的映射关系\n3.  本地解析器向 TCP/IP 参数中设置的首选 DNS 服务器（我们叫它 Local DNS 服务器）发起一个递归的查询请求\n4.  服务器收到查询时\n    1. 如果要查询的域名由 Local DNS 服务器负责解析，则返回解析结果给客户机，完成域名解析，且此解析具有权威性\n    2. 如果要查询的域名不由 Local DNS 服务器解析，则调用这个 IP 地址映射，完成域名解析，且此解析不具有权威性\n5.  根据 Local DNS 服务器的设置（是否递归）进行查询\n    1. 如果是迭代查询，Local DNS 就把请求发至13台 Root DNS\n    2. 如果是递归查询，Local DNS 就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环\n6.  Root DNS 服务器收到请求后会判断这个域名是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP\n7.  Local DNS 服务器收到 IP 信息后，将会联系负责 .edu 域的这台服务器\n8.  负责 .edu 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .edu 域的下一级 DNS 服务器地址给 Local DNS 服务器\n9.  当 Local DNS 服务器收到这个地址后，就会找 googleplex.edu 域服务器\n10.  负责 googleplex.edu 域的服务器接收到请求后，如果自己无法解析，继续找管理 googleplex.edu 域的下一级 DNS 服务器地址给 Local DNS 服务器\n11.  当 Local DNS 服务器收到这个地址后，就会找 compsci.googleplex.edu 域服务器\n12.  最后 compsci.googleplex.edu 域服务器返回需要解析的域名的 IP 地址给 Local DNS 服务器\n13.  Local DNS 服务器缓存这个解析结果（同时也会缓存，6、8、10返回的结果）\n14.  Local DNS 服务器同时将结果返回给本机域名解析器\n15.  本机缓存解析结果\n16.  本机解析器将结果返回给浏览器\n17.  浏览器通过返回的 IP 地址发起请求\n\n\n## DNS 记录\n\n资源记录：name, value, type, ttl\n\nttl：记录存活时间\n\ntype 分类：\n- A：name：主机域名，value：IP地址\n- NS：name：域，value：域的权威域名解析服务的主机域名\n- CNAME：name：真实域名的别名，value：真实域名\n- MX：value是与name相对应的邮件服务器\n\n## 其他 DNS 相关\n\n### 常见的 DNS 功能说明\n\n- 权威 DNS： 最终决定域名解析结果的服务器，可以在其上配置具体域名的对应解析结果信息\n- 递归 DNS 或本地 DNS：有域名解析结果的决定权，但代理了用户向权威DNS获取域名解析结果的过程，不属于 DNS 层次体系\n- 公共 DNS：全网开放的递归 DNS，不同于一般的本地 DNS 由 ISP 提供\n\n### DNS 相关命令\n\n- dig\n- host\n- nslookup\n\n命令的参考：[域名解析之dig,host,nslookup命令](http://luodw.cc/2015/12/27/dns03/)\n","source":"_posts/【重拾网络】DNS.md","raw":"---\ntitle: 【重拾网络】DNS\ndate: 2017-07-20 21:55:21\ntags: 网络\ncategories: 网络\n---\n\n## DNS 是什么\n\n了解网络的同学应该都是知道 DNS的，它提供最基本的从域名到 IP 地址的转换服务。简单可以把 DNS 理解成一个翻译官，这位翻译官每天默默地为我们处理上网请求时域名到 IP 的转换。\n\n上网时每次对域名的请求使用的是 HTTP 协议，而作为翻译官 DNS 发生在HTTP 真实请求之前。尽管 DNS 协议执行在 HTTP 请求之前，但与 HTTP 一样，DNS 也是 TP/IP 协议模型中应用层协议。更具体一点默认使用的是 UDP 的传输方式，端口号为 53 。\n\n补充一下，除了基本的域名到 IP 的转换服务， DNS 还可以提供主机别名，邮件服务器别名，负载均衡功能。\n\n## DNS 结构\n\n从功能上来看，DNS 只提供了非常简单的字符串到字符串的转换服务。类似于程序语言中的字典结构就可以完成映射转换。所以在很多网络结构图中 DNS 服务往往被描述成一台服务器，在客户端与服务器请求之前，首先在 DNS 服务器上查询服务器对应的 IP 即可。我们日常的使用中 DNS 也确实扮演了这样一个默默无闻的角色，运行的过程对用户非常透明。\n\n为了使 DNS 可以做到全球范围的高可用，一台简单的服务器肯定是无法满足的。实际上DNS 根据域名的层级也划分出不同的 DNS 层级。\n\n### 域名层级\n\n域名层级的划分示意：\n\n![Name_schema.jpg](https://ooo.0o0.ooo/2017/07/05/595c6d4dc5144.jpg)\n\n域名的层级结构：\n\n```\n主机名.次级域名.顶级域名.根域名\n\nhost.sld.tld.root\n```\n\n以  www.example.com 域名为例，看看域名的划分：\n\n|    域名     |          值           |         备注         |\n| :-------: | :------------------: | :----------------: |\n|   使用的域名   |   www.example.com    |     日常真实使用的域名      |\n|   真正的域名   | www.example.com.root |     .root通常省略      |\n|    根域名    |        .root         |       对所有域名        |\n|   顶级域名    |         .com         |                    |\n|   次顶级域名   |       .example       |       用户可注册的       |\n| 三级域名（主机名） |         www          | 用户在自己的域里面为服务器分配的名称 |\n\n### DNS 层级\n\n域名层级结构对应的 DNS 服务结构划分： \n\n![Structure_DNS.jpg](https://ooo.0o0.ooo/2017/07/05/595c6c612da55.jpg)\n\n上面 DNS 的层级结构很明显是一个树型的结构，解析的过程就是从根到叶子节点的访问过程。作为基础的网络服务，单节点肯定是不可靠的，所以上图的节点实际中不是孤立存在的，而是由一组服务器构成。例如根节点就对应了全世界 13 台根服务器。\n\n## DNS 查询过程\n\n既然树型的 DNS 的结构不能一步获取到最终查询结果，这里就有两种方式处理处理查询过程了：\n\n- 递归查询\n\n  客户端发出查询请求后，只接受一个准确的查询结果，而不能是查询的中间过程\n\n- 迭代查询\n\n  客户端发出查询请求后，DNS 服务器不直接回复查询结果，而是告诉客户端另一台 DNS 服务器地址，客户端再向这台 DNS 服务器请求解析，依此循环直到返回查询的结果\n\n两者各有利弊，通常是将两者结合在一起，一个 DNS 的解析大致可以分两个部分：\n\n1. 客户端向 Local DNS 的请求，通常这部分使用递归请求\n2. Local DNS 的请求，通常这部分使用迭代请求\n\n按照上述规则一个基本的 DNS 解析过程：\n\n![dn-sresolution.png](https://ooo.0o0.ooo/2017/07/05/595c5beaef747.png)\n\n1.  发出域名解析请求\n2.  本机的域名解析器 resolver 程序查询本地缓存和 host 文件中是否为域名的映射关系\n3.  本地解析器向 TCP/IP 参数中设置的首选 DNS 服务器（我们叫它 Local DNS 服务器）发起一个递归的查询请求\n4.  服务器收到查询时\n    1. 如果要查询的域名由 Local DNS 服务器负责解析，则返回解析结果给客户机，完成域名解析，且此解析具有权威性\n    2. 如果要查询的域名不由 Local DNS 服务器解析，则调用这个 IP 地址映射，完成域名解析，且此解析不具有权威性\n5.  根据 Local DNS 服务器的设置（是否递归）进行查询\n    1. 如果是迭代查询，Local DNS 就把请求发至13台 Root DNS\n    2. 如果是递归查询，Local DNS 就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环\n6.  Root DNS 服务器收到请求后会判断这个域名是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP\n7.  Local DNS 服务器收到 IP 信息后，将会联系负责 .edu 域的这台服务器\n8.  负责 .edu 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .edu 域的下一级 DNS 服务器地址给 Local DNS 服务器\n9.  当 Local DNS 服务器收到这个地址后，就会找 googleplex.edu 域服务器\n10.  负责 googleplex.edu 域的服务器接收到请求后，如果自己无法解析，继续找管理 googleplex.edu 域的下一级 DNS 服务器地址给 Local DNS 服务器\n11.  当 Local DNS 服务器收到这个地址后，就会找 compsci.googleplex.edu 域服务器\n12.  最后 compsci.googleplex.edu 域服务器返回需要解析的域名的 IP 地址给 Local DNS 服务器\n13.  Local DNS 服务器缓存这个解析结果（同时也会缓存，6、8、10返回的结果）\n14.  Local DNS 服务器同时将结果返回给本机域名解析器\n15.  本机缓存解析结果\n16.  本机解析器将结果返回给浏览器\n17.  浏览器通过返回的 IP 地址发起请求\n\n\n## DNS 记录\n\n资源记录：name, value, type, ttl\n\nttl：记录存活时间\n\ntype 分类：\n- A：name：主机域名，value：IP地址\n- NS：name：域，value：域的权威域名解析服务的主机域名\n- CNAME：name：真实域名的别名，value：真实域名\n- MX：value是与name相对应的邮件服务器\n\n## 其他 DNS 相关\n\n### 常见的 DNS 功能说明\n\n- 权威 DNS： 最终决定域名解析结果的服务器，可以在其上配置具体域名的对应解析结果信息\n- 递归 DNS 或本地 DNS：有域名解析结果的决定权，但代理了用户向权威DNS获取域名解析结果的过程，不属于 DNS 层次体系\n- 公共 DNS：全网开放的递归 DNS，不同于一般的本地 DNS 由 ISP 提供\n\n### DNS 相关命令\n\n- dig\n- host\n- nslookup\n\n命令的参考：[域名解析之dig,host,nslookup命令](http://luodw.cc/2015/12/27/dns03/)\n","slug":"【重拾网络】DNS","published":1,"updated":"2017-07-20T14:07:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2rg003bd82ezpp9wqgh","content":"<h2 id=\"DNS-是什么\"><a href=\"#DNS-是什么\" class=\"headerlink\" title=\"DNS 是什么\"></a>DNS 是什么</h2><p>了解网络的同学应该都是知道 DNS的，它提供最基本的从域名到 IP 地址的转换服务。简单可以把 DNS 理解成一个翻译官，这位翻译官每天默默地为我们处理上网请求时域名到 IP 的转换。</p>\n<p>上网时每次对域名的请求使用的是 HTTP 协议，而作为翻译官 DNS 发生在HTTP 真实请求之前。尽管 DNS 协议执行在 HTTP 请求之前，但与 HTTP 一样，DNS 也是 TP/IP 协议模型中应用层协议。更具体一点默认使用的是 UDP 的传输方式，端口号为 53 。</p>\n<p>补充一下，除了基本的域名到 IP 的转换服务， DNS 还可以提供主机别名，邮件服务器别名，负载均衡功能。</p>\n<h2 id=\"DNS-结构\"><a href=\"#DNS-结构\" class=\"headerlink\" title=\"DNS 结构\"></a>DNS 结构</h2><p>从功能上来看，DNS 只提供了非常简单的字符串到字符串的转换服务。类似于程序语言中的字典结构就可以完成映射转换。所以在很多网络结构图中 DNS 服务往往被描述成一台服务器，在客户端与服务器请求之前，首先在 DNS 服务器上查询服务器对应的 IP 即可。我们日常的使用中 DNS 也确实扮演了这样一个默默无闻的角色，运行的过程对用户非常透明。</p>\n<p>为了使 DNS 可以做到全球范围的高可用，一台简单的服务器肯定是无法满足的。实际上DNS 根据域名的层级也划分出不同的 DNS 层级。</p>\n<h3 id=\"域名层级\"><a href=\"#域名层级\" class=\"headerlink\" title=\"域名层级\"></a>域名层级</h3><p>域名层级的划分示意：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/07/05/595c6d4dc5144.jpg\" alt=\"Name_schema.jpg\"></p>\n<p>域名的层级结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">主机名.次级域名.顶级域名.根域名</div><div class=\"line\"></div><div class=\"line\">host.sld.tld.root</div></pre></td></tr></table></figure>\n<p>以  www.example.com 域名为例，看看域名的划分：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">域名</th>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">使用的域名</td>\n<td style=\"text-align:center\">www.example.com</td>\n<td style=\"text-align:center\">日常真实使用的域名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">真正的域名</td>\n<td style=\"text-align:center\">www.example.com.root</td>\n<td style=\"text-align:center\">.root通常省略</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">根域名</td>\n<td style=\"text-align:center\">.root</td>\n<td style=\"text-align:center\">对所有域名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">顶级域名</td>\n<td style=\"text-align:center\">.com</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">次顶级域名</td>\n<td style=\"text-align:center\">.example</td>\n<td style=\"text-align:center\">用户可注册的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">三级域名（主机名）</td>\n<td style=\"text-align:center\">www</td>\n<td style=\"text-align:center\">用户在自己的域里面为服务器分配的名称</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"DNS-层级\"><a href=\"#DNS-层级\" class=\"headerlink\" title=\"DNS 层级\"></a>DNS 层级</h3><p>域名层级结构对应的 DNS 服务结构划分： </p>\n<p><img src=\"https://ooo.0o0.ooo/2017/07/05/595c6c612da55.jpg\" alt=\"Structure_DNS.jpg\"></p>\n<p>上面 DNS 的层级结构很明显是一个树型的结构，解析的过程就是从根到叶子节点的访问过程。作为基础的网络服务，单节点肯定是不可靠的，所以上图的节点实际中不是孤立存在的，而是由一组服务器构成。例如根节点就对应了全世界 13 台根服务器。</p>\n<h2 id=\"DNS-查询过程\"><a href=\"#DNS-查询过程\" class=\"headerlink\" title=\"DNS 查询过程\"></a>DNS 查询过程</h2><p>既然树型的 DNS 的结构不能一步获取到最终查询结果，这里就有两种方式处理处理查询过程了：</p>\n<ul>\n<li><p>递归查询</p>\n<p>客户端发出查询请求后，只接受一个准确的查询结果，而不能是查询的中间过程</p>\n</li>\n<li><p>迭代查询</p>\n<p>客户端发出查询请求后，DNS 服务器不直接回复查询结果，而是告诉客户端另一台 DNS 服务器地址，客户端再向这台 DNS 服务器请求解析，依此循环直到返回查询的结果</p>\n</li>\n</ul>\n<p>两者各有利弊，通常是将两者结合在一起，一个 DNS 的解析大致可以分两个部分：</p>\n<ol>\n<li>客户端向 Local DNS 的请求，通常这部分使用递归请求</li>\n<li>Local DNS 的请求，通常这部分使用迭代请求</li>\n</ol>\n<p>按照上述规则一个基本的 DNS 解析过程：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/07/05/595c5beaef747.png\" alt=\"dn-sresolution.png\"></p>\n<ol>\n<li>发出域名解析请求</li>\n<li>本机的域名解析器 resolver 程序查询本地缓存和 host 文件中是否为域名的映射关系</li>\n<li>本地解析器向 TCP/IP 参数中设置的首选 DNS 服务器（我们叫它 Local DNS 服务器）发起一个递归的查询请求</li>\n<li>服务器收到查询时<ol>\n<li>如果要查询的域名由 Local DNS 服务器负责解析，则返回解析结果给客户机，完成域名解析，且此解析具有权威性</li>\n<li>如果要查询的域名不由 Local DNS 服务器解析，则调用这个 IP 地址映射，完成域名解析，且此解析不具有权威性</li>\n</ol>\n</li>\n<li>根据 Local DNS 服务器的设置（是否递归）进行查询<ol>\n<li>如果是迭代查询，Local DNS 就把请求发至13台 Root DNS</li>\n<li>如果是递归查询，Local DNS 就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环</li>\n</ol>\n</li>\n<li>Root DNS 服务器收到请求后会判断这个域名是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP</li>\n<li>Local DNS 服务器收到 IP 信息后，将会联系负责 .edu 域的这台服务器</li>\n<li>负责 .edu 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .edu 域的下一级 DNS 服务器地址给 Local DNS 服务器</li>\n<li>当 Local DNS 服务器收到这个地址后，就会找 googleplex.edu 域服务器</li>\n<li>负责 googleplex.edu 域的服务器接收到请求后，如果自己无法解析，继续找管理 googleplex.edu 域的下一级 DNS 服务器地址给 Local DNS 服务器</li>\n<li>当 Local DNS 服务器收到这个地址后，就会找 compsci.googleplex.edu 域服务器</li>\n<li>最后 compsci.googleplex.edu 域服务器返回需要解析的域名的 IP 地址给 Local DNS 服务器</li>\n<li>Local DNS 服务器缓存这个解析结果（同时也会缓存，6、8、10返回的结果）</li>\n<li>Local DNS 服务器同时将结果返回给本机域名解析器</li>\n<li>本机缓存解析结果</li>\n<li>本机解析器将结果返回给浏览器</li>\n<li>浏览器通过返回的 IP 地址发起请求</li>\n</ol>\n<h2 id=\"DNS-记录\"><a href=\"#DNS-记录\" class=\"headerlink\" title=\"DNS 记录\"></a>DNS 记录</h2><p>资源记录：name, value, type, ttl</p>\n<p>ttl：记录存活时间</p>\n<p>type 分类：</p>\n<ul>\n<li>A：name：主机域名，value：IP地址</li>\n<li>NS：name：域，value：域的权威域名解析服务的主机域名</li>\n<li>CNAME：name：真实域名的别名，value：真实域名</li>\n<li>MX：value是与name相对应的邮件服务器</li>\n</ul>\n<h2 id=\"其他-DNS-相关\"><a href=\"#其他-DNS-相关\" class=\"headerlink\" title=\"其他 DNS 相关\"></a>其他 DNS 相关</h2><h3 id=\"常见的-DNS-功能说明\"><a href=\"#常见的-DNS-功能说明\" class=\"headerlink\" title=\"常见的 DNS 功能说明\"></a>常见的 DNS 功能说明</h3><ul>\n<li>权威 DNS： 最终决定域名解析结果的服务器，可以在其上配置具体域名的对应解析结果信息</li>\n<li>递归 DNS 或本地 DNS：有域名解析结果的决定权，但代理了用户向权威DNS获取域名解析结果的过程，不属于 DNS 层次体系</li>\n<li>公共 DNS：全网开放的递归 DNS，不同于一般的本地 DNS 由 ISP 提供</li>\n</ul>\n<h3 id=\"DNS-相关命令\"><a href=\"#DNS-相关命令\" class=\"headerlink\" title=\"DNS 相关命令\"></a>DNS 相关命令</h3><ul>\n<li>dig</li>\n<li>host</li>\n<li>nslookup</li>\n</ul>\n<p>命令的参考：<a href=\"http://luodw.cc/2015/12/27/dns03/\" target=\"_blank\" rel=\"external\">域名解析之dig,host,nslookup命令</a></p>\n","excerpt":"","more":"<h2 id=\"DNS-是什么\"><a href=\"#DNS-是什么\" class=\"headerlink\" title=\"DNS 是什么\"></a>DNS 是什么</h2><p>了解网络的同学应该都是知道 DNS的，它提供最基本的从域名到 IP 地址的转换服务。简单可以把 DNS 理解成一个翻译官，这位翻译官每天默默地为我们处理上网请求时域名到 IP 的转换。</p>\n<p>上网时每次对域名的请求使用的是 HTTP 协议，而作为翻译官 DNS 发生在HTTP 真实请求之前。尽管 DNS 协议执行在 HTTP 请求之前，但与 HTTP 一样，DNS 也是 TP/IP 协议模型中应用层协议。更具体一点默认使用的是 UDP 的传输方式，端口号为 53 。</p>\n<p>补充一下，除了基本的域名到 IP 的转换服务， DNS 还可以提供主机别名，邮件服务器别名，负载均衡功能。</p>\n<h2 id=\"DNS-结构\"><a href=\"#DNS-结构\" class=\"headerlink\" title=\"DNS 结构\"></a>DNS 结构</h2><p>从功能上来看，DNS 只提供了非常简单的字符串到字符串的转换服务。类似于程序语言中的字典结构就可以完成映射转换。所以在很多网络结构图中 DNS 服务往往被描述成一台服务器，在客户端与服务器请求之前，首先在 DNS 服务器上查询服务器对应的 IP 即可。我们日常的使用中 DNS 也确实扮演了这样一个默默无闻的角色，运行的过程对用户非常透明。</p>\n<p>为了使 DNS 可以做到全球范围的高可用，一台简单的服务器肯定是无法满足的。实际上DNS 根据域名的层级也划分出不同的 DNS 层级。</p>\n<h3 id=\"域名层级\"><a href=\"#域名层级\" class=\"headerlink\" title=\"域名层级\"></a>域名层级</h3><p>域名层级的划分示意：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/07/05/595c6d4dc5144.jpg\" alt=\"Name_schema.jpg\"></p>\n<p>域名的层级结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">主机名.次级域名.顶级域名.根域名</div><div class=\"line\"></div><div class=\"line\">host.sld.tld.root</div></pre></td></tr></table></figure>\n<p>以  www.example.com 域名为例，看看域名的划分：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">域名</th>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">使用的域名</td>\n<td style=\"text-align:center\">www.example.com</td>\n<td style=\"text-align:center\">日常真实使用的域名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">真正的域名</td>\n<td style=\"text-align:center\">www.example.com.root</td>\n<td style=\"text-align:center\">.root通常省略</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">根域名</td>\n<td style=\"text-align:center\">.root</td>\n<td style=\"text-align:center\">对所有域名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">顶级域名</td>\n<td style=\"text-align:center\">.com</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">次顶级域名</td>\n<td style=\"text-align:center\">.example</td>\n<td style=\"text-align:center\">用户可注册的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">三级域名（主机名）</td>\n<td style=\"text-align:center\">www</td>\n<td style=\"text-align:center\">用户在自己的域里面为服务器分配的名称</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"DNS-层级\"><a href=\"#DNS-层级\" class=\"headerlink\" title=\"DNS 层级\"></a>DNS 层级</h3><p>域名层级结构对应的 DNS 服务结构划分： </p>\n<p><img src=\"https://ooo.0o0.ooo/2017/07/05/595c6c612da55.jpg\" alt=\"Structure_DNS.jpg\"></p>\n<p>上面 DNS 的层级结构很明显是一个树型的结构，解析的过程就是从根到叶子节点的访问过程。作为基础的网络服务，单节点肯定是不可靠的，所以上图的节点实际中不是孤立存在的，而是由一组服务器构成。例如根节点就对应了全世界 13 台根服务器。</p>\n<h2 id=\"DNS-查询过程\"><a href=\"#DNS-查询过程\" class=\"headerlink\" title=\"DNS 查询过程\"></a>DNS 查询过程</h2><p>既然树型的 DNS 的结构不能一步获取到最终查询结果，这里就有两种方式处理处理查询过程了：</p>\n<ul>\n<li><p>递归查询</p>\n<p>客户端发出查询请求后，只接受一个准确的查询结果，而不能是查询的中间过程</p>\n</li>\n<li><p>迭代查询</p>\n<p>客户端发出查询请求后，DNS 服务器不直接回复查询结果，而是告诉客户端另一台 DNS 服务器地址，客户端再向这台 DNS 服务器请求解析，依此循环直到返回查询的结果</p>\n</li>\n</ul>\n<p>两者各有利弊，通常是将两者结合在一起，一个 DNS 的解析大致可以分两个部分：</p>\n<ol>\n<li>客户端向 Local DNS 的请求，通常这部分使用递归请求</li>\n<li>Local DNS 的请求，通常这部分使用迭代请求</li>\n</ol>\n<p>按照上述规则一个基本的 DNS 解析过程：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/07/05/595c5beaef747.png\" alt=\"dn-sresolution.png\"></p>\n<ol>\n<li>发出域名解析请求</li>\n<li>本机的域名解析器 resolver 程序查询本地缓存和 host 文件中是否为域名的映射关系</li>\n<li>本地解析器向 TCP/IP 参数中设置的首选 DNS 服务器（我们叫它 Local DNS 服务器）发起一个递归的查询请求</li>\n<li>服务器收到查询时<ol>\n<li>如果要查询的域名由 Local DNS 服务器负责解析，则返回解析结果给客户机，完成域名解析，且此解析具有权威性</li>\n<li>如果要查询的域名不由 Local DNS 服务器解析，则调用这个 IP 地址映射，完成域名解析，且此解析不具有权威性</li>\n</ol>\n</li>\n<li>根据 Local DNS 服务器的设置（是否递归）进行查询<ol>\n<li>如果是迭代查询，Local DNS 就把请求发至13台 Root DNS</li>\n<li>如果是递归查询，Local DNS 就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环</li>\n</ol>\n</li>\n<li>Root DNS 服务器收到请求后会判断这个域名是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP</li>\n<li>Local DNS 服务器收到 IP 信息后，将会联系负责 .edu 域的这台服务器</li>\n<li>负责 .edu 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .edu 域的下一级 DNS 服务器地址给 Local DNS 服务器</li>\n<li>当 Local DNS 服务器收到这个地址后，就会找 googleplex.edu 域服务器</li>\n<li>负责 googleplex.edu 域的服务器接收到请求后，如果自己无法解析，继续找管理 googleplex.edu 域的下一级 DNS 服务器地址给 Local DNS 服务器</li>\n<li>当 Local DNS 服务器收到这个地址后，就会找 compsci.googleplex.edu 域服务器</li>\n<li>最后 compsci.googleplex.edu 域服务器返回需要解析的域名的 IP 地址给 Local DNS 服务器</li>\n<li>Local DNS 服务器缓存这个解析结果（同时也会缓存，6、8、10返回的结果）</li>\n<li>Local DNS 服务器同时将结果返回给本机域名解析器</li>\n<li>本机缓存解析结果</li>\n<li>本机解析器将结果返回给浏览器</li>\n<li>浏览器通过返回的 IP 地址发起请求</li>\n</ol>\n<h2 id=\"DNS-记录\"><a href=\"#DNS-记录\" class=\"headerlink\" title=\"DNS 记录\"></a>DNS 记录</h2><p>资源记录：name, value, type, ttl</p>\n<p>ttl：记录存活时间</p>\n<p>type 分类：</p>\n<ul>\n<li>A：name：主机域名，value：IP地址</li>\n<li>NS：name：域，value：域的权威域名解析服务的主机域名</li>\n<li>CNAME：name：真实域名的别名，value：真实域名</li>\n<li>MX：value是与name相对应的邮件服务器</li>\n</ul>\n<h2 id=\"其他-DNS-相关\"><a href=\"#其他-DNS-相关\" class=\"headerlink\" title=\"其他 DNS 相关\"></a>其他 DNS 相关</h2><h3 id=\"常见的-DNS-功能说明\"><a href=\"#常见的-DNS-功能说明\" class=\"headerlink\" title=\"常见的 DNS 功能说明\"></a>常见的 DNS 功能说明</h3><ul>\n<li>权威 DNS： 最终决定域名解析结果的服务器，可以在其上配置具体域名的对应解析结果信息</li>\n<li>递归 DNS 或本地 DNS：有域名解析结果的决定权，但代理了用户向权威DNS获取域名解析结果的过程，不属于 DNS 层次体系</li>\n<li>公共 DNS：全网开放的递归 DNS，不同于一般的本地 DNS 由 ISP 提供</li>\n</ul>\n<h3 id=\"DNS-相关命令\"><a href=\"#DNS-相关命令\" class=\"headerlink\" title=\"DNS 相关命令\"></a>DNS 相关命令</h3><ul>\n<li>dig</li>\n<li>host</li>\n<li>nslookup</li>\n</ul>\n<p>命令的参考：<a href=\"http://luodw.cc/2015/12/27/dns03/\">域名解析之dig,host,nslookup命令</a></p>\n"},{"title":"【Spring】容器刷新","date":"2017-07-15T16:20:31.000Z","_content":"前面文章在分析 Spring Boot 的启动过程中提到了 AbstractApplicationContext 类的 refresh 方法，这个方法是 Spring 容器的核心方法之一，该方法提供了基本的模板，完成容器的初始化，并提供了丰富的接口可以从纵向（容器启动过程）、横向（不同的容器子类型）、不同形式（声明式、编程式等）进行自定义扩展。\n\n有关 ApplicationContext 和 BeanFactory 的内容可以参考之前关于 Spring 的文章：\n\n- [Spring之BeanFactory](http://zhangh.tk/2017/03/13/Spring%E4%B9%8BBeanFactory/)\n- [Spring之ApplicationContext](http://zhangh.tk/2017/03/19/Spring%E4%B9%8BApplicationContext/)\n\n这里详细过一下 refresh 方法的过程，留个印象，方便以后回顾。\n\n这篇文章就不记录关于 Spring Boot 在启动刷新阶段的特殊实现了，只关心 Spring 的通用实现模板\n\n## 概览\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   synchronized (this.startupShutdownMonitor) {\n      // 刷新前准备工作\n      prepareRefresh();\n\n      // 调用子类refreshBeanFactory()方法，获取bean factory\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 创建bean Factory的通用设置\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 子类特殊的bean factory设置\n         postProcessBeanFactory(beanFactory);\n\n         // 实例化beanFactoryPostProcessor\n         // 调用beanFactoryPostProcessor修改bean definition\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // 注册 bean pst processors\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化信息源，和国际化相关\n         initMessageSource();\n\n         // 初始化容器事件传播器\n         initApplicationEventMulticaster();\n\n         // 调用子类特殊的刷新逻辑\n         onRefresh();\n\n         // 为事件传播器注册事件监听器\n         registerListeners();\n\n         // 实例化所有非懒加载单例\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 初始化容器的生命周期事件处理器，并发布容器的生命周期事件\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         // ...\n      }\n      finally {\n         // ...\n      }\n   }\n}\n```\n\n## 刷新过程详述\n\n### prepareRefresh\n\n```java\nprotected void prepareRefresh() {\n   // 设置Spring容器的启动时间，撤销关闭状态，开启活跃状态\n   this.startupDate = System.currentTimeMillis();\n   this.closed.set(false);\n   this.active.set(true);\n\n   if (logger.isInfoEnabled()) {\n      logger.info(\"Refreshing \" + this);\n   }\n\n   // 模板方法，设置属性源信息\n   initPropertySources();\n\n   // 验证环境信息里一些必须存在的属性\n   getEnvironment().validateRequiredProperties();\n\n   this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();\n}\n```\n\n### obtainFreshBeanFactory\n\n```java\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n   // 模板方法\n   // 获取刷新Spring上下文的Bean工厂\n   refreshBeanFactory();\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n   }\n   return beanFactory;\n}\n```\n\n### prepareBeanFactory\n\n```java\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // 设置classloader\n   beanFactory.setBeanClassLoader(getClassLoader());\n   // 设置表达式解析器\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n   // 添加属性编辑注册器\n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // 添加ApplicationContextAwareProcessor这个BeanPostProcessor用于回调\n   // ApplicationContextAwareProcessor主要的作用是给实现XxxxAware的bean注入相关属性\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n   // 取消以下接口的自动注入\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   // 设置特殊的类型对应的bean，修正依赖\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // Register early post-processor for detecting inner beans as ApplicationListeners.\n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // 如果自定义的Bean中没有一个名为”loadTimeWeaver”的Bena\n   // 添加一个LoadTimeWeaverAwareProcessor\n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   // 如果自定义的Bean中没有名为”systemProperties”和”systemEnvironment”的Bean\n   // 注册两个Bena，Key为”systemProperties”和”systemEnvironment”，Value为Map\n   // 这两个bean包含系统配置和系统环绕信息\n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}\n```\n\n### postProcessBeanFactory\n\n空实现，由具体子类实现。为子类特殊的 Application Context 实现指定特殊的 bean post 事件处理器\n\n### invokeBeanFactoryPostProcessors\n\n整个 Spring 流程中非常重要的方法，大量的用户自定义扩展都与这个方法有关。\n\n第一次读的时候看着怪复杂的直接跳过去了，结果启动过程的好多问题还是没搞清楚。\n\n```java\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n   // 实例化并调用所有注册的 beanFactoryPostProcessor\n   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n   if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n}\n```\n\n复杂的东西不在上面，是 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors 方法的调用\n\n说明这个方法之前有两个类需要特备说明，这个方法的操作都是围绕这两个类的：\n\n- BeanFactoryPostProcessor\n\n  在 bean 实例化阶段开始之前，对注册到容器的 BeanDefinition 保存的原始数据做出修改\n\n- BeanDefinitionRegistryPostProcessor\n\n  继承自上面的 BeanFactoryPostProcessor\n\n  专门用来对注册的容器的 BeanFactoryPostProcessor 的BeanDefinition 保存的原始数据做出修改\n\n有点拗口，不过意思类似指针与二级指针的关系。\n\n整个 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors 的实现太复杂了，但其实就一个意思：\n\n1. 先用 BeanDefinitionRegistryPostProcessor 修改 BeanFactoryPostProcessor 的 BeanDefinition \n2. 然后用 BeanFactoryPostProcessor 修改普通的 BeanDefinition\n\n具体在操作过程中 BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor 执行的顺序有明确的限制，两者都是根据以下规则执行：\n\n1. 首先执行实现 PriorityOrdered 接口的，调用顺序是按照接口方法 getOrder() 的实现\n2. 其次执行实现 Ordered 接口的，调用顺序是按照接口方法 getOrder() 的实现\n3. 最后执行既没有实现 PriorityOrdered  也没有实现 Ordered 的，调用顺序是 bean 的定义顺序\n\n### registerBeanPostProcessors\n\n```java\nprotected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n   // 从Spring容器中找出的BeanPostProcessor接口的bean，并设置到BeanFactory的属性中\n   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\n}\n```\n\n思路与 invokeBeanFactoryPostProcessors 方法类似。\n\n但只是从容器中找出实现 BeanPostProcessor 的bean，排序后设置到BeanFactory的属性中，并不调用。\n\n具体的排序过程：\n\n1. 优先调用 PriorityOrdered 接口的子接口，调用顺序依照接口方法getOrder的返回值从小到大排序\n2. 其次调用Ordered接口的子接口，调用顺序依照接口方法getOrder的返回值从小到大排序\n3. 接着按照 BeanPostProcessor 实现类在配置文件中定义的顺序进行调用\n4. 最后调用MergedBeanDefinitionPostProcessor接口的实现Bean，同样按照在配置文件中定义的顺序进行调用\n\n### initMessageSource\n\n```java\nprotected void initMessageSource() {\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {\n      // 如果自定义了名为”messageSource”的Bean\n      // 直接实例化Bean，该Bean必须是MessageSource接口的实现Bean\n      // 该Bean如果是HierarchicalMessageSource接口的实现类\n      // 强转为HierarchicalMessageSource接口，并设置一下parentMessageSource\n      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);\n      // Make MessageSource aware of parent MessageSource.\n      if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {\n         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;\n         if (hms.getParentMessageSource() == null) {\n            // Only set parent context as parent MessageSource if no parent MessageSource\n            // registered already.\n            hms.setParentMessageSource(getInternalParentMessageSource());\n         }\n      }\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Using MessageSource [\" + this.messageSource + \"]\");\n      }\n   }\n   else {\n      // 如果没有自定义名为”messageSource”的Bean，那么会默认注册一个DelegatingMessageSource并加入\n      // Use empty MessageSource to be able to accept getMessage calls.\n      DelegatingMessageSource dms = new DelegatingMessageSource();\n      dms.setParentMessageSource(getInternalParentMessageSource());\n      this.messageSource = dms;\n      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Unable to locate MessageSource with name '\" + MESSAGE_SOURCE_BEAN_NAME +\n               \"': using default [\" + this.messageSource + \"]\");\n      }\n   }\n}\n```\n\n### initApplicationEventMulticaster\n\n```java\nprotected void initApplicationEventMulticaster() {\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {\n      // 如果自定义了名为”applicationEventMulticaster”的Bean\n      // 实例化自定义的Bean，自定义的Bean必须是ApplicationEventMulticaster接口的实现类\n      this.applicationEventMulticaster =\n            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Using ApplicationEventMulticaster [\" + this.applicationEventMulticaster + \"]\");\n      }\n   }\n   else {\n      // 如果没有自定义名为”ApplicationEventMulticaster”的Bean\n      // 注册一个类型为SimpleApplicationEventMulticaster的Bean\n      this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);\n      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Unable to locate ApplicationEventMulticaster with name '\" +\n               APPLICATION_EVENT_MULTICASTER_BEAN_NAME +\n               \"': using default [\" + this.applicationEventMulticaster + \"]\");\n      }\n   }\n}\n```\n\n### onRefresh\n\n空的模板方法，根据不同的 ApplicationContext 子类实现对应的业务逻辑\n\n### registerListeners\n\n```java\nprotected void registerListeners() {\n   // Register statically specified listeners first.\n   for (ApplicationListener<?> listener : getApplicationListeners()) {\n      getApplicationEventMulticaster().addApplicationListener(listener);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let post-processors apply to them!\n   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\n   for (String listenerBeanName : listenerBeanNames) {\n      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n   }\n\n   // Publish early application events now that we finally have a multicaster...\n   Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;\n   this.earlyApplicationEvents = null;\n   if (earlyEventsToProcess != null) {\n      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {\n         getApplicationEventMulticaster().multicastEvent(earlyEvent);\n      }\n   }\n}\n```\n\n### finishBeanFactoryInitialization\n\n```java\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n   //有容器转换服务bean时先实例化这种Bean\n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n   \n   // 注册一个默认的嵌入式值解析器\n   if (!beanFactory.hasEmbeddedValueResolver()) {\n      beanFactory.addEmbeddedValueResolver(new StringValueResolver() {\n         @Override\n         public String resolveStringValue(String strVal) {\n            return getEnvironment().resolvePlaceholders(strVal);\n         }\n      });\n   }\n\n   // 实例化LoadTimeWeaverAware类型Bean\n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n   for (String weaverAwareName : weaverAwareNames) {\n      getBean(weaverAwareName);\n   }\n\n   // 停止使用临时类加载器\n   beanFactory.setTempClassLoader(null);\n\n   // 缓存容器中所有注册的BeanDefinition元数据，以防被修改\n   beanFactory.freezeConfiguration();\n\n   // 实例化剩余的所有非lazy-init singleton Bean\n   beanFactory.preInstantiateSingletons();\n}\n```\n\n### finishRefresh\n\n```java\nprotected void finishRefresh() {\n   // 初始化生命周期处理器（LifecycleProcessor）\n   // 先找一下有没有自定义名为lifecycleProcessor的Bean，有的话就实例化出来\n   // 该Bean必须是LifecycleProcessor的实现类\n   // 没有则向Spring上下文中注册一个类型为DefaultLifecycleProcessor的LifecycleProcessor实现类\n   initLifecycleProcessor();\n\n   // 调用生命周期处理器的onRefresh方法\n   getLifecycleProcessor().onRefresh();\n\n   // 发布ContextRefreshedEvent事件告知对应的ApplicationListener进行响应的操作\n   publishEvent(new ContextRefreshedEvent(this));\n\n   // 如果设置了JMX相关的属性，则就调用该方法\n   LiveBeansView.registerApplicationContext(this);\n}\n```\n以上就是简单的记录了 Spring 启动过程中容器刷新的动作。\n\n---\n\n以上内容除了源码的阅读还参考了其他博客，学习到了很多细节，这里表示感谢了：\n\n[SpringBoot源码分析之Spring容器的refresh过程](http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/)\n\n[Spring-- Ioc 容器Bean实例化的几种场景](http://blog.csdn.net/bubaxiu/article/details/41415685)\n\n[《Spring技术内幕》学习笔记6——IoC容器的高级特性](http://blog.csdn.net/chjttony/article/details/6278627)\n\n[Spring源码分析：非懒加载的单例Bean初始化前后的一些操作](http://www.importnew.com/24282.html)\n","source":"_posts/【Spring】容器刷新.md","raw":"---\ntitle: 【Spring】容器刷新\ndate: 2017-07-16 00:20:31\ntags:\n  - Java\n  - Spring\ncategories: Spring\n---\n前面文章在分析 Spring Boot 的启动过程中提到了 AbstractApplicationContext 类的 refresh 方法，这个方法是 Spring 容器的核心方法之一，该方法提供了基本的模板，完成容器的初始化，并提供了丰富的接口可以从纵向（容器启动过程）、横向（不同的容器子类型）、不同形式（声明式、编程式等）进行自定义扩展。\n\n有关 ApplicationContext 和 BeanFactory 的内容可以参考之前关于 Spring 的文章：\n\n- [Spring之BeanFactory](http://zhangh.tk/2017/03/13/Spring%E4%B9%8BBeanFactory/)\n- [Spring之ApplicationContext](http://zhangh.tk/2017/03/19/Spring%E4%B9%8BApplicationContext/)\n\n这里详细过一下 refresh 方法的过程，留个印象，方便以后回顾。\n\n这篇文章就不记录关于 Spring Boot 在启动刷新阶段的特殊实现了，只关心 Spring 的通用实现模板\n\n## 概览\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   synchronized (this.startupShutdownMonitor) {\n      // 刷新前准备工作\n      prepareRefresh();\n\n      // 调用子类refreshBeanFactory()方法，获取bean factory\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 创建bean Factory的通用设置\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 子类特殊的bean factory设置\n         postProcessBeanFactory(beanFactory);\n\n         // 实例化beanFactoryPostProcessor\n         // 调用beanFactoryPostProcessor修改bean definition\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // 注册 bean pst processors\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化信息源，和国际化相关\n         initMessageSource();\n\n         // 初始化容器事件传播器\n         initApplicationEventMulticaster();\n\n         // 调用子类特殊的刷新逻辑\n         onRefresh();\n\n         // 为事件传播器注册事件监听器\n         registerListeners();\n\n         // 实例化所有非懒加载单例\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 初始化容器的生命周期事件处理器，并发布容器的生命周期事件\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         // ...\n      }\n      finally {\n         // ...\n      }\n   }\n}\n```\n\n## 刷新过程详述\n\n### prepareRefresh\n\n```java\nprotected void prepareRefresh() {\n   // 设置Spring容器的启动时间，撤销关闭状态，开启活跃状态\n   this.startupDate = System.currentTimeMillis();\n   this.closed.set(false);\n   this.active.set(true);\n\n   if (logger.isInfoEnabled()) {\n      logger.info(\"Refreshing \" + this);\n   }\n\n   // 模板方法，设置属性源信息\n   initPropertySources();\n\n   // 验证环境信息里一些必须存在的属性\n   getEnvironment().validateRequiredProperties();\n\n   this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();\n}\n```\n\n### obtainFreshBeanFactory\n\n```java\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n   // 模板方法\n   // 获取刷新Spring上下文的Bean工厂\n   refreshBeanFactory();\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n   }\n   return beanFactory;\n}\n```\n\n### prepareBeanFactory\n\n```java\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // 设置classloader\n   beanFactory.setBeanClassLoader(getClassLoader());\n   // 设置表达式解析器\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n   // 添加属性编辑注册器\n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // 添加ApplicationContextAwareProcessor这个BeanPostProcessor用于回调\n   // ApplicationContextAwareProcessor主要的作用是给实现XxxxAware的bean注入相关属性\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n   // 取消以下接口的自动注入\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   // 设置特殊的类型对应的bean，修正依赖\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // Register early post-processor for detecting inner beans as ApplicationListeners.\n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // 如果自定义的Bean中没有一个名为”loadTimeWeaver”的Bena\n   // 添加一个LoadTimeWeaverAwareProcessor\n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   // 如果自定义的Bean中没有名为”systemProperties”和”systemEnvironment”的Bean\n   // 注册两个Bena，Key为”systemProperties”和”systemEnvironment”，Value为Map\n   // 这两个bean包含系统配置和系统环绕信息\n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}\n```\n\n### postProcessBeanFactory\n\n空实现，由具体子类实现。为子类特殊的 Application Context 实现指定特殊的 bean post 事件处理器\n\n### invokeBeanFactoryPostProcessors\n\n整个 Spring 流程中非常重要的方法，大量的用户自定义扩展都与这个方法有关。\n\n第一次读的时候看着怪复杂的直接跳过去了，结果启动过程的好多问题还是没搞清楚。\n\n```java\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n   // 实例化并调用所有注册的 beanFactoryPostProcessor\n   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n   if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n}\n```\n\n复杂的东西不在上面，是 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors 方法的调用\n\n说明这个方法之前有两个类需要特备说明，这个方法的操作都是围绕这两个类的：\n\n- BeanFactoryPostProcessor\n\n  在 bean 实例化阶段开始之前，对注册到容器的 BeanDefinition 保存的原始数据做出修改\n\n- BeanDefinitionRegistryPostProcessor\n\n  继承自上面的 BeanFactoryPostProcessor\n\n  专门用来对注册的容器的 BeanFactoryPostProcessor 的BeanDefinition 保存的原始数据做出修改\n\n有点拗口，不过意思类似指针与二级指针的关系。\n\n整个 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors 的实现太复杂了，但其实就一个意思：\n\n1. 先用 BeanDefinitionRegistryPostProcessor 修改 BeanFactoryPostProcessor 的 BeanDefinition \n2. 然后用 BeanFactoryPostProcessor 修改普通的 BeanDefinition\n\n具体在操作过程中 BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor 执行的顺序有明确的限制，两者都是根据以下规则执行：\n\n1. 首先执行实现 PriorityOrdered 接口的，调用顺序是按照接口方法 getOrder() 的实现\n2. 其次执行实现 Ordered 接口的，调用顺序是按照接口方法 getOrder() 的实现\n3. 最后执行既没有实现 PriorityOrdered  也没有实现 Ordered 的，调用顺序是 bean 的定义顺序\n\n### registerBeanPostProcessors\n\n```java\nprotected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n   // 从Spring容器中找出的BeanPostProcessor接口的bean，并设置到BeanFactory的属性中\n   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\n}\n```\n\n思路与 invokeBeanFactoryPostProcessors 方法类似。\n\n但只是从容器中找出实现 BeanPostProcessor 的bean，排序后设置到BeanFactory的属性中，并不调用。\n\n具体的排序过程：\n\n1. 优先调用 PriorityOrdered 接口的子接口，调用顺序依照接口方法getOrder的返回值从小到大排序\n2. 其次调用Ordered接口的子接口，调用顺序依照接口方法getOrder的返回值从小到大排序\n3. 接着按照 BeanPostProcessor 实现类在配置文件中定义的顺序进行调用\n4. 最后调用MergedBeanDefinitionPostProcessor接口的实现Bean，同样按照在配置文件中定义的顺序进行调用\n\n### initMessageSource\n\n```java\nprotected void initMessageSource() {\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {\n      // 如果自定义了名为”messageSource”的Bean\n      // 直接实例化Bean，该Bean必须是MessageSource接口的实现Bean\n      // 该Bean如果是HierarchicalMessageSource接口的实现类\n      // 强转为HierarchicalMessageSource接口，并设置一下parentMessageSource\n      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);\n      // Make MessageSource aware of parent MessageSource.\n      if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {\n         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;\n         if (hms.getParentMessageSource() == null) {\n            // Only set parent context as parent MessageSource if no parent MessageSource\n            // registered already.\n            hms.setParentMessageSource(getInternalParentMessageSource());\n         }\n      }\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Using MessageSource [\" + this.messageSource + \"]\");\n      }\n   }\n   else {\n      // 如果没有自定义名为”messageSource”的Bean，那么会默认注册一个DelegatingMessageSource并加入\n      // Use empty MessageSource to be able to accept getMessage calls.\n      DelegatingMessageSource dms = new DelegatingMessageSource();\n      dms.setParentMessageSource(getInternalParentMessageSource());\n      this.messageSource = dms;\n      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Unable to locate MessageSource with name '\" + MESSAGE_SOURCE_BEAN_NAME +\n               \"': using default [\" + this.messageSource + \"]\");\n      }\n   }\n}\n```\n\n### initApplicationEventMulticaster\n\n```java\nprotected void initApplicationEventMulticaster() {\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {\n      // 如果自定义了名为”applicationEventMulticaster”的Bean\n      // 实例化自定义的Bean，自定义的Bean必须是ApplicationEventMulticaster接口的实现类\n      this.applicationEventMulticaster =\n            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Using ApplicationEventMulticaster [\" + this.applicationEventMulticaster + \"]\");\n      }\n   }\n   else {\n      // 如果没有自定义名为”ApplicationEventMulticaster”的Bean\n      // 注册一个类型为SimpleApplicationEventMulticaster的Bean\n      this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);\n      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Unable to locate ApplicationEventMulticaster with name '\" +\n               APPLICATION_EVENT_MULTICASTER_BEAN_NAME +\n               \"': using default [\" + this.applicationEventMulticaster + \"]\");\n      }\n   }\n}\n```\n\n### onRefresh\n\n空的模板方法，根据不同的 ApplicationContext 子类实现对应的业务逻辑\n\n### registerListeners\n\n```java\nprotected void registerListeners() {\n   // Register statically specified listeners first.\n   for (ApplicationListener<?> listener : getApplicationListeners()) {\n      getApplicationEventMulticaster().addApplicationListener(listener);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let post-processors apply to them!\n   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\n   for (String listenerBeanName : listenerBeanNames) {\n      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n   }\n\n   // Publish early application events now that we finally have a multicaster...\n   Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;\n   this.earlyApplicationEvents = null;\n   if (earlyEventsToProcess != null) {\n      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {\n         getApplicationEventMulticaster().multicastEvent(earlyEvent);\n      }\n   }\n}\n```\n\n### finishBeanFactoryInitialization\n\n```java\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n   //有容器转换服务bean时先实例化这种Bean\n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n   \n   // 注册一个默认的嵌入式值解析器\n   if (!beanFactory.hasEmbeddedValueResolver()) {\n      beanFactory.addEmbeddedValueResolver(new StringValueResolver() {\n         @Override\n         public String resolveStringValue(String strVal) {\n            return getEnvironment().resolvePlaceholders(strVal);\n         }\n      });\n   }\n\n   // 实例化LoadTimeWeaverAware类型Bean\n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n   for (String weaverAwareName : weaverAwareNames) {\n      getBean(weaverAwareName);\n   }\n\n   // 停止使用临时类加载器\n   beanFactory.setTempClassLoader(null);\n\n   // 缓存容器中所有注册的BeanDefinition元数据，以防被修改\n   beanFactory.freezeConfiguration();\n\n   // 实例化剩余的所有非lazy-init singleton Bean\n   beanFactory.preInstantiateSingletons();\n}\n```\n\n### finishRefresh\n\n```java\nprotected void finishRefresh() {\n   // 初始化生命周期处理器（LifecycleProcessor）\n   // 先找一下有没有自定义名为lifecycleProcessor的Bean，有的话就实例化出来\n   // 该Bean必须是LifecycleProcessor的实现类\n   // 没有则向Spring上下文中注册一个类型为DefaultLifecycleProcessor的LifecycleProcessor实现类\n   initLifecycleProcessor();\n\n   // 调用生命周期处理器的onRefresh方法\n   getLifecycleProcessor().onRefresh();\n\n   // 发布ContextRefreshedEvent事件告知对应的ApplicationListener进行响应的操作\n   publishEvent(new ContextRefreshedEvent(this));\n\n   // 如果设置了JMX相关的属性，则就调用该方法\n   LiveBeansView.registerApplicationContext(this);\n}\n```\n以上就是简单的记录了 Spring 启动过程中容器刷新的动作。\n\n---\n\n以上内容除了源码的阅读还参考了其他博客，学习到了很多细节，这里表示感谢了：\n\n[SpringBoot源码分析之Spring容器的refresh过程](http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/)\n\n[Spring-- Ioc 容器Bean实例化的几种场景](http://blog.csdn.net/bubaxiu/article/details/41415685)\n\n[《Spring技术内幕》学习笔记6——IoC容器的高级特性](http://blog.csdn.net/chjttony/article/details/6278627)\n\n[Spring源码分析：非懒加载的单例Bean初始化前后的一些操作](http://www.importnew.com/24282.html)\n","slug":"【Spring】容器刷新","published":1,"updated":"2017-07-15T16:32:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2ri003gd82enb1hhv7k","content":"<p>前面文章在分析 Spring Boot 的启动过程中提到了 AbstractApplicationContext 类的 refresh 方法，这个方法是 Spring 容器的核心方法之一，该方法提供了基本的模板，完成容器的初始化，并提供了丰富的接口可以从纵向（容器启动过程）、横向（不同的容器子类型）、不同形式（声明式、编程式等）进行自定义扩展。</p>\n<p>有关 ApplicationContext 和 BeanFactory 的内容可以参考之前关于 Spring 的文章：</p>\n<ul>\n<li><a href=\"http://zhangh.tk/2017/03/13/Spring%E4%B9%8BBeanFactory/\" target=\"_blank\" rel=\"external\">Spring之BeanFactory</a></li>\n<li><a href=\"http://zhangh.tk/2017/03/19/Spring%E4%B9%8BApplicationContext/\" target=\"_blank\" rel=\"external\">Spring之ApplicationContext</a></li>\n</ul>\n<p>这里详细过一下 refresh 方法的过程，留个印象，方便以后回顾。</p>\n<p>这篇文章就不记录关于 Spring Boot 在启动刷新阶段的特殊实现了，只关心 Spring 的通用实现模板</p>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</div><div class=\"line\">      <span class=\"comment\">// 刷新前准备工作</span></div><div class=\"line\">      prepareRefresh();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 调用子类refreshBeanFactory()方法，获取bean factory</span></div><div class=\"line\">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 创建bean Factory的通用设置</span></div><div class=\"line\">      prepareBeanFactory(beanFactory);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         <span class=\"comment\">// 子类特殊的bean factory设置</span></div><div class=\"line\">         postProcessBeanFactory(beanFactory);</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 实例化beanFactoryPostProcessor</span></div><div class=\"line\">         <span class=\"comment\">// 调用beanFactoryPostProcessor修改bean definition</span></div><div class=\"line\">         invokeBeanFactoryPostProcessors(beanFactory);</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 注册 bean pst processors</span></div><div class=\"line\">         registerBeanPostProcessors(beanFactory);</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 初始化信息源，和国际化相关</span></div><div class=\"line\">         initMessageSource();</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 初始化容器事件传播器</span></div><div class=\"line\">         initApplicationEventMulticaster();</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 调用子类特殊的刷新逻辑</span></div><div class=\"line\">         onRefresh();</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 为事件传播器注册事件监听器</span></div><div class=\"line\">         registerListeners();</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 实例化所有非懒加载单例</span></div><div class=\"line\">         finishBeanFactoryInitialization(beanFactory);</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span></div><div class=\"line\">         finishRefresh();</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">catch</span> (BeansException ex) &#123;</div><div class=\"line\">         <span class=\"comment\">// ...</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">         <span class=\"comment\">// ...</span></div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"刷新过程详述\"><a href=\"#刷新过程详述\" class=\"headerlink\" title=\"刷新过程详述\"></a>刷新过程详述</h2><h3 id=\"prepareRefresh\"><a href=\"#prepareRefresh\" class=\"headerlink\" title=\"prepareRefresh\"></a>prepareRefresh</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareRefresh</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 设置Spring容器的启动时间，撤销关闭状态，开启活跃状态</span></div><div class=\"line\">   <span class=\"keyword\">this</span>.startupDate = System.currentTimeMillis();</div><div class=\"line\">   <span class=\"keyword\">this</span>.closed.set(<span class=\"keyword\">false</span>);</div><div class=\"line\">   <span class=\"keyword\">this</span>.active.set(<span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</div><div class=\"line\">      logger.info(<span class=\"string\">\"Refreshing \"</span> + <span class=\"keyword\">this</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 模板方法，设置属性源信息</span></div><div class=\"line\">   initPropertySources();</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 验证环境信息里一些必须存在的属性</span></div><div class=\"line\">   getEnvironment().validateRequiredProperties();</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">this</span>.earlyApplicationEvents = <span class=\"keyword\">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"obtainFreshBeanFactory\"><a href=\"#obtainFreshBeanFactory\" class=\"headerlink\" title=\"obtainFreshBeanFactory\"></a>obtainFreshBeanFactory</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ConfigurableListableBeanFactory <span class=\"title\">obtainFreshBeanFactory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 模板方法</span></div><div class=\"line\">   <span class=\"comment\">// 获取刷新Spring上下文的Bean工厂</span></div><div class=\"line\">   refreshBeanFactory();</div><div class=\"line\">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class=\"line\">   <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">      logger.debug(<span class=\"string\">\"Bean factory for \"</span> + getDisplayName() + <span class=\"string\">\": \"</span> + beanFactory);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> beanFactory;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"prepareBeanFactory\"><a href=\"#prepareBeanFactory\" class=\"headerlink\" title=\"prepareBeanFactory\"></a>prepareBeanFactory</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 设置classloader</span></div><div class=\"line\">   beanFactory.setBeanClassLoader(getClassLoader());</div><div class=\"line\">   <span class=\"comment\">// 设置表达式解析器</span></div><div class=\"line\">   beanFactory.setBeanExpressionResolver(<span class=\"keyword\">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</div><div class=\"line\">   <span class=\"comment\">// 添加属性编辑注册器</span></div><div class=\"line\">   beanFactory.addPropertyEditorRegistrar(<span class=\"keyword\">new</span> ResourceEditorRegistrar(<span class=\"keyword\">this</span>, getEnvironment()));</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 添加ApplicationContextAwareProcessor这个BeanPostProcessor用于回调</span></div><div class=\"line\">   <span class=\"comment\">// ApplicationContextAwareProcessor主要的作用是给实现XxxxAware的bean注入相关属性</span></div><div class=\"line\">   beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationContextAwareProcessor(<span class=\"keyword\">this</span>));</div><div class=\"line\">   <span class=\"comment\">// 取消以下接口的自动注入</span></div><div class=\"line\">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</div><div class=\"line\">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</div><div class=\"line\">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</div><div class=\"line\">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</div><div class=\"line\">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</div><div class=\"line\">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 设置特殊的类型对应的bean，修正依赖</span></div><div class=\"line\">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</div><div class=\"line\">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class=\"keyword\">this</span>);</div><div class=\"line\">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class=\"keyword\">this</span>);</div><div class=\"line\">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></div><div class=\"line\">   beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationListenerDetector(<span class=\"keyword\">this</span>));</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 如果自定义的Bean中没有一个名为”loadTimeWeaver”的Bena</span></div><div class=\"line\">   <span class=\"comment\">// 添加一个LoadTimeWeaverAwareProcessor</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</div><div class=\"line\">      beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</div><div class=\"line\">      <span class=\"comment\">// Set a temporary ClassLoader for type matching.</span></div><div class=\"line\">      beanFactory.setTempClassLoader(<span class=\"keyword\">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 如果自定义的Bean中没有名为”systemProperties”和”systemEnvironment”的Bean</span></div><div class=\"line\">   <span class=\"comment\">// 注册两个Bena，Key为”systemProperties”和”systemEnvironment”，Value为Map</span></div><div class=\"line\">   <span class=\"comment\">// 这两个bean包含系统配置和系统环绕信息</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</div><div class=\"line\">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</div><div class=\"line\">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</div><div class=\"line\">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"postProcessBeanFactory\"><a href=\"#postProcessBeanFactory\" class=\"headerlink\" title=\"postProcessBeanFactory\"></a>postProcessBeanFactory</h3><p>空实现，由具体子类实现。为子类特殊的 Application Context 实现指定特殊的 bean post 事件处理器</p>\n<h3 id=\"invokeBeanFactoryPostProcessors\"><a href=\"#invokeBeanFactoryPostProcessors\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors\"></a>invokeBeanFactoryPostProcessors</h3><p>整个 Spring 流程中非常重要的方法，大量的用户自定义扩展都与这个方法有关。</p>\n<p>第一次读的时候看着怪复杂的直接跳过去了，结果启动过程的好多问题还是没搞清楚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">invokeBeanFactoryPostProcessors</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 实例化并调用所有注册的 beanFactoryPostProcessor</span></div><div class=\"line\">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></div><div class=\"line\">   <span class=\"comment\">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.getTempClassLoader() == <span class=\"keyword\">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</div><div class=\"line\">      beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</div><div class=\"line\">      beanFactory.setTempClassLoader(<span class=\"keyword\">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>复杂的东西不在上面，是 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors 方法的调用</p>\n<p>说明这个方法之前有两个类需要特备说明，这个方法的操作都是围绕这两个类的：</p>\n<ul>\n<li><p>BeanFactoryPostProcessor</p>\n<p>在 bean 实例化阶段开始之前，对注册到容器的 BeanDefinition 保存的原始数据做出修改</p>\n</li>\n<li><p>BeanDefinitionRegistryPostProcessor</p>\n<p>继承自上面的 BeanFactoryPostProcessor</p>\n<p>专门用来对注册的容器的 BeanFactoryPostProcessor 的BeanDefinition 保存的原始数据做出修改</p>\n</li>\n</ul>\n<p>有点拗口，不过意思类似指针与二级指针的关系。</p>\n<p>整个 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors 的实现太复杂了，但其实就一个意思：</p>\n<ol>\n<li>先用 BeanDefinitionRegistryPostProcessor 修改 BeanFactoryPostProcessor 的 BeanDefinition </li>\n<li>然后用 BeanFactoryPostProcessor 修改普通的 BeanDefinition</li>\n</ol>\n<p>具体在操作过程中 BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor 执行的顺序有明确的限制，两者都是根据以下规则执行：</p>\n<ol>\n<li>首先执行实现 PriorityOrdered 接口的，调用顺序是按照接口方法 getOrder() 的实现</li>\n<li>其次执行实现 Ordered 接口的，调用顺序是按照接口方法 getOrder() 的实现</li>\n<li>最后执行既没有实现 PriorityOrdered  也没有实现 Ordered 的，调用顺序是 bean 的定义顺序</li>\n</ol>\n<h3 id=\"registerBeanPostProcessors\"><a href=\"#registerBeanPostProcessors\" class=\"headerlink\" title=\"registerBeanPostProcessors\"></a>registerBeanPostProcessors</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanPostProcessors</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 从Spring容器中找出的BeanPostProcessor接口的bean，并设置到BeanFactory的属性中</span></div><div class=\"line\">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>思路与 invokeBeanFactoryPostProcessors 方法类似。</p>\n<p>但只是从容器中找出实现 BeanPostProcessor 的bean，排序后设置到BeanFactory的属性中，并不调用。</p>\n<p>具体的排序过程：</p>\n<ol>\n<li>优先调用 PriorityOrdered 接口的子接口，调用顺序依照接口方法getOrder的返回值从小到大排序</li>\n<li>其次调用Ordered接口的子接口，调用顺序依照接口方法getOrder的返回值从小到大排序</li>\n<li>接着按照 BeanPostProcessor 实现类在配置文件中定义的顺序进行调用</li>\n<li>最后调用MergedBeanDefinitionPostProcessor接口的实现Bean，同样按照在配置文件中定义的顺序进行调用</li>\n</ol>\n<h3 id=\"initMessageSource\"><a href=\"#initMessageSource\" class=\"headerlink\" title=\"initMessageSource\"></a>initMessageSource</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initMessageSource</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果自定义了名为”messageSource”的Bean</span></div><div class=\"line\">      <span class=\"comment\">// 直接实例化Bean，该Bean必须是MessageSource接口的实现Bean</span></div><div class=\"line\">      <span class=\"comment\">// 该Bean如果是HierarchicalMessageSource接口的实现类</span></div><div class=\"line\">      <span class=\"comment\">// 强转为HierarchicalMessageSource接口，并设置一下parentMessageSource</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</div><div class=\"line\">      <span class=\"comment\">// Make MessageSource aware of parent MessageSource.</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.parent != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.messageSource <span class=\"keyword\">instanceof</span> HierarchicalMessageSource) &#123;</div><div class=\"line\">         HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class=\"keyword\">this</span>.messageSource;</div><div class=\"line\">         <span class=\"keyword\">if</span> (hms.getParentMessageSource() == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// Only set parent context as parent MessageSource if no parent MessageSource</span></div><div class=\"line\">            <span class=\"comment\">// registered already.</span></div><div class=\"line\">            hms.setParentMessageSource(getInternalParentMessageSource());</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">         logger.debug(<span class=\"string\">\"Using MessageSource [\"</span> + <span class=\"keyword\">this</span>.messageSource + <span class=\"string\">\"]\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果没有自定义名为”messageSource”的Bean，那么会默认注册一个DelegatingMessageSource并加入</span></div><div class=\"line\">      <span class=\"comment\">// Use empty MessageSource to be able to accept getMessage calls.</span></div><div class=\"line\">      DelegatingMessageSource dms = <span class=\"keyword\">new</span> DelegatingMessageSource();</div><div class=\"line\">      dms.setParentMessageSource(getInternalParentMessageSource());</div><div class=\"line\">      <span class=\"keyword\">this</span>.messageSource = dms;</div><div class=\"line\">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class=\"keyword\">this</span>.messageSource);</div><div class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">         logger.debug(<span class=\"string\">\"Unable to locate MessageSource with name '\"</span> + MESSAGE_SOURCE_BEAN_NAME +</div><div class=\"line\">               <span class=\"string\">\"': using default [\"</span> + <span class=\"keyword\">this</span>.messageSource + <span class=\"string\">\"]\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"initApplicationEventMulticaster\"><a href=\"#initApplicationEventMulticaster\" class=\"headerlink\" title=\"initApplicationEventMulticaster\"></a>initApplicationEventMulticaster</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initApplicationEventMulticaster</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果自定义了名为”applicationEventMulticaster”的Bean</span></div><div class=\"line\">      <span class=\"comment\">// 实例化自定义的Bean，自定义的Bean必须是ApplicationEventMulticaster接口的实现类</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.applicationEventMulticaster =</div><div class=\"line\">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</div><div class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">         logger.debug(<span class=\"string\">\"Using ApplicationEventMulticaster [\"</span> + <span class=\"keyword\">this</span>.applicationEventMulticaster + <span class=\"string\">\"]\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果没有自定义名为”ApplicationEventMulticaster”的Bean</span></div><div class=\"line\">      <span class=\"comment\">// 注册一个类型为SimpleApplicationEventMulticaster的Bean</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.applicationEventMulticaster = <span class=\"keyword\">new</span> SimpleApplicationEventMulticaster(beanFactory);</div><div class=\"line\">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class=\"keyword\">this</span>.applicationEventMulticaster);</div><div class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">         logger.debug(<span class=\"string\">\"Unable to locate ApplicationEventMulticaster with name '\"</span> +</div><div class=\"line\">               APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</div><div class=\"line\">               <span class=\"string\">\"': using default [\"</span> + <span class=\"keyword\">this</span>.applicationEventMulticaster + <span class=\"string\">\"]\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"onRefresh\"><a href=\"#onRefresh\" class=\"headerlink\" title=\"onRefresh\"></a>onRefresh</h3><p>空的模板方法，根据不同的 ApplicationContext 子类实现对应的业务逻辑</p>\n<h3 id=\"registerListeners\"><a href=\"#registerListeners\" class=\"headerlink\" title=\"registerListeners\"></a>registerListeners</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">registerListeners</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// Register statically specified listeners first.</span></div><div class=\"line\">   <span class=\"keyword\">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</div><div class=\"line\">      getApplicationEventMulticaster().addApplicationListener(listener);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></div><div class=\"line\">   <span class=\"comment\">// uninitialized to let post-processors apply to them!</span></div><div class=\"line\">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">   <span class=\"keyword\">for</span> (String listenerBeanName : listenerBeanNames) &#123;</div><div class=\"line\">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Publish early application events now that we finally have a multicaster...</span></div><div class=\"line\">   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class=\"keyword\">this</span>.earlyApplicationEvents;</div><div class=\"line\">   <span class=\"keyword\">this</span>.earlyApplicationEvents = <span class=\"keyword\">null</span>;</div><div class=\"line\">   <span class=\"keyword\">if</span> (earlyEventsToProcess != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</div><div class=\"line\">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"finishBeanFactoryInitialization\"><a href=\"#finishBeanFactoryInitialization\" class=\"headerlink\" title=\"finishBeanFactoryInitialization\"></a>finishBeanFactoryInitialization</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finishBeanFactoryInitialization</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">//有容器转换服务bean时先实例化这种Bean</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</div><div class=\"line\">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</div><div class=\"line\">      beanFactory.setConversionService(</div><div class=\"line\">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// 注册一个默认的嵌入式值解析器</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</div><div class=\"line\">      beanFactory.addEmbeddedValueResolver(<span class=\"keyword\">new</span> StringValueResolver() &#123;</div><div class=\"line\">         <span class=\"meta\">@Override</span></div><div class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">resolveStringValue</span><span class=\"params\">(String strVal)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> getEnvironment().resolvePlaceholders(strVal);</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 实例化LoadTimeWeaverAware类型Bean</span></div><div class=\"line\">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">   <span class=\"keyword\">for</span> (String weaverAwareName : weaverAwareNames) &#123;</div><div class=\"line\">      getBean(weaverAwareName);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 停止使用临时类加载器</span></div><div class=\"line\">   beanFactory.setTempClassLoader(<span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 缓存容器中所有注册的BeanDefinition元数据，以防被修改</span></div><div class=\"line\">   beanFactory.freezeConfiguration();</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 实例化剩余的所有非lazy-init singleton Bean</span></div><div class=\"line\">   beanFactory.preInstantiateSingletons();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"finishRefresh\"><a href=\"#finishRefresh\" class=\"headerlink\" title=\"finishRefresh\"></a>finishRefresh</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finishRefresh</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 初始化生命周期处理器（LifecycleProcessor）</span></div><div class=\"line\">   <span class=\"comment\">// 先找一下有没有自定义名为lifecycleProcessor的Bean，有的话就实例化出来</span></div><div class=\"line\">   <span class=\"comment\">// 该Bean必须是LifecycleProcessor的实现类</span></div><div class=\"line\">   <span class=\"comment\">// 没有则向Spring上下文中注册一个类型为DefaultLifecycleProcessor的LifecycleProcessor实现类</span></div><div class=\"line\">   initLifecycleProcessor();</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 调用生命周期处理器的onRefresh方法</span></div><div class=\"line\">   getLifecycleProcessor().onRefresh();</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 发布ContextRefreshedEvent事件告知对应的ApplicationListener进行响应的操作</span></div><div class=\"line\">   publishEvent(<span class=\"keyword\">new</span> ContextRefreshedEvent(<span class=\"keyword\">this</span>));</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 如果设置了JMX相关的属性，则就调用该方法</span></div><div class=\"line\">   LiveBeansView.registerApplicationContext(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上就是简单的记录了 Spring 启动过程中容器刷新的动作。</p>\n<hr>\n<p>以上内容除了源码的阅读还参考了其他博客，学习到了很多细节，这里表示感谢了：</p>\n<p><a href=\"http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/\" target=\"_blank\" rel=\"external\">SpringBoot源码分析之Spring容器的refresh过程</a></p>\n<p><a href=\"http://blog.csdn.net/bubaxiu/article/details/41415685\" target=\"_blank\" rel=\"external\">Spring– Ioc 容器Bean实例化的几种场景</a></p>\n<p><a href=\"http://blog.csdn.net/chjttony/article/details/6278627\" target=\"_blank\" rel=\"external\">《Spring技术内幕》学习笔记6——IoC容器的高级特性</a></p>\n<p><a href=\"http://www.importnew.com/24282.html\" target=\"_blank\" rel=\"external\">Spring源码分析：非懒加载的单例Bean初始化前后的一些操作</a></p>\n","excerpt":"","more":"<p>前面文章在分析 Spring Boot 的启动过程中提到了 AbstractApplicationContext 类的 refresh 方法，这个方法是 Spring 容器的核心方法之一，该方法提供了基本的模板，完成容器的初始化，并提供了丰富的接口可以从纵向（容器启动过程）、横向（不同的容器子类型）、不同形式（声明式、编程式等）进行自定义扩展。</p>\n<p>有关 ApplicationContext 和 BeanFactory 的内容可以参考之前关于 Spring 的文章：</p>\n<ul>\n<li><a href=\"http://zhangh.tk/2017/03/13/Spring%E4%B9%8BBeanFactory/\">Spring之BeanFactory</a></li>\n<li><a href=\"http://zhangh.tk/2017/03/19/Spring%E4%B9%8BApplicationContext/\">Spring之ApplicationContext</a></li>\n</ul>\n<p>这里详细过一下 refresh 方法的过程，留个印象，方便以后回顾。</p>\n<p>这篇文章就不记录关于 Spring Boot 在启动刷新阶段的特殊实现了，只关心 Spring 的通用实现模板</p>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</div><div class=\"line\">      <span class=\"comment\">// 刷新前准备工作</span></div><div class=\"line\">      prepareRefresh();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 调用子类refreshBeanFactory()方法，获取bean factory</span></div><div class=\"line\">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 创建bean Factory的通用设置</span></div><div class=\"line\">      prepareBeanFactory(beanFactory);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">         <span class=\"comment\">// 子类特殊的bean factory设置</span></div><div class=\"line\">         postProcessBeanFactory(beanFactory);</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 实例化beanFactoryPostProcessor</span></div><div class=\"line\">         <span class=\"comment\">// 调用beanFactoryPostProcessor修改bean definition</span></div><div class=\"line\">         invokeBeanFactoryPostProcessors(beanFactory);</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 注册 bean pst processors</span></div><div class=\"line\">         registerBeanPostProcessors(beanFactory);</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 初始化信息源，和国际化相关</span></div><div class=\"line\">         initMessageSource();</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 初始化容器事件传播器</span></div><div class=\"line\">         initApplicationEventMulticaster();</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 调用子类特殊的刷新逻辑</span></div><div class=\"line\">         onRefresh();</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 为事件传播器注册事件监听器</span></div><div class=\"line\">         registerListeners();</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 实例化所有非懒加载单例</span></div><div class=\"line\">         finishBeanFactoryInitialization(beanFactory);</div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">// 初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span></div><div class=\"line\">         finishRefresh();</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">catch</span> (BeansException ex) &#123;</div><div class=\"line\">         <span class=\"comment\">// ...</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">         <span class=\"comment\">// ...</span></div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"刷新过程详述\"><a href=\"#刷新过程详述\" class=\"headerlink\" title=\"刷新过程详述\"></a>刷新过程详述</h2><h3 id=\"prepareRefresh\"><a href=\"#prepareRefresh\" class=\"headerlink\" title=\"prepareRefresh\"></a>prepareRefresh</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareRefresh</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 设置Spring容器的启动时间，撤销关闭状态，开启活跃状态</span></div><div class=\"line\">   <span class=\"keyword\">this</span>.startupDate = System.currentTimeMillis();</div><div class=\"line\">   <span class=\"keyword\">this</span>.closed.set(<span class=\"keyword\">false</span>);</div><div class=\"line\">   <span class=\"keyword\">this</span>.active.set(<span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</div><div class=\"line\">      logger.info(<span class=\"string\">\"Refreshing \"</span> + <span class=\"keyword\">this</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 模板方法，设置属性源信息</span></div><div class=\"line\">   initPropertySources();</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 验证环境信息里一些必须存在的属性</span></div><div class=\"line\">   getEnvironment().validateRequiredProperties();</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">this</span>.earlyApplicationEvents = <span class=\"keyword\">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"obtainFreshBeanFactory\"><a href=\"#obtainFreshBeanFactory\" class=\"headerlink\" title=\"obtainFreshBeanFactory\"></a>obtainFreshBeanFactory</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ConfigurableListableBeanFactory <span class=\"title\">obtainFreshBeanFactory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 模板方法</span></div><div class=\"line\">   <span class=\"comment\">// 获取刷新Spring上下文的Bean工厂</span></div><div class=\"line\">   refreshBeanFactory();</div><div class=\"line\">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class=\"line\">   <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">      logger.debug(<span class=\"string\">\"Bean factory for \"</span> + getDisplayName() + <span class=\"string\">\": \"</span> + beanFactory);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> beanFactory;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"prepareBeanFactory\"><a href=\"#prepareBeanFactory\" class=\"headerlink\" title=\"prepareBeanFactory\"></a>prepareBeanFactory</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 设置classloader</span></div><div class=\"line\">   beanFactory.setBeanClassLoader(getClassLoader());</div><div class=\"line\">   <span class=\"comment\">// 设置表达式解析器</span></div><div class=\"line\">   beanFactory.setBeanExpressionResolver(<span class=\"keyword\">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</div><div class=\"line\">   <span class=\"comment\">// 添加属性编辑注册器</span></div><div class=\"line\">   beanFactory.addPropertyEditorRegistrar(<span class=\"keyword\">new</span> ResourceEditorRegistrar(<span class=\"keyword\">this</span>, getEnvironment()));</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 添加ApplicationContextAwareProcessor这个BeanPostProcessor用于回调</span></div><div class=\"line\">   <span class=\"comment\">// ApplicationContextAwareProcessor主要的作用是给实现XxxxAware的bean注入相关属性</span></div><div class=\"line\">   beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationContextAwareProcessor(<span class=\"keyword\">this</span>));</div><div class=\"line\">   <span class=\"comment\">// 取消以下接口的自动注入</span></div><div class=\"line\">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</div><div class=\"line\">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</div><div class=\"line\">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</div><div class=\"line\">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</div><div class=\"line\">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</div><div class=\"line\">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 设置特殊的类型对应的bean，修正依赖</span></div><div class=\"line\">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</div><div class=\"line\">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class=\"keyword\">this</span>);</div><div class=\"line\">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class=\"keyword\">this</span>);</div><div class=\"line\">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></div><div class=\"line\">   beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationListenerDetector(<span class=\"keyword\">this</span>));</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 如果自定义的Bean中没有一个名为”loadTimeWeaver”的Bena</span></div><div class=\"line\">   <span class=\"comment\">// 添加一个LoadTimeWeaverAwareProcessor</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</div><div class=\"line\">      beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</div><div class=\"line\">      <span class=\"comment\">// Set a temporary ClassLoader for type matching.</span></div><div class=\"line\">      beanFactory.setTempClassLoader(<span class=\"keyword\">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 如果自定义的Bean中没有名为”systemProperties”和”systemEnvironment”的Bean</span></div><div class=\"line\">   <span class=\"comment\">// 注册两个Bena，Key为”systemProperties”和”systemEnvironment”，Value为Map</span></div><div class=\"line\">   <span class=\"comment\">// 这两个bean包含系统配置和系统环绕信息</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</div><div class=\"line\">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</div><div class=\"line\">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</div><div class=\"line\">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"postProcessBeanFactory\"><a href=\"#postProcessBeanFactory\" class=\"headerlink\" title=\"postProcessBeanFactory\"></a>postProcessBeanFactory</h3><p>空实现，由具体子类实现。为子类特殊的 Application Context 实现指定特殊的 bean post 事件处理器</p>\n<h3 id=\"invokeBeanFactoryPostProcessors\"><a href=\"#invokeBeanFactoryPostProcessors\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors\"></a>invokeBeanFactoryPostProcessors</h3><p>整个 Spring 流程中非常重要的方法，大量的用户自定义扩展都与这个方法有关。</p>\n<p>第一次读的时候看着怪复杂的直接跳过去了，结果启动过程的好多问题还是没搞清楚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">invokeBeanFactoryPostProcessors</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 实例化并调用所有注册的 beanFactoryPostProcessor</span></div><div class=\"line\">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></div><div class=\"line\">   <span class=\"comment\">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.getTempClassLoader() == <span class=\"keyword\">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</div><div class=\"line\">      beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</div><div class=\"line\">      beanFactory.setTempClassLoader(<span class=\"keyword\">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>复杂的东西不在上面，是 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors 方法的调用</p>\n<p>说明这个方法之前有两个类需要特备说明，这个方法的操作都是围绕这两个类的：</p>\n<ul>\n<li><p>BeanFactoryPostProcessor</p>\n<p>在 bean 实例化阶段开始之前，对注册到容器的 BeanDefinition 保存的原始数据做出修改</p>\n</li>\n<li><p>BeanDefinitionRegistryPostProcessor</p>\n<p>继承自上面的 BeanFactoryPostProcessor</p>\n<p>专门用来对注册的容器的 BeanFactoryPostProcessor 的BeanDefinition 保存的原始数据做出修改</p>\n</li>\n</ul>\n<p>有点拗口，不过意思类似指针与二级指针的关系。</p>\n<p>整个 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors 的实现太复杂了，但其实就一个意思：</p>\n<ol>\n<li>先用 BeanDefinitionRegistryPostProcessor 修改 BeanFactoryPostProcessor 的 BeanDefinition </li>\n<li>然后用 BeanFactoryPostProcessor 修改普通的 BeanDefinition</li>\n</ol>\n<p>具体在操作过程中 BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor 执行的顺序有明确的限制，两者都是根据以下规则执行：</p>\n<ol>\n<li>首先执行实现 PriorityOrdered 接口的，调用顺序是按照接口方法 getOrder() 的实现</li>\n<li>其次执行实现 Ordered 接口的，调用顺序是按照接口方法 getOrder() 的实现</li>\n<li>最后执行既没有实现 PriorityOrdered  也没有实现 Ordered 的，调用顺序是 bean 的定义顺序</li>\n</ol>\n<h3 id=\"registerBeanPostProcessors\"><a href=\"#registerBeanPostProcessors\" class=\"headerlink\" title=\"registerBeanPostProcessors\"></a>registerBeanPostProcessors</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanPostProcessors</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 从Spring容器中找出的BeanPostProcessor接口的bean，并设置到BeanFactory的属性中</span></div><div class=\"line\">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>思路与 invokeBeanFactoryPostProcessors 方法类似。</p>\n<p>但只是从容器中找出实现 BeanPostProcessor 的bean，排序后设置到BeanFactory的属性中，并不调用。</p>\n<p>具体的排序过程：</p>\n<ol>\n<li>优先调用 PriorityOrdered 接口的子接口，调用顺序依照接口方法getOrder的返回值从小到大排序</li>\n<li>其次调用Ordered接口的子接口，调用顺序依照接口方法getOrder的返回值从小到大排序</li>\n<li>接着按照 BeanPostProcessor 实现类在配置文件中定义的顺序进行调用</li>\n<li>最后调用MergedBeanDefinitionPostProcessor接口的实现Bean，同样按照在配置文件中定义的顺序进行调用</li>\n</ol>\n<h3 id=\"initMessageSource\"><a href=\"#initMessageSource\" class=\"headerlink\" title=\"initMessageSource\"></a>initMessageSource</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initMessageSource</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果自定义了名为”messageSource”的Bean</span></div><div class=\"line\">      <span class=\"comment\">// 直接实例化Bean，该Bean必须是MessageSource接口的实现Bean</span></div><div class=\"line\">      <span class=\"comment\">// 该Bean如果是HierarchicalMessageSource接口的实现类</span></div><div class=\"line\">      <span class=\"comment\">// 强转为HierarchicalMessageSource接口，并设置一下parentMessageSource</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</div><div class=\"line\">      <span class=\"comment\">// Make MessageSource aware of parent MessageSource.</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.parent != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.messageSource <span class=\"keyword\">instanceof</span> HierarchicalMessageSource) &#123;</div><div class=\"line\">         HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class=\"keyword\">this</span>.messageSource;</div><div class=\"line\">         <span class=\"keyword\">if</span> (hms.getParentMessageSource() == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// Only set parent context as parent MessageSource if no parent MessageSource</span></div><div class=\"line\">            <span class=\"comment\">// registered already.</span></div><div class=\"line\">            hms.setParentMessageSource(getInternalParentMessageSource());</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">         logger.debug(<span class=\"string\">\"Using MessageSource [\"</span> + <span class=\"keyword\">this</span>.messageSource + <span class=\"string\">\"]\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果没有自定义名为”messageSource”的Bean，那么会默认注册一个DelegatingMessageSource并加入</span></div><div class=\"line\">      <span class=\"comment\">// Use empty MessageSource to be able to accept getMessage calls.</span></div><div class=\"line\">      DelegatingMessageSource dms = <span class=\"keyword\">new</span> DelegatingMessageSource();</div><div class=\"line\">      dms.setParentMessageSource(getInternalParentMessageSource());</div><div class=\"line\">      <span class=\"keyword\">this</span>.messageSource = dms;</div><div class=\"line\">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class=\"keyword\">this</span>.messageSource);</div><div class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">         logger.debug(<span class=\"string\">\"Unable to locate MessageSource with name '\"</span> + MESSAGE_SOURCE_BEAN_NAME +</div><div class=\"line\">               <span class=\"string\">\"': using default [\"</span> + <span class=\"keyword\">this</span>.messageSource + <span class=\"string\">\"]\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"initApplicationEventMulticaster\"><a href=\"#initApplicationEventMulticaster\" class=\"headerlink\" title=\"initApplicationEventMulticaster\"></a>initApplicationEventMulticaster</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initApplicationEventMulticaster</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果自定义了名为”applicationEventMulticaster”的Bean</span></div><div class=\"line\">      <span class=\"comment\">// 实例化自定义的Bean，自定义的Bean必须是ApplicationEventMulticaster接口的实现类</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.applicationEventMulticaster =</div><div class=\"line\">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</div><div class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">         logger.debug(<span class=\"string\">\"Using ApplicationEventMulticaster [\"</span> + <span class=\"keyword\">this</span>.applicationEventMulticaster + <span class=\"string\">\"]\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果没有自定义名为”ApplicationEventMulticaster”的Bean</span></div><div class=\"line\">      <span class=\"comment\">// 注册一个类型为SimpleApplicationEventMulticaster的Bean</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.applicationEventMulticaster = <span class=\"keyword\">new</span> SimpleApplicationEventMulticaster(beanFactory);</div><div class=\"line\">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class=\"keyword\">this</span>.applicationEventMulticaster);</div><div class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</div><div class=\"line\">         logger.debug(<span class=\"string\">\"Unable to locate ApplicationEventMulticaster with name '\"</span> +</div><div class=\"line\">               APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</div><div class=\"line\">               <span class=\"string\">\"': using default [\"</span> + <span class=\"keyword\">this</span>.applicationEventMulticaster + <span class=\"string\">\"]\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"onRefresh\"><a href=\"#onRefresh\" class=\"headerlink\" title=\"onRefresh\"></a>onRefresh</h3><p>空的模板方法，根据不同的 ApplicationContext 子类实现对应的业务逻辑</p>\n<h3 id=\"registerListeners\"><a href=\"#registerListeners\" class=\"headerlink\" title=\"registerListeners\"></a>registerListeners</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">registerListeners</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// Register statically specified listeners first.</span></div><div class=\"line\">   <span class=\"keyword\">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</div><div class=\"line\">      getApplicationEventMulticaster().addApplicationListener(listener);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></div><div class=\"line\">   <span class=\"comment\">// uninitialized to let post-processors apply to them!</span></div><div class=\"line\">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">   <span class=\"keyword\">for</span> (String listenerBeanName : listenerBeanNames) &#123;</div><div class=\"line\">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// Publish early application events now that we finally have a multicaster...</span></div><div class=\"line\">   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class=\"keyword\">this</span>.earlyApplicationEvents;</div><div class=\"line\">   <span class=\"keyword\">this</span>.earlyApplicationEvents = <span class=\"keyword\">null</span>;</div><div class=\"line\">   <span class=\"keyword\">if</span> (earlyEventsToProcess != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</div><div class=\"line\">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"finishBeanFactoryInitialization\"><a href=\"#finishBeanFactoryInitialization\" class=\"headerlink\" title=\"finishBeanFactoryInitialization\"></a>finishBeanFactoryInitialization</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finishBeanFactoryInitialization</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">//有容器转换服务bean时先实例化这种Bean</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</div><div class=\"line\">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</div><div class=\"line\">      beanFactory.setConversionService(</div><div class=\"line\">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// 注册一个默认的嵌入式值解析器</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</div><div class=\"line\">      beanFactory.addEmbeddedValueResolver(<span class=\"keyword\">new</span> StringValueResolver() &#123;</div><div class=\"line\">         <span class=\"meta\">@Override</span></div><div class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">resolveStringValue</span><span class=\"params\">(String strVal)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> getEnvironment().resolvePlaceholders(strVal);</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 实例化LoadTimeWeaverAware类型Bean</span></div><div class=\"line\">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">   <span class=\"keyword\">for</span> (String weaverAwareName : weaverAwareNames) &#123;</div><div class=\"line\">      getBean(weaverAwareName);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 停止使用临时类加载器</span></div><div class=\"line\">   beanFactory.setTempClassLoader(<span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 缓存容器中所有注册的BeanDefinition元数据，以防被修改</span></div><div class=\"line\">   beanFactory.freezeConfiguration();</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 实例化剩余的所有非lazy-init singleton Bean</span></div><div class=\"line\">   beanFactory.preInstantiateSingletons();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"finishRefresh\"><a href=\"#finishRefresh\" class=\"headerlink\" title=\"finishRefresh\"></a>finishRefresh</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finishRefresh</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"comment\">// 初始化生命周期处理器（LifecycleProcessor）</span></div><div class=\"line\">   <span class=\"comment\">// 先找一下有没有自定义名为lifecycleProcessor的Bean，有的话就实例化出来</span></div><div class=\"line\">   <span class=\"comment\">// 该Bean必须是LifecycleProcessor的实现类</span></div><div class=\"line\">   <span class=\"comment\">// 没有则向Spring上下文中注册一个类型为DefaultLifecycleProcessor的LifecycleProcessor实现类</span></div><div class=\"line\">   initLifecycleProcessor();</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 调用生命周期处理器的onRefresh方法</span></div><div class=\"line\">   getLifecycleProcessor().onRefresh();</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 发布ContextRefreshedEvent事件告知对应的ApplicationListener进行响应的操作</span></div><div class=\"line\">   publishEvent(<span class=\"keyword\">new</span> ContextRefreshedEvent(<span class=\"keyword\">this</span>));</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 如果设置了JMX相关的属性，则就调用该方法</span></div><div class=\"line\">   LiveBeansView.registerApplicationContext(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上就是简单的记录了 Spring 启动过程中容器刷新的动作。</p>\n<hr>\n<p>以上内容除了源码的阅读还参考了其他博客，学习到了很多细节，这里表示感谢了：</p>\n<p><a href=\"http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/\">SpringBoot源码分析之Spring容器的refresh过程</a></p>\n<p><a href=\"http://blog.csdn.net/bubaxiu/article/details/41415685\">Spring– Ioc 容器Bean实例化的几种场景</a></p>\n<p><a href=\"http://blog.csdn.net/chjttony/article/details/6278627\">《Spring技术内幕》学习笔记6——IoC容器的高级特性</a></p>\n<p><a href=\"http://www.importnew.com/24282.html\">Spring源码分析：非懒加载的单例Bean初始化前后的一些操作</a></p>\n"},{"title":"【重拾网络】基本概念","date":"2017-07-19T15:25:03.000Z","_content":"Netty 还没看几页就碰到 TCP 接收滑块的问题。隐约记得传输层协议学习的时候看过，但也忘的七七八八的了。毕业两年网络相关的知识也差不多丢完了（就好像自己以前会一样），从本文开始回顾一下网络知识。目标至少网络层以上的主要协议大致过程要清楚，尤其是 Web 开发常见协议，总结的顺序依据《计算机网络——自顶向下学习方法》。\n\n## 网络构成\n\n### 网络边缘\n\n- 主机\n- 网络应用，模型\n  - C/S\n  - P2P\n\n### 接入网络\n\n- 目的：将网络边缘接入网络核心（边缘路由器）\n- 物理介质：有线、无线通信链路\n\n\n- 分类：家庭、机构、移动\n- 关心主题：带宽、独占 / 共享\n\n#### DSL\n\n- 利用电话线\n- 频分多路复用\n  - 0 ~ 4HKZ：电话\n  - 4KHZ ~ 50KHZ：上行\n  - 50KHZ ~ 1MHZ：下行\n- 带宽：上行 < 2.5 或 1 Mbps, 下行 > 24 或 10 Mbps\n- 独占\n\n#### 电缆\n\n- 电视网络\n- 频分多路复用\n- HFC：混合光纤同轴电缆\n- 带宽：上行 2Mbps，下行 20Mbps\n- 共享\n\n#### 以太网\n\n- 机构使用\n- 带宽：10Mbps, 100Mbps, 1Gbps, 10Gbps\n\n#### 无线接入\n\n- 共享无线网络\n- 无线局域网：802.11 b/g, 11Mbps, 50Mbps\n- 广域无线接入\n\n### 网络核心\n\n目的：数据交换，从源主机通过核心网络送到目的主机\n\n#### 互联\n\n- 路由：确定分组从源主机到目的主机的传输路径\n- 转发：将分组从路由器输入端口交换至正确的输出端口\n\n#### 结构\n\n网络的网络——Internet\n\n- 端系统通过接入 ISP 连接到 Internet\n- ISP 必须进一步互联，构成复杂网络\n\nISP 互联方式：\n\n1. 直接彼此互联\n\n   需要 N * (N-1) / 2 条连接\n\n2. 每个接入 ISP 连接到一个国家/全球ISP\n\n   引入交换设备简化了方式 1，问题：1. 距离；规模：瓶颈，端口\n\n3. 在方式 2 基础引入竞争者——二级，三级 ISP\n\n   引入交换网络，解决连通性、网络规模问题\n\n4. 引入区域 ISP，连接端系统和接入 ISP\n\n5. 内容提供网络\n\n## 数据交换\n\n- 交换含义：\n  1. 动态转义\n  2. 动态分配传输资源\n- 数据交换方式：电路、报文、分组\n\n### 多路复用技术\n\n- 链路/网络资源划分为资源片\n- 将资源片分配给各路呼叫\n- 每路呼叫独占分配到的资源进行通信\n- 资源可被闲置\n- 分配\n  - 频分复用 FDM，有先电视网络，占用不同频带\n  - 时分复用 TDM，占用不同时间片\n  - 波分复用 WDM，光的频分复用\n  - 码分复用 CDM，无线链路共享\n\n### 交换技术\n\n#### 电路交换\n\n- 典型：电话网络\n- 过程：\n  1. 建立连接\n  2. 通信\n  3. 释放连接\n- 特点：独占资源\n- 中继线共享——多路复用\n\n#### 报文交换\n\n源（应用）发送信息整体，典型：电报\n\n#### 分组交换\n\n分组：报文拆分出来的较小的数据包\n\n过程：报文拆分、重复\n\n额外开销：1. 拆分，重组；2. 头信息\n\n#### 报文、分组交换异同\n\n- 同：过程都是存储-转发\n- 异：交换过程是否查分数据\n\n#### 分组、电路交换特点\n\n- 分组不独占，电路独占资源\n- 分组更适合突发数据传输网络\n- 分组特点：\n  - 无需呼叫建立\n  - 资源充分共享\n  - 可能产生拥塞：分组延迟，丢失\n\n#### 分组、报文耗时比较\n\n发送 M bits 的报文，链路带宽为 R bps，分组长 L bits，跳步数 h，路由器数 n。（n = h -1）\n\n报文：M / R * h\n\n报文：(M / R) + (h -1) * L / R -> M / R + nL / R\n\n#### 分组交换时延 & 丢包 & 吞吐量\n\n- 时延：结点处理时延、排队时延、传输时延、传播时延\n\n- 流量强度\n  \n  流量强度：分组 * 分组到达平均速率 / 传输速率\n\n  流量强度 > 1：表示比特到达平均速率超过队列传输出去速率，队列趋于无界增加，排队时延趋于无穷大\n\n- 丢包：到达的分组排满一个队列后，路由器将丢弃分组\n  \n- 吞吐量：取决于数据流过的链路的传输速率，近似为沿着源和目的地之间路径的最小传输速率\n\n## 网络分层\n\n### TCP/IP 五层模型\n\n|  协议  |               主要作用                |                  关注点                   | 常见协议      | 协议数据单位  | 物理设备    |\n| :--: | :-------------------------------: | :------------------------------------: | --------- | ------- | ------- |\n| 应用层  |           为应用程序提供网络传输接口           |                 进程如何通信                 | HTTP, DNS | PDU     |         |\n| 传输层  |        负责将上层数据分段并提供端到端的传输         |             端到端的差错控制和流量控制              | TCP, UDP  | segment |         |\n| 网络层  | 网络地址翻译成对应的物理地 ，解决如何将数据从发送方路由到接收方  |     对子网间的数据包进行路由选择，实现拥塞控制、网际互连等功能      | ARP, IP   | packet  | 路由器     |\n| 连接层  | 控制网络层与物理层之间的通信，在不可靠的物理介质上提供可靠的传输。 |      物理地址寻址、数据的成帧、流量控制、数据的检错、重发等       |           | frame   | 交换机，网桥  |\n| 物理层  |        为上层协议提供了一个传输数据的物理媒体        | 规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性 |           | bit     | 集线器，中继器 |\n\n为什么强调五层呢？因为还有个 TCP/IP 四层协议把链路层和物理层合并了，统称为网络接口层\n\n### OSI 模型\n\n实际上 TCP/IP 模型是从 OSI 模型演化来的。学院派先搞出的 OSI 模型，工业使用了更简化的 TCP/IP 协议。\n\n具体表现是 TCP/IP 协议把 OSI 的应用层、表示层、会话层合同为应用层。\n\n### 分层的过程：\n\n1. 发送方应用程序的数据总是从最上层开始，层层向下，最终经由物理层发送出去\n2. 接收方的物理层接收到数据后，层层向上，最终经由应用层分发到具体的应用程序进程中\n3. 在数据层层向下的过程中，每一层都会对数据进行一些封装处理（如打包或者编码）\n4. 在数据层层向上的过程中，每一层都会对数据进行一些逆处理（如解包或者解码）\n","source":"_posts/【重拾网络】基本概念.md","raw":"---\ntitle: 【重拾网络】基本概念\ndate: 2017-07-19 23:25:03\ntags:\n  - 网络\ncategories: 网络\n---\nNetty 还没看几页就碰到 TCP 接收滑块的问题。隐约记得传输层协议学习的时候看过，但也忘的七七八八的了。毕业两年网络相关的知识也差不多丢完了（就好像自己以前会一样），从本文开始回顾一下网络知识。目标至少网络层以上的主要协议大致过程要清楚，尤其是 Web 开发常见协议，总结的顺序依据《计算机网络——自顶向下学习方法》。\n\n## 网络构成\n\n### 网络边缘\n\n- 主机\n- 网络应用，模型\n  - C/S\n  - P2P\n\n### 接入网络\n\n- 目的：将网络边缘接入网络核心（边缘路由器）\n- 物理介质：有线、无线通信链路\n\n\n- 分类：家庭、机构、移动\n- 关心主题：带宽、独占 / 共享\n\n#### DSL\n\n- 利用电话线\n- 频分多路复用\n  - 0 ~ 4HKZ：电话\n  - 4KHZ ~ 50KHZ：上行\n  - 50KHZ ~ 1MHZ：下行\n- 带宽：上行 < 2.5 或 1 Mbps, 下行 > 24 或 10 Mbps\n- 独占\n\n#### 电缆\n\n- 电视网络\n- 频分多路复用\n- HFC：混合光纤同轴电缆\n- 带宽：上行 2Mbps，下行 20Mbps\n- 共享\n\n#### 以太网\n\n- 机构使用\n- 带宽：10Mbps, 100Mbps, 1Gbps, 10Gbps\n\n#### 无线接入\n\n- 共享无线网络\n- 无线局域网：802.11 b/g, 11Mbps, 50Mbps\n- 广域无线接入\n\n### 网络核心\n\n目的：数据交换，从源主机通过核心网络送到目的主机\n\n#### 互联\n\n- 路由：确定分组从源主机到目的主机的传输路径\n- 转发：将分组从路由器输入端口交换至正确的输出端口\n\n#### 结构\n\n网络的网络——Internet\n\n- 端系统通过接入 ISP 连接到 Internet\n- ISP 必须进一步互联，构成复杂网络\n\nISP 互联方式：\n\n1. 直接彼此互联\n\n   需要 N * (N-1) / 2 条连接\n\n2. 每个接入 ISP 连接到一个国家/全球ISP\n\n   引入交换设备简化了方式 1，问题：1. 距离；规模：瓶颈，端口\n\n3. 在方式 2 基础引入竞争者——二级，三级 ISP\n\n   引入交换网络，解决连通性、网络规模问题\n\n4. 引入区域 ISP，连接端系统和接入 ISP\n\n5. 内容提供网络\n\n## 数据交换\n\n- 交换含义：\n  1. 动态转义\n  2. 动态分配传输资源\n- 数据交换方式：电路、报文、分组\n\n### 多路复用技术\n\n- 链路/网络资源划分为资源片\n- 将资源片分配给各路呼叫\n- 每路呼叫独占分配到的资源进行通信\n- 资源可被闲置\n- 分配\n  - 频分复用 FDM，有先电视网络，占用不同频带\n  - 时分复用 TDM，占用不同时间片\n  - 波分复用 WDM，光的频分复用\n  - 码分复用 CDM，无线链路共享\n\n### 交换技术\n\n#### 电路交换\n\n- 典型：电话网络\n- 过程：\n  1. 建立连接\n  2. 通信\n  3. 释放连接\n- 特点：独占资源\n- 中继线共享——多路复用\n\n#### 报文交换\n\n源（应用）发送信息整体，典型：电报\n\n#### 分组交换\n\n分组：报文拆分出来的较小的数据包\n\n过程：报文拆分、重复\n\n额外开销：1. 拆分，重组；2. 头信息\n\n#### 报文、分组交换异同\n\n- 同：过程都是存储-转发\n- 异：交换过程是否查分数据\n\n#### 分组、电路交换特点\n\n- 分组不独占，电路独占资源\n- 分组更适合突发数据传输网络\n- 分组特点：\n  - 无需呼叫建立\n  - 资源充分共享\n  - 可能产生拥塞：分组延迟，丢失\n\n#### 分组、报文耗时比较\n\n发送 M bits 的报文，链路带宽为 R bps，分组长 L bits，跳步数 h，路由器数 n。（n = h -1）\n\n报文：M / R * h\n\n报文：(M / R) + (h -1) * L / R -> M / R + nL / R\n\n#### 分组交换时延 & 丢包 & 吞吐量\n\n- 时延：结点处理时延、排队时延、传输时延、传播时延\n\n- 流量强度\n  \n  流量强度：分组 * 分组到达平均速率 / 传输速率\n\n  流量强度 > 1：表示比特到达平均速率超过队列传输出去速率，队列趋于无界增加，排队时延趋于无穷大\n\n- 丢包：到达的分组排满一个队列后，路由器将丢弃分组\n  \n- 吞吐量：取决于数据流过的链路的传输速率，近似为沿着源和目的地之间路径的最小传输速率\n\n## 网络分层\n\n### TCP/IP 五层模型\n\n|  协议  |               主要作用                |                  关注点                   | 常见协议      | 协议数据单位  | 物理设备    |\n| :--: | :-------------------------------: | :------------------------------------: | --------- | ------- | ------- |\n| 应用层  |           为应用程序提供网络传输接口           |                 进程如何通信                 | HTTP, DNS | PDU     |         |\n| 传输层  |        负责将上层数据分段并提供端到端的传输         |             端到端的差错控制和流量控制              | TCP, UDP  | segment |         |\n| 网络层  | 网络地址翻译成对应的物理地 ，解决如何将数据从发送方路由到接收方  |     对子网间的数据包进行路由选择，实现拥塞控制、网际互连等功能      | ARP, IP   | packet  | 路由器     |\n| 连接层  | 控制网络层与物理层之间的通信，在不可靠的物理介质上提供可靠的传输。 |      物理地址寻址、数据的成帧、流量控制、数据的检错、重发等       |           | frame   | 交换机，网桥  |\n| 物理层  |        为上层协议提供了一个传输数据的物理媒体        | 规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性 |           | bit     | 集线器，中继器 |\n\n为什么强调五层呢？因为还有个 TCP/IP 四层协议把链路层和物理层合并了，统称为网络接口层\n\n### OSI 模型\n\n实际上 TCP/IP 模型是从 OSI 模型演化来的。学院派先搞出的 OSI 模型，工业使用了更简化的 TCP/IP 协议。\n\n具体表现是 TCP/IP 协议把 OSI 的应用层、表示层、会话层合同为应用层。\n\n### 分层的过程：\n\n1. 发送方应用程序的数据总是从最上层开始，层层向下，最终经由物理层发送出去\n2. 接收方的物理层接收到数据后，层层向上，最终经由应用层分发到具体的应用程序进程中\n3. 在数据层层向下的过程中，每一层都会对数据进行一些封装处理（如打包或者编码）\n4. 在数据层层向上的过程中，每一层都会对数据进行一些逆处理（如解包或者解码）\n","slug":"【重拾网络】基本概念","published":1,"updated":"2017-07-19T15:26:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2rj003jd82e1yb0nzjb","content":"<p>Netty 还没看几页就碰到 TCP 接收滑块的问题。隐约记得传输层协议学习的时候看过，但也忘的七七八八的了。毕业两年网络相关的知识也差不多丢完了（就好像自己以前会一样），从本文开始回顾一下网络知识。目标至少网络层以上的主要协议大致过程要清楚，尤其是 Web 开发常见协议，总结的顺序依据《计算机网络——自顶向下学习方法》。</p>\n<h2 id=\"网络构成\"><a href=\"#网络构成\" class=\"headerlink\" title=\"网络构成\"></a>网络构成</h2><h3 id=\"网络边缘\"><a href=\"#网络边缘\" class=\"headerlink\" title=\"网络边缘\"></a>网络边缘</h3><ul>\n<li>主机</li>\n<li>网络应用，模型<ul>\n<li>C/S</li>\n<li>P2P</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"接入网络\"><a href=\"#接入网络\" class=\"headerlink\" title=\"接入网络\"></a>接入网络</h3><ul>\n<li>目的：将网络边缘接入网络核心（边缘路由器）</li>\n<li>物理介质：有线、无线通信链路</li>\n</ul>\n<ul>\n<li>分类：家庭、机构、移动</li>\n<li>关心主题：带宽、独占 / 共享</li>\n</ul>\n<h4 id=\"DSL\"><a href=\"#DSL\" class=\"headerlink\" title=\"DSL\"></a>DSL</h4><ul>\n<li>利用电话线</li>\n<li>频分多路复用<ul>\n<li>0 ~ 4HKZ：电话</li>\n<li>4KHZ ~ 50KHZ：上行</li>\n<li>50KHZ ~ 1MHZ：下行</li>\n</ul>\n</li>\n<li>带宽：上行 &lt; 2.5 或 1 Mbps, 下行 &gt; 24 或 10 Mbps</li>\n<li>独占</li>\n</ul>\n<h4 id=\"电缆\"><a href=\"#电缆\" class=\"headerlink\" title=\"电缆\"></a>电缆</h4><ul>\n<li>电视网络</li>\n<li>频分多路复用</li>\n<li>HFC：混合光纤同轴电缆</li>\n<li>带宽：上行 2Mbps，下行 20Mbps</li>\n<li>共享</li>\n</ul>\n<h4 id=\"以太网\"><a href=\"#以太网\" class=\"headerlink\" title=\"以太网\"></a>以太网</h4><ul>\n<li>机构使用</li>\n<li>带宽：10Mbps, 100Mbps, 1Gbps, 10Gbps</li>\n</ul>\n<h4 id=\"无线接入\"><a href=\"#无线接入\" class=\"headerlink\" title=\"无线接入\"></a>无线接入</h4><ul>\n<li>共享无线网络</li>\n<li>无线局域网：802.11 b/g, 11Mbps, 50Mbps</li>\n<li>广域无线接入</li>\n</ul>\n<h3 id=\"网络核心\"><a href=\"#网络核心\" class=\"headerlink\" title=\"网络核心\"></a>网络核心</h3><p>目的：数据交换，从源主机通过核心网络送到目的主机</p>\n<h4 id=\"互联\"><a href=\"#互联\" class=\"headerlink\" title=\"互联\"></a>互联</h4><ul>\n<li>路由：确定分组从源主机到目的主机的传输路径</li>\n<li>转发：将分组从路由器输入端口交换至正确的输出端口</li>\n</ul>\n<h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><p>网络的网络——Internet</p>\n<ul>\n<li>端系统通过接入 ISP 连接到 Internet</li>\n<li>ISP 必须进一步互联，构成复杂网络</li>\n</ul>\n<p>ISP 互联方式：</p>\n<ol>\n<li><p>直接彼此互联</p>\n<p>需要 N * (N-1) / 2 条连接</p>\n</li>\n<li><p>每个接入 ISP 连接到一个国家/全球ISP</p>\n<p>引入交换设备简化了方式 1，问题：1. 距离；规模：瓶颈，端口</p>\n</li>\n<li><p>在方式 2 基础引入竞争者——二级，三级 ISP</p>\n<p>引入交换网络，解决连通性、网络规模问题</p>\n</li>\n<li><p>引入区域 ISP，连接端系统和接入 ISP</p>\n</li>\n<li><p>内容提供网络</p>\n</li>\n</ol>\n<h2 id=\"数据交换\"><a href=\"#数据交换\" class=\"headerlink\" title=\"数据交换\"></a>数据交换</h2><ul>\n<li>交换含义：<ol>\n<li>动态转义</li>\n<li>动态分配传输资源</li>\n</ol>\n</li>\n<li>数据交换方式：电路、报文、分组</li>\n</ul>\n<h3 id=\"多路复用技术\"><a href=\"#多路复用技术\" class=\"headerlink\" title=\"多路复用技术\"></a>多路复用技术</h3><ul>\n<li>链路/网络资源划分为资源片</li>\n<li>将资源片分配给各路呼叫</li>\n<li>每路呼叫独占分配到的资源进行通信</li>\n<li>资源可被闲置</li>\n<li>分配<ul>\n<li>频分复用 FDM，有先电视网络，占用不同频带</li>\n<li>时分复用 TDM，占用不同时间片</li>\n<li>波分复用 WDM，光的频分复用</li>\n<li>码分复用 CDM，无线链路共享</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"交换技术\"><a href=\"#交换技术\" class=\"headerlink\" title=\"交换技术\"></a>交换技术</h3><h4 id=\"电路交换\"><a href=\"#电路交换\" class=\"headerlink\" title=\"电路交换\"></a>电路交换</h4><ul>\n<li>典型：电话网络</li>\n<li>过程：<ol>\n<li>建立连接</li>\n<li>通信</li>\n<li>释放连接</li>\n</ol>\n</li>\n<li>特点：独占资源</li>\n<li>中继线共享——多路复用</li>\n</ul>\n<h4 id=\"报文交换\"><a href=\"#报文交换\" class=\"headerlink\" title=\"报文交换\"></a>报文交换</h4><p>源（应用）发送信息整体，典型：电报</p>\n<h4 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h4><p>分组：报文拆分出来的较小的数据包</p>\n<p>过程：报文拆分、重复</p>\n<p>额外开销：1. 拆分，重组；2. 头信息</p>\n<h4 id=\"报文、分组交换异同\"><a href=\"#报文、分组交换异同\" class=\"headerlink\" title=\"报文、分组交换异同\"></a>报文、分组交换异同</h4><ul>\n<li>同：过程都是存储-转发</li>\n<li>异：交换过程是否查分数据</li>\n</ul>\n<h4 id=\"分组、电路交换特点\"><a href=\"#分组、电路交换特点\" class=\"headerlink\" title=\"分组、电路交换特点\"></a>分组、电路交换特点</h4><ul>\n<li>分组不独占，电路独占资源</li>\n<li>分组更适合突发数据传输网络</li>\n<li>分组特点：<ul>\n<li>无需呼叫建立</li>\n<li>资源充分共享</li>\n<li>可能产生拥塞：分组延迟，丢失</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分组、报文耗时比较\"><a href=\"#分组、报文耗时比较\" class=\"headerlink\" title=\"分组、报文耗时比较\"></a>分组、报文耗时比较</h4><p>发送 M bits 的报文，链路带宽为 R bps，分组长 L bits，跳步数 h，路由器数 n。（n = h -1）</p>\n<p>报文：M / R * h</p>\n<p>报文：(M / R) + (h -1) * L / R -&gt; M / R + nL / R</p>\n<h4 id=\"分组交换时延-amp-丢包-amp-吞吐量\"><a href=\"#分组交换时延-amp-丢包-amp-吞吐量\" class=\"headerlink\" title=\"分组交换时延 &amp; 丢包 &amp; 吞吐量\"></a>分组交换时延 &amp; 丢包 &amp; 吞吐量</h4><ul>\n<li><p>时延：结点处理时延、排队时延、传输时延、传播时延</p>\n</li>\n<li><p>流量强度</p>\n<p>流量强度：分组 * 分组到达平均速率 / 传输速率</p>\n<p>流量强度 &gt; 1：表示比特到达平均速率超过队列传输出去速率，队列趋于无界增加，排队时延趋于无穷大</p>\n</li>\n<li><p>丢包：到达的分组排满一个队列后，路由器将丢弃分组</p>\n</li>\n<li><p>吞吐量：取决于数据流过的链路的传输速率，近似为沿着源和目的地之间路径的最小传输速率</p>\n</li>\n</ul>\n<h2 id=\"网络分层\"><a href=\"#网络分层\" class=\"headerlink\" title=\"网络分层\"></a>网络分层</h2><h3 id=\"TCP-IP-五层模型\"><a href=\"#TCP-IP-五层模型\" class=\"headerlink\" title=\"TCP/IP 五层模型\"></a>TCP/IP 五层模型</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">协议</th>\n<th style=\"text-align:center\">主要作用</th>\n<th style=\"text-align:center\">关注点</th>\n<th>常见协议</th>\n<th>协议数据单位</th>\n<th>物理设备</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">应用层</td>\n<td style=\"text-align:center\">为应用程序提供网络传输接口</td>\n<td style=\"text-align:center\">进程如何通信</td>\n<td>HTTP, DNS</td>\n<td>PDU</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">传输层</td>\n<td style=\"text-align:center\">负责将上层数据分段并提供端到端的传输</td>\n<td style=\"text-align:center\">端到端的差错控制和流量控制</td>\n<td>TCP, UDP</td>\n<td>segment</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">网络层</td>\n<td style=\"text-align:center\">网络地址翻译成对应的物理地 ，解决如何将数据从发送方路由到接收方</td>\n<td style=\"text-align:center\">对子网间的数据包进行路由选择，实现拥塞控制、网际互连等功能</td>\n<td>ARP, IP</td>\n<td>packet</td>\n<td>路由器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">连接层</td>\n<td style=\"text-align:center\">控制网络层与物理层之间的通信，在不可靠的物理介质上提供可靠的传输。</td>\n<td style=\"text-align:center\">物理地址寻址、数据的成帧、流量控制、数据的检错、重发等</td>\n<td></td>\n<td>frame</td>\n<td>交换机，网桥</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">物理层</td>\n<td style=\"text-align:center\">为上层协议提供了一个传输数据的物理媒体</td>\n<td style=\"text-align:center\">规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性</td>\n<td></td>\n<td>bit</td>\n<td>集线器，中继器</td>\n</tr>\n</tbody>\n</table>\n<p>为什么强调五层呢？因为还有个 TCP/IP 四层协议把链路层和物理层合并了，统称为网络接口层</p>\n<h3 id=\"OSI-模型\"><a href=\"#OSI-模型\" class=\"headerlink\" title=\"OSI 模型\"></a>OSI 模型</h3><p>实际上 TCP/IP 模型是从 OSI 模型演化来的。学院派先搞出的 OSI 模型，工业使用了更简化的 TCP/IP 协议。</p>\n<p>具体表现是 TCP/IP 协议把 OSI 的应用层、表示层、会话层合同为应用层。</p>\n<h3 id=\"分层的过程：\"><a href=\"#分层的过程：\" class=\"headerlink\" title=\"分层的过程：\"></a>分层的过程：</h3><ol>\n<li>发送方应用程序的数据总是从最上层开始，层层向下，最终经由物理层发送出去</li>\n<li>接收方的物理层接收到数据后，层层向上，最终经由应用层分发到具体的应用程序进程中</li>\n<li>在数据层层向下的过程中，每一层都会对数据进行一些封装处理（如打包或者编码）</li>\n<li>在数据层层向上的过程中，每一层都会对数据进行一些逆处理（如解包或者解码）</li>\n</ol>\n","excerpt":"","more":"<p>Netty 还没看几页就碰到 TCP 接收滑块的问题。隐约记得传输层协议学习的时候看过，但也忘的七七八八的了。毕业两年网络相关的知识也差不多丢完了（就好像自己以前会一样），从本文开始回顾一下网络知识。目标至少网络层以上的主要协议大致过程要清楚，尤其是 Web 开发常见协议，总结的顺序依据《计算机网络——自顶向下学习方法》。</p>\n<h2 id=\"网络构成\"><a href=\"#网络构成\" class=\"headerlink\" title=\"网络构成\"></a>网络构成</h2><h3 id=\"网络边缘\"><a href=\"#网络边缘\" class=\"headerlink\" title=\"网络边缘\"></a>网络边缘</h3><ul>\n<li>主机</li>\n<li>网络应用，模型<ul>\n<li>C/S</li>\n<li>P2P</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"接入网络\"><a href=\"#接入网络\" class=\"headerlink\" title=\"接入网络\"></a>接入网络</h3><ul>\n<li>目的：将网络边缘接入网络核心（边缘路由器）</li>\n<li>物理介质：有线、无线通信链路</li>\n</ul>\n<ul>\n<li>分类：家庭、机构、移动</li>\n<li>关心主题：带宽、独占 / 共享</li>\n</ul>\n<h4 id=\"DSL\"><a href=\"#DSL\" class=\"headerlink\" title=\"DSL\"></a>DSL</h4><ul>\n<li>利用电话线</li>\n<li>频分多路复用<ul>\n<li>0 ~ 4HKZ：电话</li>\n<li>4KHZ ~ 50KHZ：上行</li>\n<li>50KHZ ~ 1MHZ：下行</li>\n</ul>\n</li>\n<li>带宽：上行 &lt; 2.5 或 1 Mbps, 下行 &gt; 24 或 10 Mbps</li>\n<li>独占</li>\n</ul>\n<h4 id=\"电缆\"><a href=\"#电缆\" class=\"headerlink\" title=\"电缆\"></a>电缆</h4><ul>\n<li>电视网络</li>\n<li>频分多路复用</li>\n<li>HFC：混合光纤同轴电缆</li>\n<li>带宽：上行 2Mbps，下行 20Mbps</li>\n<li>共享</li>\n</ul>\n<h4 id=\"以太网\"><a href=\"#以太网\" class=\"headerlink\" title=\"以太网\"></a>以太网</h4><ul>\n<li>机构使用</li>\n<li>带宽：10Mbps, 100Mbps, 1Gbps, 10Gbps</li>\n</ul>\n<h4 id=\"无线接入\"><a href=\"#无线接入\" class=\"headerlink\" title=\"无线接入\"></a>无线接入</h4><ul>\n<li>共享无线网络</li>\n<li>无线局域网：802.11 b/g, 11Mbps, 50Mbps</li>\n<li>广域无线接入</li>\n</ul>\n<h3 id=\"网络核心\"><a href=\"#网络核心\" class=\"headerlink\" title=\"网络核心\"></a>网络核心</h3><p>目的：数据交换，从源主机通过核心网络送到目的主机</p>\n<h4 id=\"互联\"><a href=\"#互联\" class=\"headerlink\" title=\"互联\"></a>互联</h4><ul>\n<li>路由：确定分组从源主机到目的主机的传输路径</li>\n<li>转发：将分组从路由器输入端口交换至正确的输出端口</li>\n</ul>\n<h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><p>网络的网络——Internet</p>\n<ul>\n<li>端系统通过接入 ISP 连接到 Internet</li>\n<li>ISP 必须进一步互联，构成复杂网络</li>\n</ul>\n<p>ISP 互联方式：</p>\n<ol>\n<li><p>直接彼此互联</p>\n<p>需要 N * (N-1) / 2 条连接</p>\n</li>\n<li><p>每个接入 ISP 连接到一个国家/全球ISP</p>\n<p>引入交换设备简化了方式 1，问题：1. 距离；规模：瓶颈，端口</p>\n</li>\n<li><p>在方式 2 基础引入竞争者——二级，三级 ISP</p>\n<p>引入交换网络，解决连通性、网络规模问题</p>\n</li>\n<li><p>引入区域 ISP，连接端系统和接入 ISP</p>\n</li>\n<li><p>内容提供网络</p>\n</li>\n</ol>\n<h2 id=\"数据交换\"><a href=\"#数据交换\" class=\"headerlink\" title=\"数据交换\"></a>数据交换</h2><ul>\n<li>交换含义：<ol>\n<li>动态转义</li>\n<li>动态分配传输资源</li>\n</ol>\n</li>\n<li>数据交换方式：电路、报文、分组</li>\n</ul>\n<h3 id=\"多路复用技术\"><a href=\"#多路复用技术\" class=\"headerlink\" title=\"多路复用技术\"></a>多路复用技术</h3><ul>\n<li>链路/网络资源划分为资源片</li>\n<li>将资源片分配给各路呼叫</li>\n<li>每路呼叫独占分配到的资源进行通信</li>\n<li>资源可被闲置</li>\n<li>分配<ul>\n<li>频分复用 FDM，有先电视网络，占用不同频带</li>\n<li>时分复用 TDM，占用不同时间片</li>\n<li>波分复用 WDM，光的频分复用</li>\n<li>码分复用 CDM，无线链路共享</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"交换技术\"><a href=\"#交换技术\" class=\"headerlink\" title=\"交换技术\"></a>交换技术</h3><h4 id=\"电路交换\"><a href=\"#电路交换\" class=\"headerlink\" title=\"电路交换\"></a>电路交换</h4><ul>\n<li>典型：电话网络</li>\n<li>过程：<ol>\n<li>建立连接</li>\n<li>通信</li>\n<li>释放连接</li>\n</ol>\n</li>\n<li>特点：独占资源</li>\n<li>中继线共享——多路复用</li>\n</ul>\n<h4 id=\"报文交换\"><a href=\"#报文交换\" class=\"headerlink\" title=\"报文交换\"></a>报文交换</h4><p>源（应用）发送信息整体，典型：电报</p>\n<h4 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h4><p>分组：报文拆分出来的较小的数据包</p>\n<p>过程：报文拆分、重复</p>\n<p>额外开销：1. 拆分，重组；2. 头信息</p>\n<h4 id=\"报文、分组交换异同\"><a href=\"#报文、分组交换异同\" class=\"headerlink\" title=\"报文、分组交换异同\"></a>报文、分组交换异同</h4><ul>\n<li>同：过程都是存储-转发</li>\n<li>异：交换过程是否查分数据</li>\n</ul>\n<h4 id=\"分组、电路交换特点\"><a href=\"#分组、电路交换特点\" class=\"headerlink\" title=\"分组、电路交换特点\"></a>分组、电路交换特点</h4><ul>\n<li>分组不独占，电路独占资源</li>\n<li>分组更适合突发数据传输网络</li>\n<li>分组特点：<ul>\n<li>无需呼叫建立</li>\n<li>资源充分共享</li>\n<li>可能产生拥塞：分组延迟，丢失</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分组、报文耗时比较\"><a href=\"#分组、报文耗时比较\" class=\"headerlink\" title=\"分组、报文耗时比较\"></a>分组、报文耗时比较</h4><p>发送 M bits 的报文，链路带宽为 R bps，分组长 L bits，跳步数 h，路由器数 n。（n = h -1）</p>\n<p>报文：M / R * h</p>\n<p>报文：(M / R) + (h -1) * L / R -&gt; M / R + nL / R</p>\n<h4 id=\"分组交换时延-amp-丢包-amp-吞吐量\"><a href=\"#分组交换时延-amp-丢包-amp-吞吐量\" class=\"headerlink\" title=\"分组交换时延 &amp; 丢包 &amp; 吞吐量\"></a>分组交换时延 &amp; 丢包 &amp; 吞吐量</h4><ul>\n<li><p>时延：结点处理时延、排队时延、传输时延、传播时延</p>\n</li>\n<li><p>流量强度</p>\n<p>流量强度：分组 * 分组到达平均速率 / 传输速率</p>\n<p>流量强度 &gt; 1：表示比特到达平均速率超过队列传输出去速率，队列趋于无界增加，排队时延趋于无穷大</p>\n</li>\n<li><p>丢包：到达的分组排满一个队列后，路由器将丢弃分组</p>\n</li>\n<li><p>吞吐量：取决于数据流过的链路的传输速率，近似为沿着源和目的地之间路径的最小传输速率</p>\n</li>\n</ul>\n<h2 id=\"网络分层\"><a href=\"#网络分层\" class=\"headerlink\" title=\"网络分层\"></a>网络分层</h2><h3 id=\"TCP-IP-五层模型\"><a href=\"#TCP-IP-五层模型\" class=\"headerlink\" title=\"TCP/IP 五层模型\"></a>TCP/IP 五层模型</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">协议</th>\n<th style=\"text-align:center\">主要作用</th>\n<th style=\"text-align:center\">关注点</th>\n<th>常见协议</th>\n<th>协议数据单位</th>\n<th>物理设备</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">应用层</td>\n<td style=\"text-align:center\">为应用程序提供网络传输接口</td>\n<td style=\"text-align:center\">进程如何通信</td>\n<td>HTTP, DNS</td>\n<td>PDU</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">传输层</td>\n<td style=\"text-align:center\">负责将上层数据分段并提供端到端的传输</td>\n<td style=\"text-align:center\">端到端的差错控制和流量控制</td>\n<td>TCP, UDP</td>\n<td>segment</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">网络层</td>\n<td style=\"text-align:center\">网络地址翻译成对应的物理地 ，解决如何将数据从发送方路由到接收方</td>\n<td style=\"text-align:center\">对子网间的数据包进行路由选择，实现拥塞控制、网际互连等功能</td>\n<td>ARP, IP</td>\n<td>packet</td>\n<td>路由器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">连接层</td>\n<td style=\"text-align:center\">控制网络层与物理层之间的通信，在不可靠的物理介质上提供可靠的传输。</td>\n<td style=\"text-align:center\">物理地址寻址、数据的成帧、流量控制、数据的检错、重发等</td>\n<td></td>\n<td>frame</td>\n<td>交换机，网桥</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">物理层</td>\n<td style=\"text-align:center\">为上层协议提供了一个传输数据的物理媒体</td>\n<td style=\"text-align:center\">规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性</td>\n<td></td>\n<td>bit</td>\n<td>集线器，中继器</td>\n</tr>\n</tbody>\n</table>\n<p>为什么强调五层呢？因为还有个 TCP/IP 四层协议把链路层和物理层合并了，统称为网络接口层</p>\n<h3 id=\"OSI-模型\"><a href=\"#OSI-模型\" class=\"headerlink\" title=\"OSI 模型\"></a>OSI 模型</h3><p>实际上 TCP/IP 模型是从 OSI 模型演化来的。学院派先搞出的 OSI 模型，工业使用了更简化的 TCP/IP 协议。</p>\n<p>具体表现是 TCP/IP 协议把 OSI 的应用层、表示层、会话层合同为应用层。</p>\n<h3 id=\"分层的过程：\"><a href=\"#分层的过程：\" class=\"headerlink\" title=\"分层的过程：\"></a>分层的过程：</h3><ol>\n<li>发送方应用程序的数据总是从最上层开始，层层向下，最终经由物理层发送出去</li>\n<li>接收方的物理层接收到数据后，层层向上，最终经由应用层分发到具体的应用程序进程中</li>\n<li>在数据层层向下的过程中，每一层都会对数据进行一些封装处理（如打包或者编码）</li>\n<li>在数据层层向上的过程中，每一层都会对数据进行一些逆处理（如解包或者解码）</li>\n</ol>\n"},{"title":"2016's Summary","date":"2016-12-29T16:00:00.000Z","_content":"\n## 2016’s Summary\n\n\n| 时间      | 任务                                       |\n| ------- | ---------------------------------------- |\n| 2016.01 | 开始阅读《Java核心技术》，《Head First Java》         |\n| 2016.02 | [阅读《Java核心技术》完成，《Head First Java》](https://github.com/zhanghTK/HelloJava) |\n| 2016.03 | [阅读《Head First 设计模式》完成一半](https://github.com/zhanghTK/HelloDesignPattern) |\n| 2016.04 | 阅读《架构探险》完成一半，《看透Spring MVC》完成一半          |\n| 2016.05 | Hibernate4学习，协助强锦昕同学完成了毕业设计的编码工作（[素性检测](https://github.com/zhanghTK/PrimalityTesting) ） |\n| 2016.06 | 阅读《Spring实战》完成一半，《Spring Boot实战》完成       |\n| 2016.07 | 搭建[博客](http://zhangh.tk/)，[阅读《Head First HTML CSS》完成](http://zhangh.tk/2016/07/31/HTML%E4%B8%8ECSS%E5%B0%8F%E8%AE%B0/)，了解Docker，Dubbo |\n| 2016.08 | [阅读《函数式编程思维》完成](http://zhangh.tk/2016/08/27/%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/)，《MySQL必知必会》完成 |\n| 2016.09 | [阅读《Java并发编程实战》完成](http://zhangh.tk/2016/09/29/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/)， 阅读《Head First Servlet&JSP》完成不包含JSP部分 |\n| 2016.10 | [阅读《Java Persistence with MyBatis 3》完成](https://github.com/zhanghTK/HelloMyBatis)，参加了“编码武者”线下培训[1](http://zhangh.tk/2016/10/22/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/),[2](http://zhangh.tk/2016/10/22/%E4%BB%8E%E4%BE%9D%E8%B5%96%E5%AE%9E%E7%8E%B0%E5%88%B0%E4%BE%9D%E8%B5%96%E8%A1%8C%E4%B8%BA/),[3](http://zhangh.tk/2016/10/22/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E2%80%94%E2%80%94%E5%90%88%E7%90%86%E7%9A%84%E5%B0%81%E8%A3%85/) |\n| 2016.11 | 翻译《Spring Data官方文档》第四章,[临摹了一个IoC容器Demo](https://github.com/zhanghTK/HelloIoC)，阅读《Effective Java》完成 |\n| 2016.12 | [模仿Struts1实现一个MVC框架](https://github.com/zhanghTK/HelloStruts1)，阅读《深入理解Java虚拟机》完成 |\n\n---\n\n2016年的改善：\n\n1. 熟悉了Java以及相关的工具\n2. 对日常开源框架大体有了了解\n3. 代码质量整体提升\n\n2016年的不足：\n\n1. 乱，学习没有计划，尤其上半年，基础的积累不够，追逐时髦技术；\n2. 懒，产出不多，很多内容停留在读的层面，缺乏实现，理解不够不深入；\n3. 急，书读的囫囵吞枣，实践不够，实践的代码可维护性差；\n\n---\n\n## 2017‘s Flag\n\n![2017任务](https://ooo.0o0.ooo/2016/12/30/586615ad1ca69.jpg)\n\n![阅读计划](https://ooo.0o0.ooo/2016/12/30/586615ff1a321.jpg)\n","source":"_posts/二零一六年度总结.md","raw":"---\ntitle: 2016's Summary\ndate: 2016-12-30\ntags:\ncategories: 随笔\n---\n\n## 2016’s Summary\n\n\n| 时间      | 任务                                       |\n| ------- | ---------------------------------------- |\n| 2016.01 | 开始阅读《Java核心技术》，《Head First Java》         |\n| 2016.02 | [阅读《Java核心技术》完成，《Head First Java》](https://github.com/zhanghTK/HelloJava) |\n| 2016.03 | [阅读《Head First 设计模式》完成一半](https://github.com/zhanghTK/HelloDesignPattern) |\n| 2016.04 | 阅读《架构探险》完成一半，《看透Spring MVC》完成一半          |\n| 2016.05 | Hibernate4学习，协助强锦昕同学完成了毕业设计的编码工作（[素性检测](https://github.com/zhanghTK/PrimalityTesting) ） |\n| 2016.06 | 阅读《Spring实战》完成一半，《Spring Boot实战》完成       |\n| 2016.07 | 搭建[博客](http://zhangh.tk/)，[阅读《Head First HTML CSS》完成](http://zhangh.tk/2016/07/31/HTML%E4%B8%8ECSS%E5%B0%8F%E8%AE%B0/)，了解Docker，Dubbo |\n| 2016.08 | [阅读《函数式编程思维》完成](http://zhangh.tk/2016/08/27/%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/)，《MySQL必知必会》完成 |\n| 2016.09 | [阅读《Java并发编程实战》完成](http://zhangh.tk/2016/09/29/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/)， 阅读《Head First Servlet&JSP》完成不包含JSP部分 |\n| 2016.10 | [阅读《Java Persistence with MyBatis 3》完成](https://github.com/zhanghTK/HelloMyBatis)，参加了“编码武者”线下培训[1](http://zhangh.tk/2016/10/22/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/),[2](http://zhangh.tk/2016/10/22/%E4%BB%8E%E4%BE%9D%E8%B5%96%E5%AE%9E%E7%8E%B0%E5%88%B0%E4%BE%9D%E8%B5%96%E8%A1%8C%E4%B8%BA/),[3](http://zhangh.tk/2016/10/22/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E2%80%94%E2%80%94%E5%90%88%E7%90%86%E7%9A%84%E5%B0%81%E8%A3%85/) |\n| 2016.11 | 翻译《Spring Data官方文档》第四章,[临摹了一个IoC容器Demo](https://github.com/zhanghTK/HelloIoC)，阅读《Effective Java》完成 |\n| 2016.12 | [模仿Struts1实现一个MVC框架](https://github.com/zhanghTK/HelloStruts1)，阅读《深入理解Java虚拟机》完成 |\n\n---\n\n2016年的改善：\n\n1. 熟悉了Java以及相关的工具\n2. 对日常开源框架大体有了了解\n3. 代码质量整体提升\n\n2016年的不足：\n\n1. 乱，学习没有计划，尤其上半年，基础的积累不够，追逐时髦技术；\n2. 懒，产出不多，很多内容停留在读的层面，缺乏实现，理解不够不深入；\n3. 急，书读的囫囵吞枣，实践不够，实践的代码可维护性差；\n\n---\n\n## 2017‘s Flag\n\n![2017任务](https://ooo.0o0.ooo/2016/12/30/586615ad1ca69.jpg)\n\n![阅读计划](https://ooo.0o0.ooo/2016/12/30/586615ff1a321.jpg)\n","slug":"二零一六年度总结","published":1,"updated":"2017-01-07T08:23:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2rm003od82e3d2iasyp","content":"<h2 id=\"2016’s-Summary\"><a href=\"#2016’s-Summary\" class=\"headerlink\" title=\"2016’s Summary\"></a>2016’s Summary</h2><table>\n<thead>\n<tr>\n<th>时间</th>\n<th>任务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2016.01</td>\n<td>开始阅读《Java核心技术》，《Head First Java》</td>\n</tr>\n<tr>\n<td>2016.02</td>\n<td><a href=\"https://github.com/zhanghTK/HelloJava\" target=\"_blank\" rel=\"external\">阅读《Java核心技术》完成，《Head First Java》</a></td>\n</tr>\n<tr>\n<td>2016.03</td>\n<td><a href=\"https://github.com/zhanghTK/HelloDesignPattern\" target=\"_blank\" rel=\"external\">阅读《Head First 设计模式》完成一半</a></td>\n</tr>\n<tr>\n<td>2016.04</td>\n<td>阅读《架构探险》完成一半，《看透Spring MVC》完成一半</td>\n</tr>\n<tr>\n<td>2016.05</td>\n<td>Hibernate4学习，协助强锦昕同学完成了毕业设计的编码工作（<a href=\"https://github.com/zhanghTK/PrimalityTesting\" target=\"_blank\" rel=\"external\">素性检测</a> ）</td>\n</tr>\n<tr>\n<td>2016.06</td>\n<td>阅读《Spring实战》完成一半，《Spring Boot实战》完成</td>\n</tr>\n<tr>\n<td>2016.07</td>\n<td>搭建<a href=\"http://zhangh.tk/\" target=\"_blank\" rel=\"external\">博客</a>，<a href=\"http://zhangh.tk/2016/07/31/HTML%E4%B8%8ECSS%E5%B0%8F%E8%AE%B0/\" target=\"_blank\" rel=\"external\">阅读《Head First HTML CSS》完成</a>，了解Docker，Dubbo</td>\n</tr>\n<tr>\n<td>2016.08</td>\n<td><a href=\"http://zhangh.tk/2016/08/27/%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"external\">阅读《函数式编程思维》完成</a>，《MySQL必知必会》完成</td>\n</tr>\n<tr>\n<td>2016.09</td>\n<td><a href=\"http://zhangh.tk/2016/09/29/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"external\">阅读《Java并发编程实战》完成</a>， 阅读《Head First Servlet&amp;JSP》完成不包含JSP部分</td>\n</tr>\n<tr>\n<td>2016.10</td>\n<td><a href=\"https://github.com/zhanghTK/HelloMyBatis\" target=\"_blank\" rel=\"external\">阅读《Java Persistence with MyBatis 3》完成</a>，参加了“编码武者”线下培训<a href=\"http://zhangh.tk/2016/10/22/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/\" target=\"_blank\" rel=\"external\">1</a>,<a href=\"http://zhangh.tk/2016/10/22/%E4%BB%8E%E4%BE%9D%E8%B5%96%E5%AE%9E%E7%8E%B0%E5%88%B0%E4%BE%9D%E8%B5%96%E8%A1%8C%E4%B8%BA/\" target=\"_blank\" rel=\"external\">2</a>,<a href=\"http://zhangh.tk/2016/10/22/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E2%80%94%E2%80%94%E5%90%88%E7%90%86%E7%9A%84%E5%B0%81%E8%A3%85/\" target=\"_blank\" rel=\"external\">3</a></td>\n</tr>\n<tr>\n<td>2016.11</td>\n<td>翻译《Spring Data官方文档》第四章,<a href=\"https://github.com/zhanghTK/HelloIoC\" target=\"_blank\" rel=\"external\">临摹了一个IoC容器Demo</a>，阅读《Effective Java》完成</td>\n</tr>\n<tr>\n<td>2016.12</td>\n<td><a href=\"https://github.com/zhanghTK/HelloStruts1\" target=\"_blank\" rel=\"external\">模仿Struts1实现一个MVC框架</a>，阅读《深入理解Java虚拟机》完成</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>2016年的改善：</p>\n<ol>\n<li>熟悉了Java以及相关的工具</li>\n<li>对日常开源框架大体有了了解</li>\n<li>代码质量整体提升</li>\n</ol>\n<p>2016年的不足：</p>\n<ol>\n<li>乱，学习没有计划，尤其上半年，基础的积累不够，追逐时髦技术；</li>\n<li>懒，产出不多，很多内容停留在读的层面，缺乏实现，理解不够不深入；</li>\n<li>急，书读的囫囵吞枣，实践不够，实践的代码可维护性差；</li>\n</ol>\n<hr>\n<h2 id=\"2017‘s-Flag\"><a href=\"#2017‘s-Flag\" class=\"headerlink\" title=\"2017‘s Flag\"></a>2017‘s Flag</h2><p><img src=\"https://ooo.0o0.ooo/2016/12/30/586615ad1ca69.jpg\" alt=\"2017任务\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2016/12/30/586615ff1a321.jpg\" alt=\"阅读计划\"></p>\n","excerpt":"","more":"<h2 id=\"2016’s-Summary\"><a href=\"#2016’s-Summary\" class=\"headerlink\" title=\"2016’s Summary\"></a>2016’s Summary</h2><table>\n<thead>\n<tr>\n<th>时间</th>\n<th>任务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2016.01</td>\n<td>开始阅读《Java核心技术》，《Head First Java》</td>\n</tr>\n<tr>\n<td>2016.02</td>\n<td><a href=\"https://github.com/zhanghTK/HelloJava\">阅读《Java核心技术》完成，《Head First Java》</a></td>\n</tr>\n<tr>\n<td>2016.03</td>\n<td><a href=\"https://github.com/zhanghTK/HelloDesignPattern\">阅读《Head First 设计模式》完成一半</a></td>\n</tr>\n<tr>\n<td>2016.04</td>\n<td>阅读《架构探险》完成一半，《看透Spring MVC》完成一半</td>\n</tr>\n<tr>\n<td>2016.05</td>\n<td>Hibernate4学习，协助强锦昕同学完成了毕业设计的编码工作（<a href=\"https://github.com/zhanghTK/PrimalityTesting\">素性检测</a> ）</td>\n</tr>\n<tr>\n<td>2016.06</td>\n<td>阅读《Spring实战》完成一半，《Spring Boot实战》完成</td>\n</tr>\n<tr>\n<td>2016.07</td>\n<td>搭建<a href=\"http://zhangh.tk/\">博客</a>，<a href=\"http://zhangh.tk/2016/07/31/HTML%E4%B8%8ECSS%E5%B0%8F%E8%AE%B0/\">阅读《Head First HTML CSS》完成</a>，了解Docker，Dubbo</td>\n</tr>\n<tr>\n<td>2016.08</td>\n<td><a href=\"http://zhangh.tk/2016/08/27/%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/\">阅读《函数式编程思维》完成</a>，《MySQL必知必会》完成</td>\n</tr>\n<tr>\n<td>2016.09</td>\n<td><a href=\"http://zhangh.tk/2016/09/29/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/\">阅读《Java并发编程实战》完成</a>， 阅读《Head First Servlet&amp;JSP》完成不包含JSP部分</td>\n</tr>\n<tr>\n<td>2016.10</td>\n<td><a href=\"https://github.com/zhanghTK/HelloMyBatis\">阅读《Java Persistence with MyBatis 3》完成</a>，参加了“编码武者”线下培训<a href=\"http://zhangh.tk/2016/10/22/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/\">1</a>,<a href=\"http://zhangh.tk/2016/10/22/%E4%BB%8E%E4%BE%9D%E8%B5%96%E5%AE%9E%E7%8E%B0%E5%88%B0%E4%BE%9D%E8%B5%96%E8%A1%8C%E4%B8%BA/\">2</a>,<a href=\"http://zhangh.tk/2016/10/22/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E2%80%94%E2%80%94%E5%90%88%E7%90%86%E7%9A%84%E5%B0%81%E8%A3%85/\">3</a></td>\n</tr>\n<tr>\n<td>2016.11</td>\n<td>翻译《Spring Data官方文档》第四章,<a href=\"https://github.com/zhanghTK/HelloIoC\">临摹了一个IoC容器Demo</a>，阅读《Effective Java》完成</td>\n</tr>\n<tr>\n<td>2016.12</td>\n<td><a href=\"https://github.com/zhanghTK/HelloStruts1\">模仿Struts1实现一个MVC框架</a>，阅读《深入理解Java虚拟机》完成</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>2016年的改善：</p>\n<ol>\n<li>熟悉了Java以及相关的工具</li>\n<li>对日常开源框架大体有了了解</li>\n<li>代码质量整体提升</li>\n</ol>\n<p>2016年的不足：</p>\n<ol>\n<li>乱，学习没有计划，尤其上半年，基础的积累不够，追逐时髦技术；</li>\n<li>懒，产出不多，很多内容停留在读的层面，缺乏实现，理解不够不深入；</li>\n<li>急，书读的囫囵吞枣，实践不够，实践的代码可维护性差；</li>\n</ol>\n<hr>\n<h2 id=\"2017‘s-Flag\"><a href=\"#2017‘s-Flag\" class=\"headerlink\" title=\"2017‘s Flag\"></a>2017‘s Flag</h2><p><img src=\"https://ooo.0o0.ooo/2016/12/30/586615ad1ca69.jpg\" alt=\"2017任务\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2016/12/30/586615ff1a321.jpg\" alt=\"阅读计划\"></p>\n"},{"title":"【翻译】SpringData官方文档第四章","date":"2016-11-26T16:00:00.000Z","_content":"说明：本翻译[4.6](http://ifeve.com/repositories-custom-implementations/)和[4.7](http://ifeve.com/spring-data-4-7/)段发布在[并发编程网](http://ifeve.com/),其他段落为了熟悉上下文而翻译，没有精校。首次参与翻译任务，翻译的不好请指正。\n\n---\n\n# 第四章 使用Spring Data Repositories\n\nSpring Data repository abstraction目的是为了显著的简化必要的样板式代码来为多种持久化数据存储实现数据层。\n\n> 重要\n>\n> 本章解释Spring Data repositories核心的概念和接口。Spring Data repository documentation 与 你的模块。本章这些信息是从Spring Data Commons模块获取的。它使用了JPA模块的配置和代码示范,命名引用覆盖XML配置，它支持所有的Spring Data模块支持的repository API，Repository查询关键字覆盖被repository 接口一般的关键字查询方法。你的模块特性的细节信息，查询文档对应模块。\n>\n\n## 4.1 核心概念\n\nSpring Data repository抽象接口的核心是`Repository`（可能没有那么惊喜）。它需要管理实体类以及实体类的id作为参数。此接口主要用作是获取要使用的类型接口并帮助扩展这个接口。\n\n`CrudRepository`为被管理的实体类提供复杂CRUD功能。\n\n## 4.2 查询方法\n\n标准的CRUD功能repositories通常有查询底层数据库。\n\n在Spring Data中，分词声明这些查询变成了四个步骤的过程：\n\n1. 声明一个接口继承`Repository`或者它的一个子类，并且指定要被处理的实体类和Id类型。\n\n   ```java\n   interface PersonRepository extends Repository<Person, Long> { … }\n   ```\n\n\n1. 在接口中声明查询方法。\n\n   ```java\n   interface PersonRepository extends Repository<Person, Long> {\n     List<Person> findByLastname(String lastname);\n   }\n   ```\n\n\n1. 创建Spring生成代理实现上面接口，通过JavaConfig：\n\n   ```java\n   import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n   @EnableJpaRepositories\n   class Config {}\n   ```\n\n   或者通过XML配置：\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xmlns:jpa=\"http://www.springframework.org/schema/data/jpa\"\n   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n   http://www.springframework.org/schema/beans/spring-beans.xsd\n   http://www.springframework.org/schema/data/jpa\n   http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\">\n   <jpa:repositories base-package=\"com.acme.repositories\"/>\n   </beans>\n   ```\n\n   这个实例中使用了JPA命名空间。\n\n   如果你为其他存储使用repository接口，你需要修改来适应你的存储模块命名空间的声明，大概就是替换jpa为期望的，例如mongodb。\n\n   当然，注意JavaConfig并没有明确配置一个包默认使用注解的包。\n\n   为了定制包被扫描可以使用数据存储注解`@Enable`的一个属性`basePackage`。\n\n\n1. 获得repository实例注入并使用。\n\n   ```java\n   public class SomeClient {\n     @Autowired\n     private PersonRepository repository;\n     public void doSomething() {\n       List<Person> persons = repository.findByLastname(\"Matthews\");\n     }\n   }\n   ```\n\n\n以下部分详细说明每个步骤。\n\n## 4.3 定义repository接口\n\n第一步定义一个实体类依赖repository接口。\n\n这个接口必须继承`Repository`接口并且指定实体类型和Id类型。\n\n如果你希望实体类型拥有CRUD方法，将`Repository`接口替换成继承`CrudRepository`。\n\n### 4.3.1 小巧repository定义 \n\n一般情况下，你的repository接口应该继承`Repository`，`CrudRepository`或者`PagingAndSortingRepository`\n\n除此之外,如果你不想继承Spring Data接口,你也可以使用`@Repository`注解定义你的接口\n\n继承`CrudRepository`提供了一系列完整的方法来操纵你的实体.\n\n如果你希望选择方法,简单的从`CurdRepository`复制你希望获得的方法到你的`Repository`\n\n> 注意\n>\n> 注意这允许你定义你自己的抽闲建立在Spring Data Repositories功能.\n\n例5.有选择的展现`CRUD`方法\n\n```java\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends Repository<T, ID> {\n  T findOne(ID id);\n  T save(T entity);\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  User findByEmailAddress(EmailAddress emailAddress);\n}\n```\n\n这是第一步你定义一个通用的基本接口,接口供你所有的实体repositories使用并提供`findOne()`和`save()`方法\n\n这些方法会被转发到你选择的Spring Data提供的基本repository实现,例如JPA`SimpleJpaRepository`,因为他们匹配`CrudRepository`的方法签名.\n\n因此`UserPepository`现在可以保存用户,查找唯一用户根据id,并且触发一个查询去查找`Users`根据他们的邮箱地址\n\n> 注意\n>\n> 注意,中间的repository接口使用了注解`NoRepositoryBean`.\n>\n> 对所有Spring Data在运行时不需要生成实例的repository接口,确保你为他们添加了注解.\n\n### 4.3.2 在多个Spring Data模块使用Repositories\n\n在你的应用中使用唯一的Spring Data模块,所有repository接口定义范围限制在Spring Data模块.\n\n有时候应用需要使用不止一个Spring Data模块.\n\n这种情况下,需要repository定义在持久化技术之间有所区别.\n\n在class path发现多个repository工厂时,Spring Data严格检测repository配置模块.\n\n在repository或者实体类严格配置需要得细节以决定Spring Data模块绑定一个repository的定义:\n\n1. 如果repository定义继承模块特殊的repository,那么对Spring Data模块这是一个有效的备选.\n\n\n1. 如果实体类被模块特有的注解类型注解,那么对Spring Data模块这是一个有效的备选.\n\n   Spring Data模块接收第三方注解(例如 JPA的`@Entity`)或者提供自己的注解例如`@Document`为Spring Data MongoDB/Spring Data Elasticsearch.\n\n\n例6.使用模块特有的接口定义Repository\n\n```java\ninterface MyRepository extends JpaRepository<User, Long> { }\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends JpaRepository<T,ID{\n  …\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  …\n}\n```\n\n`MyRepository`和`UserRepository`继承`JpaRepository`在他们类型层级.他们有效的表示了Spring Data JPA模块.\n\n例7.使用通用的接口定义`Repository`.\n\n```java\ninterface AmbiguousRepository extends Repository<User, Long> {\n  …\n}\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends\n  CrudRepository<T,ID> {\n  …\n}\n\ninterface AmbiguousUserRepository extends MyBaseRepository<User, Long> {\n  …\n}\n```\n\n`AmbiguousRepository`和`AmbiguousUserRepository`在它们继承体系里只继承了`Repository`和`CrudRepository`.使用唯一的Spring Data模块是这是完成正确的,多个模块不能识别`Repository`到底绑定哪个Spring Data.\n\n例8.使用注解配合实体类定义`Repositor`\n\n```java\ninterface PersonRepository extends Repository<Person, Long> {\n  …\n}\n\n@Entity\npublic class Person {\n  …\n}\n\ninterface UserRepository extends Repository<User, Long> {\n  …\n}\n\n@Document\npublic class User {\n  …\n}\n```\n\n`PersonRepository`引用使用了JPA的注解`@Entity`进行注解的`Person`,所以这个repository明确的属于Spring Data JPA.`UserRepository`使用了Spring Data MongoDB的注解`@Document`进行注解.\n\n例9.使用混合注解配合实体类定义`Repositor`\n\n```java\ninterface JpaPersonRepository extends Repository<Person, Long> {\n  …\n}\n\ninterface MongoDBPersonRepository extends Repository<Person, Long> {\n  …\n}\n\n@Entity\n@Document\npublic class Person {\n  …\n}\n```\n\n这个示例展示实体类同时使用JPA和Spring Data MongoDB注解.\n\n这里定义了两个repository,`JpaPersonRepository`和`MongoDBPersonRepository`.\n\n一个被JPA使用,另一个被MongoDB使用.\n\nSpring Data不再能告诉repository区分,这将导致不清晰的行为\n\n\"使用模块特有的接口定义Repository\"和\"使用注解配合实体类定义`Repositor`\"都使用了严格的repository配置为一个特定的Spring Data模块识别可选的repository\n\n\n使用多种持久化技术特定的注解在同一个实体类上可能在锅中持久化技术上重用了实体类,但是这样做Spring Data将不能确定为repository绑定唯一的模块\n\n最后一种方式区分repository是划分repository的基本包.\n\n\n基本包定义起始点是扫描repository接口定义,这意味着在合适的包定义repository.\n\n默认的,注解配置使用类配置的包\n\n基于XML基本配置在这里.\n\n例10.注解配置基本包\n\n```java\n@EnableJpaRepositories(basePackages = \"com.acme.repositories.jpa\")\n@EnableMongoRepositories(basePackages = \"com.acme.repositories.mongo\")\ninterface Configuration { }\n```\n\n\n\n## 4.4 Defining query methods\n\n## 4.4 定义查询方法\n\nrepository代理有两种方式获得通过方法名获得指定查询.可以通过方法名直接获得查询,或者手动定义查询.有可用的选项定义在实际的存储.这有一些策略决定实际查询如何被创建.让我们一些看看可用的选项.\n\n### 4.4.1 Query lookup strategies\n\n下面这些repository基本组件的决定查询可用的策略.你可以配置策略,在XML配置中通过命名空间`query-look-strategy`属性或者在Java配置中通过启用${store} Repository的属性注解`queryLookupStrategy`.一些策略可能不能支持特定的数据库.\n\n- CREATE 试图通过方法名构建一个指定查询.一般处理是从方法名移除一系列给定的前缀并解析方法其他部分.更多查询构建信息阅读Query creation.\n- USE_DECLARED_QUERY试图查找一个准确的查询,并在找不到时抛出一个异常.查询可以被通过注解定义或者其它方式定义.查询特殊存储的文档了解存储的可用选择.如果repository基本组件在启动时不能为方法找到一个准确的查询,将会失败\n- CREATE_IF_NOT_FOUND(默认)联合了CREATE和USE_DECLARED_QUERY.首先查找一个准确查询,如果没有找到,创建一个定制方法基于名字的查询.这是默认的查询策略,因此如果你没有做任何明确配置.它允许根据方法名快速查询定义,而且定制查询根据需要引入声明的查询.\n\n\n### 4.4.2 查询创建\n\n建成Spring Data repository基本组件的查询构建机制有用的构建了repository所有实体类的约束查询.\n\n这个机制分隔方法前缀`find...By`,`read...By`,`query...By`,`count...By`以及`get...By`,并解析其他部分.这个引入条款可以表达包含的特性例如`Distinct`,来设置明确的标志在要生成的查询上.然而,第一个by扮演了分解符来指明真实条件的起始.分词在一个非常基本的水平,你可以在实体属性上定义条件并且连接使用and或or连接他们.\n\n例11.来自方法名的查询创建\n\n```java\npublic interface PersonRepository extends Repository<User, Long> {\n  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String\n                                             lastname);\n  // Enables the distinct flag for the query\n  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String\n                                                       firstname);\n  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String\n                                                       firstname);\n\n  // Enabling ignoring case for an individual property\n  List<Person> findByLastnameIgnoreCase(String lastname);\n  // Enabling ignoring case for all suitable properties\n  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String\n                                                       firstname);\n  // Enabling static ORDER BY for a query\n  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);\n \n  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);\n}\n```\n\n解析方法的实际结果取决于你创建查询的持久化存储.然而,这有些问题需要注意:\n\n- 表达式通常串行的连接属性的遍历与操作符.你可以使用and和or连接属性表达式.你也可以给属性表达式使用操作符,例如between,lessThan,granterThan,like.你可以使用的表达式操作符有between,LessThan,GreaterThan,Loke.被支持的操作符根据多样的数据库决定,因此查询你引用文档的恰当部分.\n- 方法解析支持为单独属性设置一个IgnoreCase标志(例如,findByLastnameIgnoreCase(...))或者为所有属性都支持忽略情况(通常是String情形,例如,findByLastnameAndFirstnameAllIgnoreCase(…)).忽略情况是否被支持由多样的数据库决定，所以具体存储查询方法在引用文档查询相关章节.\n- 你可以为查询方法引用的属性提供静态排序连接OrderBy子句并且提供排序方向(Asc或Desc).为创建一个查询方法支持动态排序,查看特殊参数处理.\n\n\n\n### 4.4.3 属性表达式\n\n属性表达式可以只为管理的实体类的直接属性使用，就像前面所展示的那样。查询常见时你已经确认解析的字段是管理的实体类的一个字段.然而,你也可以通过最近的字段定义一个约束.假设`Person`的`Address`有一个`ZipCode`字段.这种情况一个方法如果这样命名:\n\n```java\nList<Person> findByAddressZipCode(ZipCode zipCode);\n```\n\n创建属性遍历`x.address.zipCode`.决策算法从把全部(`AddressZipCode`)作为属性开始并且检查实体类依此命名的属性(小写开头).如果算法成功了,就是用这个属性.否则,算法将源码部分驼峰式大小写从右侧头部到尾巴分隔,并试图找到相应的属性,在我们的例子中,`AddressZip`和`Code`.如果从头部找到一个属性,算法将在这里生成树处理后面的部分,使用描述的方式分隔.如果第一个分隔没有匹配到,算法移动分割点到左侧继续(`Address`,`ZipCode`).\n\n这在大多数情况都可以使用,但也可能选择错误的属性.假设`Person`类也有一个`addressZip`属性.算法将匹配第一个匹配的,本质上选择了错误属性,最终失败(伴随的`addressZip`类型没有属性`code`).\n\n没了解决这种起义,你可以在方法名称内使用`_`手动的定义遍历点.所以我们的方法名称最终像这样:\n\n```java\nList<Person> findByAddress_ZipCode(ZipCode zipCode);\n```\n\nAs we treat underscore as a reserved character we strongly advise to follow standard Java naming\nconventions (i.e. not using underscores in property names but camel case instead) \n\n我们对待下划线当做一个保留关键字,我们强力建议遵循标准Java命名规范(例如,使用驼峰命名而不是下划线命名属性名称)\n\n### 4.4.4 特殊参数处理\n\n处理你查询中的参数,你可以定义简单的方法参数像上面的示例中.处理之外基本组件可以识别出某些特殊类型例如`Pageable`和`Sort`用来动态的编码和排序你的查询.\n\n例12.在查询方法使用`Pageable`,`Slice`和`Sort`\n\n```java\nPage<User> findByLastname(String lastname, Pageable pageable);\nSlice<User> findByLastname(String lastname, Pageable pageable);\nList<User> findByLastname(String lastname, Sort sort);\nList<User> findByLastname(String lastname, Pageable pageable);\n```\n\n第一个方法允许你在通过一个`org.springframework.data.domain.Pageable`实例在查询方法中动态添加分页信息在你的静态定义查询中.一个`Page`清楚数据的全部数量和页面总数.它是通过触发计数的基础设施查询计算总数。这个代价可能是昂贵的具体取决于所使用的存储,可以用`Slice`代替.一个`Slict`只知道下一个`Slice`可到到哪里,当运行在一个大的结果集上时这可能已经足够了.排序选项也通过`Pageable`实例处理.如果你只需要排序,简单起见添加`org.springframework.data.domain.Sort`参数在你的方法.如你所见,简单返回一个列表.在这种情况下,额外元数据构建实际的`Page`实例将不会被创建(反过来这意味着,没有发出额外的统计查询所必须的)简单约束只在给定的范围内查询.\n\n> 注意\n>\n> 为了尽早得到你查询了多少页,你必须出发一个格外统计查询.默认的,这个查询你实际触发的查询调用.\n\n### 4.4.5 限制查询结果\n\n查询方法的结果可以通过关键`first`或者`top`限制,可以交换使用.一个可选的数值可以追加在top/first来指定返回的最大结果集.如果数字缺失,假定结果集大小是1.\n\n例13.查询中使用Top和First限制结果大小\n\n```java\nUser findFirstByOrderByLastnameAsc();\nUser findTopByOrderByAgeDesc();\nPage<User> queryFirst10ByLastname(String lastname, Pageable pageable);\nSlice<User> findTop3ByLastname(String lastname, Pageable pageable);\nList<User> findFirst10ByLastname(String lastname, Sort sort);\nList<User> findTop10ByLastname(String lastname, Pageable pageable);\n```\n\n限制表达式也支持Distinct关键字.此外，对于将结果集设置为一个实例的查询，支持将结果包装到一个`Optional`.如果应用分页或分片限制查询分页(并且计算可用的页数)那么这可以应用limited结果.\n\n> 注意\n>\n> 请注意，限制结果结合使用`Sort`的动态排序的结果允许参数可以表示“k”最小的查询方法以及“K”的查询方法最大的元素。\n\n### 4.4.6 流式处理结果\n\n方法查询结果可以通过使用java 8`Stream<T>`逐步处理。\n\n特定的方法用来表示流而不是简单的包装查询结果在一个`Stream`数据存储\n\n例14 一个用java流8`Stream<T>`查询结果\n\n```java\n@Query(\"select u from User u\")\nStream<User> findAllByCustomQueryAndStream();\n\nStream<User> readAllByFirstnameNotNull();\n\n@Query(\"select u from User u\")\nStream<User> streamAllPaged(Pageable pageable);\n```\n\n> 注意\n>\n> 一个`Stream`潜在的包装底层数据存储在页数的资源中,因此使用完毕必须关闭.你可以使用`close()`方法手动关闭`Stream`或者使用一个Java7的try_with-resources块.\n\n```java\ntry(Stream<User> stream = repository.findAllByCustomQueryAndStream()) {\n  stream.forEach(...);\n}\n```\n\n### 4.4.7 异步查询结果\n\nRepository查询可以使用`Spring's asynchronous method execution capacity`执行异步.这意味着方法可以一执行立即返回,真实的查询执行发生在任务提交到一个Spring TaskExecutor.\n\n```java\n@Async\nFuture<User> findByFirstname(String firstname);\n\n@Async\nCompletableFuture<User> findOneByFirstname(String firstname);\n\n@Async\nListenableFuture<User> findOneByLastname(String lastname);\n```\n\n1. 使用`java.util.concurrent.Future`作为返回类型\n2. 使用一个Java8`java.util.current.CompletableFuture`作为返回类型\n3. 使用一个`org.springframework.util.concurrent.ListenableFuture`作为返回类型\n\n## 创建repository实例\n\n这个章节你创建实例和bean定义为repository接口定义.方法之一是手动的支持repository使用包含各个Spring Data模块的Spring命名空间装载,然而我们一般推荐使用Java配置的方法配置.\n\n### 4.5.1 XML配置\n\n每个Spring Data module包含一个repository 元素,这可以让你简单的定义一个基本包,Spring为你扫描它.\n\n例16 通过XML启用Spring Data repositories\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans:beans xmlns:beans=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns=\"http://www.springframework.org/schema/data/jpa\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/jpa\n        http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\">\n      <repositories base-package=\"com.acme.repositories\" />\n    </beans:beans>\n```\n\n在前面的实例中,让Spring扫描`com.acme.repositories`包和它的子包里继承`Repository`的接口或者它的子接口.找到的每个接口,继承组件注册持久化技术的`FactoryBean`来创建合适的代理处理执行查询方法.每个bean被注册在一个接口名称确定的bean name下,所以一个叫`UserRepository`将注册`userRepository`.基本包属性允许通配符,所以你可以定义一个规则扫描包.\n\n**使用过滤**\n\n默认的基本组件选取所有在配置的基本包下继承了持久化技术`Repositpry`接口以及子接口\n\n并且为他们创建一个bean实例.然而,你可能希望更细粒度的控制哪个接口bean实例被创建.为了实现这个你可以在`<repository/>`中使用`<include-filter/>`和`<exclude-filter/>`元素.语义完全等同于Spring的上下文命名空间中的元素.更多细节,查看他们的元素`Spring reference documentation`\n\n例如，要将某些确定的接口排除实例化为repository，可以使用以下配置:\n\n例17. 使用exclude-filter元素\n\n```java\n<repository base-package=\"com.acme.repositories\">\n  <context:exclude-filter type=\"regex\" expression=\".*SomeRepository\" />\n</repositories>\n```\n\n这个示例从待实例化对象中排除所有以SomeRepository结尾的接口.\n\n### 4.5.2 JavaConfig\n\nrepository基础组件也可以使用一个存储的特殊的`@Enable${store}Repositories`注解在一个JavaConfig类上.入门介绍Spring容器Java基本Spring容器查看文档:`JavaConfig in the Spring reference documentaional`\n\n一个简单配置启用Spring Data repositories像这样:\n\n例18. repository配置基于简单注解\n\n```java\n@Configuration\n@EnableJpaRepositories(\"com.acme.repositories\")\nclass ApplicationConfiguration {\n  @Bean\n  public EntityManagerFactory entityManagerFactory() {\n    // …\n  }\n}\n```\n\n> 注意\n>\n> 示例使用了JPA特有的注解,根据你使用的存储模块决定实际如何替换.示例定义`EntityManagerFactory`bean.查阅具体存储的配置\n\n### 4.5.3 单独使用\n\n你也可以在Spring容器之外使用repository基础组件,例如在CDI环境.你仍然需要一些Spring库在你的classpath中,但是你可以以编程的方式启动.repository包装持久化技术支持的Spring Data模块提供RepositoryFactory,你可以向下面这样使用:\n\n例19. repository工厂单独使用\n\n```java\nRepositoryFactorySupport factory = … // Instantiate factory here\nUserRepository repository = factory.getRepository(UserRepository.class);\n```\n\n## 4.6 定制Spring Data仓库实现\n\n时常有必要为一少部分仓库方法提供一个定制的实现.Spring数据存储库很容易允许您提供自定义存储库代码并将其与通用CRUD集成抽象和查询方法功能整合.\n\n### 4.6.1 为单独仓库添加定制行为\n\n为了定制功能丰富一个仓库,你首先为定制功能定义一个接口和实现.使用你提供的仓库接口来继承自定义接口.\n\n例20. 定制仓库功能的接口\n\n```java\ninterface UserRepositoryCustom {\n  public void someCustomMethod(User user);\n}\n```\n\n例21.定制功能的实现\n\n```java\nclass UserRepositoryImpl implements UserRepositoryCustom {\n  public void someCustomMethod(User user) {\n    // Your custom implementation\n  }\n}\n```\n\n> 注意\n>\n> 类可以被找到最重要的点是名字以Impl为后缀区别于仓库的核心接口(见下文)\n\n实现的本身没有依赖Spring Data,可以是一个标准的Spring bean.所以你可以使用标准的依赖注入行为给其他bean注入引用,像`JdbcTemplate`,切面的一部分等等.\n\n例22 修改你基本的仓库接口\n\n```java\ninterface UserRepository extends CrudRepository<User, Long>, UserRepositoryCustom {\n  // Declare query methods here\n}\n```\n\n让你的标准仓库接口继承定制的.这样做结合了CRUD和定制功能并使其可用于客户端.\n\n**配置**\n\n如果你使用命名空间配置,仓库基本组件扫描类所在包,根据扫描结果尝试自动定制实现.\n\n这些类需要遵循命名规范:给仓库接口名添加命名空间元素属性`repositoryimpl-postfix`.默认的后缀是`Impl`\n\n例23. 配置示例\n\n```xml\n<repositories base-package=\"com.acme.repository\" />\n<repositories base-package=\"com.acme.repository\" repository-impl-postfix=\"FooBar\"/>\n```\n\n第一个配置示例将查实查找一个类`com.acme.repository.UserRepositoryImpl`来作为定制藏局实现.然而第二个示例将尝试查找`com.acme.repository.UserRepositoryFooBar `.\n\n\n**手动指定**\n\n上面的方法可以正常工作,只有当你定制实现使用注解配置和自动注入,这将与其他Spring bean一样被对待.如果你定制的实现需要特殊处理,你可以像描述的简单定义一个bean并且命名它.基本组件将通过名称引用手动定义的bean定义而不是它自己创建一个.\n\n例24.手动指定定制实现\n\n```xml\n<repositories base-package=\"com.acme.repository\" />\n<beans:bean id=\"userRepositoryImpl\" class=\"…\">\n  <!-- further configuration -->\n</beans:bean>\n```\n\n### 4.6.2为所有仓库添加定制行为\n\n当你希望把一个单独的方法添加到你所有的仓库接口中时,上面的方法就不可行了.为了添加定制到所有的仓库,你首先添加一个中间接口来定义共享的行为.\n\n例25 定义共享定制行为接口\n\n```java\n@NoRepositoryBean\npublic interface MyRepository<T, ID extends Serializable>\n  extends PagingAndSortingRepository<T, ID> {\n  void sharedCustomMethod(ID id);\n}\n```\n\n现在你独立的仓库接口将继承这个中间接口而不是`Repository`接口来包含功能的定义.接下来创建一个中间接口的实现继承持久化具体仓库的基本类.这个类后面将作为仓库代理的基本类.\n\n例26 定制仓库基本类\n\n```java\npublic class MyRepositoryImpl<T, ID extends Serializable>\n  extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {\n  \n  private final EntityManager entityManager;\n  \n  public MyRepositoryImpl(JpaEntityInformation entityInformation,\n                          EntityManager entityManager) {\n    super(entityInformation, entityManager);\n    // Keep the EntityManager around to used from the newly introduced methods.\n    this.entityManager = entityManager;\n  }\n  \n  public void sharedCustomMethod(ID id) {\n    // implementation goes here\n  }\n}\n```\n\n> 警告\n>\n> 这个类需要有一个构造方法调用父类具体存储仓库工厂实现.万一仓库基础类有多个构造,覆盖包括一个`EntityInformation `加上存储具体基本组件对象(例如一个`EntityManager `或者模板类)\n\nSpring`<repository/>`命名空间下的默认行为为所有接口提供一个实现.这意味着如果处于其当前状态，`MyRepository`的实现实例将由Spring创建.这当然不是被期望的,它只是作为一个用来定义实体的 `Repository`和真实仓库接口的中间接口.为了排除一个继承`Repository`的接口被当做一个仓库接口实例化,你可以给它使用`@NoRepositoryBean`(像上面)或者把它从配置中`base-package`移除.\n\n最后一步是让Spring Data基本组件识别到定制的仓库基本类.在JavaConf使用注解`@Enable...Repository`的属性`repositoryBaseClass`完成:\n\n例27 使用JavaConfig配置一个定制仓库基本类\n\n```java\n@Configuration\n@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)\nclass ApplicationConfiguration { … }\n```\n\n类似的属性在XML命名空间中也可以找到.\n\n例28 使用XML配置一个定制仓库基本类\n\n```xml\n<repositories base-package=\"com.acme.repository\"\n              base-class=\"….MyRepositoryImpl\" />\n```\n\n## 4.7 Spring Data扩展\n\n这部分说明Spring Data一系列的扩展功能,可以使Spring Dta使用多样的上下文.目前大部分集成是针对Spring MVC.\n\n### 4.7.1 Querydsl扩展\n\nQuerydsl是一个框架,通过它的流式API构建静态类型的SQL类查询.\n\n多个Spring Data模块通过`QueryDslPredicateExecutor `与Querydsl集成.\n\n例29 QueryDslPredicateExecutor接口\n\n```java\npublic interface QueryDslPredicateExecutor<T> {\n  T findOne(Predicate predicate); ①\n    Iterable<T> findAll(Predicate predicate); ②\n    long count(Predicate predicate); ③\n    boolean exists(Predicate predicate); ④\n    // … more functionality omitted.\n}\n```\n\n① 查询并返回一个匹配`Predicate `的单例实体\n\n②查询并返回所有匹配`Predicate`的实体\n\n③ 返回匹配`Predicate`的实体数量\n\n④  返回是否存在一个匹配`Predicate`的实体\n\n为了简单的使用Querydsl功能,在你的仓库接口继承`QueryDslPredicateExecutor`.\n\n例30 在仓库集成QueryDsl\n\n```java\ninterface UserRepository extends CrudRepository<User, Long>,\n  QueryDslPredicateExecutor<User> {\n}\n```\n\n像上面这样就可以使用Querydsl的`Predicate`书写类型安全的查询\n\n```java\nPredicate predicate = user.firstname.equalsIgnoreCase(\"dave\")\n  .and(user.lastname.startsWithIgnoreCase(\"mathews\"));\nuserRepository.findAll(predicate);\n```\n\n### 4.7.2 Web支持\n\n> 注意\n>\n> 本节包含Spring Data Web支持的文档是在1.6范围内的Spring Data Commons实现的.因为支持新引入的内容改变了很多东西，我们保留了旧行为的文档在\"遗留Web支持\"部分.\n>\n\n如果模块支持仓库编程模型，那么Spring Data模块附带了各种Web模块支持.Web关联的东西需要Spring MVC的JAR包位于classpath路径下,它们中有些甚至提供了Spring HATEOAS集成.一般情况,集成方式支持使用`@EnableSpringDataWebSupport`注解在你的JavaConfig配置类.\n\n例31 启用Spring Data web支持\n\n```java\n@Configuration\n@EnableWebMvc\n@EnableSpringDataWebSupport\nclass WebConfiguration {}\n```\n\n`@EnableSpringDataWebSupport`注解注册了一些组件，我们将在稍后讨论.注解还将在类路径上检测Spring HATEOAS，如果才在将为其注册集成组件.\n\n作为可选项,如果你使用XML配置,注册`SpringDataWebSupport`或者`HateoasWareSpringDataWebSupport`作为Spring bean:\n\n例32 用XML启用Spring Data web支持\n\n```xml\n<bean class=\"org.springframework.data.web.config.SpringDataWebConfiguration\" />\n<!-- If you're using Spring HATEOAS as well register this one *instead* of the\nformer -->\n<bean class= \"org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration\" />\n```\n\n**基本Web支持**\n\n上面展示的的配置设置将注册几个基本组件：\n\n- 一个`DomainClassConverter`启用Spring MVC来根据请求参数或路径变量管理仓例实体类的实例\n- `HandlerMethodArgumentResolver`实现让Spring MVC从请求参数解析Pageable和Sort实例.\n\n**实体类转换**\n\n`DomainClassConverter`允许你在Spring MVC控制器方法签名中直接使用实体类型,因此你不必手动的通过仓库查询实例:\n\n例33 一个Spring MVC控制器在方法签名中使用实体类型\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") User user, Model model) {\n    model.addAttribute(\"user\", user);\n    return \"userForm\";\n  }\n}\n```\n\n如你所见,方法直接接收一个User实例并没有更进一步的查询是否必要.实例可以通过Spring MVC将路径变量转换为实体类的id类型并最终通过在实体类型注册的仓库实例上调用`findOne(...)`访问实例转换得到.\n\n> 注意\n>\n> 当前的仓库必须实现`CrudRepository`做好准备被发现来进行转换.\n\n**为了分页和排序分解方法参数**\n\n上面的配置片段还注册了一个`PageableHandlerMethodArgumentResolver`和一个`SortHandlerMethodArgumentResolver`实例.注册使得Pageable和Sort成为有效的控制器方法参数.\n\n例34 使用Pageable作为控制器方法参数\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @Autowired UserRepository repository;\n  @RequestMapping\n  public String showUsers(Model model, Pageable pageable) {\n    model.addAttribute(\"users\", repository.findAll(pageable));\n    return \"users\";\n  }\n}\n```\n\n这个方法签名将使Spring MVC尝试使用下面的默认配置从请求参数中转换一个Pageable实例:\n\n表1 请求参数转换Pageable实例\n\n| 参数   | 说明                                       |\n| ---- | ---------------------------------------- |\n| page | 要检索的页面,索引为0,默认为0                         |\n| size | 要检索的页面大小,默认20                            |\n| sort | 被排序的属性应以格式`property,property(, ASC\\|DESC)`表示.默认生序排序,如果你希望改变排序顺序,则使用多个排序参数,例如?sort=firstname&sort=lastname,asc |\n\n为了定制行为,可以继承`SpringDataWebConfiguration`或者启用等效的HATEOAS并覆盖`pageableResolver()`或`sortResolver()`方法并导入你的自定义配置文件替代@Enable-注解.\n\n有一种情况你需要多个`Pageable`或`Sort`实例从请求转换(例如处理多个表单),你可以使用Spring的`@Qualifier`注解来互相区别.请求参数必须以`${qualifier}为`前缀.这样一个方法的签名像这样:\n\n```java\npublic String showUsers(Model model, \n                        @Qualifier(\"foo\")Pagebale first, \n                        @Qualifier(\"bar\") Pageable second) {\n  ...\n}\n```\n\n你必须填充foo_page和bar_page等.\n\n默认的`Pageable`在方法中处理等价于一个`new PageRequest(0, 20)`,但是可以使用`@PageableDefaults`注解在`Pageable`参数上定制.\n\n**Hypermedia支持分页**\n\nSpring HATEOAS包装了一个代表模型的类`PageResources` ,\n\n它可以使用Page实例包装必要的Page元数据内容作为连接让客户端导航页面.一个页面到一个`PageResources`的转换被Spring HATEOAS的`ResourceAssembler`接口实现`PagedResourcesAssembler `来完成.\n\n例35 使用一个PagedResourcesAssembler作为控制器方法参数\n\n```java\n@Controller\nclass PersonController {\n  @Autowired PersonRepository repository;\n  @RequestMapping(value = \"/persons\", method = RequestMethod.GET)\n  HttpEntity<PagedResources<Person>> persons(Pageable pageable,\n                                             PagedResourcesAssembler assembler) {\n    Page<Person> persons = repository.findAll(pageable);\n    return new ResponseEntity<>(assembler.toResources(persons), HttpStatus.OK);\n  }\n}\n```\n\n像上面这样配置将允许`PageResourcesAssembler`作为控制器方法的一个参数.在这调用toResources(...)方法有以下作用:\n\n- `Page`的内容将`PageResources`实例的内容\n- `PageResources`将获得`PageMetadata`实例,该实例由Page和基础的PageRequest中的信息填充\n- `PageResources`获得`prev`和`next`连接,添加这些依赖在页面.这些链接将指向uri方法的调用映射.页码参数根据`PageableHandlerMethodArgumentResolver`添加到参数以在后面被转换.\n\n假设我们有30个Person实例在数据库.你现在可以触发一个GET请求 http://localhost:8080/persons, 你将可以看到类似下面的内容:\n\n```json\n{ \"links\" : [ { \"rel\" : \"next\",\n\"href\" : \"http://localhost:8080/persons?page=1&size=20 }\n],\n\"content\" : [\n… // 20 Person instances rendered here\n],\n\"pageMetadata\" : {\n\"size\" : 20,\n\"totalElements\" : 30,\n\"totalPages\" : 2,\n\"number\" : 0\n}\n}\n```\n\n你可以看到编译生成了正确的URI，并且还会提取默认配置转换参数到即将到来的请求中的`Pageable`.这意味着,如果你改变配置,链接也将自动跟随改变.默认情况下，编译指向控制器执行的方法，但是这可以被一个自定义链接作为基本构建来构成分页的`Link`重载`PagedResourcesAssembler.toResource（...）`方法定制.\n\n**Querydsl web 支持**\n\n那些整合了`QueryDSL`的存储可能从`Request`查询字符串中的属性驱动查询.\n\n这意味着前面例子的查询字符串可以给出`User`的对象\n\n```\n?firstname=Dave&lastname=Matthews\n```\n\n可以被转换为\n\n```java\nQUser.user.firstname.eq(\"Dave\").and(QUser.user.lastname.eq(\"Matthews\"))\n```\n\n使用了`QuerydslPredicateArgumentResolver`.\n\n> 注意\n>\n> 当在类路径上找到Querydsl时，该功能将在@EnableSpringDataWebSupport注解中自动启用\n\n添加一个`@QuerydslPredicate`到一个方法签名将提供一个就绪的`Predicate`,可以通过`QueryDslPredicateExecutor`执行.\n\n> 提示\n>\n> 类型信息通常从返回方法上解析.由于这些信息不一定匹配实体类型,使用`QuerydslPredicate`的`root`属性可能是个好主意.\n\n```java\n@Controller\nclass UserController {\n  @Autowired UserRepository repository;\n  @RequestMapping(value = \"/\", method = RequestMethod.GET)\n  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,\n              Pageable pageable, @RequestParam MultiValueMap<String, String>\n    parameters) {\n        model.addAttribute(\"users\", repository.findAll(predicate, pageable));\n        return \"index\";\n  } \n}\n```\n\n为User转换匹配查询字符串参数的`Predicate`\n\n默认的绑定规则如下:\n\n1. `Object`在简单属性上如同`eq`\n\n2. `Object`在集合作为属性如同`contains`\n\n3. `Collection`在简单属性上如同`in`\n\n\n这些绑定可以通过`@QuerydslPredicate`的`bindings`属性定制或者使用Java8`default methods`给仓库接口添加`QuerydslBinderCustomizer`\n\n```java\ninterface UserReposotory extends CurdRepository<User, String>, \n  QueryDslPredicateExecutor<User>,\n  QuerydslBinderCustomizer<QUser> {\n    @Override\n  \tdefault public void customize(QuerydslBindings bindings, QUser user) {\n      bindings.bind(user.username).first((path, value) -> path.contains(value));\n      bindings.bind(String.class).first((StringPath path, String value) ->\n                                        path.containsIgnoreCase(value));\n      bindings.excluding(user.password);\n  \t}\n  }\n```\n\n1. `QueryDslPredicateExecutor`为`Predicate`提供特殊的查询方法提供入口\n2. 在仓库接口定义`QuerydslBinderCustomizer`将自动注解`@QuerydslPredicate(bindings=...)`\n3. 为`username`属性定义绑定,绑定到一个简单集合\n4. 为`String`属性定义默认绑定到一个不区分大小写的集合\n5. 从`Predicate`移除密码属性\n\n### 4.7.3 仓库填充\n\n如果你使用Spring JDBC模块,你可能熟悉在`DataSource`使用SQL脚本来填充.一个类似的抽象在仓库级别可以使用,尽管它不是使用SQL作为数据定义语言,因为它必须由存储决定.填充根据仓库支持XML(通过Spring的OXM抽象)和JSON(通过Jackson)定义数据.\n\n假设你有一个文件`data.json`内容如下:\n\n例36 JSON定义的数据\n\n```json\n[ { \"_class\" : \"com.acme.Person\",\n     \"firstname\" : \"Dave\",\n      \"lastname\" : \"Matthews\" },\n      { \"_class\" : \"com.acme.Person\",\n     \"firstname\" : \"Carter\",\n      \"lastname\" : \"Beauford\" } ]\n```\n\n你可以容易的根据Spring Data Commons提供仓库的命名空间填充元素填充你的仓库.为了填充前面的数据到你的PersonRepository,像下面这样配置:\n\n例37 声明一个Jackson仓库填充\n\n```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:repository=\"http://www.springframework.org/schema/data/repository\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/repository\n        http://www.springframework.org/schema/data/repository/spring-repository.xsd\">\n      <repository:jackson2-populator locations=\"classpath:data.json\" />\n    </beans>\n```\n\n这样的声明可以让`data.json`文件可以被一个Jackson的`ObjectMpper`读取和反序列化.\n\nJSON将要解析的对象类型由检查JSON文档的`_class`属性决定.基本组件将最终选择合适的仓库去处理反序列化的对象.\n\n要使用XML定义数据填充仓库,你可以使用`unmarshaller-populator`元素.你配置它使用Spring OXM提供给你的XML装配选项.在Spring reference documentation查看更多细节.\n\n例38 声明一个装配仓库填充器(使用JAXB)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:repository=\"http://www.springframework.org/schema/data/repository\"\n      xmlns:oxm=\"http://www.springframework.org/schema/oxm\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/repository\n        http://www.springframework.org/schema/data/repository/spring-repository.xsd\n        http://www.springframework.org/schema/oxm\n        http://www.springframework.org/schema/oxm/spring-oxm.xsd\">\n      <repository:unmarshaller-populator locations=\"classpath:data.json\"\n        unmarshaller-ref=\"unmarshaller\" />\n      <oxm:jaxb2-marshaller contextPath=\"com.acme\" />\n    </beans>\n```\n\n### 4.7.4 遗留web支持\n\n**Spring MVC的实体类绑定**\n\n如果正在开发Spring MVC web应用,你通常必须从URL中解析实体类的id.默认的,你的任务是转化请求参数或URL参数到实体类并将它移交给下面或直接在实体上操作业务逻辑.这看起来像下面这样:\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  private final UserRepository userRepository;\n  \n  @Autowired\n  public UserController(UserRepository userRepository) {\n    Assert.notNull(repository, \"Repository must not be null!\");\n    this.userRepository = userRepository;\n  }\n\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") Long id, Model model) {\n    // Do null check for id\n    User user = userRepository.findOne(id);\n    // Do null check for user\n    model.addAttribute(\"user\", user);\n    return \"user\";\n  }\n}\n```\n\n首先你为每个控制器定义一个依赖的仓库来查找它们分别管理的实体.查询实体也是样板,因为它总是一个`findOne(...)`调用.幸运的Spring提供了方法来注册自定义组件,允许一个String值转换到一个属性类型.\n\n**属性编辑**\n\nSpring3.0之前Java`PropertyEditors`被使用.为了集成这些,Spring Data提出一个`DomainClassPropertyEditorRegistrar`来查询所有注册到`ApplicatonContext`的Spring Data仓库和一个定制的`PropertyEditor`来管理实体类.\n\n```xml\n<bean class=\"….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\">\n  <property name=\"webBindingInitializer\">\n    <bean class=\"….web.bind.support.ConfigurableWebBindingInitializer\">\n      <property name=\"propertyEditorRegistrars\">\n        <bean class=\n          \"org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar\" />\n      </property>\n    </bean>\n  </property>\n</bean>\n```\n\n如果你已经像上面这样配置Spring MVC,你可以向下面这样配置你的控制器,从而减少不清晰和样板式的代码\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") User user, Model model) {\n    model.addAttribute(\"user\", user);\n    return \"userForm\";\n  }\n}\n```\n\n","source":"_posts/【翻译】SpringData官方文档第四章.md","raw":"---\ntitle: 【翻译】SpringData官方文档第四章\ndate: 2016-11-27\ntags:\n  - 翻译\ncategories: 翻译\n---\n说明：本翻译[4.6](http://ifeve.com/repositories-custom-implementations/)和[4.7](http://ifeve.com/spring-data-4-7/)段发布在[并发编程网](http://ifeve.com/),其他段落为了熟悉上下文而翻译，没有精校。首次参与翻译任务，翻译的不好请指正。\n\n---\n\n# 第四章 使用Spring Data Repositories\n\nSpring Data repository abstraction目的是为了显著的简化必要的样板式代码来为多种持久化数据存储实现数据层。\n\n> 重要\n>\n> 本章解释Spring Data repositories核心的概念和接口。Spring Data repository documentation 与 你的模块。本章这些信息是从Spring Data Commons模块获取的。它使用了JPA模块的配置和代码示范,命名引用覆盖XML配置，它支持所有的Spring Data模块支持的repository API，Repository查询关键字覆盖被repository 接口一般的关键字查询方法。你的模块特性的细节信息，查询文档对应模块。\n>\n\n## 4.1 核心概念\n\nSpring Data repository抽象接口的核心是`Repository`（可能没有那么惊喜）。它需要管理实体类以及实体类的id作为参数。此接口主要用作是获取要使用的类型接口并帮助扩展这个接口。\n\n`CrudRepository`为被管理的实体类提供复杂CRUD功能。\n\n## 4.2 查询方法\n\n标准的CRUD功能repositories通常有查询底层数据库。\n\n在Spring Data中，分词声明这些查询变成了四个步骤的过程：\n\n1. 声明一个接口继承`Repository`或者它的一个子类，并且指定要被处理的实体类和Id类型。\n\n   ```java\n   interface PersonRepository extends Repository<Person, Long> { … }\n   ```\n\n\n1. 在接口中声明查询方法。\n\n   ```java\n   interface PersonRepository extends Repository<Person, Long> {\n     List<Person> findByLastname(String lastname);\n   }\n   ```\n\n\n1. 创建Spring生成代理实现上面接口，通过JavaConfig：\n\n   ```java\n   import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n   @EnableJpaRepositories\n   class Config {}\n   ```\n\n   或者通过XML配置：\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xmlns:jpa=\"http://www.springframework.org/schema/data/jpa\"\n   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n   http://www.springframework.org/schema/beans/spring-beans.xsd\n   http://www.springframework.org/schema/data/jpa\n   http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\">\n   <jpa:repositories base-package=\"com.acme.repositories\"/>\n   </beans>\n   ```\n\n   这个实例中使用了JPA命名空间。\n\n   如果你为其他存储使用repository接口，你需要修改来适应你的存储模块命名空间的声明，大概就是替换jpa为期望的，例如mongodb。\n\n   当然，注意JavaConfig并没有明确配置一个包默认使用注解的包。\n\n   为了定制包被扫描可以使用数据存储注解`@Enable`的一个属性`basePackage`。\n\n\n1. 获得repository实例注入并使用。\n\n   ```java\n   public class SomeClient {\n     @Autowired\n     private PersonRepository repository;\n     public void doSomething() {\n       List<Person> persons = repository.findByLastname(\"Matthews\");\n     }\n   }\n   ```\n\n\n以下部分详细说明每个步骤。\n\n## 4.3 定义repository接口\n\n第一步定义一个实体类依赖repository接口。\n\n这个接口必须继承`Repository`接口并且指定实体类型和Id类型。\n\n如果你希望实体类型拥有CRUD方法，将`Repository`接口替换成继承`CrudRepository`。\n\n### 4.3.1 小巧repository定义 \n\n一般情况下，你的repository接口应该继承`Repository`，`CrudRepository`或者`PagingAndSortingRepository`\n\n除此之外,如果你不想继承Spring Data接口,你也可以使用`@Repository`注解定义你的接口\n\n继承`CrudRepository`提供了一系列完整的方法来操纵你的实体.\n\n如果你希望选择方法,简单的从`CurdRepository`复制你希望获得的方法到你的`Repository`\n\n> 注意\n>\n> 注意这允许你定义你自己的抽闲建立在Spring Data Repositories功能.\n\n例5.有选择的展现`CRUD`方法\n\n```java\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends Repository<T, ID> {\n  T findOne(ID id);\n  T save(T entity);\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  User findByEmailAddress(EmailAddress emailAddress);\n}\n```\n\n这是第一步你定义一个通用的基本接口,接口供你所有的实体repositories使用并提供`findOne()`和`save()`方法\n\n这些方法会被转发到你选择的Spring Data提供的基本repository实现,例如JPA`SimpleJpaRepository`,因为他们匹配`CrudRepository`的方法签名.\n\n因此`UserPepository`现在可以保存用户,查找唯一用户根据id,并且触发一个查询去查找`Users`根据他们的邮箱地址\n\n> 注意\n>\n> 注意,中间的repository接口使用了注解`NoRepositoryBean`.\n>\n> 对所有Spring Data在运行时不需要生成实例的repository接口,确保你为他们添加了注解.\n\n### 4.3.2 在多个Spring Data模块使用Repositories\n\n在你的应用中使用唯一的Spring Data模块,所有repository接口定义范围限制在Spring Data模块.\n\n有时候应用需要使用不止一个Spring Data模块.\n\n这种情况下,需要repository定义在持久化技术之间有所区别.\n\n在class path发现多个repository工厂时,Spring Data严格检测repository配置模块.\n\n在repository或者实体类严格配置需要得细节以决定Spring Data模块绑定一个repository的定义:\n\n1. 如果repository定义继承模块特殊的repository,那么对Spring Data模块这是一个有效的备选.\n\n\n1. 如果实体类被模块特有的注解类型注解,那么对Spring Data模块这是一个有效的备选.\n\n   Spring Data模块接收第三方注解(例如 JPA的`@Entity`)或者提供自己的注解例如`@Document`为Spring Data MongoDB/Spring Data Elasticsearch.\n\n\n例6.使用模块特有的接口定义Repository\n\n```java\ninterface MyRepository extends JpaRepository<User, Long> { }\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends JpaRepository<T,ID{\n  …\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  …\n}\n```\n\n`MyRepository`和`UserRepository`继承`JpaRepository`在他们类型层级.他们有效的表示了Spring Data JPA模块.\n\n例7.使用通用的接口定义`Repository`.\n\n```java\ninterface AmbiguousRepository extends Repository<User, Long> {\n  …\n}\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID extends Serializable> extends\n  CrudRepository<T,ID> {\n  …\n}\n\ninterface AmbiguousUserRepository extends MyBaseRepository<User, Long> {\n  …\n}\n```\n\n`AmbiguousRepository`和`AmbiguousUserRepository`在它们继承体系里只继承了`Repository`和`CrudRepository`.使用唯一的Spring Data模块是这是完成正确的,多个模块不能识别`Repository`到底绑定哪个Spring Data.\n\n例8.使用注解配合实体类定义`Repositor`\n\n```java\ninterface PersonRepository extends Repository<Person, Long> {\n  …\n}\n\n@Entity\npublic class Person {\n  …\n}\n\ninterface UserRepository extends Repository<User, Long> {\n  …\n}\n\n@Document\npublic class User {\n  …\n}\n```\n\n`PersonRepository`引用使用了JPA的注解`@Entity`进行注解的`Person`,所以这个repository明确的属于Spring Data JPA.`UserRepository`使用了Spring Data MongoDB的注解`@Document`进行注解.\n\n例9.使用混合注解配合实体类定义`Repositor`\n\n```java\ninterface JpaPersonRepository extends Repository<Person, Long> {\n  …\n}\n\ninterface MongoDBPersonRepository extends Repository<Person, Long> {\n  …\n}\n\n@Entity\n@Document\npublic class Person {\n  …\n}\n```\n\n这个示例展示实体类同时使用JPA和Spring Data MongoDB注解.\n\n这里定义了两个repository,`JpaPersonRepository`和`MongoDBPersonRepository`.\n\n一个被JPA使用,另一个被MongoDB使用.\n\nSpring Data不再能告诉repository区分,这将导致不清晰的行为\n\n\"使用模块特有的接口定义Repository\"和\"使用注解配合实体类定义`Repositor`\"都使用了严格的repository配置为一个特定的Spring Data模块识别可选的repository\n\n\n使用多种持久化技术特定的注解在同一个实体类上可能在锅中持久化技术上重用了实体类,但是这样做Spring Data将不能确定为repository绑定唯一的模块\n\n最后一种方式区分repository是划分repository的基本包.\n\n\n基本包定义起始点是扫描repository接口定义,这意味着在合适的包定义repository.\n\n默认的,注解配置使用类配置的包\n\n基于XML基本配置在这里.\n\n例10.注解配置基本包\n\n```java\n@EnableJpaRepositories(basePackages = \"com.acme.repositories.jpa\")\n@EnableMongoRepositories(basePackages = \"com.acme.repositories.mongo\")\ninterface Configuration { }\n```\n\n\n\n## 4.4 Defining query methods\n\n## 4.4 定义查询方法\n\nrepository代理有两种方式获得通过方法名获得指定查询.可以通过方法名直接获得查询,或者手动定义查询.有可用的选项定义在实际的存储.这有一些策略决定实际查询如何被创建.让我们一些看看可用的选项.\n\n### 4.4.1 Query lookup strategies\n\n下面这些repository基本组件的决定查询可用的策略.你可以配置策略,在XML配置中通过命名空间`query-look-strategy`属性或者在Java配置中通过启用${store} Repository的属性注解`queryLookupStrategy`.一些策略可能不能支持特定的数据库.\n\n- CREATE 试图通过方法名构建一个指定查询.一般处理是从方法名移除一系列给定的前缀并解析方法其他部分.更多查询构建信息阅读Query creation.\n- USE_DECLARED_QUERY试图查找一个准确的查询,并在找不到时抛出一个异常.查询可以被通过注解定义或者其它方式定义.查询特殊存储的文档了解存储的可用选择.如果repository基本组件在启动时不能为方法找到一个准确的查询,将会失败\n- CREATE_IF_NOT_FOUND(默认)联合了CREATE和USE_DECLARED_QUERY.首先查找一个准确查询,如果没有找到,创建一个定制方法基于名字的查询.这是默认的查询策略,因此如果你没有做任何明确配置.它允许根据方法名快速查询定义,而且定制查询根据需要引入声明的查询.\n\n\n### 4.4.2 查询创建\n\n建成Spring Data repository基本组件的查询构建机制有用的构建了repository所有实体类的约束查询.\n\n这个机制分隔方法前缀`find...By`,`read...By`,`query...By`,`count...By`以及`get...By`,并解析其他部分.这个引入条款可以表达包含的特性例如`Distinct`,来设置明确的标志在要生成的查询上.然而,第一个by扮演了分解符来指明真实条件的起始.分词在一个非常基本的水平,你可以在实体属性上定义条件并且连接使用and或or连接他们.\n\n例11.来自方法名的查询创建\n\n```java\npublic interface PersonRepository extends Repository<User, Long> {\n  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String\n                                             lastname);\n  // Enables the distinct flag for the query\n  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String\n                                                       firstname);\n  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String\n                                                       firstname);\n\n  // Enabling ignoring case for an individual property\n  List<Person> findByLastnameIgnoreCase(String lastname);\n  // Enabling ignoring case for all suitable properties\n  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String\n                                                       firstname);\n  // Enabling static ORDER BY for a query\n  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);\n \n  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);\n}\n```\n\n解析方法的实际结果取决于你创建查询的持久化存储.然而,这有些问题需要注意:\n\n- 表达式通常串行的连接属性的遍历与操作符.你可以使用and和or连接属性表达式.你也可以给属性表达式使用操作符,例如between,lessThan,granterThan,like.你可以使用的表达式操作符有between,LessThan,GreaterThan,Loke.被支持的操作符根据多样的数据库决定,因此查询你引用文档的恰当部分.\n- 方法解析支持为单独属性设置一个IgnoreCase标志(例如,findByLastnameIgnoreCase(...))或者为所有属性都支持忽略情况(通常是String情形,例如,findByLastnameAndFirstnameAllIgnoreCase(…)).忽略情况是否被支持由多样的数据库决定，所以具体存储查询方法在引用文档查询相关章节.\n- 你可以为查询方法引用的属性提供静态排序连接OrderBy子句并且提供排序方向(Asc或Desc).为创建一个查询方法支持动态排序,查看特殊参数处理.\n\n\n\n### 4.4.3 属性表达式\n\n属性表达式可以只为管理的实体类的直接属性使用，就像前面所展示的那样。查询常见时你已经确认解析的字段是管理的实体类的一个字段.然而,你也可以通过最近的字段定义一个约束.假设`Person`的`Address`有一个`ZipCode`字段.这种情况一个方法如果这样命名:\n\n```java\nList<Person> findByAddressZipCode(ZipCode zipCode);\n```\n\n创建属性遍历`x.address.zipCode`.决策算法从把全部(`AddressZipCode`)作为属性开始并且检查实体类依此命名的属性(小写开头).如果算法成功了,就是用这个属性.否则,算法将源码部分驼峰式大小写从右侧头部到尾巴分隔,并试图找到相应的属性,在我们的例子中,`AddressZip`和`Code`.如果从头部找到一个属性,算法将在这里生成树处理后面的部分,使用描述的方式分隔.如果第一个分隔没有匹配到,算法移动分割点到左侧继续(`Address`,`ZipCode`).\n\n这在大多数情况都可以使用,但也可能选择错误的属性.假设`Person`类也有一个`addressZip`属性.算法将匹配第一个匹配的,本质上选择了错误属性,最终失败(伴随的`addressZip`类型没有属性`code`).\n\n没了解决这种起义,你可以在方法名称内使用`_`手动的定义遍历点.所以我们的方法名称最终像这样:\n\n```java\nList<Person> findByAddress_ZipCode(ZipCode zipCode);\n```\n\nAs we treat underscore as a reserved character we strongly advise to follow standard Java naming\nconventions (i.e. not using underscores in property names but camel case instead) \n\n我们对待下划线当做一个保留关键字,我们强力建议遵循标准Java命名规范(例如,使用驼峰命名而不是下划线命名属性名称)\n\n### 4.4.4 特殊参数处理\n\n处理你查询中的参数,你可以定义简单的方法参数像上面的示例中.处理之外基本组件可以识别出某些特殊类型例如`Pageable`和`Sort`用来动态的编码和排序你的查询.\n\n例12.在查询方法使用`Pageable`,`Slice`和`Sort`\n\n```java\nPage<User> findByLastname(String lastname, Pageable pageable);\nSlice<User> findByLastname(String lastname, Pageable pageable);\nList<User> findByLastname(String lastname, Sort sort);\nList<User> findByLastname(String lastname, Pageable pageable);\n```\n\n第一个方法允许你在通过一个`org.springframework.data.domain.Pageable`实例在查询方法中动态添加分页信息在你的静态定义查询中.一个`Page`清楚数据的全部数量和页面总数.它是通过触发计数的基础设施查询计算总数。这个代价可能是昂贵的具体取决于所使用的存储,可以用`Slice`代替.一个`Slict`只知道下一个`Slice`可到到哪里,当运行在一个大的结果集上时这可能已经足够了.排序选项也通过`Pageable`实例处理.如果你只需要排序,简单起见添加`org.springframework.data.domain.Sort`参数在你的方法.如你所见,简单返回一个列表.在这种情况下,额外元数据构建实际的`Page`实例将不会被创建(反过来这意味着,没有发出额外的统计查询所必须的)简单约束只在给定的范围内查询.\n\n> 注意\n>\n> 为了尽早得到你查询了多少页,你必须出发一个格外统计查询.默认的,这个查询你实际触发的查询调用.\n\n### 4.4.5 限制查询结果\n\n查询方法的结果可以通过关键`first`或者`top`限制,可以交换使用.一个可选的数值可以追加在top/first来指定返回的最大结果集.如果数字缺失,假定结果集大小是1.\n\n例13.查询中使用Top和First限制结果大小\n\n```java\nUser findFirstByOrderByLastnameAsc();\nUser findTopByOrderByAgeDesc();\nPage<User> queryFirst10ByLastname(String lastname, Pageable pageable);\nSlice<User> findTop3ByLastname(String lastname, Pageable pageable);\nList<User> findFirst10ByLastname(String lastname, Sort sort);\nList<User> findTop10ByLastname(String lastname, Pageable pageable);\n```\n\n限制表达式也支持Distinct关键字.此外，对于将结果集设置为一个实例的查询，支持将结果包装到一个`Optional`.如果应用分页或分片限制查询分页(并且计算可用的页数)那么这可以应用limited结果.\n\n> 注意\n>\n> 请注意，限制结果结合使用`Sort`的动态排序的结果允许参数可以表示“k”最小的查询方法以及“K”的查询方法最大的元素。\n\n### 4.4.6 流式处理结果\n\n方法查询结果可以通过使用java 8`Stream<T>`逐步处理。\n\n特定的方法用来表示流而不是简单的包装查询结果在一个`Stream`数据存储\n\n例14 一个用java流8`Stream<T>`查询结果\n\n```java\n@Query(\"select u from User u\")\nStream<User> findAllByCustomQueryAndStream();\n\nStream<User> readAllByFirstnameNotNull();\n\n@Query(\"select u from User u\")\nStream<User> streamAllPaged(Pageable pageable);\n```\n\n> 注意\n>\n> 一个`Stream`潜在的包装底层数据存储在页数的资源中,因此使用完毕必须关闭.你可以使用`close()`方法手动关闭`Stream`或者使用一个Java7的try_with-resources块.\n\n```java\ntry(Stream<User> stream = repository.findAllByCustomQueryAndStream()) {\n  stream.forEach(...);\n}\n```\n\n### 4.4.7 异步查询结果\n\nRepository查询可以使用`Spring's asynchronous method execution capacity`执行异步.这意味着方法可以一执行立即返回,真实的查询执行发生在任务提交到一个Spring TaskExecutor.\n\n```java\n@Async\nFuture<User> findByFirstname(String firstname);\n\n@Async\nCompletableFuture<User> findOneByFirstname(String firstname);\n\n@Async\nListenableFuture<User> findOneByLastname(String lastname);\n```\n\n1. 使用`java.util.concurrent.Future`作为返回类型\n2. 使用一个Java8`java.util.current.CompletableFuture`作为返回类型\n3. 使用一个`org.springframework.util.concurrent.ListenableFuture`作为返回类型\n\n## 创建repository实例\n\n这个章节你创建实例和bean定义为repository接口定义.方法之一是手动的支持repository使用包含各个Spring Data模块的Spring命名空间装载,然而我们一般推荐使用Java配置的方法配置.\n\n### 4.5.1 XML配置\n\n每个Spring Data module包含一个repository 元素,这可以让你简单的定义一个基本包,Spring为你扫描它.\n\n例16 通过XML启用Spring Data repositories\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans:beans xmlns:beans=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns=\"http://www.springframework.org/schema/data/jpa\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/jpa\n        http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\">\n      <repositories base-package=\"com.acme.repositories\" />\n    </beans:beans>\n```\n\n在前面的实例中,让Spring扫描`com.acme.repositories`包和它的子包里继承`Repository`的接口或者它的子接口.找到的每个接口,继承组件注册持久化技术的`FactoryBean`来创建合适的代理处理执行查询方法.每个bean被注册在一个接口名称确定的bean name下,所以一个叫`UserRepository`将注册`userRepository`.基本包属性允许通配符,所以你可以定义一个规则扫描包.\n\n**使用过滤**\n\n默认的基本组件选取所有在配置的基本包下继承了持久化技术`Repositpry`接口以及子接口\n\n并且为他们创建一个bean实例.然而,你可能希望更细粒度的控制哪个接口bean实例被创建.为了实现这个你可以在`<repository/>`中使用`<include-filter/>`和`<exclude-filter/>`元素.语义完全等同于Spring的上下文命名空间中的元素.更多细节,查看他们的元素`Spring reference documentation`\n\n例如，要将某些确定的接口排除实例化为repository，可以使用以下配置:\n\n例17. 使用exclude-filter元素\n\n```java\n<repository base-package=\"com.acme.repositories\">\n  <context:exclude-filter type=\"regex\" expression=\".*SomeRepository\" />\n</repositories>\n```\n\n这个示例从待实例化对象中排除所有以SomeRepository结尾的接口.\n\n### 4.5.2 JavaConfig\n\nrepository基础组件也可以使用一个存储的特殊的`@Enable${store}Repositories`注解在一个JavaConfig类上.入门介绍Spring容器Java基本Spring容器查看文档:`JavaConfig in the Spring reference documentaional`\n\n一个简单配置启用Spring Data repositories像这样:\n\n例18. repository配置基于简单注解\n\n```java\n@Configuration\n@EnableJpaRepositories(\"com.acme.repositories\")\nclass ApplicationConfiguration {\n  @Bean\n  public EntityManagerFactory entityManagerFactory() {\n    // …\n  }\n}\n```\n\n> 注意\n>\n> 示例使用了JPA特有的注解,根据你使用的存储模块决定实际如何替换.示例定义`EntityManagerFactory`bean.查阅具体存储的配置\n\n### 4.5.3 单独使用\n\n你也可以在Spring容器之外使用repository基础组件,例如在CDI环境.你仍然需要一些Spring库在你的classpath中,但是你可以以编程的方式启动.repository包装持久化技术支持的Spring Data模块提供RepositoryFactory,你可以向下面这样使用:\n\n例19. repository工厂单独使用\n\n```java\nRepositoryFactorySupport factory = … // Instantiate factory here\nUserRepository repository = factory.getRepository(UserRepository.class);\n```\n\n## 4.6 定制Spring Data仓库实现\n\n时常有必要为一少部分仓库方法提供一个定制的实现.Spring数据存储库很容易允许您提供自定义存储库代码并将其与通用CRUD集成抽象和查询方法功能整合.\n\n### 4.6.1 为单独仓库添加定制行为\n\n为了定制功能丰富一个仓库,你首先为定制功能定义一个接口和实现.使用你提供的仓库接口来继承自定义接口.\n\n例20. 定制仓库功能的接口\n\n```java\ninterface UserRepositoryCustom {\n  public void someCustomMethod(User user);\n}\n```\n\n例21.定制功能的实现\n\n```java\nclass UserRepositoryImpl implements UserRepositoryCustom {\n  public void someCustomMethod(User user) {\n    // Your custom implementation\n  }\n}\n```\n\n> 注意\n>\n> 类可以被找到最重要的点是名字以Impl为后缀区别于仓库的核心接口(见下文)\n\n实现的本身没有依赖Spring Data,可以是一个标准的Spring bean.所以你可以使用标准的依赖注入行为给其他bean注入引用,像`JdbcTemplate`,切面的一部分等等.\n\n例22 修改你基本的仓库接口\n\n```java\ninterface UserRepository extends CrudRepository<User, Long>, UserRepositoryCustom {\n  // Declare query methods here\n}\n```\n\n让你的标准仓库接口继承定制的.这样做结合了CRUD和定制功能并使其可用于客户端.\n\n**配置**\n\n如果你使用命名空间配置,仓库基本组件扫描类所在包,根据扫描结果尝试自动定制实现.\n\n这些类需要遵循命名规范:给仓库接口名添加命名空间元素属性`repositoryimpl-postfix`.默认的后缀是`Impl`\n\n例23. 配置示例\n\n```xml\n<repositories base-package=\"com.acme.repository\" />\n<repositories base-package=\"com.acme.repository\" repository-impl-postfix=\"FooBar\"/>\n```\n\n第一个配置示例将查实查找一个类`com.acme.repository.UserRepositoryImpl`来作为定制藏局实现.然而第二个示例将尝试查找`com.acme.repository.UserRepositoryFooBar `.\n\n\n**手动指定**\n\n上面的方法可以正常工作,只有当你定制实现使用注解配置和自动注入,这将与其他Spring bean一样被对待.如果你定制的实现需要特殊处理,你可以像描述的简单定义一个bean并且命名它.基本组件将通过名称引用手动定义的bean定义而不是它自己创建一个.\n\n例24.手动指定定制实现\n\n```xml\n<repositories base-package=\"com.acme.repository\" />\n<beans:bean id=\"userRepositoryImpl\" class=\"…\">\n  <!-- further configuration -->\n</beans:bean>\n```\n\n### 4.6.2为所有仓库添加定制行为\n\n当你希望把一个单独的方法添加到你所有的仓库接口中时,上面的方法就不可行了.为了添加定制到所有的仓库,你首先添加一个中间接口来定义共享的行为.\n\n例25 定义共享定制行为接口\n\n```java\n@NoRepositoryBean\npublic interface MyRepository<T, ID extends Serializable>\n  extends PagingAndSortingRepository<T, ID> {\n  void sharedCustomMethod(ID id);\n}\n```\n\n现在你独立的仓库接口将继承这个中间接口而不是`Repository`接口来包含功能的定义.接下来创建一个中间接口的实现继承持久化具体仓库的基本类.这个类后面将作为仓库代理的基本类.\n\n例26 定制仓库基本类\n\n```java\npublic class MyRepositoryImpl<T, ID extends Serializable>\n  extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {\n  \n  private final EntityManager entityManager;\n  \n  public MyRepositoryImpl(JpaEntityInformation entityInformation,\n                          EntityManager entityManager) {\n    super(entityInformation, entityManager);\n    // Keep the EntityManager around to used from the newly introduced methods.\n    this.entityManager = entityManager;\n  }\n  \n  public void sharedCustomMethod(ID id) {\n    // implementation goes here\n  }\n}\n```\n\n> 警告\n>\n> 这个类需要有一个构造方法调用父类具体存储仓库工厂实现.万一仓库基础类有多个构造,覆盖包括一个`EntityInformation `加上存储具体基本组件对象(例如一个`EntityManager `或者模板类)\n\nSpring`<repository/>`命名空间下的默认行为为所有接口提供一个实现.这意味着如果处于其当前状态，`MyRepository`的实现实例将由Spring创建.这当然不是被期望的,它只是作为一个用来定义实体的 `Repository`和真实仓库接口的中间接口.为了排除一个继承`Repository`的接口被当做一个仓库接口实例化,你可以给它使用`@NoRepositoryBean`(像上面)或者把它从配置中`base-package`移除.\n\n最后一步是让Spring Data基本组件识别到定制的仓库基本类.在JavaConf使用注解`@Enable...Repository`的属性`repositoryBaseClass`完成:\n\n例27 使用JavaConfig配置一个定制仓库基本类\n\n```java\n@Configuration\n@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)\nclass ApplicationConfiguration { … }\n```\n\n类似的属性在XML命名空间中也可以找到.\n\n例28 使用XML配置一个定制仓库基本类\n\n```xml\n<repositories base-package=\"com.acme.repository\"\n              base-class=\"….MyRepositoryImpl\" />\n```\n\n## 4.7 Spring Data扩展\n\n这部分说明Spring Data一系列的扩展功能,可以使Spring Dta使用多样的上下文.目前大部分集成是针对Spring MVC.\n\n### 4.7.1 Querydsl扩展\n\nQuerydsl是一个框架,通过它的流式API构建静态类型的SQL类查询.\n\n多个Spring Data模块通过`QueryDslPredicateExecutor `与Querydsl集成.\n\n例29 QueryDslPredicateExecutor接口\n\n```java\npublic interface QueryDslPredicateExecutor<T> {\n  T findOne(Predicate predicate); ①\n    Iterable<T> findAll(Predicate predicate); ②\n    long count(Predicate predicate); ③\n    boolean exists(Predicate predicate); ④\n    // … more functionality omitted.\n}\n```\n\n① 查询并返回一个匹配`Predicate `的单例实体\n\n②查询并返回所有匹配`Predicate`的实体\n\n③ 返回匹配`Predicate`的实体数量\n\n④  返回是否存在一个匹配`Predicate`的实体\n\n为了简单的使用Querydsl功能,在你的仓库接口继承`QueryDslPredicateExecutor`.\n\n例30 在仓库集成QueryDsl\n\n```java\ninterface UserRepository extends CrudRepository<User, Long>,\n  QueryDslPredicateExecutor<User> {\n}\n```\n\n像上面这样就可以使用Querydsl的`Predicate`书写类型安全的查询\n\n```java\nPredicate predicate = user.firstname.equalsIgnoreCase(\"dave\")\n  .and(user.lastname.startsWithIgnoreCase(\"mathews\"));\nuserRepository.findAll(predicate);\n```\n\n### 4.7.2 Web支持\n\n> 注意\n>\n> 本节包含Spring Data Web支持的文档是在1.6范围内的Spring Data Commons实现的.因为支持新引入的内容改变了很多东西，我们保留了旧行为的文档在\"遗留Web支持\"部分.\n>\n\n如果模块支持仓库编程模型，那么Spring Data模块附带了各种Web模块支持.Web关联的东西需要Spring MVC的JAR包位于classpath路径下,它们中有些甚至提供了Spring HATEOAS集成.一般情况,集成方式支持使用`@EnableSpringDataWebSupport`注解在你的JavaConfig配置类.\n\n例31 启用Spring Data web支持\n\n```java\n@Configuration\n@EnableWebMvc\n@EnableSpringDataWebSupport\nclass WebConfiguration {}\n```\n\n`@EnableSpringDataWebSupport`注解注册了一些组件，我们将在稍后讨论.注解还将在类路径上检测Spring HATEOAS，如果才在将为其注册集成组件.\n\n作为可选项,如果你使用XML配置,注册`SpringDataWebSupport`或者`HateoasWareSpringDataWebSupport`作为Spring bean:\n\n例32 用XML启用Spring Data web支持\n\n```xml\n<bean class=\"org.springframework.data.web.config.SpringDataWebConfiguration\" />\n<!-- If you're using Spring HATEOAS as well register this one *instead* of the\nformer -->\n<bean class= \"org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration\" />\n```\n\n**基本Web支持**\n\n上面展示的的配置设置将注册几个基本组件：\n\n- 一个`DomainClassConverter`启用Spring MVC来根据请求参数或路径变量管理仓例实体类的实例\n- `HandlerMethodArgumentResolver`实现让Spring MVC从请求参数解析Pageable和Sort实例.\n\n**实体类转换**\n\n`DomainClassConverter`允许你在Spring MVC控制器方法签名中直接使用实体类型,因此你不必手动的通过仓库查询实例:\n\n例33 一个Spring MVC控制器在方法签名中使用实体类型\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") User user, Model model) {\n    model.addAttribute(\"user\", user);\n    return \"userForm\";\n  }\n}\n```\n\n如你所见,方法直接接收一个User实例并没有更进一步的查询是否必要.实例可以通过Spring MVC将路径变量转换为实体类的id类型并最终通过在实体类型注册的仓库实例上调用`findOne(...)`访问实例转换得到.\n\n> 注意\n>\n> 当前的仓库必须实现`CrudRepository`做好准备被发现来进行转换.\n\n**为了分页和排序分解方法参数**\n\n上面的配置片段还注册了一个`PageableHandlerMethodArgumentResolver`和一个`SortHandlerMethodArgumentResolver`实例.注册使得Pageable和Sort成为有效的控制器方法参数.\n\n例34 使用Pageable作为控制器方法参数\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @Autowired UserRepository repository;\n  @RequestMapping\n  public String showUsers(Model model, Pageable pageable) {\n    model.addAttribute(\"users\", repository.findAll(pageable));\n    return \"users\";\n  }\n}\n```\n\n这个方法签名将使Spring MVC尝试使用下面的默认配置从请求参数中转换一个Pageable实例:\n\n表1 请求参数转换Pageable实例\n\n| 参数   | 说明                                       |\n| ---- | ---------------------------------------- |\n| page | 要检索的页面,索引为0,默认为0                         |\n| size | 要检索的页面大小,默认20                            |\n| sort | 被排序的属性应以格式`property,property(, ASC\\|DESC)`表示.默认生序排序,如果你希望改变排序顺序,则使用多个排序参数,例如?sort=firstname&sort=lastname,asc |\n\n为了定制行为,可以继承`SpringDataWebConfiguration`或者启用等效的HATEOAS并覆盖`pageableResolver()`或`sortResolver()`方法并导入你的自定义配置文件替代@Enable-注解.\n\n有一种情况你需要多个`Pageable`或`Sort`实例从请求转换(例如处理多个表单),你可以使用Spring的`@Qualifier`注解来互相区别.请求参数必须以`${qualifier}为`前缀.这样一个方法的签名像这样:\n\n```java\npublic String showUsers(Model model, \n                        @Qualifier(\"foo\")Pagebale first, \n                        @Qualifier(\"bar\") Pageable second) {\n  ...\n}\n```\n\n你必须填充foo_page和bar_page等.\n\n默认的`Pageable`在方法中处理等价于一个`new PageRequest(0, 20)`,但是可以使用`@PageableDefaults`注解在`Pageable`参数上定制.\n\n**Hypermedia支持分页**\n\nSpring HATEOAS包装了一个代表模型的类`PageResources` ,\n\n它可以使用Page实例包装必要的Page元数据内容作为连接让客户端导航页面.一个页面到一个`PageResources`的转换被Spring HATEOAS的`ResourceAssembler`接口实现`PagedResourcesAssembler `来完成.\n\n例35 使用一个PagedResourcesAssembler作为控制器方法参数\n\n```java\n@Controller\nclass PersonController {\n  @Autowired PersonRepository repository;\n  @RequestMapping(value = \"/persons\", method = RequestMethod.GET)\n  HttpEntity<PagedResources<Person>> persons(Pageable pageable,\n                                             PagedResourcesAssembler assembler) {\n    Page<Person> persons = repository.findAll(pageable);\n    return new ResponseEntity<>(assembler.toResources(persons), HttpStatus.OK);\n  }\n}\n```\n\n像上面这样配置将允许`PageResourcesAssembler`作为控制器方法的一个参数.在这调用toResources(...)方法有以下作用:\n\n- `Page`的内容将`PageResources`实例的内容\n- `PageResources`将获得`PageMetadata`实例,该实例由Page和基础的PageRequest中的信息填充\n- `PageResources`获得`prev`和`next`连接,添加这些依赖在页面.这些链接将指向uri方法的调用映射.页码参数根据`PageableHandlerMethodArgumentResolver`添加到参数以在后面被转换.\n\n假设我们有30个Person实例在数据库.你现在可以触发一个GET请求 http://localhost:8080/persons, 你将可以看到类似下面的内容:\n\n```json\n{ \"links\" : [ { \"rel\" : \"next\",\n\"href\" : \"http://localhost:8080/persons?page=1&size=20 }\n],\n\"content\" : [\n… // 20 Person instances rendered here\n],\n\"pageMetadata\" : {\n\"size\" : 20,\n\"totalElements\" : 30,\n\"totalPages\" : 2,\n\"number\" : 0\n}\n}\n```\n\n你可以看到编译生成了正确的URI，并且还会提取默认配置转换参数到即将到来的请求中的`Pageable`.这意味着,如果你改变配置,链接也将自动跟随改变.默认情况下，编译指向控制器执行的方法，但是这可以被一个自定义链接作为基本构建来构成分页的`Link`重载`PagedResourcesAssembler.toResource（...）`方法定制.\n\n**Querydsl web 支持**\n\n那些整合了`QueryDSL`的存储可能从`Request`查询字符串中的属性驱动查询.\n\n这意味着前面例子的查询字符串可以给出`User`的对象\n\n```\n?firstname=Dave&lastname=Matthews\n```\n\n可以被转换为\n\n```java\nQUser.user.firstname.eq(\"Dave\").and(QUser.user.lastname.eq(\"Matthews\"))\n```\n\n使用了`QuerydslPredicateArgumentResolver`.\n\n> 注意\n>\n> 当在类路径上找到Querydsl时，该功能将在@EnableSpringDataWebSupport注解中自动启用\n\n添加一个`@QuerydslPredicate`到一个方法签名将提供一个就绪的`Predicate`,可以通过`QueryDslPredicateExecutor`执行.\n\n> 提示\n>\n> 类型信息通常从返回方法上解析.由于这些信息不一定匹配实体类型,使用`QuerydslPredicate`的`root`属性可能是个好主意.\n\n```java\n@Controller\nclass UserController {\n  @Autowired UserRepository repository;\n  @RequestMapping(value = \"/\", method = RequestMethod.GET)\n  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,\n              Pageable pageable, @RequestParam MultiValueMap<String, String>\n    parameters) {\n        model.addAttribute(\"users\", repository.findAll(predicate, pageable));\n        return \"index\";\n  } \n}\n```\n\n为User转换匹配查询字符串参数的`Predicate`\n\n默认的绑定规则如下:\n\n1. `Object`在简单属性上如同`eq`\n\n2. `Object`在集合作为属性如同`contains`\n\n3. `Collection`在简单属性上如同`in`\n\n\n这些绑定可以通过`@QuerydslPredicate`的`bindings`属性定制或者使用Java8`default methods`给仓库接口添加`QuerydslBinderCustomizer`\n\n```java\ninterface UserReposotory extends CurdRepository<User, String>, \n  QueryDslPredicateExecutor<User>,\n  QuerydslBinderCustomizer<QUser> {\n    @Override\n  \tdefault public void customize(QuerydslBindings bindings, QUser user) {\n      bindings.bind(user.username).first((path, value) -> path.contains(value));\n      bindings.bind(String.class).first((StringPath path, String value) ->\n                                        path.containsIgnoreCase(value));\n      bindings.excluding(user.password);\n  \t}\n  }\n```\n\n1. `QueryDslPredicateExecutor`为`Predicate`提供特殊的查询方法提供入口\n2. 在仓库接口定义`QuerydslBinderCustomizer`将自动注解`@QuerydslPredicate(bindings=...)`\n3. 为`username`属性定义绑定,绑定到一个简单集合\n4. 为`String`属性定义默认绑定到一个不区分大小写的集合\n5. 从`Predicate`移除密码属性\n\n### 4.7.3 仓库填充\n\n如果你使用Spring JDBC模块,你可能熟悉在`DataSource`使用SQL脚本来填充.一个类似的抽象在仓库级别可以使用,尽管它不是使用SQL作为数据定义语言,因为它必须由存储决定.填充根据仓库支持XML(通过Spring的OXM抽象)和JSON(通过Jackson)定义数据.\n\n假设你有一个文件`data.json`内容如下:\n\n例36 JSON定义的数据\n\n```json\n[ { \"_class\" : \"com.acme.Person\",\n     \"firstname\" : \"Dave\",\n      \"lastname\" : \"Matthews\" },\n      { \"_class\" : \"com.acme.Person\",\n     \"firstname\" : \"Carter\",\n      \"lastname\" : \"Beauford\" } ]\n```\n\n你可以容易的根据Spring Data Commons提供仓库的命名空间填充元素填充你的仓库.为了填充前面的数据到你的PersonRepository,像下面这样配置:\n\n例37 声明一个Jackson仓库填充\n\n```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:repository=\"http://www.springframework.org/schema/data/repository\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/repository\n        http://www.springframework.org/schema/data/repository/spring-repository.xsd\">\n      <repository:jackson2-populator locations=\"classpath:data.json\" />\n    </beans>\n```\n\n这样的声明可以让`data.json`文件可以被一个Jackson的`ObjectMpper`读取和反序列化.\n\nJSON将要解析的对象类型由检查JSON文档的`_class`属性决定.基本组件将最终选择合适的仓库去处理反序列化的对象.\n\n要使用XML定义数据填充仓库,你可以使用`unmarshaller-populator`元素.你配置它使用Spring OXM提供给你的XML装配选项.在Spring reference documentation查看更多细节.\n\n例38 声明一个装配仓库填充器(使用JAXB)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:repository=\"http://www.springframework.org/schema/data/repository\"\n      xmlns:oxm=\"http://www.springframework.org/schema/oxm\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/data/repository\n        http://www.springframework.org/schema/data/repository/spring-repository.xsd\n        http://www.springframework.org/schema/oxm\n        http://www.springframework.org/schema/oxm/spring-oxm.xsd\">\n      <repository:unmarshaller-populator locations=\"classpath:data.json\"\n        unmarshaller-ref=\"unmarshaller\" />\n      <oxm:jaxb2-marshaller contextPath=\"com.acme\" />\n    </beans>\n```\n\n### 4.7.4 遗留web支持\n\n**Spring MVC的实体类绑定**\n\n如果正在开发Spring MVC web应用,你通常必须从URL中解析实体类的id.默认的,你的任务是转化请求参数或URL参数到实体类并将它移交给下面或直接在实体上操作业务逻辑.这看起来像下面这样:\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  private final UserRepository userRepository;\n  \n  @Autowired\n  public UserController(UserRepository userRepository) {\n    Assert.notNull(repository, \"Repository must not be null!\");\n    this.userRepository = userRepository;\n  }\n\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") Long id, Model model) {\n    // Do null check for id\n    User user = userRepository.findOne(id);\n    // Do null check for user\n    model.addAttribute(\"user\", user);\n    return \"user\";\n  }\n}\n```\n\n首先你为每个控制器定义一个依赖的仓库来查找它们分别管理的实体.查询实体也是样板,因为它总是一个`findOne(...)`调用.幸运的Spring提供了方法来注册自定义组件,允许一个String值转换到一个属性类型.\n\n**属性编辑**\n\nSpring3.0之前Java`PropertyEditors`被使用.为了集成这些,Spring Data提出一个`DomainClassPropertyEditorRegistrar`来查询所有注册到`ApplicatonContext`的Spring Data仓库和一个定制的`PropertyEditor`来管理实体类.\n\n```xml\n<bean class=\"….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\">\n  <property name=\"webBindingInitializer\">\n    <bean class=\"….web.bind.support.ConfigurableWebBindingInitializer\">\n      <property name=\"propertyEditorRegistrars\">\n        <bean class=\n          \"org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar\" />\n      </property>\n    </bean>\n  </property>\n</bean>\n```\n\n如果你已经像上面这样配置Spring MVC,你可以向下面这样配置你的控制器,从而减少不清晰和样板式的代码\n\n```java\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n  @RequestMapping(\"/{id}\")\n  public String showUserForm(@PathVariable(\"id\") User user, Model model) {\n    model.addAttribute(\"user\", user);\n    return \"userForm\";\n  }\n}\n```\n\n","slug":"【翻译】SpringData官方文档第四章","published":1,"updated":"2017-01-07T06:58:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2ro003rd82eu428ew15","content":"<p>说明：本翻译<a href=\"http://ifeve.com/repositories-custom-implementations/\" target=\"_blank\" rel=\"external\">4.6</a>和<a href=\"http://ifeve.com/spring-data-4-7/\" target=\"_blank\" rel=\"external\">4.7</a>段发布在<a href=\"http://ifeve.com/\" target=\"_blank\" rel=\"external\">并发编程网</a>,其他段落为了熟悉上下文而翻译，没有精校。首次参与翻译任务，翻译的不好请指正。</p>\n<hr>\n<h1 id=\"第四章-使用Spring-Data-Repositories\"><a href=\"#第四章-使用Spring-Data-Repositories\" class=\"headerlink\" title=\"第四章 使用Spring Data Repositories\"></a>第四章 使用Spring Data Repositories</h1><p>Spring Data repository abstraction目的是为了显著的简化必要的样板式代码来为多种持久化数据存储实现数据层。</p>\n<blockquote>\n<p>重要</p>\n<p>本章解释Spring Data repositories核心的概念和接口。Spring Data repository documentation 与 你的模块。本章这些信息是从Spring Data Commons模块获取的。它使用了JPA模块的配置和代码示范,命名引用覆盖XML配置，它支持所有的Spring Data模块支持的repository API，Repository查询关键字覆盖被repository 接口一般的关键字查询方法。你的模块特性的细节信息，查询文档对应模块。</p>\n</blockquote>\n<h2 id=\"4-1-核心概念\"><a href=\"#4-1-核心概念\" class=\"headerlink\" title=\"4.1 核心概念\"></a>4.1 核心概念</h2><p>Spring Data repository抽象接口的核心是<code>Repository</code>（可能没有那么惊喜）。它需要管理实体类以及实体类的id作为参数。此接口主要用作是获取要使用的类型接口并帮助扩展这个接口。</p>\n<p><code>CrudRepository</code>为被管理的实体类提供复杂CRUD功能。</p>\n<h2 id=\"4-2-查询方法\"><a href=\"#4-2-查询方法\" class=\"headerlink\" title=\"4.2 查询方法\"></a>4.2 查询方法</h2><p>标准的CRUD功能repositories通常有查询底层数据库。</p>\n<p>在Spring Data中，分词声明这些查询变成了四个步骤的过程：</p>\n<ol>\n<li><p>声明一个接口继承<code>Repository</code>或者它的一个子类，并且指定要被处理的实体类和Id类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123; … &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在接口中声明查询方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建Spring生成代理实现上面接口，通过JavaConfig：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>或者通过XML配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xmlns:jpa</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/jpa\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></div><div class=\"line\">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">http://www.springframework.org/schema/data/jpa</div><div class=\"line\">http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\"&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jpa:repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repositories\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个实例中使用了JPA命名空间。</p>\n<p>如果你为其他存储使用repository接口，你需要修改来适应你的存储模块命名空间的声明，大概就是替换jpa为期望的，例如mongodb。</p>\n<p>当然，注意JavaConfig并没有明确配置一个包默认使用注解的包。</p>\n<p>为了定制包被扫描可以使用数据存储注解<code>@Enable</code>的一个属性<code>basePackage</code>。</p>\n</li>\n</ol>\n<ol>\n<li><p>获得repository实例注入并使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClient</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"keyword\">private</span> PersonRepository repository;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    List&lt;Person&gt; persons = repository.findByLastname(<span class=\"string\">\"Matthews\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>以下部分详细说明每个步骤。</p>\n<h2 id=\"4-3-定义repository接口\"><a href=\"#4-3-定义repository接口\" class=\"headerlink\" title=\"4.3 定义repository接口\"></a>4.3 定义repository接口</h2><p>第一步定义一个实体类依赖repository接口。</p>\n<p>这个接口必须继承<code>Repository</code>接口并且指定实体类型和Id类型。</p>\n<p>如果你希望实体类型拥有CRUD方法，将<code>Repository</code>接口替换成继承<code>CrudRepository</code>。</p>\n<h3 id=\"4-3-1-小巧repository定义\"><a href=\"#4-3-1-小巧repository定义\" class=\"headerlink\" title=\"4.3.1 小巧repository定义\"></a>4.3.1 小巧repository定义</h3><p>一般情况下，你的repository接口应该继承<code>Repository</code>，<code>CrudRepository</code>或者<code>PagingAndSortingRepository</code></p>\n<p>除此之外,如果你不想继承Spring Data接口,你也可以使用<code>@Repository</code>注解定义你的接口</p>\n<p>继承<code>CrudRepository</code>提供了一系列完整的方法来操纵你的实体.</p>\n<p>如果你希望选择方法,简单的从<code>CurdRepository</code>复制你希望获得的方法到你的<code>Repository</code></p>\n<blockquote>\n<p>注意</p>\n<p>注意这允许你定义你自己的抽闲建立在Spring Data Repositories功能.</p>\n</blockquote>\n<p>例5.有选择的展现<code>CRUD</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">findOne</span><span class=\"params\">(ID id)</span></span>;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">save</span><span class=\"params\">(T entity)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">User <span class=\"title\">findByEmailAddress</span><span class=\"params\">(EmailAddress emailAddress)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是第一步你定义一个通用的基本接口,接口供你所有的实体repositories使用并提供<code>findOne()</code>和<code>save()</code>方法</p>\n<p>这些方法会被转发到你选择的Spring Data提供的基本repository实现,例如JPA<code>SimpleJpaRepository</code>,因为他们匹配<code>CrudRepository</code>的方法签名.</p>\n<p>因此<code>UserPepository</code>现在可以保存用户,查找唯一用户根据id,并且触发一个查询去查找<code>Users</code>根据他们的邮箱地址</p>\n<blockquote>\n<p>注意</p>\n<p>注意,中间的repository接口使用了注解<code>NoRepositoryBean</code>.</p>\n<p>对所有Spring Data在运行时不需要生成实例的repository接口,确保你为他们添加了注解.</p>\n</blockquote>\n<h3 id=\"4-3-2-在多个Spring-Data模块使用Repositories\"><a href=\"#4-3-2-在多个Spring-Data模块使用Repositories\" class=\"headerlink\" title=\"4.3.2 在多个Spring Data模块使用Repositories\"></a>4.3.2 在多个Spring Data模块使用Repositories</h3><p>在你的应用中使用唯一的Spring Data模块,所有repository接口定义范围限制在Spring Data模块.</p>\n<p>有时候应用需要使用不止一个Spring Data模块.</p>\n<p>这种情况下,需要repository定义在持久化技术之间有所区别.</p>\n<p>在class path发现多个repository工厂时,Spring Data严格检测repository配置模块.</p>\n<p>在repository或者实体类严格配置需要得细节以决定Spring Data模块绑定一个repository的定义:</p>\n<ol>\n<li>如果repository定义继承模块特殊的repository,那么对Spring Data模块这是一个有效的备选.</li>\n</ol>\n<ol>\n<li><p>如果实体类被模块特有的注解类型注解,那么对Spring Data模块这是一个有效的备选.</p>\n<p>Spring Data模块接收第三方注解(例如 JPA的<code>@Entity</code>)或者提供自己的注解例如<code>@Document</code>为Spring Data MongoDB/Spring Data Elasticsearch.</p>\n</li>\n</ol>\n<p>例6.使用模块特有的接口定义Repository</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123; &#125;</div><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">T</span>,<span class=\"title\">ID</span></span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>MyRepository</code>和<code>UserRepository</code>继承<code>JpaRepository</code>在他们类型层级.他们有效的表示了Spring Data JPA模块.</p>\n<p>例7.使用通用的接口定义<code>Repository</code>.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AmbiguousRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span></span></div><div class=\"line\">  <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">T</span>,<span class=\"title\">ID</span>&gt; &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AmbiguousUserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>AmbiguousRepository</code>和<code>AmbiguousUserRepository</code>在它们继承体系里只继承了<code>Repository</code>和<code>CrudRepository</code>.使用唯一的Spring Data模块是这是完成正确的,多个模块不能识别<code>Repository</code>到底绑定哪个Spring Data.</p>\n<p>例8.使用注解配合实体类定义<code>Repositor</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Entity</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Document</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>PersonRepository</code>引用使用了JPA的注解<code>@Entity</code>进行注解的<code>Person</code>,所以这个repository明确的属于Spring Data JPA.<code>UserRepository</code>使用了Spring Data MongoDB的注解<code>@Document</code>进行注解.</p>\n<p>例9.使用混合注解配合实体类定义<code>Repositor</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">JpaPersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MongoDBPersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Entity</span></div><div class=\"line\"><span class=\"meta\">@Document</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个示例展示实体类同时使用JPA和Spring Data MongoDB注解.</p>\n<p>这里定义了两个repository,<code>JpaPersonRepository</code>和<code>MongoDBPersonRepository</code>.</p>\n<p>一个被JPA使用,另一个被MongoDB使用.</p>\n<p>Spring Data不再能告诉repository区分,这将导致不清晰的行为</p>\n<p>“使用模块特有的接口定义Repository”和”使用注解配合实体类定义<code>Repositor</code>“都使用了严格的repository配置为一个特定的Spring Data模块识别可选的repository</p>\n<p>使用多种持久化技术特定的注解在同一个实体类上可能在锅中持久化技术上重用了实体类,但是这样做Spring Data将不能确定为repository绑定唯一的模块</p>\n<p>最后一种方式区分repository是划分repository的基本包.</p>\n<p>基本包定义起始点是扫描repository接口定义,这意味着在合适的包定义repository.</p>\n<p>默认的,注解配置使用类配置的包</p>\n<p>基于XML基本配置在这里.</p>\n<p>例10.注解配置基本包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(basePackages = <span class=\"string\">\"com.acme.repositories.jpa\"</span>)</div><div class=\"line\"><span class=\"meta\">@EnableMongoRepositories</span>(basePackages = <span class=\"string\">\"com.acme.repositories.mongo\"</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Configuration</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4-4-Defining-query-methods\"><a href=\"#4-4-Defining-query-methods\" class=\"headerlink\" title=\"4.4 Defining query methods\"></a>4.4 Defining query methods</h2><h2 id=\"4-4-定义查询方法\"><a href=\"#4-4-定义查询方法\" class=\"headerlink\" title=\"4.4 定义查询方法\"></a>4.4 定义查询方法</h2><p>repository代理有两种方式获得通过方法名获得指定查询.可以通过方法名直接获得查询,或者手动定义查询.有可用的选项定义在实际的存储.这有一些策略决定实际查询如何被创建.让我们一些看看可用的选项.</p>\n<h3 id=\"4-4-1-Query-lookup-strategies\"><a href=\"#4-4-1-Query-lookup-strategies\" class=\"headerlink\" title=\"4.4.1 Query lookup strategies\"></a>4.4.1 Query lookup strategies</h3><p>下面这些repository基本组件的决定查询可用的策略.你可以配置策略,在XML配置中通过命名空间<code>query-look-strategy</code>属性或者在Java配置中通过启用${store} Repository的属性注解<code>queryLookupStrategy</code>.一些策略可能不能支持特定的数据库.</p>\n<ul>\n<li>CREATE 试图通过方法名构建一个指定查询.一般处理是从方法名移除一系列给定的前缀并解析方法其他部分.更多查询构建信息阅读Query creation.</li>\n<li>USE_DECLARED_QUERY试图查找一个准确的查询,并在找不到时抛出一个异常.查询可以被通过注解定义或者其它方式定义.查询特殊存储的文档了解存储的可用选择.如果repository基本组件在启动时不能为方法找到一个准确的查询,将会失败</li>\n<li>CREATE_IF_NOT_FOUND(默认)联合了CREATE和USE_DECLARED_QUERY.首先查找一个准确查询,如果没有找到,创建一个定制方法基于名字的查询.这是默认的查询策略,因此如果你没有做任何明确配置.它允许根据方法名快速查询定义,而且定制查询根据需要引入声明的查询.</li>\n</ul>\n<h3 id=\"4-4-2-查询创建\"><a href=\"#4-4-2-查询创建\" class=\"headerlink\" title=\"4.4.2 查询创建\"></a>4.4.2 查询创建</h3><p>建成Spring Data repository基本组件的查询构建机制有用的构建了repository所有实体类的约束查询.</p>\n<p>这个机制分隔方法前缀<code>find...By</code>,<code>read...By</code>,<code>query...By</code>,<code>count...By</code>以及<code>get...By</code>,并解析其他部分.这个引入条款可以表达包含的特性例如<code>Distinct</code>,来设置明确的标志在要生成的查询上.然而,第一个by扮演了分解符来指明真实条件的起始.分词在一个非常基本的水平,你可以在实体属性上定义条件并且连接使用and或or连接他们.</p>\n<p>例11.来自方法名的查询创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByEmailAddressAndLastname</span><span class=\"params\">(EmailAddress emailAddress, String</span></span></div><div class=\"line\">                                             lastname);</div><div class=\"line\">  <span class=\"comment\">// Enables the distinct flag for the query</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findDistinctPeopleByLastnameOrFirstname</span><span class=\"params\">(String lastname, String</span></span></div><div class=\"line\">                                                       firstname);</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findPeopleDistinctByLastnameOrFirstname</span><span class=\"params\">(String lastname, String</span></span></div><div class=\"line\">                                                       firstname);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Enabling ignoring case for an individual property</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameIgnoreCase</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">  <span class=\"comment\">// Enabling ignoring case for all suitable properties</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameAndFirstnameAllIgnoreCase</span><span class=\"params\">(String lastname, String</span></span></div><div class=\"line\">                                                       firstname);</div><div class=\"line\">  <span class=\"comment\">// Enabling static ORDER BY for a query</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameOrderByFirstnameAsc</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameOrderByFirstnameDesc</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析方法的实际结果取决于你创建查询的持久化存储.然而,这有些问题需要注意:</p>\n<ul>\n<li>表达式通常串行的连接属性的遍历与操作符.你可以使用and和or连接属性表达式.你也可以给属性表达式使用操作符,例如between,lessThan,granterThan,like.你可以使用的表达式操作符有between,LessThan,GreaterThan,Loke.被支持的操作符根据多样的数据库决定,因此查询你引用文档的恰当部分.</li>\n<li>方法解析支持为单独属性设置一个IgnoreCase标志(例如,findByLastnameIgnoreCase(…))或者为所有属性都支持忽略情况(通常是String情形,例如,findByLastnameAndFirstnameAllIgnoreCase(…)).忽略情况是否被支持由多样的数据库决定，所以具体存储查询方法在引用文档查询相关章节.</li>\n<li>你可以为查询方法引用的属性提供静态排序连接OrderBy子句并且提供排序方向(Asc或Desc).为创建一个查询方法支持动态排序,查看特殊参数处理.</li>\n</ul>\n<h3 id=\"4-4-3-属性表达式\"><a href=\"#4-4-3-属性表达式\" class=\"headerlink\" title=\"4.4.3 属性表达式\"></a>4.4.3 属性表达式</h3><p>属性表达式可以只为管理的实体类的直接属性使用，就像前面所展示的那样。查询常见时你已经确认解析的字段是管理的实体类的一个字段.然而,你也可以通过最近的字段定义一个约束.假设<code>Person</code>的<code>Address</code>有一个<code>ZipCode</code>字段.这种情况一个方法如果这样命名:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByAddressZipCode</span><span class=\"params\">(ZipCode zipCode)</span></span>;</div></pre></td></tr></table></figure>\n<p>创建属性遍历<code>x.address.zipCode</code>.决策算法从把全部(<code>AddressZipCode</code>)作为属性开始并且检查实体类依此命名的属性(小写开头).如果算法成功了,就是用这个属性.否则,算法将源码部分驼峰式大小写从右侧头部到尾巴分隔,并试图找到相应的属性,在我们的例子中,<code>AddressZip</code>和<code>Code</code>.如果从头部找到一个属性,算法将在这里生成树处理后面的部分,使用描述的方式分隔.如果第一个分隔没有匹配到,算法移动分割点到左侧继续(<code>Address</code>,<code>ZipCode</code>).</p>\n<p>这在大多数情况都可以使用,但也可能选择错误的属性.假设<code>Person</code>类也有一个<code>addressZip</code>属性.算法将匹配第一个匹配的,本质上选择了错误属性,最终失败(伴随的<code>addressZip</code>类型没有属性<code>code</code>).</p>\n<p>没了解决这种起义,你可以在方法名称内使用<code>_</code>手动的定义遍历点.所以我们的方法名称最终像这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByAddress_ZipCode</span><span class=\"params\">(ZipCode zipCode)</span></span>;</div></pre></td></tr></table></figure>\n<p>As we treat underscore as a reserved character we strongly advise to follow standard Java naming<br>conventions (i.e. not using underscores in property names but camel case instead) </p>\n<p>我们对待下划线当做一个保留关键字,我们强力建议遵循标准Java命名规范(例如,使用驼峰命名而不是下划线命名属性名称)</p>\n<h3 id=\"4-4-4-特殊参数处理\"><a href=\"#4-4-4-特殊参数处理\" class=\"headerlink\" title=\"4.4.4 特殊参数处理\"></a>4.4.4 特殊参数处理</h3><p>处理你查询中的参数,你可以定义简单的方法参数像上面的示例中.处理之外基本组件可以识别出某些特殊类型例如<code>Pageable</code>和<code>Sort</code>用来动态的编码和排序你的查询.</p>\n<p>例12.在查询方法使用<code>Pageable</code>,<code>Slice</code>和<code>Sort</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Page&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">Slice&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Sort sort)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<p>第一个方法允许你在通过一个<code>org.springframework.data.domain.Pageable</code>实例在查询方法中动态添加分页信息在你的静态定义查询中.一个<code>Page</code>清楚数据的全部数量和页面总数.它是通过触发计数的基础设施查询计算总数。这个代价可能是昂贵的具体取决于所使用的存储,可以用<code>Slice</code>代替.一个<code>Slict</code>只知道下一个<code>Slice</code>可到到哪里,当运行在一个大的结果集上时这可能已经足够了.排序选项也通过<code>Pageable</code>实例处理.如果你只需要排序,简单起见添加<code>org.springframework.data.domain.Sort</code>参数在你的方法.如你所见,简单返回一个列表.在这种情况下,额外元数据构建实际的<code>Page</code>实例将不会被创建(反过来这意味着,没有发出额外的统计查询所必须的)简单约束只在给定的范围内查询.</p>\n<blockquote>\n<p>注意</p>\n<p>为了尽早得到你查询了多少页,你必须出发一个格外统计查询.默认的,这个查询你实际触发的查询调用.</p>\n</blockquote>\n<h3 id=\"4-4-5-限制查询结果\"><a href=\"#4-4-5-限制查询结果\" class=\"headerlink\" title=\"4.4.5 限制查询结果\"></a>4.4.5 限制查询结果</h3><p>查询方法的结果可以通过关键<code>first</code>或者<code>top</code>限制,可以交换使用.一个可选的数值可以追加在top/first来指定返回的最大结果集.如果数字缺失,假定结果集大小是1.</p>\n<p>例13.查询中使用Top和First限制结果大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">User <span class=\"title\">findFirstByOrderByLastnameAsc</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\">User <span class=\"title\">findTopByOrderByAgeDesc</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\">Page&lt;User&gt; <span class=\"title\">queryFirst10ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">Slice&lt;User&gt; <span class=\"title\">findTop3ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findFirst10ByLastname</span><span class=\"params\">(String lastname, Sort sort)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findTop10ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<p>限制表达式也支持Distinct关键字.此外，对于将结果集设置为一个实例的查询，支持将结果包装到一个<code>Optional</code>.如果应用分页或分片限制查询分页(并且计算可用的页数)那么这可以应用limited结果.</p>\n<blockquote>\n<p>注意</p>\n<p>请注意，限制结果结合使用<code>Sort</code>的动态排序的结果允许参数可以表示“k”最小的查询方法以及“K”的查询方法最大的元素。</p>\n</blockquote>\n<h3 id=\"4-4-6-流式处理结果\"><a href=\"#4-4-6-流式处理结果\" class=\"headerlink\" title=\"4.4.6 流式处理结果\"></a>4.4.6 流式处理结果</h3><p>方法查询结果可以通过使用java 8<code>Stream&lt;T&gt;</code>逐步处理。</p>\n<p>特定的方法用来表示流而不是简单的包装查询结果在一个<code>Stream</code>数据存储</p>\n<p>例14 一个用java流8<code>Stream&lt;T&gt;</code>查询结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"select u from User u\"</span>)</div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">findAllByCustomQueryAndStream</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">readAllByFirstnameNotNull</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"select u from User u\"</span>)</div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">streamAllPaged</span><span class=\"params\">(Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>一个<code>Stream</code>潜在的包装底层数据存储在页数的资源中,因此使用完毕必须关闭.你可以使用<code>close()</code>方法手动关闭<code>Stream</code>或者使用一个Java7的try_with-resources块.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>(Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</div><div class=\"line\">  stream.forEach(...);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-4-7-异步查询结果\"><a href=\"#4-4-7-异步查询结果\" class=\"headerlink\" title=\"4.4.7 异步查询结果\"></a>4.4.7 异步查询结果</h3><p>Repository查询可以使用<code>Spring&#39;s asynchronous method execution capacity</code>执行异步.这意味着方法可以一执行立即返回,真实的查询执行发生在任务提交到一个Spring TaskExecutor.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">Future&lt;User&gt; <span class=\"title\">findByFirstname</span><span class=\"params\">(String firstname)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">CompletableFuture&lt;User&gt; <span class=\"title\">findOneByFirstname</span><span class=\"params\">(String firstname)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">ListenableFuture&lt;User&gt; <span class=\"title\">findOneByLastname</span><span class=\"params\">(String lastname)</span></span>;</div></pre></td></tr></table></figure>\n<ol>\n<li>使用<code>java.util.concurrent.Future</code>作为返回类型</li>\n<li>使用一个Java8<code>java.util.current.CompletableFuture</code>作为返回类型</li>\n<li>使用一个<code>org.springframework.util.concurrent.ListenableFuture</code>作为返回类型</li>\n</ol>\n<h2 id=\"创建repository实例\"><a href=\"#创建repository实例\" class=\"headerlink\" title=\"创建repository实例\"></a>创建repository实例</h2><p>这个章节你创建实例和bean定义为repository接口定义.方法之一是手动的支持repository使用包含各个Spring Data模块的Spring命名空间装载,然而我们一般推荐使用Java配置的方法配置.</p>\n<h3 id=\"4-5-1-XML配置\"><a href=\"#4-5-1-XML配置\" class=\"headerlink\" title=\"4.5.1 XML配置\"></a>4.5.1 XML配置</h3><p>每个Spring Data module包含一个repository 元素,这可以让你简单的定义一个基本包,Spring为你扫描它.</p>\n<p>例16 通过XML启用Spring Data repositories</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans:beans</span> <span class=\"attr\">xmlns:beans</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/jpa\"</span></div><div class=\"line\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></div><div class=\"line\">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">        http://www.springframework.org/schema/data/jpa</div><div class=\"line\">        http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\"&gt;</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repositories\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans:beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在前面的实例中,让Spring扫描<code>com.acme.repositories</code>包和它的子包里继承<code>Repository</code>的接口或者它的子接口.找到的每个接口,继承组件注册持久化技术的<code>FactoryBean</code>来创建合适的代理处理执行查询方法.每个bean被注册在一个接口名称确定的bean name下,所以一个叫<code>UserRepository</code>将注册<code>userRepository</code>.基本包属性允许通配符,所以你可以定义一个规则扫描包.</p>\n<p><strong>使用过滤</strong></p>\n<p>默认的基本组件选取所有在配置的基本包下继承了持久化技术<code>Repositpry</code>接口以及子接口</p>\n<p>并且为他们创建一个bean实例.然而,你可能希望更细粒度的控制哪个接口bean实例被创建.为了实现这个你可以在<code>&lt;repository/&gt;</code>中使用<code>&lt;include-filter/&gt;</code>和<code>&lt;exclude-filter/&gt;</code>元素.语义完全等同于Spring的上下文命名空间中的元素.更多细节,查看他们的元素<code>Spring reference documentation</code></p>\n<p>例如，要将某些确定的接口排除实例化为repository，可以使用以下配置:</p>\n<p>例17. 使用exclude-filter元素</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;repository base-package=\"com.acme.repositories\"&gt;</div><div class=\"line\">  &lt;context:exclude-filter type=\"regex\" expression=\".*SomeRepository\" /&gt;</div><div class=\"line\">&lt;/repositories&gt;</div></pre></td></tr></table></figure>\n<p>这个示例从待实例化对象中排除所有以SomeRepository结尾的接口.</p>\n<h3 id=\"4-5-2-JavaConfig\"><a href=\"#4-5-2-JavaConfig\" class=\"headerlink\" title=\"4.5.2 JavaConfig\"></a>4.5.2 JavaConfig</h3><p>repository基础组件也可以使用一个存储的特殊的<code>@Enable${store}Repositories</code>注解在一个JavaConfig类上.入门介绍Spring容器Java基本Spring容器查看文档:<code>JavaConfig in the Spring reference documentaional</code></p>\n<p>一个简单配置启用Spring Data repositories像这样:</p>\n<p>例18. repository配置基于简单注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(<span class=\"string\">\"com.acme.repositories\"</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationConfiguration</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Bean</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> EntityManagerFactory <span class=\"title\">entityManagerFactory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// …</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>示例使用了JPA特有的注解,根据你使用的存储模块决定实际如何替换.示例定义<code>EntityManagerFactory</code>bean.查阅具体存储的配置</p>\n</blockquote>\n<h3 id=\"4-5-3-单独使用\"><a href=\"#4-5-3-单独使用\" class=\"headerlink\" title=\"4.5.3 单独使用\"></a>4.5.3 单独使用</h3><p>你也可以在Spring容器之外使用repository基础组件,例如在CDI环境.你仍然需要一些Spring库在你的classpath中,但是你可以以编程的方式启动.repository包装持久化技术支持的Spring Data模块提供RepositoryFactory,你可以向下面这样使用:</p>\n<p>例19. repository工厂单独使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">RepositoryFactorySupport factory = … <span class=\"comment\">// Instantiate factory here</span></div><div class=\"line\">UserRepository repository = factory.getRepository(UserRepository.class);</div></pre></td></tr></table></figure>\n<h2 id=\"4-6-定制Spring-Data仓库实现\"><a href=\"#4-6-定制Spring-Data仓库实现\" class=\"headerlink\" title=\"4.6 定制Spring Data仓库实现\"></a>4.6 定制Spring Data仓库实现</h2><p>时常有必要为一少部分仓库方法提供一个定制的实现.Spring数据存储库很容易允许您提供自定义存储库代码并将其与通用CRUD集成抽象和查询方法功能整合.</p>\n<h3 id=\"4-6-1-为单独仓库添加定制行为\"><a href=\"#4-6-1-为单独仓库添加定制行为\" class=\"headerlink\" title=\"4.6.1 为单独仓库添加定制行为\"></a>4.6.1 为单独仓库添加定制行为</h3><p>为了定制功能丰富一个仓库,你首先为定制功能定义一个接口和实现.使用你提供的仓库接口来继承自定义接口.</p>\n<p>例20. 定制仓库功能的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">someCustomMethod</span><span class=\"params\">(User user)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例21.定制功能的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRepositoryImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">someCustomMethod</span><span class=\"params\">(User user)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Your custom implementation</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>类可以被找到最重要的点是名字以Impl为后缀区别于仓库的核心接口(见下文)</p>\n</blockquote>\n<p>实现的本身没有依赖Spring Data,可以是一个标准的Spring bean.所以你可以使用标准的依赖注入行为给其他bean注入引用,像<code>JdbcTemplate</code>,切面的一部分等等.</p>\n<p>例22 修改你基本的仓库接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// Declare query methods here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>让你的标准仓库接口继承定制的.这样做结合了CRUD和定制功能并使其可用于客户端.</p>\n<p><strong>配置</strong></p>\n<p>如果你使用命名空间配置,仓库基本组件扫描类所在包,根据扫描结果尝试自动定制实现.</p>\n<p>这些类需要遵循命名规范:给仓库接口名添加命名空间元素属性<code>repositoryimpl-postfix</code>.默认的后缀是<code>Impl</code></p>\n<p>例23. 配置示例</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> <span class=\"attr\">repository-impl-postfix</span>=<span class=\"string\">\"FooBar\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>第一个配置示例将查实查找一个类<code>com.acme.repository.UserRepositoryImpl</code>来作为定制藏局实现.然而第二个示例将尝试查找<code>com.acme.repository.UserRepositoryFooBar</code>.</p>\n<p><strong>手动指定</strong></p>\n<p>上面的方法可以正常工作,只有当你定制实现使用注解配置和自动注入,这将与其他Spring bean一样被对待.如果你定制的实现需要特殊处理,你可以像描述的简单定义一个bean并且命名它.基本组件将通过名称引用手动定义的bean定义而不是它自己创建一个.</p>\n<p>例24.手动指定定制实现</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans:bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userRepositoryImpl\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"…\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- further configuration --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans:bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-6-2为所有仓库添加定制行为\"><a href=\"#4-6-2为所有仓库添加定制行为\" class=\"headerlink\" title=\"4.6.2为所有仓库添加定制行为\"></a>4.6.2为所有仓库添加定制行为</h3><p>当你希望把一个单独的方法添加到你所有的仓库接口中时,上面的方法就不可行了.为了添加定制到所有的仓库,你首先添加一个中间接口来定义共享的行为.</p>\n<p>例25 定义共享定制行为接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt;</span></div><div class=\"line\">  <span class=\"keyword\">extends</span> <span class=\"title\">PagingAndSortingRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sharedCustomMethod</span><span class=\"params\">(ID id)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在你独立的仓库接口将继承这个中间接口而不是<code>Repository</code>接口来包含功能的定义.接下来创建一个中间接口的实现继承持久化具体仓库的基本类.这个类后面将作为仓库代理的基本类.</p>\n<p>例26 定制仓库基本类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRepositoryImpl</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt;</span></div><div class=\"line\">  <span class=\"keyword\">extends</span> <span class=\"title\">SimpleJpaRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; &#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EntityManager entityManager;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyRepositoryImpl</span><span class=\"params\">(JpaEntityInformation entityInformation,</span></span></div><div class=\"line\">                          EntityManager entityManager) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(entityInformation, entityManager);</div><div class=\"line\">    <span class=\"comment\">// Keep the EntityManager around to used from the newly introduced methods.</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.entityManager = entityManager;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sharedCustomMethod</span><span class=\"params\">(ID id)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// implementation goes here</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>警告</p>\n<p>这个类需要有一个构造方法调用父类具体存储仓库工厂实现.万一仓库基础类有多个构造,覆盖包括一个<code>EntityInformation</code>加上存储具体基本组件对象(例如一个<code>EntityManager</code>或者模板类)</p>\n</blockquote>\n<p>Spring<code>&lt;repository/&gt;</code>命名空间下的默认行为为所有接口提供一个实现.这意味着如果处于其当前状态，<code>MyRepository</code>的实现实例将由Spring创建.这当然不是被期望的,它只是作为一个用来定义实体的 <code>Repository</code>和真实仓库接口的中间接口.为了排除一个继承<code>Repository</code>的接口被当做一个仓库接口实例化,你可以给它使用<code>@NoRepositoryBean</code>(像上面)或者把它从配置中<code>base-package</code>移除.</p>\n<p>最后一步是让Spring Data基本组件识别到定制的仓库基本类.在JavaConf使用注解<code>@Enable...Repository</code>的属性<code>repositoryBaseClass</code>完成:</p>\n<p>例27 使用JavaConfig配置一个定制仓库基本类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(repositoryBaseClass = MyRepositoryImpl.class)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationConfiguration</span> </span>&#123; … &#125;</div></pre></td></tr></table></figure>\n<p>类似的属性在XML命名空间中也可以找到.</p>\n<p>例28 使用XML配置一个定制仓库基本类</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span></span></div><div class=\"line\">              <span class=\"attr\">base-class</span>=<span class=\"string\">\"….MyRepositoryImpl\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"4-7-Spring-Data扩展\"><a href=\"#4-7-Spring-Data扩展\" class=\"headerlink\" title=\"4.7 Spring Data扩展\"></a>4.7 Spring Data扩展</h2><p>这部分说明Spring Data一系列的扩展功能,可以使Spring Dta使用多样的上下文.目前大部分集成是针对Spring MVC.</p>\n<h3 id=\"4-7-1-Querydsl扩展\"><a href=\"#4-7-1-Querydsl扩展\" class=\"headerlink\" title=\"4.7.1 Querydsl扩展\"></a>4.7.1 Querydsl扩展</h3><p>Querydsl是一个框架,通过它的流式API构建静态类型的SQL类查询.</p>\n<p>多个Spring Data模块通过<code>QueryDslPredicateExecutor</code>与Querydsl集成.</p>\n<p>例29 QueryDslPredicateExecutor接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">findOne</span><span class=\"params\">(Predicate predicate)</span></span>; ①</div><div class=\"line\">    <span class=\"function\">Iterable&lt;T&gt; <span class=\"title\">findAll</span><span class=\"params\">(Predicate predicate)</span></span>; ②</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">count</span><span class=\"params\">(Predicate predicate)</span></span>; ③</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">exists</span><span class=\"params\">(Predicate predicate)</span></span>; ④</div><div class=\"line\">    <span class=\"comment\">// … more functionality omitted.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>① 查询并返回一个匹配<code>Predicate</code>的单例实体</p>\n<p>②查询并返回所有匹配<code>Predicate</code>的实体</p>\n<p>③ 返回匹配<code>Predicate</code>的实体数量</p>\n<p>④  返回是否存在一个匹配<code>Predicate</code>的实体</p>\n<p>为了简单的使用Querydsl功能,在你的仓库接口继承<code>QueryDslPredicateExecutor</code>.</p>\n<p>例30 在仓库集成QueryDsl</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt;,</span></div><div class=\"line\">  <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">User</span>&gt; &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面这样就可以使用Querydsl的<code>Predicate</code>书写类型安全的查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Predicate predicate = user.firstname.equalsIgnoreCase(<span class=\"string\">\"dave\"</span>)</div><div class=\"line\">  .and(user.lastname.startsWithIgnoreCase(<span class=\"string\">\"mathews\"</span>));</div><div class=\"line\">userRepository.findAll(predicate);</div></pre></td></tr></table></figure>\n<h3 id=\"4-7-2-Web支持\"><a href=\"#4-7-2-Web支持\" class=\"headerlink\" title=\"4.7.2 Web支持\"></a>4.7.2 Web支持</h3><blockquote>\n<p>注意</p>\n<p>本节包含Spring Data Web支持的文档是在1.6范围内的Spring Data Commons实现的.因为支持新引入的内容改变了很多东西，我们保留了旧行为的文档在”遗留Web支持”部分.</p>\n</blockquote>\n<p>如果模块支持仓库编程模型，那么Spring Data模块附带了各种Web模块支持.Web关联的东西需要Spring MVC的JAR包位于classpath路径下,它们中有些甚至提供了Spring HATEOAS集成.一般情况,集成方式支持使用<code>@EnableSpringDataWebSupport</code>注解在你的JavaConfig配置类.</p>\n<p>例31 启用Spring Data web支持</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableWebMvc</span></div><div class=\"line\"><span class=\"meta\">@EnableSpringDataWebSupport</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p><code>@EnableSpringDataWebSupport</code>注解注册了一些组件，我们将在稍后讨论.注解还将在类路径上检测Spring HATEOAS，如果才在将为其注册集成组件.</p>\n<p>作为可选项,如果你使用XML配置,注册<code>SpringDataWebSupport</code>或者<code>HateoasWareSpringDataWebSupport</code>作为Spring bean:</p>\n<p>例32 用XML启用Spring Data web支持</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.data.web.config.SpringDataWebConfiguration\"</span> /&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- If you're using Spring HATEOAS as well register this one *instead* of the</span></div><div class=\"line\">former --&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>= <span class=\"string\">\"org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>基本Web支持</strong></p>\n<p>上面展示的的配置设置将注册几个基本组件：</p>\n<ul>\n<li>一个<code>DomainClassConverter</code>启用Spring MVC来根据请求参数或路径变量管理仓例实体类的实例</li>\n<li><code>HandlerMethodArgumentResolver</code>实现让Spring MVC从请求参数解析Pageable和Sort实例.</li>\n</ul>\n<p><strong>实体类转换</strong></p>\n<p><code>DomainClassConverter</code>允许你在Spring MVC控制器方法签名中直接使用实体类型,因此你不必手动的通过仓库查询实例:</p>\n<p>例33 一个Spring MVC控制器在方法签名中使用实体类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> User user, Model model) </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"userForm\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如你所见,方法直接接收一个User实例并没有更进一步的查询是否必要.实例可以通过Spring MVC将路径变量转换为实体类的id类型并最终通过在实体类型注册的仓库实例上调用<code>findOne(...)</code>访问实例转换得到.</p>\n<blockquote>\n<p>注意</p>\n<p>当前的仓库必须实现<code>CrudRepository</code>做好准备被发现来进行转换.</p>\n</blockquote>\n<p><strong>为了分页和排序分解方法参数</strong></p>\n<p>上面的配置片段还注册了一个<code>PageableHandlerMethodArgumentResolver</code>和一个<code>SortHandlerMethodArgumentResolver</code>实例.注册使得Pageable和Sort成为有效的控制器方法参数.</p>\n<p>例34 使用Pageable作为控制器方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> UserRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUsers</span><span class=\"params\">(Model model, Pageable pageable)</span> </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"users\"</span>, repository.findAll(pageable));</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"users\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法签名将使Spring MVC尝试使用下面的默认配置从请求参数中转换一个Pageable实例:</p>\n<p>表1 请求参数转换Pageable实例</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>page</td>\n<td>要检索的页面,索引为0,默认为0</td>\n</tr>\n<tr>\n<td>size</td>\n<td>要检索的页面大小,默认20</td>\n</tr>\n<tr>\n<td>sort</td>\n<td>被排序的属性应以格式`property,property(, ASC\\</td>\n<td>DESC)`表示.默认生序排序,如果你希望改变排序顺序,则使用多个排序参数,例如?sort=firstname&amp;sort=lastname,asc</td>\n</tr>\n</tbody>\n</table>\n<p>为了定制行为,可以继承<code>SpringDataWebConfiguration</code>或者启用等效的HATEOAS并覆盖<code>pageableResolver()</code>或<code>sortResolver()</code>方法并导入你的自定义配置文件替代@Enable-注解.</p>\n<p>有一种情况你需要多个<code>Pageable</code>或<code>Sort</code>实例从请求转换(例如处理多个表单),你可以使用Spring的<code>@Qualifier</code>注解来互相区别.请求参数必须以<code>${qualifier}为</code>前缀.这样一个方法的签名像这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUsers</span><span class=\"params\">(Model model, </span></span></div><div class=\"line\">                        @Qualifier(<span class=\"string\">\"foo\"</span>)Pagebale first, </div><div class=\"line\">                        @<span class=\"title\">Qualifier</span><span class=\"params\">(<span class=\"string\">\"bar\"</span>)</span> Pageable second) &#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你必须填充foo_page和bar_page等.</p>\n<p>默认的<code>Pageable</code>在方法中处理等价于一个<code>new PageRequest(0, 20)</code>,但是可以使用<code>@PageableDefaults</code>注解在<code>Pageable</code>参数上定制.</p>\n<p><strong>Hypermedia支持分页</strong></p>\n<p>Spring HATEOAS包装了一个代表模型的类<code>PageResources</code> ,</p>\n<p>它可以使用Page实例包装必要的Page元数据内容作为连接让客户端导航页面.一个页面到一个<code>PageResources</code>的转换被Spring HATEOAS的<code>ResourceAssembler</code>接口实现<code>PagedResourcesAssembler</code>来完成.</p>\n<p>例35 使用一个PagedResourcesAssembler作为控制器方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> PersonRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/persons\"</span>, method = RequestMethod.GET)</div><div class=\"line\">  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,</div><div class=\"line\">                                             PagedResourcesAssembler assembler) &#123;</div><div class=\"line\">    Page&lt;Person&gt; persons = repository.findAll(pageable);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面这样配置将允许<code>PageResourcesAssembler</code>作为控制器方法的一个参数.在这调用toResources(…)方法有以下作用:</p>\n<ul>\n<li><code>Page</code>的内容将<code>PageResources</code>实例的内容</li>\n<li><code>PageResources</code>将获得<code>PageMetadata</code>实例,该实例由Page和基础的PageRequest中的信息填充</li>\n<li><code>PageResources</code>获得<code>prev</code>和<code>next</code>连接,添加这些依赖在页面.这些链接将指向uri方法的调用映射.页码参数根据<code>PageableHandlerMethodArgumentResolver</code>添加到参数以在后面被转换.</li>\n</ul>\n<p>假设我们有30个Person实例在数据库.你现在可以触发一个GET请求 <a href=\"http://localhost:8080/persons\" target=\"_blank\" rel=\"external\">http://localhost:8080/persons</a>, 你将可以看到类似下面的内容:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; \"links\" : [ &#123; \"rel\" : \"next\",</div><div class=\"line\">\"href\" : \"http://localhost:8080/persons?page=1&amp;size=20 &#125;</div><div class=\"line\">],</div><div class=\"line\">\"content\" : [</div><div class=\"line\">… // 20 Person instances rendered here</div><div class=\"line\">],</div><div class=\"line\">\"pageMetadata\" : &#123;</div><div class=\"line\">\"size\" : 20,</div><div class=\"line\">\"totalElements\" : 30,</div><div class=\"line\">\"totalPages\" : 2,</div><div class=\"line\">\"number\" : 0</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以看到编译生成了正确的URI，并且还会提取默认配置转换参数到即将到来的请求中的<code>Pageable</code>.这意味着,如果你改变配置,链接也将自动跟随改变.默认情况下，编译指向控制器执行的方法，但是这可以被一个自定义链接作为基本构建来构成分页的<code>Link</code>重载<code>PagedResourcesAssembler.toResource（...）</code>方法定制.</p>\n<p><strong>Querydsl web 支持</strong></p>\n<p>那些整合了<code>QueryDSL</code>的存储可能从<code>Request</code>查询字符串中的属性驱动查询.</p>\n<p>这意味着前面例子的查询字符串可以给出<code>User</code>的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?firstname=Dave&amp;lastname=Matthews</div></pre></td></tr></table></figure>\n<p>可以被转换为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">QUser.user.firstname.eq(<span class=\"string\">\"Dave\"</span>).and(QUser.user.lastname.eq(<span class=\"string\">\"Matthews\"</span>))</div></pre></td></tr></table></figure>\n<p>使用了<code>QuerydslPredicateArgumentResolver</code>.</p>\n<blockquote>\n<p>注意</p>\n<p>当在类路径上找到Querydsl时，该功能将在@EnableSpringDataWebSupport注解中自动启用</p>\n</blockquote>\n<p>添加一个<code>@QuerydslPredicate</code>到一个方法签名将提供一个就绪的<code>Predicate</code>,可以通过<code>QueryDslPredicateExecutor</code>执行.</p>\n<blockquote>\n<p>提示</p>\n<p>类型信息通常从返回方法上解析.由于这些信息不一定匹配实体类型,使用<code>QuerydslPredicate</code>的<code>root</code>属性可能是个好主意.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> UserRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/\"</span>, method = RequestMethod.GET)</div><div class=\"line\">  <span class=\"function\">String <span class=\"title\">index</span><span class=\"params\">(Model model, @QuerydslPredicate(root = User.class)</span> Predicate predicate,</span></div><div class=\"line\">              Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt;</div><div class=\"line\">    parameters) &#123;</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"users\"</span>, repository.findAll(predicate, pageable));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"index\"</span>;</div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为User转换匹配查询字符串参数的<code>Predicate</code></p>\n<p>默认的绑定规则如下:</p>\n<ol>\n<li><p><code>Object</code>在简单属性上如同<code>eq</code></p>\n</li>\n<li><p><code>Object</code>在集合作为属性如同<code>contains</code></p>\n</li>\n<li><p><code>Collection</code>在简单属性上如同<code>in</code></p>\n</li>\n</ol>\n<p>这些绑定可以通过<code>@QuerydslPredicate</code>的<code>bindings</code>属性定制或者使用Java8<code>default methods</code>给仓库接口添加<code>QuerydslBinderCustomizer</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserReposotory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CurdRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">String</span>&gt;, </span></div><div class=\"line\">  <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">User</span>&gt;,</div><div class=\"line\">  <span class=\"title\">QuerydslBinderCustomizer</span>&lt;<span class=\"title\">QUser</span>&gt; &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customize</span><span class=\"params\">(QuerydslBindings bindings, QUser user)</span> </span>&#123;</div><div class=\"line\">      bindings.bind(user.username).first((path, value) -&gt; path.contains(value));</div><div class=\"line\">      bindings.bind(String.class).first((StringPath path, String value) -&gt;</div><div class=\"line\">                                        path.containsIgnoreCase(value));</div><div class=\"line\">      bindings.excluding(user.password);</div><div class=\"line\">  \t&#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><code>QueryDslPredicateExecutor</code>为<code>Predicate</code>提供特殊的查询方法提供入口</li>\n<li>在仓库接口定义<code>QuerydslBinderCustomizer</code>将自动注解<code>@QuerydslPredicate(bindings=...)</code></li>\n<li>为<code>username</code>属性定义绑定,绑定到一个简单集合</li>\n<li>为<code>String</code>属性定义默认绑定到一个不区分大小写的集合</li>\n<li>从<code>Predicate</code>移除密码属性</li>\n</ol>\n<h3 id=\"4-7-3-仓库填充\"><a href=\"#4-7-3-仓库填充\" class=\"headerlink\" title=\"4.7.3 仓库填充\"></a>4.7.3 仓库填充</h3><p>如果你使用Spring JDBC模块,你可能熟悉在<code>DataSource</code>使用SQL脚本来填充.一个类似的抽象在仓库级别可以使用,尽管它不是使用SQL作为数据定义语言,因为它必须由存储决定.填充根据仓库支持XML(通过Spring的OXM抽象)和JSON(通过Jackson)定义数据.</p>\n<p>假设你有一个文件<code>data.json</code>内容如下:</p>\n<p>例36 JSON定义的数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ &#123; <span class=\"attr\">\"_class\"</span> : <span class=\"string\">\"com.acme.Person\"</span>,</div><div class=\"line\">     <span class=\"attr\">\"firstname\"</span> : <span class=\"string\">\"Dave\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"lastname\"</span> : <span class=\"string\">\"Matthews\"</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">\"_class\"</span> : <span class=\"string\">\"com.acme.Person\"</span>,</div><div class=\"line\">     <span class=\"attr\">\"firstname\"</span> : <span class=\"string\">\"Carter\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"lastname\"</span> : <span class=\"string\">\"Beauford\"</span> &#125; ]</div></pre></td></tr></table></figure>\n<p>你可以容易的根据Spring Data Commons提供仓库的命名空间填充元素填充你的仓库.为了填充前面的数据到你的PersonRepository,像下面这样配置:</p>\n<p>例37 声明一个Jackson仓库填充</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">    <span class=\"attr\">xmlns:repository</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/repository\"</span></div><div class=\"line\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></div><div class=\"line\">      http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">      http://www.springframework.org/schema/data/repository</div><div class=\"line\">      http://www.springframework.org/schema/data/repository/spring-repository.xsd\"&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">repository:jackson2-populator</span> <span class=\"attr\">locations</span>=<span class=\"string\">\"classpath:data.json\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这样的声明可以让<code>data.json</code>文件可以被一个Jackson的<code>ObjectMpper</code>读取和反序列化.</p>\n<p>JSON将要解析的对象类型由检查JSON文档的<code>_class</code>属性决定.基本组件将最终选择合适的仓库去处理反序列化的对象.</p>\n<p>要使用XML定义数据填充仓库,你可以使用<code>unmarshaller-populator</code>元素.你配置它使用Spring OXM提供给你的XML装配选项.在Spring reference documentation查看更多细节.</p>\n<p>例38 声明一个装配仓库填充器(使用JAXB)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:repository</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/repository\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:oxm</span>=<span class=\"string\">\"http://www.springframework.org/schema/oxm\"</span></div><div class=\"line\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></div><div class=\"line\">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">        http://www.springframework.org/schema/data/repository</div><div class=\"line\">        http://www.springframework.org/schema/data/repository/spring-repository.xsd</div><div class=\"line\">        http://www.springframework.org/schema/oxm</div><div class=\"line\">        http://www.springframework.org/schema/oxm/spring-oxm.xsd\"&gt;</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repository:unmarshaller-populator</span> <span class=\"attr\">locations</span>=<span class=\"string\">\"classpath:data.json\"</span></span></div><div class=\"line\">        <span class=\"attr\">unmarshaller-ref</span>=<span class=\"string\">\"unmarshaller\"</span> /&gt;</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">oxm:jaxb2-marshaller</span> <span class=\"attr\">contextPath</span>=<span class=\"string\">\"com.acme\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-7-4-遗留web支持\"><a href=\"#4-7-4-遗留web支持\" class=\"headerlink\" title=\"4.7.4 遗留web支持\"></a>4.7.4 遗留web支持</h3><p><strong>Spring MVC的实体类绑定</strong></p>\n<p>如果正在开发Spring MVC web应用,你通常必须从URL中解析实体类的id.默认的,你的任务是转化请求参数或URL参数到实体类并将它移交给下面或直接在实体上操作业务逻辑.这看起来像下面这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> UserRepository userRepository;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</div><div class=\"line\">    Assert.notNull(repository, <span class=\"string\">\"Repository must not be null!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.userRepository = userRepository;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> Long id, Model model) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Do null check for id</span></div><div class=\"line\">    User user = userRepository.findOne(id);</div><div class=\"line\">    <span class=\"comment\">// Do null check for user</span></div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"user\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先你为每个控制器定义一个依赖的仓库来查找它们分别管理的实体.查询实体也是样板,因为它总是一个<code>findOne(...)</code>调用.幸运的Spring提供了方法来注册自定义组件,允许一个String值转换到一个属性类型.</p>\n<p><strong>属性编辑</strong></p>\n<p>Spring3.0之前Java<code>PropertyEditors</code>被使用.为了集成这些,Spring Data提出一个<code>DomainClassPropertyEditorRegistrar</code>来查询所有注册到<code>ApplicatonContext</code>的Spring Data仓库和一个定制的<code>PropertyEditor</code>来管理实体类.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"webBindingInitializer\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"….web.bind.support.ConfigurableWebBindingInitializer\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"propertyEditorRegistrars\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=</span></div><div class=\"line\">          <span class=\"string\">\"org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar\"</span> /&gt;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果你已经像上面这样配置Spring MVC,你可以向下面这样配置你的控制器,从而减少不清晰和样板式的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> User user, Model model) </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"userForm\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>说明：本翻译<a href=\"http://ifeve.com/repositories-custom-implementations/\">4.6</a>和<a href=\"http://ifeve.com/spring-data-4-7/\">4.7</a>段发布在<a href=\"http://ifeve.com/\">并发编程网</a>,其他段落为了熟悉上下文而翻译，没有精校。首次参与翻译任务，翻译的不好请指正。</p>\n<hr>\n<h1 id=\"第四章-使用Spring-Data-Repositories\"><a href=\"#第四章-使用Spring-Data-Repositories\" class=\"headerlink\" title=\"第四章 使用Spring Data Repositories\"></a>第四章 使用Spring Data Repositories</h1><p>Spring Data repository abstraction目的是为了显著的简化必要的样板式代码来为多种持久化数据存储实现数据层。</p>\n<blockquote>\n<p>重要</p>\n<p>本章解释Spring Data repositories核心的概念和接口。Spring Data repository documentation 与 你的模块。本章这些信息是从Spring Data Commons模块获取的。它使用了JPA模块的配置和代码示范,命名引用覆盖XML配置，它支持所有的Spring Data模块支持的repository API，Repository查询关键字覆盖被repository 接口一般的关键字查询方法。你的模块特性的细节信息，查询文档对应模块。</p>\n</blockquote>\n<h2 id=\"4-1-核心概念\"><a href=\"#4-1-核心概念\" class=\"headerlink\" title=\"4.1 核心概念\"></a>4.1 核心概念</h2><p>Spring Data repository抽象接口的核心是<code>Repository</code>（可能没有那么惊喜）。它需要管理实体类以及实体类的id作为参数。此接口主要用作是获取要使用的类型接口并帮助扩展这个接口。</p>\n<p><code>CrudRepository</code>为被管理的实体类提供复杂CRUD功能。</p>\n<h2 id=\"4-2-查询方法\"><a href=\"#4-2-查询方法\" class=\"headerlink\" title=\"4.2 查询方法\"></a>4.2 查询方法</h2><p>标准的CRUD功能repositories通常有查询底层数据库。</p>\n<p>在Spring Data中，分词声明这些查询变成了四个步骤的过程：</p>\n<ol>\n<li><p>声明一个接口继承<code>Repository</code>或者它的一个子类，并且指定要被处理的实体类和Id类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123; … &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在接口中声明查询方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建Spring生成代理实现上面接口，通过JavaConfig：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>或者通过XML配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xmlns:jpa</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/jpa\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</div><div class=\"line\">http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">http://www.springframework.org/schema/data/jpa</div><div class=\"line\">http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jpa:repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repositories\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个实例中使用了JPA命名空间。</p>\n<p>如果你为其他存储使用repository接口，你需要修改来适应你的存储模块命名空间的声明，大概就是替换jpa为期望的，例如mongodb。</p>\n<p>当然，注意JavaConfig并没有明确配置一个包默认使用注解的包。</p>\n<p>为了定制包被扫描可以使用数据存储注解<code>@Enable</code>的一个属性<code>basePackage</code>。</p>\n</li>\n</ol>\n<ol>\n<li><p>获得repository实例注入并使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClient</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"keyword\">private</span> PersonRepository repository;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    List&lt;Person&gt; persons = repository.findByLastname(<span class=\"string\">\"Matthews\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>以下部分详细说明每个步骤。</p>\n<h2 id=\"4-3-定义repository接口\"><a href=\"#4-3-定义repository接口\" class=\"headerlink\" title=\"4.3 定义repository接口\"></a>4.3 定义repository接口</h2><p>第一步定义一个实体类依赖repository接口。</p>\n<p>这个接口必须继承<code>Repository</code>接口并且指定实体类型和Id类型。</p>\n<p>如果你希望实体类型拥有CRUD方法，将<code>Repository</code>接口替换成继承<code>CrudRepository</code>。</p>\n<h3 id=\"4-3-1-小巧repository定义\"><a href=\"#4-3-1-小巧repository定义\" class=\"headerlink\" title=\"4.3.1 小巧repository定义\"></a>4.3.1 小巧repository定义</h3><p>一般情况下，你的repository接口应该继承<code>Repository</code>，<code>CrudRepository</code>或者<code>PagingAndSortingRepository</code></p>\n<p>除此之外,如果你不想继承Spring Data接口,你也可以使用<code>@Repository</code>注解定义你的接口</p>\n<p>继承<code>CrudRepository</code>提供了一系列完整的方法来操纵你的实体.</p>\n<p>如果你希望选择方法,简单的从<code>CurdRepository</code>复制你希望获得的方法到你的<code>Repository</code></p>\n<blockquote>\n<p>注意</p>\n<p>注意这允许你定义你自己的抽闲建立在Spring Data Repositories功能.</p>\n</blockquote>\n<p>例5.有选择的展现<code>CRUD</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">findOne</span><span class=\"params\">(ID id)</span></span>;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">save</span><span class=\"params\">(T entity)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">User <span class=\"title\">findByEmailAddress</span><span class=\"params\">(EmailAddress emailAddress)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是第一步你定义一个通用的基本接口,接口供你所有的实体repositories使用并提供<code>findOne()</code>和<code>save()</code>方法</p>\n<p>这些方法会被转发到你选择的Spring Data提供的基本repository实现,例如JPA<code>SimpleJpaRepository</code>,因为他们匹配<code>CrudRepository</code>的方法签名.</p>\n<p>因此<code>UserPepository</code>现在可以保存用户,查找唯一用户根据id,并且触发一个查询去查找<code>Users</code>根据他们的邮箱地址</p>\n<blockquote>\n<p>注意</p>\n<p>注意,中间的repository接口使用了注解<code>NoRepositoryBean</code>.</p>\n<p>对所有Spring Data在运行时不需要生成实例的repository接口,确保你为他们添加了注解.</p>\n</blockquote>\n<h3 id=\"4-3-2-在多个Spring-Data模块使用Repositories\"><a href=\"#4-3-2-在多个Spring-Data模块使用Repositories\" class=\"headerlink\" title=\"4.3.2 在多个Spring Data模块使用Repositories\"></a>4.3.2 在多个Spring Data模块使用Repositories</h3><p>在你的应用中使用唯一的Spring Data模块,所有repository接口定义范围限制在Spring Data模块.</p>\n<p>有时候应用需要使用不止一个Spring Data模块.</p>\n<p>这种情况下,需要repository定义在持久化技术之间有所区别.</p>\n<p>在class path发现多个repository工厂时,Spring Data严格检测repository配置模块.</p>\n<p>在repository或者实体类严格配置需要得细节以决定Spring Data模块绑定一个repository的定义:</p>\n<ol>\n<li>如果repository定义继承模块特殊的repository,那么对Spring Data模块这是一个有效的备选.</li>\n</ol>\n<ol>\n<li><p>如果实体类被模块特有的注解类型注解,那么对Spring Data模块这是一个有效的备选.</p>\n<p>Spring Data模块接收第三方注解(例如 JPA的<code>@Entity</code>)或者提供自己的注解例如<code>@Document</code>为Spring Data MongoDB/Spring Data Elasticsearch.</p>\n</li>\n</ol>\n<p>例6.使用模块特有的接口定义Repository</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123; &#125;</div><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">T</span>,<span class=\"title\">ID</span></span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>MyRepository</code>和<code>UserRepository</code>继承<code>JpaRepository</code>在他们类型层级.他们有效的表示了Spring Data JPA模块.</p>\n<p>例7.使用通用的接口定义<code>Repository</code>.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AmbiguousRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span></div><div class=\"line\">  <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">T</span>,<span class=\"title\">ID</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AmbiguousUserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyBaseRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>AmbiguousRepository</code>和<code>AmbiguousUserRepository</code>在它们继承体系里只继承了<code>Repository</code>和<code>CrudRepository</code>.使用唯一的Spring Data模块是这是完成正确的,多个模块不能识别<code>Repository</code>到底绑定哪个Spring Data.</p>\n<p>例8.使用注解配合实体类定义<code>Repositor</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Entity</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Document</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>PersonRepository</code>引用使用了JPA的注解<code>@Entity</code>进行注解的<code>Person</code>,所以这个repository明确的属于Spring Data JPA.<code>UserRepository</code>使用了Spring Data MongoDB的注解<code>@Document</code>进行注解.</p>\n<p>例9.使用混合注解配合实体类定义<code>Repositor</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">JpaPersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MongoDBPersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Entity</span></div><div class=\"line\"><span class=\"meta\">@Document</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个示例展示实体类同时使用JPA和Spring Data MongoDB注解.</p>\n<p>这里定义了两个repository,<code>JpaPersonRepository</code>和<code>MongoDBPersonRepository</code>.</p>\n<p>一个被JPA使用,另一个被MongoDB使用.</p>\n<p>Spring Data不再能告诉repository区分,这将导致不清晰的行为</p>\n<p>“使用模块特有的接口定义Repository”和”使用注解配合实体类定义<code>Repositor</code>“都使用了严格的repository配置为一个特定的Spring Data模块识别可选的repository</p>\n<p>使用多种持久化技术特定的注解在同一个实体类上可能在锅中持久化技术上重用了实体类,但是这样做Spring Data将不能确定为repository绑定唯一的模块</p>\n<p>最后一种方式区分repository是划分repository的基本包.</p>\n<p>基本包定义起始点是扫描repository接口定义,这意味着在合适的包定义repository.</p>\n<p>默认的,注解配置使用类配置的包</p>\n<p>基于XML基本配置在这里.</p>\n<p>例10.注解配置基本包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(basePackages = <span class=\"string\">\"com.acme.repositories.jpa\"</span>)</div><div class=\"line\"><span class=\"meta\">@EnableMongoRepositories</span>(basePackages = <span class=\"string\">\"com.acme.repositories.mongo\"</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Configuration</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4-4-Defining-query-methods\"><a href=\"#4-4-Defining-query-methods\" class=\"headerlink\" title=\"4.4 Defining query methods\"></a>4.4 Defining query methods</h2><h2 id=\"4-4-定义查询方法\"><a href=\"#4-4-定义查询方法\" class=\"headerlink\" title=\"4.4 定义查询方法\"></a>4.4 定义查询方法</h2><p>repository代理有两种方式获得通过方法名获得指定查询.可以通过方法名直接获得查询,或者手动定义查询.有可用的选项定义在实际的存储.这有一些策略决定实际查询如何被创建.让我们一些看看可用的选项.</p>\n<h3 id=\"4-4-1-Query-lookup-strategies\"><a href=\"#4-4-1-Query-lookup-strategies\" class=\"headerlink\" title=\"4.4.1 Query lookup strategies\"></a>4.4.1 Query lookup strategies</h3><p>下面这些repository基本组件的决定查询可用的策略.你可以配置策略,在XML配置中通过命名空间<code>query-look-strategy</code>属性或者在Java配置中通过启用${store} Repository的属性注解<code>queryLookupStrategy</code>.一些策略可能不能支持特定的数据库.</p>\n<ul>\n<li>CREATE 试图通过方法名构建一个指定查询.一般处理是从方法名移除一系列给定的前缀并解析方法其他部分.更多查询构建信息阅读Query creation.</li>\n<li>USE_DECLARED_QUERY试图查找一个准确的查询,并在找不到时抛出一个异常.查询可以被通过注解定义或者其它方式定义.查询特殊存储的文档了解存储的可用选择.如果repository基本组件在启动时不能为方法找到一个准确的查询,将会失败</li>\n<li>CREATE_IF_NOT_FOUND(默认)联合了CREATE和USE_DECLARED_QUERY.首先查找一个准确查询,如果没有找到,创建一个定制方法基于名字的查询.这是默认的查询策略,因此如果你没有做任何明确配置.它允许根据方法名快速查询定义,而且定制查询根据需要引入声明的查询.</li>\n</ul>\n<h3 id=\"4-4-2-查询创建\"><a href=\"#4-4-2-查询创建\" class=\"headerlink\" title=\"4.4.2 查询创建\"></a>4.4.2 查询创建</h3><p>建成Spring Data repository基本组件的查询构建机制有用的构建了repository所有实体类的约束查询.</p>\n<p>这个机制分隔方法前缀<code>find...By</code>,<code>read...By</code>,<code>query...By</code>,<code>count...By</code>以及<code>get...By</code>,并解析其他部分.这个引入条款可以表达包含的特性例如<code>Distinct</code>,来设置明确的标志在要生成的查询上.然而,第一个by扮演了分解符来指明真实条件的起始.分词在一个非常基本的水平,你可以在实体属性上定义条件并且连接使用and或or连接他们.</p>\n<p>例11.来自方法名的查询创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByEmailAddressAndLastname</span><span class=\"params\">(EmailAddress emailAddress, String</div><div class=\"line\">                                             lastname)</span></span>;</div><div class=\"line\">  <span class=\"comment\">// Enables the distinct flag for the query</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findDistinctPeopleByLastnameOrFirstname</span><span class=\"params\">(String lastname, String</div><div class=\"line\">                                                       firstname)</span></span>;</div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findPeopleDistinctByLastnameOrFirstname</span><span class=\"params\">(String lastname, String</div><div class=\"line\">                                                       firstname)</span></span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Enabling ignoring case for an individual property</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameIgnoreCase</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">  <span class=\"comment\">// Enabling ignoring case for all suitable properties</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameAndFirstnameAllIgnoreCase</span><span class=\"params\">(String lastname, String</div><div class=\"line\">                                                       firstname)</span></span>;</div><div class=\"line\">  <span class=\"comment\">// Enabling static ORDER BY for a query</span></div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameOrderByFirstnameAsc</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByLastnameOrderByFirstnameDesc</span><span class=\"params\">(String lastname)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析方法的实际结果取决于你创建查询的持久化存储.然而,这有些问题需要注意:</p>\n<ul>\n<li>表达式通常串行的连接属性的遍历与操作符.你可以使用and和or连接属性表达式.你也可以给属性表达式使用操作符,例如between,lessThan,granterThan,like.你可以使用的表达式操作符有between,LessThan,GreaterThan,Loke.被支持的操作符根据多样的数据库决定,因此查询你引用文档的恰当部分.</li>\n<li>方法解析支持为单独属性设置一个IgnoreCase标志(例如,findByLastnameIgnoreCase(…))或者为所有属性都支持忽略情况(通常是String情形,例如,findByLastnameAndFirstnameAllIgnoreCase(…)).忽略情况是否被支持由多样的数据库决定，所以具体存储查询方法在引用文档查询相关章节.</li>\n<li>你可以为查询方法引用的属性提供静态排序连接OrderBy子句并且提供排序方向(Asc或Desc).为创建一个查询方法支持动态排序,查看特殊参数处理.</li>\n</ul>\n<h3 id=\"4-4-3-属性表达式\"><a href=\"#4-4-3-属性表达式\" class=\"headerlink\" title=\"4.4.3 属性表达式\"></a>4.4.3 属性表达式</h3><p>属性表达式可以只为管理的实体类的直接属性使用，就像前面所展示的那样。查询常见时你已经确认解析的字段是管理的实体类的一个字段.然而,你也可以通过最近的字段定义一个约束.假设<code>Person</code>的<code>Address</code>有一个<code>ZipCode</code>字段.这种情况一个方法如果这样命名:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByAddressZipCode</span><span class=\"params\">(ZipCode zipCode)</span></span>;</div></pre></td></tr></table></figure>\n<p>创建属性遍历<code>x.address.zipCode</code>.决策算法从把全部(<code>AddressZipCode</code>)作为属性开始并且检查实体类依此命名的属性(小写开头).如果算法成功了,就是用这个属性.否则,算法将源码部分驼峰式大小写从右侧头部到尾巴分隔,并试图找到相应的属性,在我们的例子中,<code>AddressZip</code>和<code>Code</code>.如果从头部找到一个属性,算法将在这里生成树处理后面的部分,使用描述的方式分隔.如果第一个分隔没有匹配到,算法移动分割点到左侧继续(<code>Address</code>,<code>ZipCode</code>).</p>\n<p>这在大多数情况都可以使用,但也可能选择错误的属性.假设<code>Person</code>类也有一个<code>addressZip</code>属性.算法将匹配第一个匹配的,本质上选择了错误属性,最终失败(伴随的<code>addressZip</code>类型没有属性<code>code</code>).</p>\n<p>没了解决这种起义,你可以在方法名称内使用<code>_</code>手动的定义遍历点.所以我们的方法名称最终像这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">findByAddress_ZipCode</span><span class=\"params\">(ZipCode zipCode)</span></span>;</div></pre></td></tr></table></figure>\n<p>As we treat underscore as a reserved character we strongly advise to follow standard Java naming<br>conventions (i.e. not using underscores in property names but camel case instead) </p>\n<p>我们对待下划线当做一个保留关键字,我们强力建议遵循标准Java命名规范(例如,使用驼峰命名而不是下划线命名属性名称)</p>\n<h3 id=\"4-4-4-特殊参数处理\"><a href=\"#4-4-4-特殊参数处理\" class=\"headerlink\" title=\"4.4.4 特殊参数处理\"></a>4.4.4 特殊参数处理</h3><p>处理你查询中的参数,你可以定义简单的方法参数像上面的示例中.处理之外基本组件可以识别出某些特殊类型例如<code>Pageable</code>和<code>Sort</code>用来动态的编码和排序你的查询.</p>\n<p>例12.在查询方法使用<code>Pageable</code>,<code>Slice</code>和<code>Sort</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Page&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">Slice&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Sort sort)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<p>第一个方法允许你在通过一个<code>org.springframework.data.domain.Pageable</code>实例在查询方法中动态添加分页信息在你的静态定义查询中.一个<code>Page</code>清楚数据的全部数量和页面总数.它是通过触发计数的基础设施查询计算总数。这个代价可能是昂贵的具体取决于所使用的存储,可以用<code>Slice</code>代替.一个<code>Slict</code>只知道下一个<code>Slice</code>可到到哪里,当运行在一个大的结果集上时这可能已经足够了.排序选项也通过<code>Pageable</code>实例处理.如果你只需要排序,简单起见添加<code>org.springframework.data.domain.Sort</code>参数在你的方法.如你所见,简单返回一个列表.在这种情况下,额外元数据构建实际的<code>Page</code>实例将不会被创建(反过来这意味着,没有发出额外的统计查询所必须的)简单约束只在给定的范围内查询.</p>\n<blockquote>\n<p>注意</p>\n<p>为了尽早得到你查询了多少页,你必须出发一个格外统计查询.默认的,这个查询你实际触发的查询调用.</p>\n</blockquote>\n<h3 id=\"4-4-5-限制查询结果\"><a href=\"#4-4-5-限制查询结果\" class=\"headerlink\" title=\"4.4.5 限制查询结果\"></a>4.4.5 限制查询结果</h3><p>查询方法的结果可以通过关键<code>first</code>或者<code>top</code>限制,可以交换使用.一个可选的数值可以追加在top/first来指定返回的最大结果集.如果数字缺失,假定结果集大小是1.</p>\n<p>例13.查询中使用Top和First限制结果大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">User <span class=\"title\">findFirstByOrderByLastnameAsc</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\">User <span class=\"title\">findTopByOrderByAgeDesc</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\">Page&lt;User&gt; <span class=\"title\">queryFirst10ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">Slice&lt;User&gt; <span class=\"title\">findTop3ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findFirst10ByLastname</span><span class=\"params\">(String lastname, Sort sort)</span></span>;</div><div class=\"line\"><span class=\"function\">List&lt;User&gt; <span class=\"title\">findTop10ByLastname</span><span class=\"params\">(String lastname, Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<p>限制表达式也支持Distinct关键字.此外，对于将结果集设置为一个实例的查询，支持将结果包装到一个<code>Optional</code>.如果应用分页或分片限制查询分页(并且计算可用的页数)那么这可以应用limited结果.</p>\n<blockquote>\n<p>注意</p>\n<p>请注意，限制结果结合使用<code>Sort</code>的动态排序的结果允许参数可以表示“k”最小的查询方法以及“K”的查询方法最大的元素。</p>\n</blockquote>\n<h3 id=\"4-4-6-流式处理结果\"><a href=\"#4-4-6-流式处理结果\" class=\"headerlink\" title=\"4.4.6 流式处理结果\"></a>4.4.6 流式处理结果</h3><p>方法查询结果可以通过使用java 8<code>Stream&lt;T&gt;</code>逐步处理。</p>\n<p>特定的方法用来表示流而不是简单的包装查询结果在一个<code>Stream</code>数据存储</p>\n<p>例14 一个用java流8<code>Stream&lt;T&gt;</code>查询结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"select u from User u\"</span>)</div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">findAllByCustomQueryAndStream</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">readAllByFirstnameNotNull</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"select u from User u\"</span>)</div><div class=\"line\"><span class=\"function\">Stream&lt;User&gt; <span class=\"title\">streamAllPaged</span><span class=\"params\">(Pageable pageable)</span></span>;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>一个<code>Stream</code>潜在的包装底层数据存储在页数的资源中,因此使用完毕必须关闭.你可以使用<code>close()</code>方法手动关闭<code>Stream</code>或者使用一个Java7的try_with-resources块.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>(Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</div><div class=\"line\">  stream.forEach(...);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-4-7-异步查询结果\"><a href=\"#4-4-7-异步查询结果\" class=\"headerlink\" title=\"4.4.7 异步查询结果\"></a>4.4.7 异步查询结果</h3><p>Repository查询可以使用<code>Spring&#39;s asynchronous method execution capacity</code>执行异步.这意味着方法可以一执行立即返回,真实的查询执行发生在任务提交到一个Spring TaskExecutor.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">Future&lt;User&gt; <span class=\"title\">findByFirstname</span><span class=\"params\">(String firstname)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">CompletableFuture&lt;User&gt; <span class=\"title\">findOneByFirstname</span><span class=\"params\">(String firstname)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Async</span></div><div class=\"line\"><span class=\"function\">ListenableFuture&lt;User&gt; <span class=\"title\">findOneByLastname</span><span class=\"params\">(String lastname)</span></span>;</div></pre></td></tr></table></figure>\n<ol>\n<li>使用<code>java.util.concurrent.Future</code>作为返回类型</li>\n<li>使用一个Java8<code>java.util.current.CompletableFuture</code>作为返回类型</li>\n<li>使用一个<code>org.springframework.util.concurrent.ListenableFuture</code>作为返回类型</li>\n</ol>\n<h2 id=\"创建repository实例\"><a href=\"#创建repository实例\" class=\"headerlink\" title=\"创建repository实例\"></a>创建repository实例</h2><p>这个章节你创建实例和bean定义为repository接口定义.方法之一是手动的支持repository使用包含各个Spring Data模块的Spring命名空间装载,然而我们一般推荐使用Java配置的方法配置.</p>\n<h3 id=\"4-5-1-XML配置\"><a href=\"#4-5-1-XML配置\" class=\"headerlink\" title=\"4.5.1 XML配置\"></a>4.5.1 XML配置</h3><p>每个Spring Data module包含一个repository 元素,这可以让你简单的定义一个基本包,Spring为你扫描它.</p>\n<p>例16 通过XML启用Spring Data repositories</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans:beans</span> <span class=\"attr\">xmlns:beans</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/jpa\"</span></div><div class=\"line\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</div><div class=\"line\">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">        http://www.springframework.org/schema/data/jpa</div><div class=\"line\">        http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repositories\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans:beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在前面的实例中,让Spring扫描<code>com.acme.repositories</code>包和它的子包里继承<code>Repository</code>的接口或者它的子接口.找到的每个接口,继承组件注册持久化技术的<code>FactoryBean</code>来创建合适的代理处理执行查询方法.每个bean被注册在一个接口名称确定的bean name下,所以一个叫<code>UserRepository</code>将注册<code>userRepository</code>.基本包属性允许通配符,所以你可以定义一个规则扫描包.</p>\n<p><strong>使用过滤</strong></p>\n<p>默认的基本组件选取所有在配置的基本包下继承了持久化技术<code>Repositpry</code>接口以及子接口</p>\n<p>并且为他们创建一个bean实例.然而,你可能希望更细粒度的控制哪个接口bean实例被创建.为了实现这个你可以在<code>&lt;repository/&gt;</code>中使用<code>&lt;include-filter/&gt;</code>和<code>&lt;exclude-filter/&gt;</code>元素.语义完全等同于Spring的上下文命名空间中的元素.更多细节,查看他们的元素<code>Spring reference documentation</code></p>\n<p>例如，要将某些确定的接口排除实例化为repository，可以使用以下配置:</p>\n<p>例17. 使用exclude-filter元素</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;repository base-package=\"com.acme.repositories\"&gt;</div><div class=\"line\">  &lt;context:exclude-filter type=\"regex\" expression=\".*SomeRepository\" /&gt;</div><div class=\"line\">&lt;/repositories&gt;</div></pre></td></tr></table></figure>\n<p>这个示例从待实例化对象中排除所有以SomeRepository结尾的接口.</p>\n<h3 id=\"4-5-2-JavaConfig\"><a href=\"#4-5-2-JavaConfig\" class=\"headerlink\" title=\"4.5.2 JavaConfig\"></a>4.5.2 JavaConfig</h3><p>repository基础组件也可以使用一个存储的特殊的<code>@Enable${store}Repositories</code>注解在一个JavaConfig类上.入门介绍Spring容器Java基本Spring容器查看文档:<code>JavaConfig in the Spring reference documentaional</code></p>\n<p>一个简单配置启用Spring Data repositories像这样:</p>\n<p>例18. repository配置基于简单注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(<span class=\"string\">\"com.acme.repositories\"</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationConfiguration</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Bean</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> EntityManagerFactory <span class=\"title\">entityManagerFactory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// …</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>示例使用了JPA特有的注解,根据你使用的存储模块决定实际如何替换.示例定义<code>EntityManagerFactory</code>bean.查阅具体存储的配置</p>\n</blockquote>\n<h3 id=\"4-5-3-单独使用\"><a href=\"#4-5-3-单独使用\" class=\"headerlink\" title=\"4.5.3 单独使用\"></a>4.5.3 单独使用</h3><p>你也可以在Spring容器之外使用repository基础组件,例如在CDI环境.你仍然需要一些Spring库在你的classpath中,但是你可以以编程的方式启动.repository包装持久化技术支持的Spring Data模块提供RepositoryFactory,你可以向下面这样使用:</p>\n<p>例19. repository工厂单独使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">RepositoryFactorySupport factory = … <span class=\"comment\">// Instantiate factory here</span></div><div class=\"line\">UserRepository repository = factory.getRepository(UserRepository.class);</div></pre></td></tr></table></figure>\n<h2 id=\"4-6-定制Spring-Data仓库实现\"><a href=\"#4-6-定制Spring-Data仓库实现\" class=\"headerlink\" title=\"4.6 定制Spring Data仓库实现\"></a>4.6 定制Spring Data仓库实现</h2><p>时常有必要为一少部分仓库方法提供一个定制的实现.Spring数据存储库很容易允许您提供自定义存储库代码并将其与通用CRUD集成抽象和查询方法功能整合.</p>\n<h3 id=\"4-6-1-为单独仓库添加定制行为\"><a href=\"#4-6-1-为单独仓库添加定制行为\" class=\"headerlink\" title=\"4.6.1 为单独仓库添加定制行为\"></a>4.6.1 为单独仓库添加定制行为</h3><p>为了定制功能丰富一个仓库,你首先为定制功能定义一个接口和实现.使用你提供的仓库接口来继承自定义接口.</p>\n<p>例20. 定制仓库功能的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">someCustomMethod</span><span class=\"params\">(User user)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例21.定制功能的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRepositoryImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">someCustomMethod</span><span class=\"params\">(User user)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Your custom implementation</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意</p>\n<p>类可以被找到最重要的点是名字以Impl为后缀区别于仓库的核心接口(见下文)</p>\n</blockquote>\n<p>实现的本身没有依赖Spring Data,可以是一个标准的Spring bean.所以你可以使用标准的依赖注入行为给其他bean注入引用,像<code>JdbcTemplate</code>,切面的一部分等等.</p>\n<p>例22 修改你基本的仓库接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">UserRepositoryCustom</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// Declare query methods here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>让你的标准仓库接口继承定制的.这样做结合了CRUD和定制功能并使其可用于客户端.</p>\n<p><strong>配置</strong></p>\n<p>如果你使用命名空间配置,仓库基本组件扫描类所在包,根据扫描结果尝试自动定制实现.</p>\n<p>这些类需要遵循命名规范:给仓库接口名添加命名空间元素属性<code>repositoryimpl-postfix</code>.默认的后缀是<code>Impl</code></p>\n<p>例23. 配置示例</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> <span class=\"attr\">repository-impl-postfix</span>=<span class=\"string\">\"FooBar\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>第一个配置示例将查实查找一个类<code>com.acme.repository.UserRepositoryImpl</code>来作为定制藏局实现.然而第二个示例将尝试查找<code>com.acme.repository.UserRepositoryFooBar</code>.</p>\n<p><strong>手动指定</strong></p>\n<p>上面的方法可以正常工作,只有当你定制实现使用注解配置和自动注入,这将与其他Spring bean一样被对待.如果你定制的实现需要特殊处理,你可以像描述的简单定义一个bean并且命名它.基本组件将通过名称引用手动定义的bean定义而不是它自己创建一个.</p>\n<p>例24.手动指定定制实现</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans:bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userRepositoryImpl\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"…\"</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- further configuration --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans:bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-6-2为所有仓库添加定制行为\"><a href=\"#4-6-2为所有仓库添加定制行为\" class=\"headerlink\" title=\"4.6.2为所有仓库添加定制行为\"></a>4.6.2为所有仓库添加定制行为</h3><p>当你希望把一个单独的方法添加到你所有的仓库接口中时,上面的方法就不可行了.为了添加定制到所有的仓库,你首先添加一个中间接口来定义共享的行为.</p>\n<p>例25 定义共享定制行为接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NoRepositoryBean</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt;</div><div class=\"line\">  <span class=\"keyword\">extends</span> <span class=\"title\">PagingAndSortingRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sharedCustomMethod</span><span class=\"params\">(ID id)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在你独立的仓库接口将继承这个中间接口而不是<code>Repository</code>接口来包含功能的定义.接下来创建一个中间接口的实现继承持久化具体仓库的基本类.这个类后面将作为仓库代理的基本类.</p>\n<p>例26 定制仓库基本类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRepositoryImpl</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt;</div><div class=\"line\">  <span class=\"keyword\">extends</span> <span class=\"title\">SimpleJpaRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EntityManager entityManager;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyRepositoryImpl</span><span class=\"params\">(JpaEntityInformation entityInformation,</div><div class=\"line\">                          EntityManager entityManager)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(entityInformation, entityManager);</div><div class=\"line\">    <span class=\"comment\">// Keep the EntityManager around to used from the newly introduced methods.</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.entityManager = entityManager;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sharedCustomMethod</span><span class=\"params\">(ID id)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// implementation goes here</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>警告</p>\n<p>这个类需要有一个构造方法调用父类具体存储仓库工厂实现.万一仓库基础类有多个构造,覆盖包括一个<code>EntityInformation</code>加上存储具体基本组件对象(例如一个<code>EntityManager</code>或者模板类)</p>\n</blockquote>\n<p>Spring<code>&lt;repository/&gt;</code>命名空间下的默认行为为所有接口提供一个实现.这意味着如果处于其当前状态，<code>MyRepository</code>的实现实例将由Spring创建.这当然不是被期望的,它只是作为一个用来定义实体的 <code>Repository</code>和真实仓库接口的中间接口.为了排除一个继承<code>Repository</code>的接口被当做一个仓库接口实例化,你可以给它使用<code>@NoRepositoryBean</code>(像上面)或者把它从配置中<code>base-package</code>移除.</p>\n<p>最后一步是让Spring Data基本组件识别到定制的仓库基本类.在JavaConf使用注解<code>@Enable...Repository</code>的属性<code>repositoryBaseClass</code>完成:</p>\n<p>例27 使用JavaConfig配置一个定制仓库基本类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(repositoryBaseClass = MyRepositoryImpl.class)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationConfiguration</span> </span>&#123; … &#125;</div></pre></td></tr></table></figure>\n<p>类似的属性在XML命名空间中也可以找到.</p>\n<p>例28 使用XML配置一个定制仓库基本类</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.acme.repository\"</span></div><div class=\"line\">              <span class=\"attr\">base-class</span>=<span class=\"string\">\"….MyRepositoryImpl\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"4-7-Spring-Data扩展\"><a href=\"#4-7-Spring-Data扩展\" class=\"headerlink\" title=\"4.7 Spring Data扩展\"></a>4.7 Spring Data扩展</h2><p>这部分说明Spring Data一系列的扩展功能,可以使Spring Dta使用多样的上下文.目前大部分集成是针对Spring MVC.</p>\n<h3 id=\"4-7-1-Querydsl扩展\"><a href=\"#4-7-1-Querydsl扩展\" class=\"headerlink\" title=\"4.7.1 Querydsl扩展\"></a>4.7.1 Querydsl扩展</h3><p>Querydsl是一个框架,通过它的流式API构建静态类型的SQL类查询.</p>\n<p>多个Spring Data模块通过<code>QueryDslPredicateExecutor</code>与Querydsl集成.</p>\n<p>例29 QueryDslPredicateExecutor接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"function\">T <span class=\"title\">findOne</span><span class=\"params\">(Predicate predicate)</span></span>; ①</div><div class=\"line\">    <span class=\"function\">Iterable&lt;T&gt; <span class=\"title\">findAll</span><span class=\"params\">(Predicate predicate)</span></span>; ②</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">count</span><span class=\"params\">(Predicate predicate)</span></span>; ③</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">exists</span><span class=\"params\">(Predicate predicate)</span></span>; ④</div><div class=\"line\">    <span class=\"comment\">// … more functionality omitted.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>① 查询并返回一个匹配<code>Predicate</code>的单例实体</p>\n<p>②查询并返回所有匹配<code>Predicate</code>的实体</p>\n<p>③ 返回匹配<code>Predicate</code>的实体数量</p>\n<p>④  返回是否存在一个匹配<code>Predicate</code>的实体</p>\n<p>为了简单的使用Querydsl功能,在你的仓库接口继承<code>QueryDslPredicateExecutor</code>.</p>\n<p>例30 在仓库集成QueryDsl</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt;,</div><div class=\"line\">  <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面这样就可以使用Querydsl的<code>Predicate</code>书写类型安全的查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Predicate predicate = user.firstname.equalsIgnoreCase(<span class=\"string\">\"dave\"</span>)</div><div class=\"line\">  .and(user.lastname.startsWithIgnoreCase(<span class=\"string\">\"mathews\"</span>));</div><div class=\"line\">userRepository.findAll(predicate);</div></pre></td></tr></table></figure>\n<h3 id=\"4-7-2-Web支持\"><a href=\"#4-7-2-Web支持\" class=\"headerlink\" title=\"4.7.2 Web支持\"></a>4.7.2 Web支持</h3><blockquote>\n<p>注意</p>\n<p>本节包含Spring Data Web支持的文档是在1.6范围内的Spring Data Commons实现的.因为支持新引入的内容改变了很多东西，我们保留了旧行为的文档在”遗留Web支持”部分.</p>\n</blockquote>\n<p>如果模块支持仓库编程模型，那么Spring Data模块附带了各种Web模块支持.Web关联的东西需要Spring MVC的JAR包位于classpath路径下,它们中有些甚至提供了Spring HATEOAS集成.一般情况,集成方式支持使用<code>@EnableSpringDataWebSupport</code>注解在你的JavaConfig配置类.</p>\n<p>例31 启用Spring Data web支持</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@EnableWebMvc</span></div><div class=\"line\"><span class=\"meta\">@EnableSpringDataWebSupport</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p><code>@EnableSpringDataWebSupport</code>注解注册了一些组件，我们将在稍后讨论.注解还将在类路径上检测Spring HATEOAS，如果才在将为其注册集成组件.</p>\n<p>作为可选项,如果你使用XML配置,注册<code>SpringDataWebSupport</code>或者<code>HateoasWareSpringDataWebSupport</code>作为Spring bean:</p>\n<p>例32 用XML启用Spring Data web支持</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.data.web.config.SpringDataWebConfiguration\"</span> /&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- If you're using Spring HATEOAS as well register this one *instead* of the</div><div class=\"line\">former --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>= <span class=\"string\">\"org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>基本Web支持</strong></p>\n<p>上面展示的的配置设置将注册几个基本组件：</p>\n<ul>\n<li>一个<code>DomainClassConverter</code>启用Spring MVC来根据请求参数或路径变量管理仓例实体类的实例</li>\n<li><code>HandlerMethodArgumentResolver</code>实现让Spring MVC从请求参数解析Pageable和Sort实例.</li>\n</ul>\n<p><strong>实体类转换</strong></p>\n<p><code>DomainClassConverter</code>允许你在Spring MVC控制器方法签名中直接使用实体类型,因此你不必手动的通过仓库查询实例:</p>\n<p>例33 一个Spring MVC控制器在方法签名中使用实体类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> User user, Model model) </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"userForm\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如你所见,方法直接接收一个User实例并没有更进一步的查询是否必要.实例可以通过Spring MVC将路径变量转换为实体类的id类型并最终通过在实体类型注册的仓库实例上调用<code>findOne(...)</code>访问实例转换得到.</p>\n<blockquote>\n<p>注意</p>\n<p>当前的仓库必须实现<code>CrudRepository</code>做好准备被发现来进行转换.</p>\n</blockquote>\n<p><strong>为了分页和排序分解方法参数</strong></p>\n<p>上面的配置片段还注册了一个<code>PageableHandlerMethodArgumentResolver</code>和一个<code>SortHandlerMethodArgumentResolver</code>实例.注册使得Pageable和Sort成为有效的控制器方法参数.</p>\n<p>例34 使用Pageable作为控制器方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> UserRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUsers</span><span class=\"params\">(Model model, Pageable pageable)</span> </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"users\"</span>, repository.findAll(pageable));</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"users\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法签名将使Spring MVC尝试使用下面的默认配置从请求参数中转换一个Pageable实例:</p>\n<p>表1 请求参数转换Pageable实例</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>page</td>\n<td>要检索的页面,索引为0,默认为0</td>\n</tr>\n<tr>\n<td>size</td>\n<td>要检索的页面大小,默认20</td>\n</tr>\n<tr>\n<td>sort</td>\n<td>被排序的属性应以格式`property,property(, ASC\\</td>\n<td>DESC)`表示.默认生序排序,如果你希望改变排序顺序,则使用多个排序参数,例如?sort=firstname&amp;sort=lastname,asc</td>\n</tr>\n</tbody>\n</table>\n<p>为了定制行为,可以继承<code>SpringDataWebConfiguration</code>或者启用等效的HATEOAS并覆盖<code>pageableResolver()</code>或<code>sortResolver()</code>方法并导入你的自定义配置文件替代@Enable-注解.</p>\n<p>有一种情况你需要多个<code>Pageable</code>或<code>Sort</code>实例从请求转换(例如处理多个表单),你可以使用Spring的<code>@Qualifier</code>注解来互相区别.请求参数必须以<code>${qualifier}为</code>前缀.这样一个方法的签名像这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUsers</span><span class=\"params\">(Model model, </div><div class=\"line\">                        @Qualifier(<span class=\"string\">\"foo\"</span>)</span>Pagebale first, </div><div class=\"line\">                        @<span class=\"title\">Qualifier</span><span class=\"params\">(<span class=\"string\">\"bar\"</span>)</span> Pageable second) </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你必须填充foo_page和bar_page等.</p>\n<p>默认的<code>Pageable</code>在方法中处理等价于一个<code>new PageRequest(0, 20)</code>,但是可以使用<code>@PageableDefaults</code>注解在<code>Pageable</code>参数上定制.</p>\n<p><strong>Hypermedia支持分页</strong></p>\n<p>Spring HATEOAS包装了一个代表模型的类<code>PageResources</code> ,</p>\n<p>它可以使用Page实例包装必要的Page元数据内容作为连接让客户端导航页面.一个页面到一个<code>PageResources</code>的转换被Spring HATEOAS的<code>ResourceAssembler</code>接口实现<code>PagedResourcesAssembler</code>来完成.</p>\n<p>例35 使用一个PagedResourcesAssembler作为控制器方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> PersonRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/persons\"</span>, method = RequestMethod.GET)</div><div class=\"line\">  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,</div><div class=\"line\">                                             PagedResourcesAssembler assembler) &#123;</div><div class=\"line\">    Page&lt;Person&gt; persons = repository.findAll(pageable);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像上面这样配置将允许<code>PageResourcesAssembler</code>作为控制器方法的一个参数.在这调用toResources(…)方法有以下作用:</p>\n<ul>\n<li><code>Page</code>的内容将<code>PageResources</code>实例的内容</li>\n<li><code>PageResources</code>将获得<code>PageMetadata</code>实例,该实例由Page和基础的PageRequest中的信息填充</li>\n<li><code>PageResources</code>获得<code>prev</code>和<code>next</code>连接,添加这些依赖在页面.这些链接将指向uri方法的调用映射.页码参数根据<code>PageableHandlerMethodArgumentResolver</code>添加到参数以在后面被转换.</li>\n</ul>\n<p>假设我们有30个Person实例在数据库.你现在可以触发一个GET请求 <a href=\"http://localhost:8080/persons\">http://localhost:8080/persons</a>, 你将可以看到类似下面的内容:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; \"links\" : [ &#123; \"rel\" : \"next\",</div><div class=\"line\">\"href\" : \"http://localhost:8080/persons?page=1&amp;size=20 &#125;</div><div class=\"line\">],</div><div class=\"line\">\"content\" : [</div><div class=\"line\">… // 20 Person instances rendered here</div><div class=\"line\">],</div><div class=\"line\">\"pageMetadata\" : &#123;</div><div class=\"line\">\"size\" : 20,</div><div class=\"line\">\"totalElements\" : 30,</div><div class=\"line\">\"totalPages\" : 2,</div><div class=\"line\">\"number\" : 0</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以看到编译生成了正确的URI，并且还会提取默认配置转换参数到即将到来的请求中的<code>Pageable</code>.这意味着,如果你改变配置,链接也将自动跟随改变.默认情况下，编译指向控制器执行的方法，但是这可以被一个自定义链接作为基本构建来构成分页的<code>Link</code>重载<code>PagedResourcesAssembler.toResource（...）</code>方法定制.</p>\n<p><strong>Querydsl web 支持</strong></p>\n<p>那些整合了<code>QueryDSL</code>的存储可能从<code>Request</code>查询字符串中的属性驱动查询.</p>\n<p>这意味着前面例子的查询字符串可以给出<code>User</code>的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">?firstname=Dave&amp;lastname=Matthews</div></pre></td></tr></table></figure>\n<p>可以被转换为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">QUser.user.firstname.eq(<span class=\"string\">\"Dave\"</span>).and(QUser.user.lastname.eq(<span class=\"string\">\"Matthews\"</span>))</div></pre></td></tr></table></figure>\n<p>使用了<code>QuerydslPredicateArgumentResolver</code>.</p>\n<blockquote>\n<p>注意</p>\n<p>当在类路径上找到Querydsl时，该功能将在@EnableSpringDataWebSupport注解中自动启用</p>\n</blockquote>\n<p>添加一个<code>@QuerydslPredicate</code>到一个方法签名将提供一个就绪的<code>Predicate</code>,可以通过<code>QueryDslPredicateExecutor</code>执行.</p>\n<blockquote>\n<p>提示</p>\n<p>类型信息通常从返回方法上解析.由于这些信息不一定匹配实体类型,使用<code>QuerydslPredicate</code>的<code>root</code>属性可能是个好主意.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Autowired</span> UserRepository repository;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/\"</span>, method = RequestMethod.GET)</div><div class=\"line\">  <span class=\"function\">String <span class=\"title\">index</span><span class=\"params\">(Model model, @QuerydslPredicate(root = User.class)</span> Predicate predicate,</div><div class=\"line\">              Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt;</div><div class=\"line\">    parameters) </span>&#123;</div><div class=\"line\">        model.addAttribute(<span class=\"string\">\"users\"</span>, repository.findAll(predicate, pageable));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"index\"</span>;</div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为User转换匹配查询字符串参数的<code>Predicate</code></p>\n<p>默认的绑定规则如下:</p>\n<ol>\n<li><p><code>Object</code>在简单属性上如同<code>eq</code></p>\n</li>\n<li><p><code>Object</code>在集合作为属性如同<code>contains</code></p>\n</li>\n<li><p><code>Collection</code>在简单属性上如同<code>in</code></p>\n</li>\n</ol>\n<p>这些绑定可以通过<code>@QuerydslPredicate</code>的<code>bindings</code>属性定制或者使用Java8<code>default methods</code>给仓库接口添加<code>QuerydslBinderCustomizer</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserReposotory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CurdRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">String</span>&gt;, </div><div class=\"line\">  <span class=\"title\">QueryDslPredicateExecutor</span>&lt;<span class=\"title\">User</span>&gt;,</div><div class=\"line\">  <span class=\"title\">QuerydslBinderCustomizer</span>&lt;<span class=\"title\">QUser</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">customize</span><span class=\"params\">(QuerydslBindings bindings, QUser user)</span> </span>&#123;</div><div class=\"line\">      bindings.bind(user.username).first((path, value) -&gt; path.contains(value));</div><div class=\"line\">      bindings.bind(String.class).first((StringPath path, String value) -&gt;</div><div class=\"line\">                                        path.containsIgnoreCase(value));</div><div class=\"line\">      bindings.excluding(user.password);</div><div class=\"line\">  \t&#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><code>QueryDslPredicateExecutor</code>为<code>Predicate</code>提供特殊的查询方法提供入口</li>\n<li>在仓库接口定义<code>QuerydslBinderCustomizer</code>将自动注解<code>@QuerydslPredicate(bindings=...)</code></li>\n<li>为<code>username</code>属性定义绑定,绑定到一个简单集合</li>\n<li>为<code>String</code>属性定义默认绑定到一个不区分大小写的集合</li>\n<li>从<code>Predicate</code>移除密码属性</li>\n</ol>\n<h3 id=\"4-7-3-仓库填充\"><a href=\"#4-7-3-仓库填充\" class=\"headerlink\" title=\"4.7.3 仓库填充\"></a>4.7.3 仓库填充</h3><p>如果你使用Spring JDBC模块,你可能熟悉在<code>DataSource</code>使用SQL脚本来填充.一个类似的抽象在仓库级别可以使用,尽管它不是使用SQL作为数据定义语言,因为它必须由存储决定.填充根据仓库支持XML(通过Spring的OXM抽象)和JSON(通过Jackson)定义数据.</p>\n<p>假设你有一个文件<code>data.json</code>内容如下:</p>\n<p>例36 JSON定义的数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ &#123; <span class=\"attr\">\"_class\"</span> : <span class=\"string\">\"com.acme.Person\"</span>,</div><div class=\"line\">     <span class=\"attr\">\"firstname\"</span> : <span class=\"string\">\"Dave\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"lastname\"</span> : <span class=\"string\">\"Matthews\"</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">\"_class\"</span> : <span class=\"string\">\"com.acme.Person\"</span>,</div><div class=\"line\">     <span class=\"attr\">\"firstname\"</span> : <span class=\"string\">\"Carter\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"lastname\"</span> : <span class=\"string\">\"Beauford\"</span> &#125; ]</div></pre></td></tr></table></figure>\n<p>你可以容易的根据Spring Data Commons提供仓库的命名空间填充元素填充你的仓库.为了填充前面的数据到你的PersonRepository,像下面这样配置:</p>\n<p>例37 声明一个Jackson仓库填充</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">    <span class=\"attr\">xmlns:repository</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/repository\"</span></div><div class=\"line\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</div><div class=\"line\">      http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">      http://www.springframework.org/schema/data/repository</div><div class=\"line\">      http://www.springframework.org/schema/data/repository/spring-repository.xsd\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">repository:jackson2-populator</span> <span class=\"attr\">locations</span>=<span class=\"string\">\"classpath:data.json\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这样的声明可以让<code>data.json</code>文件可以被一个Jackson的<code>ObjectMpper</code>读取和反序列化.</p>\n<p>JSON将要解析的对象类型由检查JSON文档的<code>_class</code>属性决定.基本组件将最终选择合适的仓库去处理反序列化的对象.</p>\n<p>要使用XML定义数据填充仓库,你可以使用<code>unmarshaller-populator</code>元素.你配置它使用Spring OXM提供给你的XML装配选项.在Spring reference documentation查看更多细节.</p>\n<p>例38 声明一个装配仓库填充器(使用JAXB)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:repository</span>=<span class=\"string\">\"http://www.springframework.org/schema/data/repository\"</span></div><div class=\"line\">      <span class=\"attr\">xmlns:oxm</span>=<span class=\"string\">\"http://www.springframework.org/schema/oxm\"</span></div><div class=\"line\">      <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</div><div class=\"line\">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">        http://www.springframework.org/schema/data/repository</div><div class=\"line\">        http://www.springframework.org/schema/data/repository/spring-repository.xsd</div><div class=\"line\">        http://www.springframework.org/schema/oxm</div><div class=\"line\">        http://www.springframework.org/schema/oxm/spring-oxm.xsd\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repository:unmarshaller-populator</span> <span class=\"attr\">locations</span>=<span class=\"string\">\"classpath:data.json\"</span></div><div class=\"line\">        <span class=\"attr\">unmarshaller-ref</span>=<span class=\"string\">\"unmarshaller\"</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">oxm:jaxb2-marshaller</span> <span class=\"attr\">contextPath</span>=<span class=\"string\">\"com.acme\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-7-4-遗留web支持\"><a href=\"#4-7-4-遗留web支持\" class=\"headerlink\" title=\"4.7.4 遗留web支持\"></a>4.7.4 遗留web支持</h3><p><strong>Spring MVC的实体类绑定</strong></p>\n<p>如果正在开发Spring MVC web应用,你通常必须从URL中解析实体类的id.默认的,你的任务是转化请求参数或URL参数到实体类并将它移交给下面或直接在实体上操作业务逻辑.这看起来像下面这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> UserRepository userRepository;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</div><div class=\"line\">    Assert.notNull(repository, <span class=\"string\">\"Repository must not be null!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.userRepository = userRepository;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> Long id, Model model) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Do null check for id</span></div><div class=\"line\">    User user = userRepository.findOne(id);</div><div class=\"line\">    <span class=\"comment\">// Do null check for user</span></div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"user\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先你为每个控制器定义一个依赖的仓库来查找它们分别管理的实体.查询实体也是样板,因为它总是一个<code>findOne(...)</code>调用.幸运的Spring提供了方法来注册自定义组件,允许一个String值转换到一个属性类型.</p>\n<p><strong>属性编辑</strong></p>\n<p>Spring3.0之前Java<code>PropertyEditors</code>被使用.为了集成这些,Spring Data提出一个<code>DomainClassPropertyEditorRegistrar</code>来查询所有注册到<code>ApplicatonContext</code>的Spring Data仓库和一个定制的<code>PropertyEditor</code>来管理实体类.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"webBindingInitializer\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"….web.bind.support.ConfigurableWebBindingInitializer\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"propertyEditorRegistrars\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=</div><div class=\"line\">          <span class=\"string\">\"org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar\"</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果你已经像上面这样配置Spring MVC,你可以向下面这样配置你的控制器,从而减少不清晰和样板式的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/users\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">showUserForm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> User user, Model model) </span>&#123;</div><div class=\"line\">    model.addAttribute(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"userForm\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"【重拾网络】应用层","date":"2017-07-20T13:49:20.000Z","_content":"## 原理\n\n- 网络应用的体系结构：CS, P2P, 混合\n\n- 不同端系统上的进程通信方式：跨越计算机网络交换报文\n\n- 套接字：传输基础设施向进程提供的 API\n\n- 进程寻址：\n  - 主机地址：IP\n  - 进程标示符：端口号\n\n\n- 网络应用的需求：\n  - 数据丢失/可靠性\n  - 时间/延迟\n  - 带宽\n  - 安全\n\n\n- 传输层提供的服务：\n  - TCP:\n    - 面向连接\n    - 可靠传输\n    - 流量控制\n    - 拥塞控制\n  - UDP\n    - 无连接\n    - 不可靠数据传输\n\n\n  TCP & UDP 都无法提供时间/延时保障、最小带宽保障\n\n  安全传输服务：在 TCP 套接字基础上实现的应用层协议——SSL(Secure Socket Layer)\n\n## 应用层协议\n\n应用层协议定义的内容：\n- 交换的报文类型\n- 各种报文语法\n- 字段语义\n- 一个进程何时 & 如何发送报文\n\n### HTTP\n\n这部分不知道怎么说啊，内容有点多、有点杂，简单记一下，尤其是众多头部。\n简单记一下，挖个坑后期填。\n\n- 连接类型：\n  - 非持久连接：HTTP 1.0 版本默认\n  - 持久连接：HTTP 1.1 版本默认\n    - 无流水线：使用一个 TCP 连接，一个一个请求\n    - 流水线：并行请求\n\n\n- 各种头部信息\n\n\n- 无状态 & Cokite 技术\n\n\n- 代理 & 缓存\n\n  条件 GET\n\n  对于相同 IP 的访问，HOST 头部完整指定主机名/域名URI \n\n### EMAIL\n\n邮件系统构成：用户代理，邮件服务器（邮箱，报文队列）、简单邮件传输协议\n\n邮件协议基于命令/响应模式\n- 命令：ASCII 文本\n- 响应：状态代码和语句\n\n#### SMTP\n\n简单邮件传输协议，特点：\n1. 邮件报文体只能采用简单的 7 比特 ASCII 表示\n2. 一般不使用中间邮件服务器，邮件不在中间某个服务器留存\n3. 使用 TCP 可靠数据传输服务，端口 25\n4. MIME：多媒体邮件扩展，头部增加 MIME 内容类型\n\n\n与 HTTP 比较：\n1. 都建立在 TCP 连接，都是 持续连接\n2. HTTP 是拉协议，SMTP 是推协议\n3. SMTP 要求每个报文使用 7 比特 ASCII, HTTP 不受该限制\n4. 对混合消息处理，HTTP 把每个对象封装在一个相应报文里，SMTP 把所有对象放在一个报文\n\n#### POP3 & IMAP\n\n邮件访问协议\n\nPOP3 特点：\n1. 实现简单\n2. 使用 TCP 连接，110 端口\n3. 三个阶段：\n   1. 认证\n   2. 事务处理\n   3. 退出\n4. 无状态\n\n\nIMAP 特点：\n1. 实现相对复杂\n2. 使用 TCP 连接，端口 145\n3. 可以把邮件与文件夹联系起来\n4. 允许用户代理获取邮件\n5. 有状态\n\n#### TELNET 收发邮件 demo\n\n```shell\n// 使用 SMTP 发邮件\ntelnet smtp.163.com 25\n\nHELO 163.com\n\nAUTH LOGIN\n\nBase64(YourUsername)\n\nBase64(YourPassword)\n\nMAIL FROM: <${Your Email Address}>\n\nRCPT TO: <${Receiver's Email Address}>\n\ndata\n\nSubject:${SUBJECT}\nFrom:${SENDER}\nTo:${RECEIVER}\n\n${DATA}\n.\n\n// 使用 POP3 收邮件\nTelnet pop3.163.com 110\n\nUser:YourUsername\n\nPass:yourPassword\n\nList\n\nRetr 邮件编号\n\nDele 邮件编号\n\nQuit\n```\n\n### DNS\n\n[【重拾网络】DNS](http://zhangh.tk/2017/07/20/【重拾网络】DNS/)\n","source":"_posts/【重拾网络】应用层.md","raw":"---\ntitle: 【重拾网络】应用层\ndate: 2017-07-20 21:49:20\ntags: 网络\ncategories: 网络\n---\n## 原理\n\n- 网络应用的体系结构：CS, P2P, 混合\n\n- 不同端系统上的进程通信方式：跨越计算机网络交换报文\n\n- 套接字：传输基础设施向进程提供的 API\n\n- 进程寻址：\n  - 主机地址：IP\n  - 进程标示符：端口号\n\n\n- 网络应用的需求：\n  - 数据丢失/可靠性\n  - 时间/延迟\n  - 带宽\n  - 安全\n\n\n- 传输层提供的服务：\n  - TCP:\n    - 面向连接\n    - 可靠传输\n    - 流量控制\n    - 拥塞控制\n  - UDP\n    - 无连接\n    - 不可靠数据传输\n\n\n  TCP & UDP 都无法提供时间/延时保障、最小带宽保障\n\n  安全传输服务：在 TCP 套接字基础上实现的应用层协议——SSL(Secure Socket Layer)\n\n## 应用层协议\n\n应用层协议定义的内容：\n- 交换的报文类型\n- 各种报文语法\n- 字段语义\n- 一个进程何时 & 如何发送报文\n\n### HTTP\n\n这部分不知道怎么说啊，内容有点多、有点杂，简单记一下，尤其是众多头部。\n简单记一下，挖个坑后期填。\n\n- 连接类型：\n  - 非持久连接：HTTP 1.0 版本默认\n  - 持久连接：HTTP 1.1 版本默认\n    - 无流水线：使用一个 TCP 连接，一个一个请求\n    - 流水线：并行请求\n\n\n- 各种头部信息\n\n\n- 无状态 & Cokite 技术\n\n\n- 代理 & 缓存\n\n  条件 GET\n\n  对于相同 IP 的访问，HOST 头部完整指定主机名/域名URI \n\n### EMAIL\n\n邮件系统构成：用户代理，邮件服务器（邮箱，报文队列）、简单邮件传输协议\n\n邮件协议基于命令/响应模式\n- 命令：ASCII 文本\n- 响应：状态代码和语句\n\n#### SMTP\n\n简单邮件传输协议，特点：\n1. 邮件报文体只能采用简单的 7 比特 ASCII 表示\n2. 一般不使用中间邮件服务器，邮件不在中间某个服务器留存\n3. 使用 TCP 可靠数据传输服务，端口 25\n4. MIME：多媒体邮件扩展，头部增加 MIME 内容类型\n\n\n与 HTTP 比较：\n1. 都建立在 TCP 连接，都是 持续连接\n2. HTTP 是拉协议，SMTP 是推协议\n3. SMTP 要求每个报文使用 7 比特 ASCII, HTTP 不受该限制\n4. 对混合消息处理，HTTP 把每个对象封装在一个相应报文里，SMTP 把所有对象放在一个报文\n\n#### POP3 & IMAP\n\n邮件访问协议\n\nPOP3 特点：\n1. 实现简单\n2. 使用 TCP 连接，110 端口\n3. 三个阶段：\n   1. 认证\n   2. 事务处理\n   3. 退出\n4. 无状态\n\n\nIMAP 特点：\n1. 实现相对复杂\n2. 使用 TCP 连接，端口 145\n3. 可以把邮件与文件夹联系起来\n4. 允许用户代理获取邮件\n5. 有状态\n\n#### TELNET 收发邮件 demo\n\n```shell\n// 使用 SMTP 发邮件\ntelnet smtp.163.com 25\n\nHELO 163.com\n\nAUTH LOGIN\n\nBase64(YourUsername)\n\nBase64(YourPassword)\n\nMAIL FROM: <${Your Email Address}>\n\nRCPT TO: <${Receiver's Email Address}>\n\ndata\n\nSubject:${SUBJECT}\nFrom:${SENDER}\nTo:${RECEIVER}\n\n${DATA}\n.\n\n// 使用 POP3 收邮件\nTelnet pop3.163.com 110\n\nUser:YourUsername\n\nPass:yourPassword\n\nList\n\nRetr 邮件编号\n\nDele 邮件编号\n\nQuit\n```\n\n### DNS\n\n[【重拾网络】DNS](http://zhangh.tk/2017/07/20/【重拾网络】DNS/)\n","slug":"【重拾网络】应用层","published":1,"updated":"2017-07-20T14:04:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2rp003wd82euczj48go","content":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ul>\n<li><p>网络应用的体系结构：CS, P2P, 混合</p>\n</li>\n<li><p>不同端系统上的进程通信方式：跨越计算机网络交换报文</p>\n</li>\n<li><p>套接字：传输基础设施向进程提供的 API</p>\n</li>\n<li><p>进程寻址：</p>\n<ul>\n<li>主机地址：IP</li>\n<li>进程标示符：端口号</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>网络应用的需求：<ul>\n<li>数据丢失/可靠性</li>\n<li>时间/延迟</li>\n<li>带宽</li>\n<li>安全</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>传输层提供的服务：<ul>\n<li>TCP:<ul>\n<li>面向连接</li>\n<li>可靠传输</li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n</ul>\n</li>\n<li>UDP<ul>\n<li>无连接</li>\n<li>不可靠数据传输</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>  TCP &amp; UDP 都无法提供时间/延时保障、最小带宽保障</p>\n<p>  安全传输服务：在 TCP 套接字基础上实现的应用层协议——SSL(Secure Socket Layer)</p>\n<h2 id=\"应用层协议\"><a href=\"#应用层协议\" class=\"headerlink\" title=\"应用层协议\"></a>应用层协议</h2><p>应用层协议定义的内容：</p>\n<ul>\n<li>交换的报文类型</li>\n<li>各种报文语法</li>\n<li>字段语义</li>\n<li>一个进程何时 &amp; 如何发送报文</li>\n</ul>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><p>这部分不知道怎么说啊，内容有点多、有点杂，简单记一下，尤其是众多头部。<br>简单记一下，挖个坑后期填。</p>\n<ul>\n<li>连接类型：<ul>\n<li>非持久连接：HTTP 1.0 版本默认</li>\n<li>持久连接：HTTP 1.1 版本默认<ul>\n<li>无流水线：使用一个 TCP 连接，一个一个请求</li>\n<li>流水线：并行请求</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>各种头部信息</li>\n</ul>\n<ul>\n<li>无状态 &amp; Cokite 技术</li>\n</ul>\n<ul>\n<li><p>代理 &amp; 缓存</p>\n<p>条件 GET</p>\n<p>对于相同 IP 的访问，HOST 头部完整指定主机名/域名URI </p>\n</li>\n</ul>\n<h3 id=\"EMAIL\"><a href=\"#EMAIL\" class=\"headerlink\" title=\"EMAIL\"></a>EMAIL</h3><p>邮件系统构成：用户代理，邮件服务器（邮箱，报文队列）、简单邮件传输协议</p>\n<p>邮件协议基于命令/响应模式</p>\n<ul>\n<li>命令：ASCII 文本</li>\n<li>响应：状态代码和语句</li>\n</ul>\n<h4 id=\"SMTP\"><a href=\"#SMTP\" class=\"headerlink\" title=\"SMTP\"></a>SMTP</h4><p>简单邮件传输协议，特点：</p>\n<ol>\n<li>邮件报文体只能采用简单的 7 比特 ASCII 表示</li>\n<li>一般不使用中间邮件服务器，邮件不在中间某个服务器留存</li>\n<li>使用 TCP 可靠数据传输服务，端口 25</li>\n<li>MIME：多媒体邮件扩展，头部增加 MIME 内容类型</li>\n</ol>\n<p>与 HTTP 比较：</p>\n<ol>\n<li>都建立在 TCP 连接，都是 持续连接</li>\n<li>HTTP 是拉协议，SMTP 是推协议</li>\n<li>SMTP 要求每个报文使用 7 比特 ASCII, HTTP 不受该限制</li>\n<li>对混合消息处理，HTTP 把每个对象封装在一个相应报文里，SMTP 把所有对象放在一个报文</li>\n</ol>\n<h4 id=\"POP3-amp-IMAP\"><a href=\"#POP3-amp-IMAP\" class=\"headerlink\" title=\"POP3 &amp; IMAP\"></a>POP3 &amp; IMAP</h4><p>邮件访问协议</p>\n<p>POP3 特点：</p>\n<ol>\n<li>实现简单</li>\n<li>使用 TCP 连接，110 端口</li>\n<li>三个阶段：<ol>\n<li>认证</li>\n<li>事务处理</li>\n<li>退出</li>\n</ol>\n</li>\n<li>无状态</li>\n</ol>\n<p>IMAP 特点：</p>\n<ol>\n<li>实现相对复杂</li>\n<li>使用 TCP 连接，端口 145</li>\n<li>可以把邮件与文件夹联系起来</li>\n<li>允许用户代理获取邮件</li>\n<li>有状态</li>\n</ol>\n<h4 id=\"TELNET-收发邮件-demo\"><a href=\"#TELNET-收发邮件-demo\" class=\"headerlink\" title=\"TELNET 收发邮件 demo\"></a>TELNET 收发邮件 demo</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 使用 SMTP 发邮件</div><div class=\"line\">telnet smtp.163.com 25</div><div class=\"line\"></div><div class=\"line\">HELO 163.com</div><div class=\"line\"></div><div class=\"line\">AUTH LOGIN</div><div class=\"line\"></div><div class=\"line\">Base64(YourUsername)</div><div class=\"line\"></div><div class=\"line\">Base64(YourPassword)</div><div class=\"line\"></div><div class=\"line\">MAIL FROM: &lt;$&#123;Your Email Address&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">RCPT TO: &lt;$&#123;Receiver&apos;s Email Address&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">data</div><div class=\"line\"></div><div class=\"line\">Subject:$&#123;SUBJECT&#125;</div><div class=\"line\">From:$&#123;SENDER&#125;</div><div class=\"line\">To:$&#123;RECEIVER&#125;</div><div class=\"line\"></div><div class=\"line\">$&#123;DATA&#125;</div><div class=\"line\">.</div><div class=\"line\"></div><div class=\"line\">// 使用 POP3 收邮件</div><div class=\"line\">Telnet pop3.163.com 110</div><div class=\"line\"></div><div class=\"line\">User:YourUsername</div><div class=\"line\"></div><div class=\"line\">Pass:yourPassword</div><div class=\"line\"></div><div class=\"line\">List</div><div class=\"line\"></div><div class=\"line\">Retr 邮件编号</div><div class=\"line\"></div><div class=\"line\">Dele 邮件编号</div><div class=\"line\"></div><div class=\"line\">Quit</div></pre></td></tr></table></figure>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p><a href=\"http://zhangh.tk/2017/07/20/【重拾网络】DNS/\" target=\"_blank\" rel=\"external\">【重拾网络】DNS</a></p>\n","excerpt":"","more":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ul>\n<li><p>网络应用的体系结构：CS, P2P, 混合</p>\n</li>\n<li><p>不同端系统上的进程通信方式：跨越计算机网络交换报文</p>\n</li>\n<li><p>套接字：传输基础设施向进程提供的 API</p>\n</li>\n<li><p>进程寻址：</p>\n<ul>\n<li>主机地址：IP</li>\n<li>进程标示符：端口号</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>网络应用的需求：<ul>\n<li>数据丢失/可靠性</li>\n<li>时间/延迟</li>\n<li>带宽</li>\n<li>安全</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>传输层提供的服务：<ul>\n<li>TCP:<ul>\n<li>面向连接</li>\n<li>可靠传输</li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n</ul>\n</li>\n<li>UDP<ul>\n<li>无连接</li>\n<li>不可靠数据传输</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>  TCP &amp; UDP 都无法提供时间/延时保障、最小带宽保障</p>\n<p>  安全传输服务：在 TCP 套接字基础上实现的应用层协议——SSL(Secure Socket Layer)</p>\n<h2 id=\"应用层协议\"><a href=\"#应用层协议\" class=\"headerlink\" title=\"应用层协议\"></a>应用层协议</h2><p>应用层协议定义的内容：</p>\n<ul>\n<li>交换的报文类型</li>\n<li>各种报文语法</li>\n<li>字段语义</li>\n<li>一个进程何时 &amp; 如何发送报文</li>\n</ul>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><p>这部分不知道怎么说啊，内容有点多、有点杂，简单记一下，尤其是众多头部。<br>简单记一下，挖个坑后期填。</p>\n<ul>\n<li>连接类型：<ul>\n<li>非持久连接：HTTP 1.0 版本默认</li>\n<li>持久连接：HTTP 1.1 版本默认<ul>\n<li>无流水线：使用一个 TCP 连接，一个一个请求</li>\n<li>流水线：并行请求</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>各种头部信息</li>\n</ul>\n<ul>\n<li>无状态 &amp; Cokite 技术</li>\n</ul>\n<ul>\n<li><p>代理 &amp; 缓存</p>\n<p>条件 GET</p>\n<p>对于相同 IP 的访问，HOST 头部完整指定主机名/域名URI </p>\n</li>\n</ul>\n<h3 id=\"EMAIL\"><a href=\"#EMAIL\" class=\"headerlink\" title=\"EMAIL\"></a>EMAIL</h3><p>邮件系统构成：用户代理，邮件服务器（邮箱，报文队列）、简单邮件传输协议</p>\n<p>邮件协议基于命令/响应模式</p>\n<ul>\n<li>命令：ASCII 文本</li>\n<li>响应：状态代码和语句</li>\n</ul>\n<h4 id=\"SMTP\"><a href=\"#SMTP\" class=\"headerlink\" title=\"SMTP\"></a>SMTP</h4><p>简单邮件传输协议，特点：</p>\n<ol>\n<li>邮件报文体只能采用简单的 7 比特 ASCII 表示</li>\n<li>一般不使用中间邮件服务器，邮件不在中间某个服务器留存</li>\n<li>使用 TCP 可靠数据传输服务，端口 25</li>\n<li>MIME：多媒体邮件扩展，头部增加 MIME 内容类型</li>\n</ol>\n<p>与 HTTP 比较：</p>\n<ol>\n<li>都建立在 TCP 连接，都是 持续连接</li>\n<li>HTTP 是拉协议，SMTP 是推协议</li>\n<li>SMTP 要求每个报文使用 7 比特 ASCII, HTTP 不受该限制</li>\n<li>对混合消息处理，HTTP 把每个对象封装在一个相应报文里，SMTP 把所有对象放在一个报文</li>\n</ol>\n<h4 id=\"POP3-amp-IMAP\"><a href=\"#POP3-amp-IMAP\" class=\"headerlink\" title=\"POP3 &amp; IMAP\"></a>POP3 &amp; IMAP</h4><p>邮件访问协议</p>\n<p>POP3 特点：</p>\n<ol>\n<li>实现简单</li>\n<li>使用 TCP 连接，110 端口</li>\n<li>三个阶段：<ol>\n<li>认证</li>\n<li>事务处理</li>\n<li>退出</li>\n</ol>\n</li>\n<li>无状态</li>\n</ol>\n<p>IMAP 特点：</p>\n<ol>\n<li>实现相对复杂</li>\n<li>使用 TCP 连接，端口 145</li>\n<li>可以把邮件与文件夹联系起来</li>\n<li>允许用户代理获取邮件</li>\n<li>有状态</li>\n</ol>\n<h4 id=\"TELNET-收发邮件-demo\"><a href=\"#TELNET-收发邮件-demo\" class=\"headerlink\" title=\"TELNET 收发邮件 demo\"></a>TELNET 收发邮件 demo</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 使用 SMTP 发邮件</div><div class=\"line\">telnet smtp.163.com 25</div><div class=\"line\"></div><div class=\"line\">HELO 163.com</div><div class=\"line\"></div><div class=\"line\">AUTH LOGIN</div><div class=\"line\"></div><div class=\"line\">Base64(YourUsername)</div><div class=\"line\"></div><div class=\"line\">Base64(YourPassword)</div><div class=\"line\"></div><div class=\"line\">MAIL FROM: &lt;$&#123;Your Email Address&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">RCPT TO: &lt;$&#123;Receiver&apos;s Email Address&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">data</div><div class=\"line\"></div><div class=\"line\">Subject:$&#123;SUBJECT&#125;</div><div class=\"line\">From:$&#123;SENDER&#125;</div><div class=\"line\">To:$&#123;RECEIVER&#125;</div><div class=\"line\"></div><div class=\"line\">$&#123;DATA&#125;</div><div class=\"line\">.</div><div class=\"line\"></div><div class=\"line\">// 使用 POP3 收邮件</div><div class=\"line\">Telnet pop3.163.com 110</div><div class=\"line\"></div><div class=\"line\">User:YourUsername</div><div class=\"line\"></div><div class=\"line\">Pass:yourPassword</div><div class=\"line\"></div><div class=\"line\">List</div><div class=\"line\"></div><div class=\"line\">Retr 邮件编号</div><div class=\"line\"></div><div class=\"line\">Dele 邮件编号</div><div class=\"line\"></div><div class=\"line\">Quit</div></pre></td></tr></table></figure>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p><a href=\"http://zhangh.tk/2017/07/20/【重拾网络】DNS/\">【重拾网络】DNS</a></p>\n"},{"title":"使用Builder模式改进多参数方法","date":"2016-10-16T03:58:39.000Z","_content":"\n## 概述\n\n记一次工作当中对多参数方法重构。\n\n1. 使用对象封装对多参数，简化方法调用\n2. 使用Builder（创建者）模式简化多属性对象的创建\n\n## 问题\n\n业务系统中统一的邮件发送服务接口在改造前大概长着个样子：\n\n```java\n\t/**\n     * 不帶附件的邮件发送\n     * 未使用建造者模式的原始方法（不良代码）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons){\n        logger.info(\"send email\");\n    }\n\n\n    /**\n     * 带附件的邮件发送\n     * 未使用建造者模式的原始方法（不良）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     * @param docName                       文档名称\n     * @param fileName                      文件名称(单个文件)\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons, String docName, String fileName){\n        logger.info(\"send email\");\n    }\n\n    /**\n     * 带附件的邮件发送\n     * 未使用建造者模式的原始方法（不良代码）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     * @param docName                       文档名称\n     * @param fileNames                     文件名称(多个文件,文件名称列表)\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons, String docName, List<String> fileNames){\n        logger.info(\"send email\");\n    }\n```\n\n接口有个重要的内容注释中并没有说明：参数中“模板”和“收件人”是必填的，而其他参数是非必填的。\n\n接口的可配置程度还是不错的，但是调用的过程就比较痛苦了。\n\n一大堆String和List接口暴露出来，同时又使用了不同的参数个数来进行重载。\n\n调用的时候光是创建这些参数就够麻烦的了，还要考虑哪些参数是必填的以及参数的正确位置。更糟糕的是参数传错位置你会发现很有可能并没有显式的暴露出问题，邮件还是发送了只是发送到错误的相关人员那里。\n\n其他人看到方法调用也无法清晰知道这个到底是要发什么邮件，给哪些人。\n\n这应该就是坏代码的味道吧。\n\n## 改进\n\n简单的改进思路就是把参数做成一个modle封装起来，以后传递model给方法。就像这样：\n\n```java\n    /**\n     * 邮件发送通用接口\n     * @param email 邮件发送参数对象\n     */\n    public static void sendEmail(EmailSendMain email){\n    \tlogger.info(\"send email:\" + email);\n    }\n```\n\n但是问题还是没有根本解决，对象的构造还是需要多个参数的构造方法，可能还需要重载。\n\n比较容易想到的改进是使用Java Bean模式。简化构造方法字段，构造方法只传入必要的字段，使用setter方法设置其他值。我就是这么肤浅的想到这个地步了。\n\n乍一看问题是解决了，其实不然。\n\n1. 在对象创建过程中Java Bean可能处于不一致状态\n2. 使用Java Bean就将不能创建不可变对象\n\n读了《Effective Java》只是第二章就有了更好的解决思路——Builder模式。\n\n先看改进后的代码：\n\n```java\n/**\n * 复杂类型构建接口\n *\n * 建造者模式中的抽象构建者\n * Created by ZhangHao on 2016/10/15.\n */\npublic interface Builder<T> {\n    T build();\n}\n\n/**\n * 邮件发送参数对象\n * 包含多个字段的复杂类型，使用内部类实现Builder接口创建对象\n *\n * 建造者模式中的产品类\n * Created by ZhangHao on 2016/10/15.\n */\npublic final class EmailSendMain {\n    private final String template;  // 模板名称\n    private final List<String> subjects;  // 主题参数列表\n    private final List<String> contents;  // 内容参数列表\n    private final List<String> toPersons;  // 收件人列表\n    private final List<String> ccPersons;  // 抄送人列表\n    private final List<String> bccPersons;  // 暗送人列表\n    private final String docName;  // 文档名称\n    private final List<String> fileNames;  // 文件名称列表\n\n    private EmailSendMain(Builder builder) {\n        this.template = builder.template;\n        this.subjects = builder.subjects;\n        this.contents = builder.contents;\n        this.toPersons = builder.toPersons;\n        this.ccPersons = builder.ccPersons;\n        this.bccPersons = builder.bccPersons;\n        this.docName = builder.docName;\n        this.fileNames = builder.fileNames;\n    }\n\n    /**\n     * 实现Builder接口的构建类，用于创建EmailSendMain\n     *\n     * 建造者模式中的建造类\n     */\n    public static class Builder implements tk.zhangh.pattern.create.builder.demo1.Builder<EmailSendMain> {\n        private String template;  // 模板名称\n        private List<String> subjects;  // 主题参数列表\n        private List<String> contents;  // 内容参数列表\n        private List<String> toPersons;  // 收件人列表\n        private List<String> ccPersons;  // 抄送人列表\n        private List<String> bccPersons;  // 暗送人列表\n        private String docName;  // 文档名称\n        private List<String> fileNames;  // 文件名称列表\n\n        public Builder(String template, List<String> toPersons) {\n            this.template = template;\n            this.toPersons = toPersons;\n        }\n\n        @Override\n        public EmailSendMain build() {\n            return new EmailSendMain(this);\n        }\n\n        public Builder subjects(List<String> subjects) {\n            this.subjects = subjects;\n            return this;\n        }\n\n        public Builder contents(List<String> contents) {\n            this.contents = contents;\n            return this;\n        }\n\n        public Builder ccPersons(List<String> ccPersons) {\n            this.ccPersons = ccPersons;\n            return this;\n        }\n\n        public Builder bccPersons(List<String> bccPersons) {\n            this.bccPersons = bccPersons;\n            return this;\n        }\n\n        public Builder docName(String docName) {\n            this.docName = docName;\n            return this;\n        }\n\n        public Builder fileNames(List<String> fileNames) {\n            this.fileNames = fileNames;\n            return this;\n        }\n    }\n\n    // getter,toString方法省略\n}\n```\n\n重写做的接口方法封装：\n\n```java\n    /**\n     * 邮件发送通用接口\n     * @param email 邮件发送参数对象\n     */\n    public static void sendEmail(EmailSendMain email){\n        logger.info(\"send email:\" + email);\n        if ((email.getDocName() == null || email.getDocName().equals(\"\")) ||\n                (email.getFileNames() == null || email.getFileNames().size() == 0)) {\n            sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),\n                    email.getCcPersons(), email.getBccPersons());\n        }else {\n            sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),\n                    email.getCcPersons(), email.getBccPersons(), email.getDocName(), email.getFileNames());\n        }\n    }\n```\n\n客户端调用：\n\n```java\n    @Test\n    public void testSendEmail() throws Exception {\n        EmailSendMain email =\n                new EmailSendMain.Builder(\"邮件模版名\",toPersons).\n                        subjects(subjects).\n                        contents(contents).\n                        ccPersons(ccPersons).\n                        bccPersons(bccPersons).build();\n        SendEmailUtil.sendEmail(email);\n    }\n```\n\n问题圆满解决，支持可选参数的链式结构调用，创建过程也确保了一致性，使用不可变类也没问题。\n\n如果说缺点，其实不难看出EmailSendMain的字段和它的内部类Builder字段完全重复了。为了创建EmailSendMain的对象将必须先创建Builder也会带来轻微的性能问题。创建的调用过程虽然看起来更清晰，但也更加冗长。\n\n但是Builder模式还是创建多参数类的不错选择，尤其是大多数参数是可选。\n\n## 扩展\n\n这篇文章的思路是根据《Effective Java》得来的，文章只提到书中建议的第二条，实际关于上面使用到的内部类，泛型，在书中的建议都让我有了更多的认识。我就不赘述了，连上8天班我要去偷懒了。\n\n写这篇文章的时候看到有个系列专门讲Java方法参数太多的问题\n\n传送门：https://dzone.com/articles/too-many-parameters-java\n\n以及翻译：http://www.importnew.com/6518.html\n\n代码我放在了学习设计模式的项目下：\n\n传送门：https://github.com/zhanghTK/HelloDesignPattern\n","source":"_posts/使用Builder模式改进多参数方法.md","raw":"---\ntitle: 使用Builder模式改进多参数方法\ndate: 2016-10-16 11:58:39\ntags: \n  - 设计模式\n  - Java\ncategory: 设计模式\n---\n\n## 概述\n\n记一次工作当中对多参数方法重构。\n\n1. 使用对象封装对多参数，简化方法调用\n2. 使用Builder（创建者）模式简化多属性对象的创建\n\n## 问题\n\n业务系统中统一的邮件发送服务接口在改造前大概长着个样子：\n\n```java\n\t/**\n     * 不帶附件的邮件发送\n     * 未使用建造者模式的原始方法（不良代码）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons){\n        logger.info(\"send email\");\n    }\n\n\n    /**\n     * 带附件的邮件发送\n     * 未使用建造者模式的原始方法（不良）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     * @param docName                       文档名称\n     * @param fileName                      文件名称(单个文件)\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons, String docName, String fileName){\n        logger.info(\"send email\");\n    }\n\n    /**\n     * 带附件的邮件发送\n     * 未使用建造者模式的原始方法（不良代码）\n     * @param template                      模板\n     * @param subjects                      主题\n     * @param contents                      内容\n     * @param toPersons                     收件人\n     * @param ccPersons                     抄送人\n     * @param bccPersons                    暗送人\n     * @param docName                       文档名称\n     * @param fileNames                     文件名称(多个文件,文件名称列表)\n     */\n    public static void sendEmail(String template, List<String> subjects, List<String> contents, List<String> toPersons,\n                                  List<String> ccPersons, List<String> bccPersons, String docName, List<String> fileNames){\n        logger.info(\"send email\");\n    }\n```\n\n接口有个重要的内容注释中并没有说明：参数中“模板”和“收件人”是必填的，而其他参数是非必填的。\n\n接口的可配置程度还是不错的，但是调用的过程就比较痛苦了。\n\n一大堆String和List接口暴露出来，同时又使用了不同的参数个数来进行重载。\n\n调用的时候光是创建这些参数就够麻烦的了，还要考虑哪些参数是必填的以及参数的正确位置。更糟糕的是参数传错位置你会发现很有可能并没有显式的暴露出问题，邮件还是发送了只是发送到错误的相关人员那里。\n\n其他人看到方法调用也无法清晰知道这个到底是要发什么邮件，给哪些人。\n\n这应该就是坏代码的味道吧。\n\n## 改进\n\n简单的改进思路就是把参数做成一个modle封装起来，以后传递model给方法。就像这样：\n\n```java\n    /**\n     * 邮件发送通用接口\n     * @param email 邮件发送参数对象\n     */\n    public static void sendEmail(EmailSendMain email){\n    \tlogger.info(\"send email:\" + email);\n    }\n```\n\n但是问题还是没有根本解决，对象的构造还是需要多个参数的构造方法，可能还需要重载。\n\n比较容易想到的改进是使用Java Bean模式。简化构造方法字段，构造方法只传入必要的字段，使用setter方法设置其他值。我就是这么肤浅的想到这个地步了。\n\n乍一看问题是解决了，其实不然。\n\n1. 在对象创建过程中Java Bean可能处于不一致状态\n2. 使用Java Bean就将不能创建不可变对象\n\n读了《Effective Java》只是第二章就有了更好的解决思路——Builder模式。\n\n先看改进后的代码：\n\n```java\n/**\n * 复杂类型构建接口\n *\n * 建造者模式中的抽象构建者\n * Created by ZhangHao on 2016/10/15.\n */\npublic interface Builder<T> {\n    T build();\n}\n\n/**\n * 邮件发送参数对象\n * 包含多个字段的复杂类型，使用内部类实现Builder接口创建对象\n *\n * 建造者模式中的产品类\n * Created by ZhangHao on 2016/10/15.\n */\npublic final class EmailSendMain {\n    private final String template;  // 模板名称\n    private final List<String> subjects;  // 主题参数列表\n    private final List<String> contents;  // 内容参数列表\n    private final List<String> toPersons;  // 收件人列表\n    private final List<String> ccPersons;  // 抄送人列表\n    private final List<String> bccPersons;  // 暗送人列表\n    private final String docName;  // 文档名称\n    private final List<String> fileNames;  // 文件名称列表\n\n    private EmailSendMain(Builder builder) {\n        this.template = builder.template;\n        this.subjects = builder.subjects;\n        this.contents = builder.contents;\n        this.toPersons = builder.toPersons;\n        this.ccPersons = builder.ccPersons;\n        this.bccPersons = builder.bccPersons;\n        this.docName = builder.docName;\n        this.fileNames = builder.fileNames;\n    }\n\n    /**\n     * 实现Builder接口的构建类，用于创建EmailSendMain\n     *\n     * 建造者模式中的建造类\n     */\n    public static class Builder implements tk.zhangh.pattern.create.builder.demo1.Builder<EmailSendMain> {\n        private String template;  // 模板名称\n        private List<String> subjects;  // 主题参数列表\n        private List<String> contents;  // 内容参数列表\n        private List<String> toPersons;  // 收件人列表\n        private List<String> ccPersons;  // 抄送人列表\n        private List<String> bccPersons;  // 暗送人列表\n        private String docName;  // 文档名称\n        private List<String> fileNames;  // 文件名称列表\n\n        public Builder(String template, List<String> toPersons) {\n            this.template = template;\n            this.toPersons = toPersons;\n        }\n\n        @Override\n        public EmailSendMain build() {\n            return new EmailSendMain(this);\n        }\n\n        public Builder subjects(List<String> subjects) {\n            this.subjects = subjects;\n            return this;\n        }\n\n        public Builder contents(List<String> contents) {\n            this.contents = contents;\n            return this;\n        }\n\n        public Builder ccPersons(List<String> ccPersons) {\n            this.ccPersons = ccPersons;\n            return this;\n        }\n\n        public Builder bccPersons(List<String> bccPersons) {\n            this.bccPersons = bccPersons;\n            return this;\n        }\n\n        public Builder docName(String docName) {\n            this.docName = docName;\n            return this;\n        }\n\n        public Builder fileNames(List<String> fileNames) {\n            this.fileNames = fileNames;\n            return this;\n        }\n    }\n\n    // getter,toString方法省略\n}\n```\n\n重写做的接口方法封装：\n\n```java\n    /**\n     * 邮件发送通用接口\n     * @param email 邮件发送参数对象\n     */\n    public static void sendEmail(EmailSendMain email){\n        logger.info(\"send email:\" + email);\n        if ((email.getDocName() == null || email.getDocName().equals(\"\")) ||\n                (email.getFileNames() == null || email.getFileNames().size() == 0)) {\n            sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),\n                    email.getCcPersons(), email.getBccPersons());\n        }else {\n            sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),\n                    email.getCcPersons(), email.getBccPersons(), email.getDocName(), email.getFileNames());\n        }\n    }\n```\n\n客户端调用：\n\n```java\n    @Test\n    public void testSendEmail() throws Exception {\n        EmailSendMain email =\n                new EmailSendMain.Builder(\"邮件模版名\",toPersons).\n                        subjects(subjects).\n                        contents(contents).\n                        ccPersons(ccPersons).\n                        bccPersons(bccPersons).build();\n        SendEmailUtil.sendEmail(email);\n    }\n```\n\n问题圆满解决，支持可选参数的链式结构调用，创建过程也确保了一致性，使用不可变类也没问题。\n\n如果说缺点，其实不难看出EmailSendMain的字段和它的内部类Builder字段完全重复了。为了创建EmailSendMain的对象将必须先创建Builder也会带来轻微的性能问题。创建的调用过程虽然看起来更清晰，但也更加冗长。\n\n但是Builder模式还是创建多参数类的不错选择，尤其是大多数参数是可选。\n\n## 扩展\n\n这篇文章的思路是根据《Effective Java》得来的，文章只提到书中建议的第二条，实际关于上面使用到的内部类，泛型，在书中的建议都让我有了更多的认识。我就不赘述了，连上8天班我要去偷懒了。\n\n写这篇文章的时候看到有个系列专门讲Java方法参数太多的问题\n\n传送门：https://dzone.com/articles/too-many-parameters-java\n\n以及翻译：http://www.importnew.com/6518.html\n\n代码我放在了学习设计模式的项目下：\n\n传送门：https://github.com/zhanghTK/HelloDesignPattern\n","slug":"使用Builder模式改进多参数方法","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2rs003zd82edxmnxwji","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>记一次工作当中对多参数方法重构。</p>\n<ol>\n<li>使用对象封装对多参数，简化方法调用</li>\n<li>使用Builder（创建者）模式简化多属性对象的创建</li>\n</ol>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>业务系统中统一的邮件发送服务接口在改造前大概长着个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">    * 不帶附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良代码）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</span></span></div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons)&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">    * 带附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> docName                       文档名称</div><div class=\"line\">    * <span class=\"doctag\">@param</span> fileName                      文件名称(单个文件)</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</span></span></div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons, String docName, String fileName)&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">    * 带附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良代码）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> docName                       文档名称</div><div class=\"line\">    * <span class=\"doctag\">@param</span> fileNames                     文件名称(多个文件,文件名称列表)</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</span></span></div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons, String docName, List&lt;String&gt; fileNames)&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>接口有个重要的内容注释中并没有说明：参数中“模板”和“收件人”是必填的，而其他参数是非必填的。</p>\n<p>接口的可配置程度还是不错的，但是调用的过程就比较痛苦了。</p>\n<p>一大堆String和List接口暴露出来，同时又使用了不同的参数个数来进行重载。</p>\n<p>调用的时候光是创建这些参数就够麻烦的了，还要考虑哪些参数是必填的以及参数的正确位置。更糟糕的是参数传错位置你会发现很有可能并没有显式的暴露出问题，邮件还是发送了只是发送到错误的相关人员那里。</p>\n<p>其他人看到方法调用也无法清晰知道这个到底是要发什么邮件，给哪些人。</p>\n<p>这应该就是坏代码的味道吧。</p>\n<h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><p>简单的改进思路就是把参数做成一个modle封装起来，以后传递model给方法。就像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 邮件发送通用接口</div><div class=\"line\"> * <span class=\"doctag\">@param</span> email 邮件发送参数对象</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(EmailSendMain email)</span></span>&#123;</div><div class=\"line\">\tlogger.info(<span class=\"string\">\"send email:\"</span> + email);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是问题还是没有根本解决，对象的构造还是需要多个参数的构造方法，可能还需要重载。</p>\n<p>比较容易想到的改进是使用Java Bean模式。简化构造方法字段，构造方法只传入必要的字段，使用setter方法设置其他值。我就是这么肤浅的想到这个地步了。</p>\n<p>乍一看问题是解决了，其实不然。</p>\n<ol>\n<li>在对象创建过程中Java Bean可能处于不一致状态</li>\n<li>使用Java Bean就将不能创建不可变对象</li>\n</ol>\n<p>读了《Effective Java》只是第二章就有了更好的解决思路——Builder模式。</p>\n<p>先看改进后的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 复杂类型构建接口</div><div class=\"line\"> *</div><div class=\"line\"> * 建造者模式中的抽象构建者</div><div class=\"line\"> * Created by ZhangHao on 2016/10/15.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Builder</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\">T <span class=\"title\">build</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 邮件发送参数对象</div><div class=\"line\"> * 包含多个字段的复杂类型，使用内部类实现Builder接口创建对象</div><div class=\"line\"> *</div><div class=\"line\"> * 建造者模式中的产品类</div><div class=\"line\"> * Created by ZhangHao on 2016/10/15.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmailSendMain</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String template;  <span class=\"comment\">// 模板名称</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; subjects;  <span class=\"comment\">// 主题参数列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; contents;  <span class=\"comment\">// 内容参数列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; toPersons;  <span class=\"comment\">// 收件人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; ccPersons;  <span class=\"comment\">// 抄送人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; bccPersons;  <span class=\"comment\">// 暗送人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String docName;  <span class=\"comment\">// 文档名称</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; fileNames;  <span class=\"comment\">// 文件名称列表</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">EmailSendMain</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.template = builder.template;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subjects = builder.subjects;</div><div class=\"line\">        <span class=\"keyword\">this</span>.contents = builder.contents;</div><div class=\"line\">        <span class=\"keyword\">this</span>.toPersons = builder.toPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.ccPersons = builder.ccPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.bccPersons = builder.bccPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.docName = builder.docName;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fileNames = builder.fileNames;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 实现Builder接口的构建类，用于创建EmailSendMain</div><div class=\"line\">     *</div><div class=\"line\">     * 建造者模式中的建造类</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> <span class=\"keyword\">implements</span> <span class=\"title\">tk</span>.<span class=\"title\">zhangh</span>.<span class=\"title\">pattern</span>.<span class=\"title\">create</span>.<span class=\"title\">builder</span>.<span class=\"title\">demo1</span>.<span class=\"title\">Builder</span>&lt;<span class=\"title\">EmailSendMain</span>&gt; </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> String template;  <span class=\"comment\">// 模板名称</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; subjects;  <span class=\"comment\">// 主题参数列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; contents;  <span class=\"comment\">// 内容参数列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; toPersons;  <span class=\"comment\">// 收件人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; ccPersons;  <span class=\"comment\">// 抄送人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; bccPersons;  <span class=\"comment\">// 暗送人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> String docName;  <span class=\"comment\">// 文档名称</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; fileNames;  <span class=\"comment\">// 文件名称列表</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(String template, List&lt;String&gt; toPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.template = template;</div><div class=\"line\">            <span class=\"keyword\">this</span>.toPersons = toPersons;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> EmailSendMain <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EmailSendMain(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">subjects</span><span class=\"params\">(List&lt;String&gt; subjects)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.subjects = subjects;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">contents</span><span class=\"params\">(List&lt;String&gt; contents)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.contents = contents;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">ccPersons</span><span class=\"params\">(List&lt;String&gt; ccPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.ccPersons = ccPersons;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">bccPersons</span><span class=\"params\">(List&lt;String&gt; bccPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.bccPersons = bccPersons;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">docName</span><span class=\"params\">(String docName)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.docName = docName;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">fileNames</span><span class=\"params\">(List&lt;String&gt; fileNames)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.fileNames = fileNames;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// getter,toString方法省略</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重写做的接口方法封装：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 邮件发送通用接口</div><div class=\"line\"> * <span class=\"doctag\">@param</span> email 邮件发送参数对象</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(EmailSendMain email)</span></span>&#123;</div><div class=\"line\">    logger.info(<span class=\"string\">\"send email:\"</span> + email);</div><div class=\"line\">    <span class=\"keyword\">if</span> ((email.getDocName() == <span class=\"keyword\">null</span> || email.getDocName().equals(<span class=\"string\">\"\"</span>)) ||</div><div class=\"line\">            (email.getFileNames() == <span class=\"keyword\">null</span> || email.getFileNames().size() == <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">        sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),</div><div class=\"line\">                email.getCcPersons(), email.getBccPersons());</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),</div><div class=\"line\">                email.getCcPersons(), email.getBccPersons(), email.getDocName(), email.getFileNames());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>客户端调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testSendEmail</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    EmailSendMain email =</div><div class=\"line\">            <span class=\"keyword\">new</span> EmailSendMain.Builder(<span class=\"string\">\"邮件模版名\"</span>,toPersons).</div><div class=\"line\">                    subjects(subjects).</div><div class=\"line\">                    contents(contents).</div><div class=\"line\">                    ccPersons(ccPersons).</div><div class=\"line\">                    bccPersons(bccPersons).build();</div><div class=\"line\">    SendEmailUtil.sendEmail(email);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题圆满解决，支持可选参数的链式结构调用，创建过程也确保了一致性，使用不可变类也没问题。</p>\n<p>如果说缺点，其实不难看出EmailSendMain的字段和它的内部类Builder字段完全重复了。为了创建EmailSendMain的对象将必须先创建Builder也会带来轻微的性能问题。创建的调用过程虽然看起来更清晰，但也更加冗长。</p>\n<p>但是Builder模式还是创建多参数类的不错选择，尤其是大多数参数是可选。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>这篇文章的思路是根据《Effective Java》得来的，文章只提到书中建议的第二条，实际关于上面使用到的内部类，泛型，在书中的建议都让我有了更多的认识。我就不赘述了，连上8天班我要去偷懒了。</p>\n<p>写这篇文章的时候看到有个系列专门讲Java方法参数太多的问题</p>\n<p>传送门：<a href=\"https://dzone.com/articles/too-many-parameters-java\" target=\"_blank\" rel=\"external\">https://dzone.com/articles/too-many-parameters-java</a></p>\n<p>以及翻译：<a href=\"http://www.importnew.com/6518.html\" target=\"_blank\" rel=\"external\">http://www.importnew.com/6518.html</a></p>\n<p>代码我放在了学习设计模式的项目下：</p>\n<p>传送门：<a href=\"https://github.com/zhanghTK/HelloDesignPattern\" target=\"_blank\" rel=\"external\">https://github.com/zhanghTK/HelloDesignPattern</a></p>\n","excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>记一次工作当中对多参数方法重构。</p>\n<ol>\n<li>使用对象封装对多参数，简化方法调用</li>\n<li>使用Builder（创建者）模式简化多属性对象的创建</li>\n</ol>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>业务系统中统一的邮件发送服务接口在改造前大概长着个样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">    * 不帶附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良代码）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons)</span></span>&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">    * 带附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> docName                       文档名称</div><div class=\"line\">    * <span class=\"doctag\">@param</span> fileName                      文件名称(单个文件)</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons, String docName, String fileName)</span></span>&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">    * 带附件的邮件发送</div><div class=\"line\">    * 未使用建造者模式的原始方法（不良代码）</div><div class=\"line\">    * <span class=\"doctag\">@param</span> template                      模板</div><div class=\"line\">    * <span class=\"doctag\">@param</span> subjects                      主题</div><div class=\"line\">    * <span class=\"doctag\">@param</span> contents                      内容</div><div class=\"line\">    * <span class=\"doctag\">@param</span> toPersons                     收件人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> ccPersons                     抄送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bccPersons                    暗送人</div><div class=\"line\">    * <span class=\"doctag\">@param</span> docName                       文档名称</div><div class=\"line\">    * <span class=\"doctag\">@param</span> fileNames                     文件名称(多个文件,文件名称列表)</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(String template, List&lt;String&gt; subjects, List&lt;String&gt; contents, List&lt;String&gt; toPersons,</div><div class=\"line\">                                 List&lt;String&gt; ccPersons, List&lt;String&gt; bccPersons, String docName, List&lt;String&gt; fileNames)</span></span>&#123;</div><div class=\"line\">       logger.info(<span class=\"string\">\"send email\"</span>);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>接口有个重要的内容注释中并没有说明：参数中“模板”和“收件人”是必填的，而其他参数是非必填的。</p>\n<p>接口的可配置程度还是不错的，但是调用的过程就比较痛苦了。</p>\n<p>一大堆String和List接口暴露出来，同时又使用了不同的参数个数来进行重载。</p>\n<p>调用的时候光是创建这些参数就够麻烦的了，还要考虑哪些参数是必填的以及参数的正确位置。更糟糕的是参数传错位置你会发现很有可能并没有显式的暴露出问题，邮件还是发送了只是发送到错误的相关人员那里。</p>\n<p>其他人看到方法调用也无法清晰知道这个到底是要发什么邮件，给哪些人。</p>\n<p>这应该就是坏代码的味道吧。</p>\n<h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><p>简单的改进思路就是把参数做成一个modle封装起来，以后传递model给方法。就像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 邮件发送通用接口</div><div class=\"line\"> * <span class=\"doctag\">@param</span> email 邮件发送参数对象</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(EmailSendMain email)</span></span>&#123;</div><div class=\"line\">\tlogger.info(<span class=\"string\">\"send email:\"</span> + email);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是问题还是没有根本解决，对象的构造还是需要多个参数的构造方法，可能还需要重载。</p>\n<p>比较容易想到的改进是使用Java Bean模式。简化构造方法字段，构造方法只传入必要的字段，使用setter方法设置其他值。我就是这么肤浅的想到这个地步了。</p>\n<p>乍一看问题是解决了，其实不然。</p>\n<ol>\n<li>在对象创建过程中Java Bean可能处于不一致状态</li>\n<li>使用Java Bean就将不能创建不可变对象</li>\n</ol>\n<p>读了《Effective Java》只是第二章就有了更好的解决思路——Builder模式。</p>\n<p>先看改进后的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 复杂类型构建接口</div><div class=\"line\"> *</div><div class=\"line\"> * 建造者模式中的抽象构建者</div><div class=\"line\"> * Created by ZhangHao on 2016/10/15.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Builder</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\">T <span class=\"title\">build</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 邮件发送参数对象</div><div class=\"line\"> * 包含多个字段的复杂类型，使用内部类实现Builder接口创建对象</div><div class=\"line\"> *</div><div class=\"line\"> * 建造者模式中的产品类</div><div class=\"line\"> * Created by ZhangHao on 2016/10/15.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmailSendMain</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String template;  <span class=\"comment\">// 模板名称</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; subjects;  <span class=\"comment\">// 主题参数列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; contents;  <span class=\"comment\">// 内容参数列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; toPersons;  <span class=\"comment\">// 收件人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; ccPersons;  <span class=\"comment\">// 抄送人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; bccPersons;  <span class=\"comment\">// 暗送人列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String docName;  <span class=\"comment\">// 文档名称</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; fileNames;  <span class=\"comment\">// 文件名称列表</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">EmailSendMain</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.template = builder.template;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subjects = builder.subjects;</div><div class=\"line\">        <span class=\"keyword\">this</span>.contents = builder.contents;</div><div class=\"line\">        <span class=\"keyword\">this</span>.toPersons = builder.toPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.ccPersons = builder.ccPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.bccPersons = builder.bccPersons;</div><div class=\"line\">        <span class=\"keyword\">this</span>.docName = builder.docName;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fileNames = builder.fileNames;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 实现Builder接口的构建类，用于创建EmailSendMain</div><div class=\"line\">     *</div><div class=\"line\">     * 建造者模式中的建造类</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> <span class=\"keyword\">implements</span> <span class=\"title\">tk</span>.<span class=\"title\">zhangh</span>.<span class=\"title\">pattern</span>.<span class=\"title\">create</span>.<span class=\"title\">builder</span>.<span class=\"title\">demo1</span>.<span class=\"title\">Builder</span>&lt;<span class=\"title\">EmailSendMain</span>&gt; </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> String template;  <span class=\"comment\">// 模板名称</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; subjects;  <span class=\"comment\">// 主题参数列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; contents;  <span class=\"comment\">// 内容参数列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; toPersons;  <span class=\"comment\">// 收件人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; ccPersons;  <span class=\"comment\">// 抄送人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; bccPersons;  <span class=\"comment\">// 暗送人列表</span></div><div class=\"line\">        <span class=\"keyword\">private</span> String docName;  <span class=\"comment\">// 文档名称</span></div><div class=\"line\">        <span class=\"keyword\">private</span> List&lt;String&gt; fileNames;  <span class=\"comment\">// 文件名称列表</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(String template, List&lt;String&gt; toPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.template = template;</div><div class=\"line\">            <span class=\"keyword\">this</span>.toPersons = toPersons;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> EmailSendMain <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EmailSendMain(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">subjects</span><span class=\"params\">(List&lt;String&gt; subjects)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.subjects = subjects;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">contents</span><span class=\"params\">(List&lt;String&gt; contents)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.contents = contents;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">ccPersons</span><span class=\"params\">(List&lt;String&gt; ccPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.ccPersons = ccPersons;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">bccPersons</span><span class=\"params\">(List&lt;String&gt; bccPersons)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.bccPersons = bccPersons;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">docName</span><span class=\"params\">(String docName)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.docName = docName;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">fileNames</span><span class=\"params\">(List&lt;String&gt; fileNames)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.fileNames = fileNames;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// getter,toString方法省略</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重写做的接口方法封装：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 邮件发送通用接口</div><div class=\"line\"> * <span class=\"doctag\">@param</span> email 邮件发送参数对象</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(EmailSendMain email)</span></span>&#123;</div><div class=\"line\">    logger.info(<span class=\"string\">\"send email:\"</span> + email);</div><div class=\"line\">    <span class=\"keyword\">if</span> ((email.getDocName() == <span class=\"keyword\">null</span> || email.getDocName().equals(<span class=\"string\">\"\"</span>)) ||</div><div class=\"line\">            (email.getFileNames() == <span class=\"keyword\">null</span> || email.getFileNames().size() == <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">        sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),</div><div class=\"line\">                email.getCcPersons(), email.getBccPersons());</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        sendEmail(email.getTemplate(), email.getSubjects(), email.getContents(), email.getToPersons(),</div><div class=\"line\">                email.getCcPersons(), email.getBccPersons(), email.getDocName(), email.getFileNames());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>客户端调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testSendEmail</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    EmailSendMain email =</div><div class=\"line\">            <span class=\"keyword\">new</span> EmailSendMain.Builder(<span class=\"string\">\"邮件模版名\"</span>,toPersons).</div><div class=\"line\">                    subjects(subjects).</div><div class=\"line\">                    contents(contents).</div><div class=\"line\">                    ccPersons(ccPersons).</div><div class=\"line\">                    bccPersons(bccPersons).build();</div><div class=\"line\">    SendEmailUtil.sendEmail(email);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题圆满解决，支持可选参数的链式结构调用，创建过程也确保了一致性，使用不可变类也没问题。</p>\n<p>如果说缺点，其实不难看出EmailSendMain的字段和它的内部类Builder字段完全重复了。为了创建EmailSendMain的对象将必须先创建Builder也会带来轻微的性能问题。创建的调用过程虽然看起来更清晰，但也更加冗长。</p>\n<p>但是Builder模式还是创建多参数类的不错选择，尤其是大多数参数是可选。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>这篇文章的思路是根据《Effective Java》得来的，文章只提到书中建议的第二条，实际关于上面使用到的内部类，泛型，在书中的建议都让我有了更多的认识。我就不赘述了，连上8天班我要去偷懒了。</p>\n<p>写这篇文章的时候看到有个系列专门讲Java方法参数太多的问题</p>\n<p>传送门：<a href=\"https://dzone.com/articles/too-many-parameters-java\">https://dzone.com/articles/too-many-parameters-java</a></p>\n<p>以及翻译：<a href=\"http://www.importnew.com/6518.html\">http://www.importnew.com/6518.html</a></p>\n<p>代码我放在了学习设计模式的项目下：</p>\n<p>传送门：<a href=\"https://github.com/zhanghTK/HelloDesignPattern\">https://github.com/zhanghTK/HelloDesignPattern</a></p>\n"},{"title":"从ReentrantLock看AQS","date":"2017-06-07T15:34:20.000Z","_content":"\n之前的文章有简单描述了JUC下的各种同步器。`ReentrantLock`的引入弥补了原生的`synchronized`关键字的不足。好些天不更新博客了，今天简单记录一下`ReentrantLock`的实现。\n\n## 同步器的基本实现\n\nJUC包下各种同步器主要依赖的都是`AbstractQueuedSynchronizer`（AQS）的实现，对于具体的实现大体可以分为两类：独占类型和共享类型。各种同步器并不直接继承成AQS，而是依赖于AQS的子类。\n\n例如：`CountDownLatch`的内部类`java.util.concurrent.CountDownLatch.Sync`就是共享型的同步器，其继承了AQS。\n\n本文记录同步器`ReentrantLock`的加锁、释放锁的具体实现。\n\n## ReentrantLock\n\n与`CountDownLatch`类似，`ReentrantLock`对同步器的实现也是依赖其继承了AQS的内部类`java.util.concurrent.locks.ReentrantLock.Sync`。根据公平性，又具体提供了`FairSync`和`NonfairSync`。\n\n默认情况是`ReentrantLock`使用的是非公平的`NonfairSync`。\n\n下面看看`ReentrantLock`的`NonfairSync`的加锁和释放锁，分析一下AQS对独占型同步器的支持。\n\n### NonfairSync\n\n#### lock\n\n非公平锁加锁方法的入口：\n\n```java\nfinal void lock() {\n  if (compareAndSetState(0, 1))\n    setExclusiveOwnerThread(Thread.currentThread());\n  else\n    acquire(1);\n}\n```\n\n首先是一个CAS操作，比较设置state变量的值。\n\nstate变量来自AQS，表示资源（锁）的状态，0表示未获取，1表示已获取一个。大于1表示获取（重入）的次数。\n\n若资源未获取，修改资源状态成功后，会保存独占资源的线程（使用`setExclusiveOwnerThread`方法，该方法位于`AbstractOwnableSynchronizer`，AQS继承于它）。\n\n若资源已经被获取，则调用`acquire`方法获取锁。\n\n`acquire`是AQS在独占模式下获取资源的入口。可以看出在`ReentrantLock`加锁的主要逻辑都是依赖于AQS的，代码如下：\n\n```java\npublic final void acquire(int arg) {\n  if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n    selfInterrupt();\n}\n```\n\n分别看一下`tryAcquire`,`acquireQueued`,`addWaiter`,`selfInterrupt`的具体实现：\n\n1. 在ReentrantLock中`tryAcquire`具体的逻辑：\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n  return nonfairTryAcquire(acquires);\n}\n```\n\n`AQS`的`tryAcquire`是一个空方法，直接抛异常。`ReentrantLock`中对非公平锁的的实现则调用`nonfairTryAcquire`方法，逻辑如下：\n\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n  // 获取当前要获取锁的线程\n  final Thread current = Thread.currentThread();\n  // 当前锁的状态\n  int c = getState();\n  // CAS操作，如果锁未获取修改锁状态，获取锁\n  if (c == 0) {\n    if (compareAndSetState(0, acquires)) {\n      setExclusiveOwnerThread(current);\n      return true;\n    }\n  }\n  // 如果锁已经被获取且当前线程是获取锁的线程，更新锁状态，重入锁\n  else if (current == getExclusiveOwnerThread()) {\n    int nextc = c + acquires;\n    if (nextc < 0) // overflow\n      throw new Error(\"Maximum lock count exceeded\");\n    setState(nextc);\n    return true;\n  }\n  // 其他情况都失败\n  return false;\n}\n```\n\n2. `addWaiter`\n\n```java\nprivate Node addWaiter(Node mode) {\n  // 根据线程实例和模式封装节点\n  Node node = new Node(Thread.currentThread(), mode);\n  // 尝试快速添加节点到队尾，成功则直接返回\n  Node pred = tail;\n  if (pred != null) {\n    node.prev = pred;\n    if (compareAndSetTail(pred, node)) {\n      pred.next = node;\n      return node;\n    }\n  }\n  // 调用enq方法添加至队尾\n  enq(node);\n  return node;\n}\n```\n\n```java\nprivate Node enq(final Node node) {\n  // 自旋操作\n  for (;;) {\n    Node t = tail;\n    // 如果尾节点空（链表为空），创建一个不包含线程的头结点\n    if (t == null) { // Must initialize\n      if (compareAndSetHead(new Node()))\n        tail = head;\n    } else {\n      // 添加至队尾\n      node.prev = t;\n      if (compareAndSetTail(t, node)) {\n        t.next = node;\n        return t;\n      }\n    }\n  }\n}\n```\n\n3. `acquireQueued`\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n  boolean failed = true;  // 是否获取锁失败\n  try {\n    boolean interrupted = false;\n    // 自旋操作\n    for (;;) {\n      final Node p = node.predecessor();  // 前驱节点\n      // 如果前驱是头结点，并且获取资源成功\n      // 因为enq方法中判断若链表为空，则创建一个没有线程的头结点。\n      // 所以当前驱是头结点时，说明该节点有可能获取资源\n      if (p == head && tryAcquire(arg)) {\n        setHead(node);\n        p.next = null; // help GC\n        failed = false;\n        return interrupted;\n      }\n      if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n        interrupted = true;\n    }\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n  }\n}\n```\n\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n  int ws = pred.waitStatus;\n  if (ws == Node.SIGNAL)\n    // 如果前驱节点状态是SIGNAL，返回\n    return true;\n  if (ws > 0) {\n    // 如果前驱节点状态是CANCEL，删除此节都，直到前驱节点不是CANCEL\n    do {\n      node.prev = pred = pred.prev;\n    } while (pred.waitStatus > 0);\n    pred.next = node;\n  } else {\n    // 其他情况，使用CAS操作将前驱设置为SIGNAL\n    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n  }\n  return false;\n}\n```\n\n关于节点状态的说明：\n\n```java\n// 代表线程已经被取消\nstatic final int CANCELLED =  1;\n// 代表后续节点需要唤醒\nstatic final int SIGNAL    = -1;\n// 代表线程在condition queue中，等待某一条件\nstatic final int CONDITION = -2;\n// 代表后续结点会传播唤醒的操作，共享模式下起作用\nstatic final int PROPAGATE = -3;\n// 新结点会处于这种状态\n\t\t\t\t\t\t    0;\n```\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n  // 暂停\n  LockSupport.park(this);\n  // 返回中断状况\n  return Thread.interrupted();\n}\n```\n\n至此完成锁获取的完整过程。\n\n#### unlock\n\n非公平锁释放锁方法的入口更简单，完全依赖AQS：\n\n```java\npublic void unlock() {\n  sync.release(1);\n}\n```\n\nAQS中资源的释放实现：\n\n```java\npublic final boolean release(int arg) {\n  if (tryRelease(arg)) {\n    // 释放资源成功\n    Node h = head;\n    // 队列后不为空，且队列头状态不是新建\n    if (h != null && h.waitStatus != 0)\n      // 释放队列头的后继节点\n      unparkSuccessor(h);\n    return true;\n  }\n  return false;\n}\n```\n\n如同`tryAcquire`方法，AQS中`tryRelease`方法也是个空方法。`ReentrantLock`中的实现：\n\n```java\nprotected final boolean tryRelease(int releases) {\n  // 获取当前的state减一\n  int c = getState() - releases;\n  // 如果当前线程不是独占线程，抛出异常\n  if (Thread.currentThread() != getExclusiveOwnerThread())\n    throw new IllegalMonitorStateException();\n  // 申请的锁是否都被释放\n  boolean free = false;\n  // 锁都被释放，重置独占线程\n  if (c == 0) {\n    free = true;\n    setExclusiveOwnerThread(null);\n  }\n  // 更新state\n  setState(c);\n  return free;\n}\n```\n\n释放头节点的后继节点：\n\n```java\nprivate void unparkSuccessor(Node node) {\n  // 获取头结点的状态\n  int ws = node.waitStatus;\n  // 如果头结点状态小于0，更新为0\n  if (ws < 0)\n    compareAndSetWaitStatus(node, ws, 0);\n  // 获取后继节点\n  Node s = node.next;\n  // 寻找头结点的下一个有效节点\n  if (s == null || s.waitStatus > 0) {\n    s = null;\n    // 从尾部遍历，寻找第一个有效节点\n    for (Node t = tail; t != null && t != node; t = t.prev)\n      if (t.waitStatus <= 0)\n        s = t;\n  }\n  // 释放锁\n  if (s != null)\n    LockSupport.unpark(s.thread);\n}\n```\n\n以上就是释放资源的过程，相对于加锁还是比较简单的。\n\n###  FairSync\n\n与非公平的同步器不同，对于公平的同步器。在申请锁时条件更苛刻，要先判断当前节点前是否还有其他节点：\n\n```java\nfinal void lock() {\n    acquire(1);\n}\n\nprotected final boolean tryAcquire(int acquires) {\n  final Thread current = Thread.currentThread();\n  int c = getState();\n  if (c == 0) {\n    // 判断当前线程前是否还有其他线程\n    if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {\n      setExclusiveOwnerThread(current);\n      return true;\n    }\n  }\n  else if (current == getExclusiveOwnerThread()) {\n    int nextc = c + acquires;\n    if (nextc < 0)\n      throw new Error(\"Maximum lock count exceeded\");\n    setState(nextc);\n    return true;\n  }\n  return false;\n}\n```\n\n锁的释放则与非公平的同步器完全一致。\n\n---\n\n除了`lock`和`unlock`方法，`ReentrantLock`还提供了其他功能的锁申请/释放的方法，但都是依赖于AQS。\n\n通过`ReentrantLock`大体可以对AQS后个印象：\n\n1. 整个AQS使用双向链表作为底层数据结构；\n2. 每个节点保存线程，以及状态信息；\n3. 所有节点共同维护资源的使用情况；\n4. 通过模板模式完成基本的同步器，具体的实现由子类完成（例如是否允许重入）；\n5. 内部大量使用了CAS而非加锁确保线程安全；\n","source":"_posts/从ReentrantLock看AQS.md","raw":"---\ntitle: 从ReentrantLock看AQS\ndate: 2017-06-07 23:34:20\ntags:\n  - Java\ncategories:\n  - Java\n---\n\n之前的文章有简单描述了JUC下的各种同步器。`ReentrantLock`的引入弥补了原生的`synchronized`关键字的不足。好些天不更新博客了，今天简单记录一下`ReentrantLock`的实现。\n\n## 同步器的基本实现\n\nJUC包下各种同步器主要依赖的都是`AbstractQueuedSynchronizer`（AQS）的实现，对于具体的实现大体可以分为两类：独占类型和共享类型。各种同步器并不直接继承成AQS，而是依赖于AQS的子类。\n\n例如：`CountDownLatch`的内部类`java.util.concurrent.CountDownLatch.Sync`就是共享型的同步器，其继承了AQS。\n\n本文记录同步器`ReentrantLock`的加锁、释放锁的具体实现。\n\n## ReentrantLock\n\n与`CountDownLatch`类似，`ReentrantLock`对同步器的实现也是依赖其继承了AQS的内部类`java.util.concurrent.locks.ReentrantLock.Sync`。根据公平性，又具体提供了`FairSync`和`NonfairSync`。\n\n默认情况是`ReentrantLock`使用的是非公平的`NonfairSync`。\n\n下面看看`ReentrantLock`的`NonfairSync`的加锁和释放锁，分析一下AQS对独占型同步器的支持。\n\n### NonfairSync\n\n#### lock\n\n非公平锁加锁方法的入口：\n\n```java\nfinal void lock() {\n  if (compareAndSetState(0, 1))\n    setExclusiveOwnerThread(Thread.currentThread());\n  else\n    acquire(1);\n}\n```\n\n首先是一个CAS操作，比较设置state变量的值。\n\nstate变量来自AQS，表示资源（锁）的状态，0表示未获取，1表示已获取一个。大于1表示获取（重入）的次数。\n\n若资源未获取，修改资源状态成功后，会保存独占资源的线程（使用`setExclusiveOwnerThread`方法，该方法位于`AbstractOwnableSynchronizer`，AQS继承于它）。\n\n若资源已经被获取，则调用`acquire`方法获取锁。\n\n`acquire`是AQS在独占模式下获取资源的入口。可以看出在`ReentrantLock`加锁的主要逻辑都是依赖于AQS的，代码如下：\n\n```java\npublic final void acquire(int arg) {\n  if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n    selfInterrupt();\n}\n```\n\n分别看一下`tryAcquire`,`acquireQueued`,`addWaiter`,`selfInterrupt`的具体实现：\n\n1. 在ReentrantLock中`tryAcquire`具体的逻辑：\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n  return nonfairTryAcquire(acquires);\n}\n```\n\n`AQS`的`tryAcquire`是一个空方法，直接抛异常。`ReentrantLock`中对非公平锁的的实现则调用`nonfairTryAcquire`方法，逻辑如下：\n\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n  // 获取当前要获取锁的线程\n  final Thread current = Thread.currentThread();\n  // 当前锁的状态\n  int c = getState();\n  // CAS操作，如果锁未获取修改锁状态，获取锁\n  if (c == 0) {\n    if (compareAndSetState(0, acquires)) {\n      setExclusiveOwnerThread(current);\n      return true;\n    }\n  }\n  // 如果锁已经被获取且当前线程是获取锁的线程，更新锁状态，重入锁\n  else if (current == getExclusiveOwnerThread()) {\n    int nextc = c + acquires;\n    if (nextc < 0) // overflow\n      throw new Error(\"Maximum lock count exceeded\");\n    setState(nextc);\n    return true;\n  }\n  // 其他情况都失败\n  return false;\n}\n```\n\n2. `addWaiter`\n\n```java\nprivate Node addWaiter(Node mode) {\n  // 根据线程实例和模式封装节点\n  Node node = new Node(Thread.currentThread(), mode);\n  // 尝试快速添加节点到队尾，成功则直接返回\n  Node pred = tail;\n  if (pred != null) {\n    node.prev = pred;\n    if (compareAndSetTail(pred, node)) {\n      pred.next = node;\n      return node;\n    }\n  }\n  // 调用enq方法添加至队尾\n  enq(node);\n  return node;\n}\n```\n\n```java\nprivate Node enq(final Node node) {\n  // 自旋操作\n  for (;;) {\n    Node t = tail;\n    // 如果尾节点空（链表为空），创建一个不包含线程的头结点\n    if (t == null) { // Must initialize\n      if (compareAndSetHead(new Node()))\n        tail = head;\n    } else {\n      // 添加至队尾\n      node.prev = t;\n      if (compareAndSetTail(t, node)) {\n        t.next = node;\n        return t;\n      }\n    }\n  }\n}\n```\n\n3. `acquireQueued`\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n  boolean failed = true;  // 是否获取锁失败\n  try {\n    boolean interrupted = false;\n    // 自旋操作\n    for (;;) {\n      final Node p = node.predecessor();  // 前驱节点\n      // 如果前驱是头结点，并且获取资源成功\n      // 因为enq方法中判断若链表为空，则创建一个没有线程的头结点。\n      // 所以当前驱是头结点时，说明该节点有可能获取资源\n      if (p == head && tryAcquire(arg)) {\n        setHead(node);\n        p.next = null; // help GC\n        failed = false;\n        return interrupted;\n      }\n      if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n        interrupted = true;\n    }\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n  }\n}\n```\n\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n  int ws = pred.waitStatus;\n  if (ws == Node.SIGNAL)\n    // 如果前驱节点状态是SIGNAL，返回\n    return true;\n  if (ws > 0) {\n    // 如果前驱节点状态是CANCEL，删除此节都，直到前驱节点不是CANCEL\n    do {\n      node.prev = pred = pred.prev;\n    } while (pred.waitStatus > 0);\n    pred.next = node;\n  } else {\n    // 其他情况，使用CAS操作将前驱设置为SIGNAL\n    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n  }\n  return false;\n}\n```\n\n关于节点状态的说明：\n\n```java\n// 代表线程已经被取消\nstatic final int CANCELLED =  1;\n// 代表后续节点需要唤醒\nstatic final int SIGNAL    = -1;\n// 代表线程在condition queue中，等待某一条件\nstatic final int CONDITION = -2;\n// 代表后续结点会传播唤醒的操作，共享模式下起作用\nstatic final int PROPAGATE = -3;\n// 新结点会处于这种状态\n\t\t\t\t\t\t    0;\n```\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n  // 暂停\n  LockSupport.park(this);\n  // 返回中断状况\n  return Thread.interrupted();\n}\n```\n\n至此完成锁获取的完整过程。\n\n#### unlock\n\n非公平锁释放锁方法的入口更简单，完全依赖AQS：\n\n```java\npublic void unlock() {\n  sync.release(1);\n}\n```\n\nAQS中资源的释放实现：\n\n```java\npublic final boolean release(int arg) {\n  if (tryRelease(arg)) {\n    // 释放资源成功\n    Node h = head;\n    // 队列后不为空，且队列头状态不是新建\n    if (h != null && h.waitStatus != 0)\n      // 释放队列头的后继节点\n      unparkSuccessor(h);\n    return true;\n  }\n  return false;\n}\n```\n\n如同`tryAcquire`方法，AQS中`tryRelease`方法也是个空方法。`ReentrantLock`中的实现：\n\n```java\nprotected final boolean tryRelease(int releases) {\n  // 获取当前的state减一\n  int c = getState() - releases;\n  // 如果当前线程不是独占线程，抛出异常\n  if (Thread.currentThread() != getExclusiveOwnerThread())\n    throw new IllegalMonitorStateException();\n  // 申请的锁是否都被释放\n  boolean free = false;\n  // 锁都被释放，重置独占线程\n  if (c == 0) {\n    free = true;\n    setExclusiveOwnerThread(null);\n  }\n  // 更新state\n  setState(c);\n  return free;\n}\n```\n\n释放头节点的后继节点：\n\n```java\nprivate void unparkSuccessor(Node node) {\n  // 获取头结点的状态\n  int ws = node.waitStatus;\n  // 如果头结点状态小于0，更新为0\n  if (ws < 0)\n    compareAndSetWaitStatus(node, ws, 0);\n  // 获取后继节点\n  Node s = node.next;\n  // 寻找头结点的下一个有效节点\n  if (s == null || s.waitStatus > 0) {\n    s = null;\n    // 从尾部遍历，寻找第一个有效节点\n    for (Node t = tail; t != null && t != node; t = t.prev)\n      if (t.waitStatus <= 0)\n        s = t;\n  }\n  // 释放锁\n  if (s != null)\n    LockSupport.unpark(s.thread);\n}\n```\n\n以上就是释放资源的过程，相对于加锁还是比较简单的。\n\n###  FairSync\n\n与非公平的同步器不同，对于公平的同步器。在申请锁时条件更苛刻，要先判断当前节点前是否还有其他节点：\n\n```java\nfinal void lock() {\n    acquire(1);\n}\n\nprotected final boolean tryAcquire(int acquires) {\n  final Thread current = Thread.currentThread();\n  int c = getState();\n  if (c == 0) {\n    // 判断当前线程前是否还有其他线程\n    if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {\n      setExclusiveOwnerThread(current);\n      return true;\n    }\n  }\n  else if (current == getExclusiveOwnerThread()) {\n    int nextc = c + acquires;\n    if (nextc < 0)\n      throw new Error(\"Maximum lock count exceeded\");\n    setState(nextc);\n    return true;\n  }\n  return false;\n}\n```\n\n锁的释放则与非公平的同步器完全一致。\n\n---\n\n除了`lock`和`unlock`方法，`ReentrantLock`还提供了其他功能的锁申请/释放的方法，但都是依赖于AQS。\n\n通过`ReentrantLock`大体可以对AQS后个印象：\n\n1. 整个AQS使用双向链表作为底层数据结构；\n2. 每个节点保存线程，以及状态信息；\n3. 所有节点共同维护资源的使用情况；\n4. 通过模板模式完成基本的同步器，具体的实现由子类完成（例如是否允许重入）；\n5. 内部大量使用了CAS而非加锁确保线程安全；\n","slug":"从ReentrantLock看AQS","published":1,"updated":"2017-06-07T15:37:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2ru0044d82e8drks4um","content":"<p>之前的文章有简单描述了JUC下的各种同步器。<code>ReentrantLock</code>的引入弥补了原生的<code>synchronized</code>关键字的不足。好些天不更新博客了，今天简单记录一下<code>ReentrantLock</code>的实现。</p>\n<h2 id=\"同步器的基本实现\"><a href=\"#同步器的基本实现\" class=\"headerlink\" title=\"同步器的基本实现\"></a>同步器的基本实现</h2><p>JUC包下各种同步器主要依赖的都是<code>AbstractQueuedSynchronizer</code>（AQS）的实现，对于具体的实现大体可以分为两类：独占类型和共享类型。各种同步器并不直接继承成AQS，而是依赖于AQS的子类。</p>\n<p>例如：<code>CountDownLatch</code>的内部类<code>java.util.concurrent.CountDownLatch.Sync</code>就是共享型的同步器，其继承了AQS。</p>\n<p>本文记录同步器<code>ReentrantLock</code>的加锁、释放锁的具体实现。</p>\n<h2 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h2><p>与<code>CountDownLatch</code>类似，<code>ReentrantLock</code>对同步器的实现也是依赖其继承了AQS的内部类<code>java.util.concurrent.locks.ReentrantLock.Sync</code>。根据公平性，又具体提供了<code>FairSync</code>和<code>NonfairSync</code>。</p>\n<p>默认情况是<code>ReentrantLock</code>使用的是非公平的<code>NonfairSync</code>。</p>\n<p>下面看看<code>ReentrantLock</code>的<code>NonfairSync</code>的加锁和释放锁，分析一下AQS对独占型同步器的支持。</p>\n<h3 id=\"NonfairSync\"><a href=\"#NonfairSync\" class=\"headerlink\" title=\"NonfairSync\"></a>NonfairSync</h3><h4 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock\"></a>lock</h4><p>非公平锁加锁方法的入口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</div><div class=\"line\">    setExclusiveOwnerThread(Thread.currentThread());</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    acquire(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先是一个CAS操作，比较设置state变量的值。</p>\n<p>state变量来自AQS，表示资源（锁）的状态，0表示未获取，1表示已获取一个。大于1表示获取（重入）的次数。</p>\n<p>若资源未获取，修改资源状态成功后，会保存独占资源的线程（使用<code>setExclusiveOwnerThread</code>方法，该方法位于<code>AbstractOwnableSynchronizer</code>，AQS继承于它）。</p>\n<p>若资源已经被获取，则调用<code>acquire</code>方法获取锁。</p>\n<p><code>acquire</code>是AQS在独占模式下获取资源的入口。可以看出在<code>ReentrantLock</code>加锁的主要逻辑都是依赖于AQS的，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class=\"line\">    selfInterrupt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>分别看一下<code>tryAcquire</code>,<code>acquireQueued</code>,<code>addWaiter</code>,<code>selfInterrupt</code>的具体实现：</p>\n<ol>\n<li>在ReentrantLock中<code>tryAcquire</code>具体的逻辑：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>AQS</code>的<code>tryAcquire</code>是一个空方法，直接抛异常。<code>ReentrantLock</code>中对非公平锁的的实现则调用<code>nonfairTryAcquire</code>方法，逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 获取当前要获取锁的线程</span></div><div class=\"line\">  <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</div><div class=\"line\">  <span class=\"comment\">// 当前锁的状态</span></div><div class=\"line\">  <span class=\"keyword\">int</span> c = getState();</div><div class=\"line\">  <span class=\"comment\">// CAS操作，如果锁未获取修改锁状态，获取锁</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</div><div class=\"line\">      setExclusiveOwnerThread(current);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果锁已经被获取且当前线程是获取锁的线程，更新锁状态，重入锁</span></div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nextc = c + acquires;</div><div class=\"line\">    <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</div><div class=\"line\">    setState(nextc);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 其他情况都失败</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><code>addWaiter</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 根据线程实例和模式封装节点</span></div><div class=\"line\">  Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</div><div class=\"line\">  <span class=\"comment\">// 尝试快速添加节点到队尾，成功则直接返回</span></div><div class=\"line\">  Node pred = tail;</div><div class=\"line\">  <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    node.prev = pred;</div><div class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class=\"line\">      pred.next = node;</div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 调用enq方法添加至队尾</span></div><div class=\"line\">  enq(node);</div><div class=\"line\">  <span class=\"keyword\">return</span> node;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 自旋操作</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">    Node t = tail;</div><div class=\"line\">    <span class=\"comment\">// 如果尾节点空（链表为空），创建一个不包含线程的头结点</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</div><div class=\"line\">        tail = head;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 添加至队尾</span></div><div class=\"line\">      node.prev = t;</div><div class=\"line\">      <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</div><div class=\"line\">        t.next = node;</div><div class=\"line\">        <span class=\"keyword\">return</span> t;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><code>acquireQueued</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;  <span class=\"comment\">// 是否获取锁失败</span></div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"comment\">// 自旋操作</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">      <span class=\"keyword\">final</span> Node p = node.predecessor();  <span class=\"comment\">// 前驱节点</span></div><div class=\"line\">      <span class=\"comment\">// 如果前驱是头结点，并且获取资源成功</span></div><div class=\"line\">      <span class=\"comment\">// 因为enq方法中判断若链表为空，则创建一个没有线程的头结点。</span></div><div class=\"line\">      <span class=\"comment\">// 所以当前驱是头结点时，说明该节点有可能获取资源</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class=\"line\">        setHead(node);</div><div class=\"line\">        p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></div><div class=\"line\">        failed = <span class=\"keyword\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> interrupted;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</div><div class=\"line\">        interrupted = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (failed)</div><div class=\"line\">      cancelAcquire(node);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> ws = pred.waitStatus;</div><div class=\"line\">  <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</div><div class=\"line\">    <span class=\"comment\">// 如果前驱节点状态是SIGNAL，返回</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 如果前驱节点状态是CANCEL，删除此节都，直到前驱节点不是CANCEL</span></div><div class=\"line\">    do &#123;</div><div class=\"line\">      node.prev = pred = pred.prev;</div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</div><div class=\"line\">    pred.next = node;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 其他情况，使用CAS操作将前驱设置为SIGNAL</span></div><div class=\"line\">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于节点状态的说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 代表线程已经被取消</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"comment\">// 代表后续节点需要唤醒</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"comment\">// 代表线程在condition queue中，等待某一条件</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"comment\">// 代表后续结点会传播唤醒的操作，共享模式下起作用</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"comment\">// 新结点会处于这种状态</span></div><div class=\"line\">\t\t\t\t\t\t    <span class=\"number\">0</span>;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 暂停</span></div><div class=\"line\">  LockSupport.park(<span class=\"keyword\">this</span>);</div><div class=\"line\">  <span class=\"comment\">// 返回中断状况</span></div><div class=\"line\">  <span class=\"keyword\">return</span> Thread.interrupted();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至此完成锁获取的完整过程。</p>\n<h4 id=\"unlock\"><a href=\"#unlock\" class=\"headerlink\" title=\"unlock\"></a>unlock</h4><p>非公平锁释放锁方法的入口更简单，完全依赖AQS：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  sync.release(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>AQS中资源的释放实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</div><div class=\"line\">    <span class=\"comment\">// 释放资源成功</span></div><div class=\"line\">    Node h = head;</div><div class=\"line\">    <span class=\"comment\">// 队列后不为空，且队列头状态不是新建</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</div><div class=\"line\">      <span class=\"comment\">// 释放队列头的后继节点</span></div><div class=\"line\">      unparkSuccessor(h);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如同<code>tryAcquire</code>方法，AQS中<code>tryRelease</code>方法也是个空方法。<code>ReentrantLock</code>中的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 获取当前的state减一</span></div><div class=\"line\">  <span class=\"keyword\">int</span> c = getState() - releases;</div><div class=\"line\">  <span class=\"comment\">// 如果当前线程不是独占线程，抛出异常</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</div><div class=\"line\">  <span class=\"comment\">// 申请的锁是否都被释放</span></div><div class=\"line\">  <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</div><div class=\"line\">  <span class=\"comment\">// 锁都被释放，重置独占线程</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    free = <span class=\"keyword\">true</span>;</div><div class=\"line\">    setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 更新state</span></div><div class=\"line\">  setState(c);</div><div class=\"line\">  <span class=\"keyword\">return</span> free;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>释放头节点的后继节点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 获取头结点的状态</span></div><div class=\"line\">  <span class=\"keyword\">int</span> ws = node.waitStatus;</div><div class=\"line\">  <span class=\"comment\">// 如果头结点状态小于0，更新为0</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</div><div class=\"line\">    compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"comment\">// 获取后继节点</span></div><div class=\"line\">  Node s = node.next;</div><div class=\"line\">  <span class=\"comment\">// 寻找头结点的下一个有效节点</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    s = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"comment\">// 从尾部遍历，寻找第一个有效节点</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</div><div class=\"line\">      <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</div><div class=\"line\">        s = t;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 释放锁</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</div><div class=\"line\">    LockSupport.unpark(s.thread);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上就是释放资源的过程，相对于加锁还是比较简单的。</p>\n<h3 id=\"FairSync\"><a href=\"#FairSync\" class=\"headerlink\" title=\"FairSync\"></a>FairSync</h3><p>与非公平的同步器不同，对于公平的同步器。在申请锁时条件更苛刻，要先判断当前节点前是否还有其他节点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    acquire(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</div><div class=\"line\">  <span class=\"keyword\">int</span> c = getState();</div><div class=\"line\">  <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 判断当前线程前是否还有其他线程</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</div><div class=\"line\">      setExclusiveOwnerThread(current);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nextc = c + acquires;</div><div class=\"line\">    <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</div><div class=\"line\">    setState(nextc);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>锁的释放则与非公平的同步器完全一致。</p>\n<hr>\n<p>除了<code>lock</code>和<code>unlock</code>方法，<code>ReentrantLock</code>还提供了其他功能的锁申请/释放的方法，但都是依赖于AQS。</p>\n<p>通过<code>ReentrantLock</code>大体可以对AQS后个印象：</p>\n<ol>\n<li>整个AQS使用双向链表作为底层数据结构；</li>\n<li>每个节点保存线程，以及状态信息；</li>\n<li>所有节点共同维护资源的使用情况；</li>\n<li>通过模板模式完成基本的同步器，具体的实现由子类完成（例如是否允许重入）；</li>\n<li>内部大量使用了CAS而非加锁确保线程安全；</li>\n</ol>\n","excerpt":"","more":"<p>之前的文章有简单描述了JUC下的各种同步器。<code>ReentrantLock</code>的引入弥补了原生的<code>synchronized</code>关键字的不足。好些天不更新博客了，今天简单记录一下<code>ReentrantLock</code>的实现。</p>\n<h2 id=\"同步器的基本实现\"><a href=\"#同步器的基本实现\" class=\"headerlink\" title=\"同步器的基本实现\"></a>同步器的基本实现</h2><p>JUC包下各种同步器主要依赖的都是<code>AbstractQueuedSynchronizer</code>（AQS）的实现，对于具体的实现大体可以分为两类：独占类型和共享类型。各种同步器并不直接继承成AQS，而是依赖于AQS的子类。</p>\n<p>例如：<code>CountDownLatch</code>的内部类<code>java.util.concurrent.CountDownLatch.Sync</code>就是共享型的同步器，其继承了AQS。</p>\n<p>本文记录同步器<code>ReentrantLock</code>的加锁、释放锁的具体实现。</p>\n<h2 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h2><p>与<code>CountDownLatch</code>类似，<code>ReentrantLock</code>对同步器的实现也是依赖其继承了AQS的内部类<code>java.util.concurrent.locks.ReentrantLock.Sync</code>。根据公平性，又具体提供了<code>FairSync</code>和<code>NonfairSync</code>。</p>\n<p>默认情况是<code>ReentrantLock</code>使用的是非公平的<code>NonfairSync</code>。</p>\n<p>下面看看<code>ReentrantLock</code>的<code>NonfairSync</code>的加锁和释放锁，分析一下AQS对独占型同步器的支持。</p>\n<h3 id=\"NonfairSync\"><a href=\"#NonfairSync\" class=\"headerlink\" title=\"NonfairSync\"></a>NonfairSync</h3><h4 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock\"></a>lock</h4><p>非公平锁加锁方法的入口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</div><div class=\"line\">    setExclusiveOwnerThread(Thread.currentThread());</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    acquire(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先是一个CAS操作，比较设置state变量的值。</p>\n<p>state变量来自AQS，表示资源（锁）的状态，0表示未获取，1表示已获取一个。大于1表示获取（重入）的次数。</p>\n<p>若资源未获取，修改资源状态成功后，会保存独占资源的线程（使用<code>setExclusiveOwnerThread</code>方法，该方法位于<code>AbstractOwnableSynchronizer</code>，AQS继承于它）。</p>\n<p>若资源已经被获取，则调用<code>acquire</code>方法获取锁。</p>\n<p><code>acquire</code>是AQS在独占模式下获取资源的入口。可以看出在<code>ReentrantLock</code>加锁的主要逻辑都是依赖于AQS的，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class=\"line\">    selfInterrupt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>分别看一下<code>tryAcquire</code>,<code>acquireQueued</code>,<code>addWaiter</code>,<code>selfInterrupt</code>的具体实现：</p>\n<ol>\n<li>在ReentrantLock中<code>tryAcquire</code>具体的逻辑：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>AQS</code>的<code>tryAcquire</code>是一个空方法，直接抛异常。<code>ReentrantLock</code>中对非公平锁的的实现则调用<code>nonfairTryAcquire</code>方法，逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 获取当前要获取锁的线程</span></div><div class=\"line\">  <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</div><div class=\"line\">  <span class=\"comment\">// 当前锁的状态</span></div><div class=\"line\">  <span class=\"keyword\">int</span> c = getState();</div><div class=\"line\">  <span class=\"comment\">// CAS操作，如果锁未获取修改锁状态，获取锁</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</div><div class=\"line\">      setExclusiveOwnerThread(current);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果锁已经被获取且当前线程是获取锁的线程，更新锁状态，重入锁</span></div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nextc = c + acquires;</div><div class=\"line\">    <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</div><div class=\"line\">    setState(nextc);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 其他情况都失败</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><code>addWaiter</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 根据线程实例和模式封装节点</span></div><div class=\"line\">  Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</div><div class=\"line\">  <span class=\"comment\">// 尝试快速添加节点到队尾，成功则直接返回</span></div><div class=\"line\">  Node pred = tail;</div><div class=\"line\">  <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    node.prev = pred;</div><div class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class=\"line\">      pred.next = node;</div><div class=\"line\">      <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 调用enq方法添加至队尾</span></div><div class=\"line\">  enq(node);</div><div class=\"line\">  <span class=\"keyword\">return</span> node;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 自旋操作</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">    Node t = tail;</div><div class=\"line\">    <span class=\"comment\">// 如果尾节点空（链表为空），创建一个不包含线程的头结点</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</div><div class=\"line\">        tail = head;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 添加至队尾</span></div><div class=\"line\">      node.prev = t;</div><div class=\"line\">      <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</div><div class=\"line\">        t.next = node;</div><div class=\"line\">        <span class=\"keyword\">return</span> t;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><code>acquireQueued</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;  <span class=\"comment\">// 是否获取锁失败</span></div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"comment\">// 自旋操作</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">      <span class=\"keyword\">final</span> Node p = node.predecessor();  <span class=\"comment\">// 前驱节点</span></div><div class=\"line\">      <span class=\"comment\">// 如果前驱是头结点，并且获取资源成功</span></div><div class=\"line\">      <span class=\"comment\">// 因为enq方法中判断若链表为空，则创建一个没有线程的头结点。</span></div><div class=\"line\">      <span class=\"comment\">// 所以当前驱是头结点时，说明该节点有可能获取资源</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class=\"line\">        setHead(node);</div><div class=\"line\">        p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></div><div class=\"line\">        failed = <span class=\"keyword\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> interrupted;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</div><div class=\"line\">        interrupted = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (failed)</div><div class=\"line\">      cancelAcquire(node);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> ws = pred.waitStatus;</div><div class=\"line\">  <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</div><div class=\"line\">    <span class=\"comment\">// 如果前驱节点状态是SIGNAL，返回</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 如果前驱节点状态是CANCEL，删除此节都，直到前驱节点不是CANCEL</span></div><div class=\"line\">    do &#123;</div><div class=\"line\">      node.prev = pred = pred.prev;</div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</div><div class=\"line\">    pred.next = node;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 其他情况，使用CAS操作将前驱设置为SIGNAL</span></div><div class=\"line\">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于节点状态的说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 代表线程已经被取消</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"comment\">// 代表后续节点需要唤醒</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"comment\">// 代表线程在condition queue中，等待某一条件</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"comment\">// 代表后续结点会传播唤醒的操作，共享模式下起作用</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"comment\">// 新结点会处于这种状态</span></div><div class=\"line\">\t\t\t\t\t\t    <span class=\"number\">0</span>;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 暂停</span></div><div class=\"line\">  LockSupport.park(<span class=\"keyword\">this</span>);</div><div class=\"line\">  <span class=\"comment\">// 返回中断状况</span></div><div class=\"line\">  <span class=\"keyword\">return</span> Thread.interrupted();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至此完成锁获取的完整过程。</p>\n<h4 id=\"unlock\"><a href=\"#unlock\" class=\"headerlink\" title=\"unlock\"></a>unlock</h4><p>非公平锁释放锁方法的入口更简单，完全依赖AQS：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  sync.release(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>AQS中资源的释放实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</div><div class=\"line\">    <span class=\"comment\">// 释放资源成功</span></div><div class=\"line\">    Node h = head;</div><div class=\"line\">    <span class=\"comment\">// 队列后不为空，且队列头状态不是新建</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</div><div class=\"line\">      <span class=\"comment\">// 释放队列头的后继节点</span></div><div class=\"line\">      unparkSuccessor(h);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如同<code>tryAcquire</code>方法，AQS中<code>tryRelease</code>方法也是个空方法。<code>ReentrantLock</code>中的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 获取当前的state减一</span></div><div class=\"line\">  <span class=\"keyword\">int</span> c = getState() - releases;</div><div class=\"line\">  <span class=\"comment\">// 如果当前线程不是独占线程，抛出异常</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</div><div class=\"line\">  <span class=\"comment\">// 申请的锁是否都被释放</span></div><div class=\"line\">  <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</div><div class=\"line\">  <span class=\"comment\">// 锁都被释放，重置独占线程</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    free = <span class=\"keyword\">true</span>;</div><div class=\"line\">    setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 更新state</span></div><div class=\"line\">  setState(c);</div><div class=\"line\">  <span class=\"keyword\">return</span> free;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>释放头节点的后继节点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 获取头结点的状态</span></div><div class=\"line\">  <span class=\"keyword\">int</span> ws = node.waitStatus;</div><div class=\"line\">  <span class=\"comment\">// 如果头结点状态小于0，更新为0</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</div><div class=\"line\">    compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"comment\">// 获取后继节点</span></div><div class=\"line\">  Node s = node.next;</div><div class=\"line\">  <span class=\"comment\">// 寻找头结点的下一个有效节点</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    s = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"comment\">// 从尾部遍历，寻找第一个有效节点</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</div><div class=\"line\">      <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</div><div class=\"line\">        s = t;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 释放锁</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</div><div class=\"line\">    LockSupport.unpark(s.thread);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上就是释放资源的过程，相对于加锁还是比较简单的。</p>\n<h3 id=\"FairSync\"><a href=\"#FairSync\" class=\"headerlink\" title=\"FairSync\"></a>FairSync</h3><p>与非公平的同步器不同，对于公平的同步器。在申请锁时条件更苛刻，要先判断当前节点前是否还有其他节点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    acquire(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</div><div class=\"line\">  <span class=\"keyword\">int</span> c = getState();</div><div class=\"line\">  <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 判断当前线程前是否还有其他线程</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</div><div class=\"line\">      setExclusiveOwnerThread(current);</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nextc = c + acquires;</div><div class=\"line\">    <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</div><div class=\"line\">    setState(nextc);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>锁的释放则与非公平的同步器完全一致。</p>\n<hr>\n<p>除了<code>lock</code>和<code>unlock</code>方法，<code>ReentrantLock</code>还提供了其他功能的锁申请/释放的方法，但都是依赖于AQS。</p>\n<p>通过<code>ReentrantLock</code>大体可以对AQS后个印象：</p>\n<ol>\n<li>整个AQS使用双向链表作为底层数据结构；</li>\n<li>每个节点保存线程，以及状态信息；</li>\n<li>所有节点共同维护资源的使用情况；</li>\n<li>通过模板模式完成基本的同步器，具体的实现由子类完成（例如是否允许重入）；</li>\n<li>内部大量使用了CAS而非加锁确保线程安全；</li>\n</ol>\n"},{"title":"使用CI发布Hexo","date":"2017-01-07T05:34:08.000Z","_content":"\n**测试使用CI发布Hexo**\n\n从此刻开始本站开始使用[Travis-CI](https://travis-ci.org)发布。\n博客已有两个月没有更新内容了，年底各项事宜又赶上上冲刺，这一个月忙的焦头烂额。\n整理了一点东西准备发布也就放弃了，整个发布都得手工执行，今年起始的目标就有使用CI让开发更高效。\n今天在博客上实践了一下持续集成，一口气把之前整理的几篇文章都发布了，整个流程还是简单了不少。\n\n\n网上关于Travis-CI的说明还是比较多的，我主要参考了[这里](http://blog.csdn.net/woblog/article/details/51319364)。\n\n但是我掉了一个坑，我使用的主题是[nexT](http://theme-next.iissnan.com/)，直接从Github上clone得到并做了自定义，同时没有删除next主题文件夹内的`.git`文件夹。所以博客的版本控制没有直接管理next主题文件夹，在提交的时候整个next主题文件夹就没有提交上去，所以不能正确生成页面文件，导致最终网站的所有页面都成了空白页面。\n\n解决办法很简单，删除themes/next的.git和.gitignore，加入版本控制提交就可以了。\n\n同时我还根据报错调整了`.travis.yml`, like this:\n\n```yaml\nanguage: node_js\nnode_js: stable\n\ninstall:\n  - npm install -g hexo\n  - npm install -g hexo-cli\n  - npm install\n\nscript:\n  - hexo clean\n  - hexo g\n\nafter_script:\n  - cd ./public\n  - git init\n  - git config user.name \"zahnghTK\"\n  - git config user.email \"510223064@qq.com\"\n  - git add .\n  - git commit -m \"Update docs\"\n  - git push --force --quiet \"https://${GH_TOKEN}@${GH_REF}\" master:master\n\nbranches:\n  only:\n    - hexo\nenv:\n global:\n   - GH_REF: github.com/zhanghTK/zhanghTK.github.io.git\n```\n\n好啦，本篇文章就到这里，2017起始，容我水一文。\n","source":"_posts/使用CI发布Hexo.md","raw":"---\ntitle: 使用CI发布Hexo\ndate: 2017-01-07 13:34:08\ntags:\ncategories: 随笔\n---\n\n**测试使用CI发布Hexo**\n\n从此刻开始本站开始使用[Travis-CI](https://travis-ci.org)发布。\n博客已有两个月没有更新内容了，年底各项事宜又赶上上冲刺，这一个月忙的焦头烂额。\n整理了一点东西准备发布也就放弃了，整个发布都得手工执行，今年起始的目标就有使用CI让开发更高效。\n今天在博客上实践了一下持续集成，一口气把之前整理的几篇文章都发布了，整个流程还是简单了不少。\n\n\n网上关于Travis-CI的说明还是比较多的，我主要参考了[这里](http://blog.csdn.net/woblog/article/details/51319364)。\n\n但是我掉了一个坑，我使用的主题是[nexT](http://theme-next.iissnan.com/)，直接从Github上clone得到并做了自定义，同时没有删除next主题文件夹内的`.git`文件夹。所以博客的版本控制没有直接管理next主题文件夹，在提交的时候整个next主题文件夹就没有提交上去，所以不能正确生成页面文件，导致最终网站的所有页面都成了空白页面。\n\n解决办法很简单，删除themes/next的.git和.gitignore，加入版本控制提交就可以了。\n\n同时我还根据报错调整了`.travis.yml`, like this:\n\n```yaml\nanguage: node_js\nnode_js: stable\n\ninstall:\n  - npm install -g hexo\n  - npm install -g hexo-cli\n  - npm install\n\nscript:\n  - hexo clean\n  - hexo g\n\nafter_script:\n  - cd ./public\n  - git init\n  - git config user.name \"zahnghTK\"\n  - git config user.email \"510223064@qq.com\"\n  - git add .\n  - git commit -m \"Update docs\"\n  - git push --force --quiet \"https://${GH_TOKEN}@${GH_REF}\" master:master\n\nbranches:\n  only:\n    - hexo\nenv:\n global:\n   - GH_REF: github.com/zhanghTK/zhanghTK.github.io.git\n```\n\n好啦，本篇文章就到这里，2017起始，容我水一文。\n","slug":"使用CI发布Hexo","published":1,"updated":"2017-01-07T08:38:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2rw0046d82ennbnalmr","content":"<p><strong>测试使用CI发布Hexo</strong></p>\n<p>从此刻开始本站开始使用<a href=\"https://travis-ci.org\" target=\"_blank\" rel=\"external\">Travis-CI</a>发布。<br>博客已有两个月没有更新内容了，年底各项事宜又赶上上冲刺，这一个月忙的焦头烂额。<br>整理了一点东西准备发布也就放弃了，整个发布都得手工执行，今年起始的目标就有使用CI让开发更高效。<br>今天在博客上实践了一下持续集成，一口气把之前整理的几篇文章都发布了，整个流程还是简单了不少。</p>\n<p>网上关于Travis-CI的说明还是比较多的，我主要参考了<a href=\"http://blog.csdn.net/woblog/article/details/51319364\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<p>但是我掉了一个坑，我使用的主题是<a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"external\">nexT</a>，直接从Github上clone得到并做了自定义，同时没有删除next主题文件夹内的<code>.git</code>文件夹。所以博客的版本控制没有直接管理next主题文件夹，在提交的时候整个next主题文件夹就没有提交上去，所以不能正确生成页面文件，导致最终网站的所有页面都成了空白页面。</p>\n<p>解决办法很简单，删除themes/next的.git和.gitignore，加入版本控制提交就可以了。</p>\n<p>同时我还根据报错调整了<code>.travis.yml</code>, like this:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">anguage:</span> node_js</div><div class=\"line\"><span class=\"attr\">node_js:</span> stable</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">install:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> npm install -g hexo</div><div class=\"line\"><span class=\"bullet\">  -</span> npm install -g hexo-cli</div><div class=\"line\"><span class=\"bullet\">  -</span> npm install</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> hexo clean</div><div class=\"line\"><span class=\"bullet\">  -</span> hexo g</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">after_script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> cd ./public</div><div class=\"line\"><span class=\"bullet\">  -</span> git init</div><div class=\"line\"><span class=\"bullet\">  -</span> git config user.name <span class=\"string\">\"zahnghTK\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git config user.email <span class=\"string\">\"510223064@qq.com\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git add .</div><div class=\"line\"><span class=\"bullet\">  -</span> git commit -m <span class=\"string\">\"Update docs\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git push --force --quiet <span class=\"string\">\"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;\"</span> master:master</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">branches:</span></div><div class=\"line\"><span class=\"attr\">  only:</span></div><div class=\"line\"><span class=\"bullet\">    -</span> hexo</div><div class=\"line\"><span class=\"attr\">env:</span></div><div class=\"line\"><span class=\"attr\"> global:</span></div><div class=\"line\"><span class=\"attr\">   - GH_REF:</span> github.com/zhanghTK/zhanghTK.github.io.git</div></pre></td></tr></table></figure>\n<p>好啦，本篇文章就到这里，2017起始，容我水一文。</p>\n","excerpt":"","more":"<p><strong>测试使用CI发布Hexo</strong></p>\n<p>从此刻开始本站开始使用<a href=\"https://travis-ci.org\">Travis-CI</a>发布。<br>博客已有两个月没有更新内容了，年底各项事宜又赶上上冲刺，这一个月忙的焦头烂额。<br>整理了一点东西准备发布也就放弃了，整个发布都得手工执行，今年起始的目标就有使用CI让开发更高效。<br>今天在博客上实践了一下持续集成，一口气把之前整理的几篇文章都发布了，整个流程还是简单了不少。</p>\n<p>网上关于Travis-CI的说明还是比较多的，我主要参考了<a href=\"http://blog.csdn.net/woblog/article/details/51319364\">这里</a>。</p>\n<p>但是我掉了一个坑，我使用的主题是<a href=\"http://theme-next.iissnan.com/\">nexT</a>，直接从Github上clone得到并做了自定义，同时没有删除next主题文件夹内的<code>.git</code>文件夹。所以博客的版本控制没有直接管理next主题文件夹，在提交的时候整个next主题文件夹就没有提交上去，所以不能正确生成页面文件，导致最终网站的所有页面都成了空白页面。</p>\n<p>解决办法很简单，删除themes/next的.git和.gitignore，加入版本控制提交就可以了。</p>\n<p>同时我还根据报错调整了<code>.travis.yml</code>, like this:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">anguage:</span> node_js</div><div class=\"line\"><span class=\"attr\">node_js:</span> stable</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">install:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> npm install -g hexo</div><div class=\"line\"><span class=\"bullet\">  -</span> npm install -g hexo-cli</div><div class=\"line\"><span class=\"bullet\">  -</span> npm install</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> hexo clean</div><div class=\"line\"><span class=\"bullet\">  -</span> hexo g</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">after_script:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> cd ./public</div><div class=\"line\"><span class=\"bullet\">  -</span> git init</div><div class=\"line\"><span class=\"bullet\">  -</span> git config user.name <span class=\"string\">\"zahnghTK\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git config user.email <span class=\"string\">\"510223064@qq.com\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git add .</div><div class=\"line\"><span class=\"bullet\">  -</span> git commit -m <span class=\"string\">\"Update docs\"</span></div><div class=\"line\"><span class=\"bullet\">  -</span> git push --force --quiet <span class=\"string\">\"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;\"</span> master:master</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">branches:</span></div><div class=\"line\"><span class=\"attr\">  only:</span></div><div class=\"line\"><span class=\"bullet\">    -</span> hexo</div><div class=\"line\"><span class=\"attr\">env:</span></div><div class=\"line\"><span class=\"attr\"> global:</span></div><div class=\"line\"><span class=\"attr\">   - GH_REF:</span> github.com/zhanghTK/zhanghTK.github.io.git</div></pre></td></tr></table></figure>\n<p>好啦，本篇文章就到这里，2017起始，容我水一文。</p>\n"},{"title":"从依赖实现到依赖行为","date":"2016-10-22T10:59:11.000Z","_content":"\n## 背景\n\n一个报表程序需要初始化报表参数。具体的参数分为三种类型，都实现了`Parameter`类型，具体的初始化过程由子类实现。\n\n对报表参数初始化的过程，从对具体实现过程的依赖，依次经历对接口、对数据结构，最终对行为依赖，不断抽象依赖，实现更大程度的复用。\n\n## 对实现的依赖\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        for (Parameter para : parameterGraph.getParmaeters()) {\n            if (para instanceof SimpleParameter) {\n                SimpleParameter simplePara = (SimpleParameter) para;\n                String[] values = request.getParameterValues(para.getName());\n                simplePara.setValue(values);\n            } else {\n                if (para instanceof ItemParameter) {\n                    ItemParameter itemPara = (ItemParameter) para;\n                    for (Item item : itemPara.getItems()) {\n                        String[] values = request.getParameterValues(item.getName());\n                        item.setValues(values);\n                    }\n                } else {\n                    TableParameter tablePara = (TableParameter) para;\n                    String[] rows =\n                            request.getParameterValues(tablePara.getRowName());\n                    String[] columns =\n                            request.getParameterValues(tablePara.getColumnName());\n                    String[] dataCells =\n                            request.getParameterValues(tablePara.getDataCellName());\n\n                    int columnSize = columns.length;\n                    for (int i = 0; i < rows.length; i++) {\n                        for (int j = 0; j < columns.length; j++) {\n                            TableParameterElement element = new TableParameterElement();\n                            element.setRow(rows[i]);\n                            element.setColumn(columns[j]);\n                            element.setDataCell(dataCells[columnSize * i + j]);\n                            tablePara.addElement(element);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n坏代码的味道：\n\n1. 多层次的循环、IF嵌套，如果要在这个层次上加一个期限，那就是大于2。\n2. `IF/SWITCH instanceof Class`式的样板代码\n\n##  对接口的依赖\n\n多态替换分支语句，重构：\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        for (Parameter para : parameterGraph.getParmaeters()) {\n            para.fillParamter(request);\n        }\n    }\n}\n```\n## 对数据结构的依赖\n\n上面的重构使用多态极大简化了`ParameterCollector`，同时也让不同实现的`Parameter`更加容易维护。但是在Parameter的方法中传递了request，这使得Parameter类所在的包也必须依赖ServletHttpRequest。这种包之间不必要的耦合可以使用Map保存需要的键值映射关系，弱化这种依赖关系。\n\n进一步重构：\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        Map parmaeters = getParameterMap();           \n        for (Parameter para : parameterGraph.getParmaeters()) {\n            para.fillParamter(parmaeters);\n        }\n    }\n}\n```\n\n进一步重构后的代码虽然避免了对ServletHttpRequest的依赖，但是无法避免的对Map进行了依赖。\n\n对类似Map这样具体的数据结构依赖，让人无法清晰知道方法参数含义并不是好的编码风格。\n\n## 对行为的依赖\n\n在回头看最初的代码，与Servlet API强耦合的是这样一句`request.getParameterValues(para.getName())`\n\n依赖的到底是什么？站在函数式编程的角度，依赖的其实是一种行为：\n\n```java\nstring ->  request.getParameterValues(string)\n```\n\n在Java语法中为了传递一个方法，必须让方法附属在一个接口上，像这样：\n\n```java\npublic interface ParamterRequest {\n    String[] getParameterValues(String string);\n}\n```\n\n为了让ServletHttpRequest与ParamterRequest相关联，必须适配器模式，对象的适配器实现像下面这样：\n\n```java\nprivate class ParameterRequestAdapter implements ParamterRequest {\n    ServletHttpRequest servletHttpRequest;\n\n    public ParameterRequestAdapter(ServletHttpRequest servletHttpRequest) {\n        this.servletHttpRequest = servletHttpRequest;\n    }\n\n    @Override\n    public String[] getParameterValues(String string) {\n        return servletHttpRequest.getParameterValues(string);\n    }\n}\n```\n\n使用上面的适配器再进一步重构：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n\tfor (Parameter para : parameterGraph.getParmaeters()) {\n\t\tpara.fillParamter(new ParameterRequestAdapter(request));\n\t}\n}\n```\n\n我们还可以使用匿名内部类：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(new ParamterRequest() {\n      @Override\n      public String[] getParameterValues(String string) {\n        return request.getParameterValues(string);\n      }\n    });\n  }\n}\n```\n\n在Java8我们还可以这样写：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(string ->  request.getParameterValues(string));\n  }\n}\n```\n\n甚至还可以这样：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(request::getParameterValues);\n  }\n}\n```\n回头看一眼原有大篇幅的方法，再看看多次重构过的代码。\n\n最明显的感受`fillParameters`方法比以前薄了：\n\n不相关的职责从方法中抽取出来放到单独的类维护了（职责单一）\n\n当有更多参数类型需要添加时`fillParameters`不需要做任何的修改，只要添加对应类型就好（开闭原则）\n\n之前对实现类的依赖现在变成了对接口的依赖（依赖倒置）\n\n重构过程中`Parameter`从对`request`的依赖变为对数据结构（Map）的依赖，避免了Parameter所在模块与`Servlet API`之间的耦合。\n\n从对数据结构的依赖最后变成了对接口（行为）的依赖，抽象程度进一步提高，可维护性也更好。\n\n\n\n## 面向对象与函数式编程\n\n面向对象强调对事物的抽象，强调名词\n\n函数式编程强调对行为的抽象，强调动词\n\n例如：\n\n```java\npublic class People {\n    private List<Person> persons = new ArrayList<Person>();\n\n    public List<Person> findByName(String name) {\n        List<Person> result = new ArrayList<Person>();\n        for (Person person : persons) {\n            if (person.getName().equals(name)) {\n                result.add(person);\n            }\n        }\n        return result;\n    }\n}\n```\n例如我们有一个方法findByName，以后可能还需要更多方法例如findByAge，findByGender，findChildren等等方法，所有的方法其实都只有查找的过滤条件不同，可以抽象出函数式的写法：\n\n```java\npublic List<Person> findPersons(Predicate<Person> predicate, Person people) {\n  List<Person> result = new ArrayList<>();\n  for (Person person : persons) {\n    if (predicate.test(people)) {\n      result.add(person);\n    }\n  }\n  return result;\n}\n```\n\nJava8可以简写成：\n\n\n```java\npublic List<Person> findPersons(Predicate<Person> predicate, Person people) {\n  return persons.stream().filter(predicate).collect(Collectors.toList());\n}\n```\n\n","source":"_posts/从依赖实现到依赖行为.md","raw":"---\ntitle: 从依赖实现到依赖行为\ndate: 2016-10-22 18:59:11\ntags:\n  - Java\n  - 设计模式\n  - Functional\ncategories: 设计模式\n---\n\n## 背景\n\n一个报表程序需要初始化报表参数。具体的参数分为三种类型，都实现了`Parameter`类型，具体的初始化过程由子类实现。\n\n对报表参数初始化的过程，从对具体实现过程的依赖，依次经历对接口、对数据结构，最终对行为依赖，不断抽象依赖，实现更大程度的复用。\n\n## 对实现的依赖\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        for (Parameter para : parameterGraph.getParmaeters()) {\n            if (para instanceof SimpleParameter) {\n                SimpleParameter simplePara = (SimpleParameter) para;\n                String[] values = request.getParameterValues(para.getName());\n                simplePara.setValue(values);\n            } else {\n                if (para instanceof ItemParameter) {\n                    ItemParameter itemPara = (ItemParameter) para;\n                    for (Item item : itemPara.getItems()) {\n                        String[] values = request.getParameterValues(item.getName());\n                        item.setValues(values);\n                    }\n                } else {\n                    TableParameter tablePara = (TableParameter) para;\n                    String[] rows =\n                            request.getParameterValues(tablePara.getRowName());\n                    String[] columns =\n                            request.getParameterValues(tablePara.getColumnName());\n                    String[] dataCells =\n                            request.getParameterValues(tablePara.getDataCellName());\n\n                    int columnSize = columns.length;\n                    for (int i = 0; i < rows.length; i++) {\n                        for (int j = 0; j < columns.length; j++) {\n                            TableParameterElement element = new TableParameterElement();\n                            element.setRow(rows[i]);\n                            element.setColumn(columns[j]);\n                            element.setDataCell(dataCells[columnSize * i + j]);\n                            tablePara.addElement(element);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n坏代码的味道：\n\n1. 多层次的循环、IF嵌套，如果要在这个层次上加一个期限，那就是大于2。\n2. `IF/SWITCH instanceof Class`式的样板代码\n\n##  对接口的依赖\n\n多态替换分支语句，重构：\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        for (Parameter para : parameterGraph.getParmaeters()) {\n            para.fillParamter(request);\n        }\n    }\n}\n```\n## 对数据结构的依赖\n\n上面的重构使用多态极大简化了`ParameterCollector`，同时也让不同实现的`Parameter`更加容易维护。但是在Parameter的方法中传递了request，这使得Parameter类所在的包也必须依赖ServletHttpRequest。这种包之间不必要的耦合可以使用Map保存需要的键值映射关系，弱化这种依赖关系。\n\n进一步重构：\n\n```java\npublic class ParameterCollector {\n    public void fillParameters(ServletHttpRequest request, \n                                ParameterGraph parameterGraph) {\n        Map parmaeters = getParameterMap();           \n        for (Parameter para : parameterGraph.getParmaeters()) {\n            para.fillParamter(parmaeters);\n        }\n    }\n}\n```\n\n进一步重构后的代码虽然避免了对ServletHttpRequest的依赖，但是无法避免的对Map进行了依赖。\n\n对类似Map这样具体的数据结构依赖，让人无法清晰知道方法参数含义并不是好的编码风格。\n\n## 对行为的依赖\n\n在回头看最初的代码，与Servlet API强耦合的是这样一句`request.getParameterValues(para.getName())`\n\n依赖的到底是什么？站在函数式编程的角度，依赖的其实是一种行为：\n\n```java\nstring ->  request.getParameterValues(string)\n```\n\n在Java语法中为了传递一个方法，必须让方法附属在一个接口上，像这样：\n\n```java\npublic interface ParamterRequest {\n    String[] getParameterValues(String string);\n}\n```\n\n为了让ServletHttpRequest与ParamterRequest相关联，必须适配器模式，对象的适配器实现像下面这样：\n\n```java\nprivate class ParameterRequestAdapter implements ParamterRequest {\n    ServletHttpRequest servletHttpRequest;\n\n    public ParameterRequestAdapter(ServletHttpRequest servletHttpRequest) {\n        this.servletHttpRequest = servletHttpRequest;\n    }\n\n    @Override\n    public String[] getParameterValues(String string) {\n        return servletHttpRequest.getParameterValues(string);\n    }\n}\n```\n\n使用上面的适配器再进一步重构：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n\tfor (Parameter para : parameterGraph.getParmaeters()) {\n\t\tpara.fillParamter(new ParameterRequestAdapter(request));\n\t}\n}\n```\n\n我们还可以使用匿名内部类：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(new ParamterRequest() {\n      @Override\n      public String[] getParameterValues(String string) {\n        return request.getParameterValues(string);\n      }\n    });\n  }\n}\n```\n\n在Java8我们还可以这样写：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(string ->  request.getParameterValues(string));\n  }\n}\n```\n\n甚至还可以这样：\n\n```java\npublic void fillParameters(ServletHttpRequest request, ParameterGraph parameterGraph) {\n  for (Parameter para : parameterGraph.getParmaeters()) {\n    para.fillParamter(request::getParameterValues);\n  }\n}\n```\n回头看一眼原有大篇幅的方法，再看看多次重构过的代码。\n\n最明显的感受`fillParameters`方法比以前薄了：\n\n不相关的职责从方法中抽取出来放到单独的类维护了（职责单一）\n\n当有更多参数类型需要添加时`fillParameters`不需要做任何的修改，只要添加对应类型就好（开闭原则）\n\n之前对实现类的依赖现在变成了对接口的依赖（依赖倒置）\n\n重构过程中`Parameter`从对`request`的依赖变为对数据结构（Map）的依赖，避免了Parameter所在模块与`Servlet API`之间的耦合。\n\n从对数据结构的依赖最后变成了对接口（行为）的依赖，抽象程度进一步提高，可维护性也更好。\n\n\n\n## 面向对象与函数式编程\n\n面向对象强调对事物的抽象，强调名词\n\n函数式编程强调对行为的抽象，强调动词\n\n例如：\n\n```java\npublic class People {\n    private List<Person> persons = new ArrayList<Person>();\n\n    public List<Person> findByName(String name) {\n        List<Person> result = new ArrayList<Person>();\n        for (Person person : persons) {\n            if (person.getName().equals(name)) {\n                result.add(person);\n            }\n        }\n        return result;\n    }\n}\n```\n例如我们有一个方法findByName，以后可能还需要更多方法例如findByAge，findByGender，findChildren等等方法，所有的方法其实都只有查找的过滤条件不同，可以抽象出函数式的写法：\n\n```java\npublic List<Person> findPersons(Predicate<Person> predicate, Person people) {\n  List<Person> result = new ArrayList<>();\n  for (Person person : persons) {\n    if (predicate.test(people)) {\n      result.add(person);\n    }\n  }\n  return result;\n}\n```\n\nJava8可以简写成：\n\n\n```java\npublic List<Person> findPersons(Predicate<Person> predicate, Person people) {\n  return persons.stream().filter(predicate).collect(Collectors.toList());\n}\n```\n\n","slug":"从依赖实现到依赖行为","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2s8004bd82eylsw548g","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>一个报表程序需要初始化报表参数。具体的参数分为三种类型，都实现了<code>Parameter</code>类型，具体的初始化过程由子类实现。</p>\n<p>对报表参数初始化的过程，从对具体实现过程的依赖，依次经历对接口、对数据结构，最终对行为依赖，不断抽象依赖，实现更大程度的复用。</p>\n<h2 id=\"对实现的依赖\"><a href=\"#对实现的依赖\" class=\"headerlink\" title=\"对实现的依赖\"></a>对实现的依赖</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </span></span></div><div class=\"line\">                                ParameterGraph parameterGraph) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (para <span class=\"keyword\">instanceof</span> SimpleParameter) &#123;</div><div class=\"line\">                SimpleParameter simplePara = (SimpleParameter) para;</div><div class=\"line\">                String[] values = request.getParameterValues(para.getName());</div><div class=\"line\">                simplePara.setValue(values);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (para <span class=\"keyword\">instanceof</span> ItemParameter) &#123;</div><div class=\"line\">                    ItemParameter itemPara = (ItemParameter) para;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (Item item : itemPara.getItems()) &#123;</div><div class=\"line\">                        String[] values = request.getParameterValues(item.getName());</div><div class=\"line\">                        item.setValues(values);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    TableParameter tablePara = (TableParameter) para;</div><div class=\"line\">                    String[] rows =</div><div class=\"line\">                            request.getParameterValues(tablePara.getRowName());</div><div class=\"line\">                    String[] columns =</div><div class=\"line\">                            request.getParameterValues(tablePara.getColumnName());</div><div class=\"line\">                    String[] dataCells =</div><div class=\"line\">                            request.getParameterValues(tablePara.getDataCellName());</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">int</span> columnSize = columns.length;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows.length; i++) &#123;</div><div class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; columns.length; j++) &#123;</div><div class=\"line\">                            TableParameterElement element = <span class=\"keyword\">new</span> TableParameterElement();</div><div class=\"line\">                            element.setRow(rows[i]);</div><div class=\"line\">                            element.setColumn(columns[j]);</div><div class=\"line\">                            element.setDataCell(dataCells[columnSize * i + j]);</div><div class=\"line\">                            tablePara.addElement(element);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>坏代码的味道：</p>\n<ol>\n<li>多层次的循环、IF嵌套，如果要在这个层次上加一个期限，那就是大于2。</li>\n<li><code>IF/SWITCH instanceof Class</code>式的样板代码</li>\n</ol>\n<h2 id=\"对接口的依赖\"><a href=\"#对接口的依赖\" class=\"headerlink\" title=\"对接口的依赖\"></a>对接口的依赖</h2><p>多态替换分支语句，重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </span></span></div><div class=\"line\">                                ParameterGraph parameterGraph) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            para.fillParamter(request);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"对数据结构的依赖\"><a href=\"#对数据结构的依赖\" class=\"headerlink\" title=\"对数据结构的依赖\"></a>对数据结构的依赖</h2><p>上面的重构使用多态极大简化了<code>ParameterCollector</code>，同时也让不同实现的<code>Parameter</code>更加容易维护。但是在Parameter的方法中传递了request，这使得Parameter类所在的包也必须依赖ServletHttpRequest。这种包之间不必要的耦合可以使用Map保存需要的键值映射关系，弱化这种依赖关系。</p>\n<p>进一步重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </span></span></div><div class=\"line\">                                ParameterGraph parameterGraph) &#123;</div><div class=\"line\">        Map parmaeters = getParameterMap();           </div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            para.fillParamter(parmaeters);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进一步重构后的代码虽然避免了对ServletHttpRequest的依赖，但是无法避免的对Map进行了依赖。</p>\n<p>对类似Map这样具体的数据结构依赖，让人无法清晰知道方法参数含义并不是好的编码风格。</p>\n<h2 id=\"对行为的依赖\"><a href=\"#对行为的依赖\" class=\"headerlink\" title=\"对行为的依赖\"></a>对行为的依赖</h2><p>在回头看最初的代码，与Servlet API强耦合的是这样一句<code>request.getParameterValues(para.getName())</code></p>\n<p>依赖的到底是什么？站在函数式编程的角度，依赖的其实是一种行为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">string -&gt;  request.getParameterValues(string)</div></pre></td></tr></table></figure>\n<p>在Java语法中为了传递一个方法，必须让方法附属在一个接口上，像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ParamterRequest</span> </span>&#123;</div><div class=\"line\">    String[] getParameterValues(String string);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了让ServletHttpRequest与ParamterRequest相关联，必须适配器模式，对象的适配器实现像下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterRequestAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">ParamterRequest</span> </span>&#123;</div><div class=\"line\">    ServletHttpRequest servletHttpRequest;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ParameterRequestAdapter</span><span class=\"params\">(ServletHttpRequest servletHttpRequest)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.servletHttpRequest = servletHttpRequest;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> String[] getParameterValues(String string) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> servletHttpRequest.getParameterValues(string);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用上面的适配器再进一步重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">\t\tpara.fillParamter(<span class=\"keyword\">new</span> ParameterRequestAdapter(request));</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们还可以使用匿名内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(<span class=\"keyword\">new</span> ParamterRequest() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"keyword\">public</span> String[] getParameterValues(String string) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> request.getParameterValues(string);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Java8我们还可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(string -&gt;  request.getParameterValues(string));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>甚至还可以这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(request::getParameterValues);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>回头看一眼原有大篇幅的方法，再看看多次重构过的代码。</p>\n<p>最明显的感受<code>fillParameters</code>方法比以前薄了：</p>\n<p>不相关的职责从方法中抽取出来放到单独的类维护了（职责单一）</p>\n<p>当有更多参数类型需要添加时<code>fillParameters</code>不需要做任何的修改，只要添加对应类型就好（开闭原则）</p>\n<p>之前对实现类的依赖现在变成了对接口的依赖（依赖倒置）</p>\n<p>重构过程中<code>Parameter</code>从对<code>request</code>的依赖变为对数据结构（Map）的依赖，避免了Parameter所在模块与<code>Servlet API</code>之间的耦合。</p>\n<p>从对数据结构的依赖最后变成了对接口（行为）的依赖，抽象程度进一步提高，可维护性也更好。</p>\n<h2 id=\"面向对象与函数式编程\"><a href=\"#面向对象与函数式编程\" class=\"headerlink\" title=\"面向对象与函数式编程\"></a>面向对象与函数式编程</h2><p>面向对象强调对事物的抽象，强调名词</p>\n<p>函数式编程强调对行为的抽象，强调动词</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList&lt;Person&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findByName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        List&lt;Person&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;Person&gt;();</div><div class=\"line\">        <span class=\"keyword\">for</span> (Person person : persons) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (person.getName().equals(name)) &#123;</div><div class=\"line\">                result.add(person);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例如我们有一个方法findByName，以后可能还需要更多方法例如findByAge，findByGender，findChildren等等方法，所有的方法其实都只有查找的过滤条件不同，可以抽象出函数式的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findPersons</span><span class=\"params\">(Predicate&lt;Person&gt; predicate, Person people)</span> </span>&#123;</div><div class=\"line\">  List&lt;Person&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">  <span class=\"keyword\">for</span> (Person person : persons) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (predicate.test(people)) &#123;</div><div class=\"line\">      result.add(person);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Java8可以简写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findPersons</span><span class=\"params\">(Predicate&lt;Person&gt; predicate, Person people)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> persons.stream().filter(predicate).collect(Collectors.toList());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>一个报表程序需要初始化报表参数。具体的参数分为三种类型，都实现了<code>Parameter</code>类型，具体的初始化过程由子类实现。</p>\n<p>对报表参数初始化的过程，从对具体实现过程的依赖，依次经历对接口、对数据结构，最终对行为依赖，不断抽象依赖，实现更大程度的复用。</p>\n<h2 id=\"对实现的依赖\"><a href=\"#对实现的依赖\" class=\"headerlink\" title=\"对实现的依赖\"></a>对实现的依赖</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </div><div class=\"line\">                                ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (para <span class=\"keyword\">instanceof</span> SimpleParameter) &#123;</div><div class=\"line\">                SimpleParameter simplePara = (SimpleParameter) para;</div><div class=\"line\">                String[] values = request.getParameterValues(para.getName());</div><div class=\"line\">                simplePara.setValue(values);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (para <span class=\"keyword\">instanceof</span> ItemParameter) &#123;</div><div class=\"line\">                    ItemParameter itemPara = (ItemParameter) para;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (Item item : itemPara.getItems()) &#123;</div><div class=\"line\">                        String[] values = request.getParameterValues(item.getName());</div><div class=\"line\">                        item.setValues(values);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    TableParameter tablePara = (TableParameter) para;</div><div class=\"line\">                    String[] rows =</div><div class=\"line\">                            request.getParameterValues(tablePara.getRowName());</div><div class=\"line\">                    String[] columns =</div><div class=\"line\">                            request.getParameterValues(tablePara.getColumnName());</div><div class=\"line\">                    String[] dataCells =</div><div class=\"line\">                            request.getParameterValues(tablePara.getDataCellName());</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">int</span> columnSize = columns.length;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows.length; i++) &#123;</div><div class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; columns.length; j++) &#123;</div><div class=\"line\">                            TableParameterElement element = <span class=\"keyword\">new</span> TableParameterElement();</div><div class=\"line\">                            element.setRow(rows[i]);</div><div class=\"line\">                            element.setColumn(columns[j]);</div><div class=\"line\">                            element.setDataCell(dataCells[columnSize * i + j]);</div><div class=\"line\">                            tablePara.addElement(element);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>坏代码的味道：</p>\n<ol>\n<li>多层次的循环、IF嵌套，如果要在这个层次上加一个期限，那就是大于2。</li>\n<li><code>IF/SWITCH instanceof Class</code>式的样板代码</li>\n</ol>\n<h2 id=\"对接口的依赖\"><a href=\"#对接口的依赖\" class=\"headerlink\" title=\"对接口的依赖\"></a>对接口的依赖</h2><p>多态替换分支语句，重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </div><div class=\"line\">                                ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            para.fillParamter(request);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"对数据结构的依赖\"><a href=\"#对数据结构的依赖\" class=\"headerlink\" title=\"对数据结构的依赖\"></a>对数据结构的依赖</h2><p>上面的重构使用多态极大简化了<code>ParameterCollector</code>，同时也让不同实现的<code>Parameter</code>更加容易维护。但是在Parameter的方法中传递了request，这使得Parameter类所在的包也必须依赖ServletHttpRequest。这种包之间不必要的耦合可以使用Map保存需要的键值映射关系，弱化这种依赖关系。</p>\n<p>进一步重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterCollector</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, </div><div class=\"line\">                                ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">        Map parmaeters = getParameterMap();           </div><div class=\"line\">        <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">            para.fillParamter(parmaeters);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进一步重构后的代码虽然避免了对ServletHttpRequest的依赖，但是无法避免的对Map进行了依赖。</p>\n<p>对类似Map这样具体的数据结构依赖，让人无法清晰知道方法参数含义并不是好的编码风格。</p>\n<h2 id=\"对行为的依赖\"><a href=\"#对行为的依赖\" class=\"headerlink\" title=\"对行为的依赖\"></a>对行为的依赖</h2><p>在回头看最初的代码，与Servlet API强耦合的是这样一句<code>request.getParameterValues(para.getName())</code></p>\n<p>依赖的到底是什么？站在函数式编程的角度，依赖的其实是一种行为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">string -&gt;  request.getParameterValues(string)</div></pre></td></tr></table></figure>\n<p>在Java语法中为了传递一个方法，必须让方法附属在一个接口上，像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ParamterRequest</span> </span>&#123;</div><div class=\"line\">    String[] getParameterValues(String string);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了让ServletHttpRequest与ParamterRequest相关联，必须适配器模式，对象的适配器实现像下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParameterRequestAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">ParamterRequest</span> </span>&#123;</div><div class=\"line\">    ServletHttpRequest servletHttpRequest;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ParameterRequestAdapter</span><span class=\"params\">(ServletHttpRequest servletHttpRequest)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.servletHttpRequest = servletHttpRequest;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> String[] getParameterValues(String string) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> servletHttpRequest.getParameterValues(string);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用上面的适配器再进一步重构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">\t\tpara.fillParamter(<span class=\"keyword\">new</span> ParameterRequestAdapter(request));</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们还可以使用匿名内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(<span class=\"keyword\">new</span> ParamterRequest() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"keyword\">public</span> String[] getParameterValues(String string) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> request.getParameterValues(string);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Java8我们还可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(string -&gt;  request.getParameterValues(string));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>甚至还可以这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fillParameters</span><span class=\"params\">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</div><div class=\"line\">    para.fillParamter(request::getParameterValues);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>回头看一眼原有大篇幅的方法，再看看多次重构过的代码。</p>\n<p>最明显的感受<code>fillParameters</code>方法比以前薄了：</p>\n<p>不相关的职责从方法中抽取出来放到单独的类维护了（职责单一）</p>\n<p>当有更多参数类型需要添加时<code>fillParameters</code>不需要做任何的修改，只要添加对应类型就好（开闭原则）</p>\n<p>之前对实现类的依赖现在变成了对接口的依赖（依赖倒置）</p>\n<p>重构过程中<code>Parameter</code>从对<code>request</code>的依赖变为对数据结构（Map）的依赖，避免了Parameter所在模块与<code>Servlet API</code>之间的耦合。</p>\n<p>从对数据结构的依赖最后变成了对接口（行为）的依赖，抽象程度进一步提高，可维护性也更好。</p>\n<h2 id=\"面向对象与函数式编程\"><a href=\"#面向对象与函数式编程\" class=\"headerlink\" title=\"面向对象与函数式编程\"></a>面向对象与函数式编程</h2><p>面向对象强调对事物的抽象，强调名词</p>\n<p>函数式编程强调对行为的抽象，强调动词</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList&lt;Person&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findByName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        List&lt;Person&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;Person&gt;();</div><div class=\"line\">        <span class=\"keyword\">for</span> (Person person : persons) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (person.getName().equals(name)) &#123;</div><div class=\"line\">                result.add(person);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例如我们有一个方法findByName，以后可能还需要更多方法例如findByAge，findByGender，findChildren等等方法，所有的方法其实都只有查找的过滤条件不同，可以抽象出函数式的写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findPersons</span><span class=\"params\">(Predicate&lt;Person&gt; predicate, Person people)</span> </span>&#123;</div><div class=\"line\">  List&lt;Person&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">  <span class=\"keyword\">for</span> (Person person : persons) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (predicate.test(people)) &#123;</div><div class=\"line\">      result.add(person);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Java8可以简写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Person&gt; <span class=\"title\">findPersons</span><span class=\"params\">(Predicate&lt;Person&gt; predicate, Person people)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> persons.stream().filter(predicate).collect(Collectors.toList());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"命令模式","date":"2017-01-15T18:29:27.000Z","_content":"\n\n提到命令模式先别管他干什么，名字里有命令那肯定离不开命令，好的，开始编码：\n\n```\ncommandSender.order();\n```\n\n写完收工！当然是不行的，要面向对象，要遵循设计模式的几大原则的。\n\n（到底是几？我也不知道，有人说是五大原则，也有人说六大原则，还有说七大原则）\n\n简单划分一下职责，很自然的就能想到三个角色：\n\n1. 命令的发出者\n2. 命令\n3. 命令的接收者\n\n```java\nCommand command = commandSender.createCommend();\ncommandReceiver.execute(command);\n```\n\n《Head First 设计模式》中是以一个为多个电器设计通用遥控器的例子开始介绍命令模式的。\n\n假如我们认为遥控器是命令的发出者，那么谁是命令的接收者呢？\n\n我们无法根据命令就知道接受者到底是电视机，电灯还是其他。\n\n那么就有两种选择了，\n\n第一种：\n\n```\nCommand command = commandSender.createCommand();\nCommandReceiver commandReceiver = commandSender.getCommandReceiver();\ncommandReceiver.execute(command);\n```\n\n第二种：\n\n```java\nCommand command = commandSender.createCommandWithReceiver();\nCommandReceiver commandReceiver = command.getReceiver();\ncommandReceiver.execute(command);\n```\n\n如果遥控器是命令的发出者，第一种方式将造成遥控器与电器紧密的耦合在一起。\n\n当电器发生变化，遥控器也必须跟随发生变化，这就违反开闭原则。\n\n第二种方式其实就是命令模式，只不过习惯上命令模式把命令发出者成为调用者。UML类图如下：\n![19. 命令模式.png](https://ooo.0o0.ooo/2017/01/09/5873103fcee67.png)\n\n调用者封装命令，命令的具体执行由调用者委托给具体的命令。\n\n命令又封装了具体的命令接受者，命令的执行委托给命令的接受者。\n\n整个命令的执行起来时序图如下：\n\n![命令模式时序图.png](https://ooo.0o0.ooo/2017/01/09/5873353bc9c8e.png)\n\n除了遥控器的例子《Head First 设计模式》中还举了个餐厅订餐的例子，其中角色对应关系如下：\n\n| 命令模式  | 遥控器  | 餐厅   |\n| ----- | ---- | ---- |\n| 客户端   | 用户   | 顾客   |\n| 调用者   | 遥控器  | 女招待  |\n| 命令    | 按钮   | 订单   |\n| 命令接受者 | 电器   | 厨师   |\n\n关于点餐的例子我觉得不是很恰当，当然也可能是我理解的不对，书上描述顾客创建订单，订单作为命令包含具体的命令接受者厨师，这点怎么都不能接受，谁家点餐的时候会关注厨师呢？\n\n我的理解应该是顾客到店前，女招待，订单，厨师已经做好了准备。\n\n顾客要下单时直接找女招待就可以了，由女招待根据订单找厨师做菜。\n\n在通俗的说就是客户端只需要与调用者交互，不需要关心其他。其他部分的装配应给交给系统（例如，Spring）\n\n理清了这层关系，我们把目光停留在调用者身上。\n\n对于客户端来说，调用实际是从调用者这里发出的，换句话说，调用者实际上决定了命令实际的执行时机。\n\n假设一个场景，调用者和命令的关系不是一对一，而是一对多。\n\n当多个命令排队，依次等待调用者执行命令，这不就是队列请求模型？\n\n---\n\n命令模式的总结：\n\n所属类别：行为模式\n\n最大的优点：调用者与接受者的充分解耦\n\n基于命令模式可以方便的做出如下扩展：\n\n1. 调用者可以不知道接受者，甚至是不知道具体的命令，只需要预留接口；\n2. 一个命令中可以由多个命令组成，当此命令被调用时可以，触发多个命令的调用：宏命令；\n3. 方便命令执行前后增加切面，方便记录，回滚操作；\n4. 延迟命令执行的时机：队列请求模式；\n","source":"_posts/命令模式.md","raw":"---\ntitle: 命令模式\ndate: 2017-01-16 02:29:27\ntags:\n - 设计模式\n - Java\ncategory: 设计模式\n---\n\n\n提到命令模式先别管他干什么，名字里有命令那肯定离不开命令，好的，开始编码：\n\n```\ncommandSender.order();\n```\n\n写完收工！当然是不行的，要面向对象，要遵循设计模式的几大原则的。\n\n（到底是几？我也不知道，有人说是五大原则，也有人说六大原则，还有说七大原则）\n\n简单划分一下职责，很自然的就能想到三个角色：\n\n1. 命令的发出者\n2. 命令\n3. 命令的接收者\n\n```java\nCommand command = commandSender.createCommend();\ncommandReceiver.execute(command);\n```\n\n《Head First 设计模式》中是以一个为多个电器设计通用遥控器的例子开始介绍命令模式的。\n\n假如我们认为遥控器是命令的发出者，那么谁是命令的接收者呢？\n\n我们无法根据命令就知道接受者到底是电视机，电灯还是其他。\n\n那么就有两种选择了，\n\n第一种：\n\n```\nCommand command = commandSender.createCommand();\nCommandReceiver commandReceiver = commandSender.getCommandReceiver();\ncommandReceiver.execute(command);\n```\n\n第二种：\n\n```java\nCommand command = commandSender.createCommandWithReceiver();\nCommandReceiver commandReceiver = command.getReceiver();\ncommandReceiver.execute(command);\n```\n\n如果遥控器是命令的发出者，第一种方式将造成遥控器与电器紧密的耦合在一起。\n\n当电器发生变化，遥控器也必须跟随发生变化，这就违反开闭原则。\n\n第二种方式其实就是命令模式，只不过习惯上命令模式把命令发出者成为调用者。UML类图如下：\n![19. 命令模式.png](https://ooo.0o0.ooo/2017/01/09/5873103fcee67.png)\n\n调用者封装命令，命令的具体执行由调用者委托给具体的命令。\n\n命令又封装了具体的命令接受者，命令的执行委托给命令的接受者。\n\n整个命令的执行起来时序图如下：\n\n![命令模式时序图.png](https://ooo.0o0.ooo/2017/01/09/5873353bc9c8e.png)\n\n除了遥控器的例子《Head First 设计模式》中还举了个餐厅订餐的例子，其中角色对应关系如下：\n\n| 命令模式  | 遥控器  | 餐厅   |\n| ----- | ---- | ---- |\n| 客户端   | 用户   | 顾客   |\n| 调用者   | 遥控器  | 女招待  |\n| 命令    | 按钮   | 订单   |\n| 命令接受者 | 电器   | 厨师   |\n\n关于点餐的例子我觉得不是很恰当，当然也可能是我理解的不对，书上描述顾客创建订单，订单作为命令包含具体的命令接受者厨师，这点怎么都不能接受，谁家点餐的时候会关注厨师呢？\n\n我的理解应该是顾客到店前，女招待，订单，厨师已经做好了准备。\n\n顾客要下单时直接找女招待就可以了，由女招待根据订单找厨师做菜。\n\n在通俗的说就是客户端只需要与调用者交互，不需要关心其他。其他部分的装配应给交给系统（例如，Spring）\n\n理清了这层关系，我们把目光停留在调用者身上。\n\n对于客户端来说，调用实际是从调用者这里发出的，换句话说，调用者实际上决定了命令实际的执行时机。\n\n假设一个场景，调用者和命令的关系不是一对一，而是一对多。\n\n当多个命令排队，依次等待调用者执行命令，这不就是队列请求模型？\n\n---\n\n命令模式的总结：\n\n所属类别：行为模式\n\n最大的优点：调用者与接受者的充分解耦\n\n基于命令模式可以方便的做出如下扩展：\n\n1. 调用者可以不知道接受者，甚至是不知道具体的命令，只需要预留接口；\n2. 一个命令中可以由多个命令组成，当此命令被调用时可以，触发多个命令的调用：宏命令；\n3. 方便命令执行前后增加切面，方便记录，回滚操作；\n4. 延迟命令执行的时机：队列请求模式；\n","slug":"命令模式","published":1,"updated":"2017-01-15T18:32:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2sc004ed82e15g8gz7x","content":"<p>提到命令模式先别管他干什么，名字里有命令那肯定离不开命令，好的，开始编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">commandSender.order();</div></pre></td></tr></table></figure>\n<p>写完收工！当然是不行的，要面向对象，要遵循设计模式的几大原则的。</p>\n<p>（到底是几？我也不知道，有人说是五大原则，也有人说六大原则，还有说七大原则）</p>\n<p>简单划分一下职责，很自然的就能想到三个角色：</p>\n<ol>\n<li>命令的发出者</li>\n<li>命令</li>\n<li>命令的接收者</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommend();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>《Head First 设计模式》中是以一个为多个电器设计通用遥控器的例子开始介绍命令模式的。</p>\n<p>假如我们认为遥控器是命令的发出者，那么谁是命令的接收者呢？</p>\n<p>我们无法根据命令就知道接受者到底是电视机，电灯还是其他。</p>\n<p>那么就有两种选择了，</p>\n<p>第一种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommand();</div><div class=\"line\">CommandReceiver commandReceiver = commandSender.getCommandReceiver();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>第二种：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommandWithReceiver();</div><div class=\"line\">CommandReceiver commandReceiver = command.getReceiver();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>如果遥控器是命令的发出者，第一种方式将造成遥控器与电器紧密的耦合在一起。</p>\n<p>当电器发生变化，遥控器也必须跟随发生变化，这就违反开闭原则。</p>\n<p>第二种方式其实就是命令模式，只不过习惯上命令模式把命令发出者成为调用者。UML类图如下：<br><img src=\"https://ooo.0o0.ooo/2017/01/09/5873103fcee67.png\" alt=\"19. 命令模式.png\"></p>\n<p>调用者封装命令，命令的具体执行由调用者委托给具体的命令。</p>\n<p>命令又封装了具体的命令接受者，命令的执行委托给命令的接受者。</p>\n<p>整个命令的执行起来时序图如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/09/5873353bc9c8e.png\" alt=\"命令模式时序图.png\"></p>\n<p>除了遥控器的例子《Head First 设计模式》中还举了个餐厅订餐的例子，其中角色对应关系如下：</p>\n<table>\n<thead>\n<tr>\n<th>命令模式</th>\n<th>遥控器</th>\n<th>餐厅</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>客户端</td>\n<td>用户</td>\n<td>顾客</td>\n</tr>\n<tr>\n<td>调用者</td>\n<td>遥控器</td>\n<td>女招待</td>\n</tr>\n<tr>\n<td>命令</td>\n<td>按钮</td>\n<td>订单</td>\n</tr>\n<tr>\n<td>命令接受者</td>\n<td>电器</td>\n<td>厨师</td>\n</tr>\n</tbody>\n</table>\n<p>关于点餐的例子我觉得不是很恰当，当然也可能是我理解的不对，书上描述顾客创建订单，订单作为命令包含具体的命令接受者厨师，这点怎么都不能接受，谁家点餐的时候会关注厨师呢？</p>\n<p>我的理解应该是顾客到店前，女招待，订单，厨师已经做好了准备。</p>\n<p>顾客要下单时直接找女招待就可以了，由女招待根据订单找厨师做菜。</p>\n<p>在通俗的说就是客户端只需要与调用者交互，不需要关心其他。其他部分的装配应给交给系统（例如，Spring）</p>\n<p>理清了这层关系，我们把目光停留在调用者身上。</p>\n<p>对于客户端来说，调用实际是从调用者这里发出的，换句话说，调用者实际上决定了命令实际的执行时机。</p>\n<p>假设一个场景，调用者和命令的关系不是一对一，而是一对多。</p>\n<p>当多个命令排队，依次等待调用者执行命令，这不就是队列请求模型？</p>\n<hr>\n<p>命令模式的总结：</p>\n<p>所属类别：行为模式</p>\n<p>最大的优点：调用者与接受者的充分解耦</p>\n<p>基于命令模式可以方便的做出如下扩展：</p>\n<ol>\n<li>调用者可以不知道接受者，甚至是不知道具体的命令，只需要预留接口；</li>\n<li>一个命令中可以由多个命令组成，当此命令被调用时可以，触发多个命令的调用：宏命令；</li>\n<li>方便命令执行前后增加切面，方便记录，回滚操作；</li>\n<li>延迟命令执行的时机：队列请求模式；</li>\n</ol>\n","excerpt":"","more":"<p>提到命令模式先别管他干什么，名字里有命令那肯定离不开命令，好的，开始编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">commandSender.order();</div></pre></td></tr></table></figure>\n<p>写完收工！当然是不行的，要面向对象，要遵循设计模式的几大原则的。</p>\n<p>（到底是几？我也不知道，有人说是五大原则，也有人说六大原则，还有说七大原则）</p>\n<p>简单划分一下职责，很自然的就能想到三个角色：</p>\n<ol>\n<li>命令的发出者</li>\n<li>命令</li>\n<li>命令的接收者</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommend();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>《Head First 设计模式》中是以一个为多个电器设计通用遥控器的例子开始介绍命令模式的。</p>\n<p>假如我们认为遥控器是命令的发出者，那么谁是命令的接收者呢？</p>\n<p>我们无法根据命令就知道接受者到底是电视机，电灯还是其他。</p>\n<p>那么就有两种选择了，</p>\n<p>第一种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommand();</div><div class=\"line\">CommandReceiver commandReceiver = commandSender.getCommandReceiver();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>第二种：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command command = commandSender.createCommandWithReceiver();</div><div class=\"line\">CommandReceiver commandReceiver = command.getReceiver();</div><div class=\"line\">commandReceiver.execute(command);</div></pre></td></tr></table></figure>\n<p>如果遥控器是命令的发出者，第一种方式将造成遥控器与电器紧密的耦合在一起。</p>\n<p>当电器发生变化，遥控器也必须跟随发生变化，这就违反开闭原则。</p>\n<p>第二种方式其实就是命令模式，只不过习惯上命令模式把命令发出者成为调用者。UML类图如下：<br><img src=\"https://ooo.0o0.ooo/2017/01/09/5873103fcee67.png\" alt=\"19. 命令模式.png\"></p>\n<p>调用者封装命令，命令的具体执行由调用者委托给具体的命令。</p>\n<p>命令又封装了具体的命令接受者，命令的执行委托给命令的接受者。</p>\n<p>整个命令的执行起来时序图如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/09/5873353bc9c8e.png\" alt=\"命令模式时序图.png\"></p>\n<p>除了遥控器的例子《Head First 设计模式》中还举了个餐厅订餐的例子，其中角色对应关系如下：</p>\n<table>\n<thead>\n<tr>\n<th>命令模式</th>\n<th>遥控器</th>\n<th>餐厅</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>客户端</td>\n<td>用户</td>\n<td>顾客</td>\n</tr>\n<tr>\n<td>调用者</td>\n<td>遥控器</td>\n<td>女招待</td>\n</tr>\n<tr>\n<td>命令</td>\n<td>按钮</td>\n<td>订单</td>\n</tr>\n<tr>\n<td>命令接受者</td>\n<td>电器</td>\n<td>厨师</td>\n</tr>\n</tbody>\n</table>\n<p>关于点餐的例子我觉得不是很恰当，当然也可能是我理解的不对，书上描述顾客创建订单，订单作为命令包含具体的命令接受者厨师，这点怎么都不能接受，谁家点餐的时候会关注厨师呢？</p>\n<p>我的理解应该是顾客到店前，女招待，订单，厨师已经做好了准备。</p>\n<p>顾客要下单时直接找女招待就可以了，由女招待根据订单找厨师做菜。</p>\n<p>在通俗的说就是客户端只需要与调用者交互，不需要关心其他。其他部分的装配应给交给系统（例如，Spring）</p>\n<p>理清了这层关系，我们把目光停留在调用者身上。</p>\n<p>对于客户端来说，调用实际是从调用者这里发出的，换句话说，调用者实际上决定了命令实际的执行时机。</p>\n<p>假设一个场景，调用者和命令的关系不是一对一，而是一对多。</p>\n<p>当多个命令排队，依次等待调用者执行命令，这不就是队列请求模型？</p>\n<hr>\n<p>命令模式的总结：</p>\n<p>所属类别：行为模式</p>\n<p>最大的优点：调用者与接受者的充分解耦</p>\n<p>基于命令模式可以方便的做出如下扩展：</p>\n<ol>\n<li>调用者可以不知道接受者，甚至是不知道具体的命令，只需要预留接口；</li>\n<li>一个命令中可以由多个命令组成，当此命令被调用时可以，触发多个命令的调用：宏命令；</li>\n<li>方便命令执行前后增加切面，方便记录，回滚操作；</li>\n<li>延迟命令执行的时机：队列请求模式；</li>\n</ol>\n"},{"title":"容器生态系统","date":"2017-12-08T14:02:16.000Z","_content":"\n## 容器核心技术\n\n### 容器规范\n\nOpen Container Initiative（OCI），制定开放的容器规范\n\n两个规范：runtime spec 和 image format spec\n\n### 容器runtime&管理工具\n\n容器的运行环境，容器只有在 runtime 中才能运行，主流容器：\n\n| runtime | 管理工具          | 备注                                       |\n| ------- | ------------- | ---------------------------------------- |\n| lxc     | lxd           | Linux 上老牌的容器 runtime；Docker 最初的 runtime  |\n| runc    | docker engine | Docker 开发的容器 runtime；符合 oci 规范；现在 Docker 的默认 runtime |\n| rkt     | rkt cli       | CoreOS 开发的容器 runtime，符合 oci 规范，能够运行 Docker 的容器 |\n\n### Registry&&容器OS\n\n- Registry：Docker Registry、[Docker Hub]([https://hub.docker.com]())、[Quay.io](https://quay.io/)\n- 容器OS：CoreOS、atomic、ubuntu core\n\n## 容器平台技术\n\n### 容器编排引擎\n\n高效的管理（容器管理、调度、集群定义和服务发现等）容器集群\n\n- docker swarm ： Docker 开发的容器编排引擎\n- kubernetes ： Google 领导开发的开源容器编排引擎，同时支持 Docker 和 CoreOS 容器\n- mesos 是一个通用的集群资源调度平台，mesos 与 marathon 一起提供容器编排引擎功能\n\n### 容器管理平台&&基于容器的PaaS\n\n容器管理平台：支持多种编排引擎，抽象了编排引擎的底层实现细节\n\n- Rancher\n- ContainerShip\n\n基于容器的PaaS：Deis、Flynn 和 Dokku\n\n## 容器支持技术\n\n- 容器网络：docker network、flannel、weave 和 calico\n- 服务发现：etcd、consul 和 zookeeper\n- 监控：docker ps/top/stats、stats API、sysdig、cAdvisor/Heapster 和 Weave Scope\n- 数据管理：Flocker\n- 日志管理：docker logs、logspout\n- 安全性：OpenSCAP\n\n\n## 运行容器——Hello World\n\n- 环境：\n\n  1. 管理工具：Docker Engine\n  2. runtime：runc\n  3. 操作系统：Ubuntu 16.04\n\n- 安装&运行：\n\n  1. 安装包，允许 `apt` 命令 HTTPS 访问 Docker 源\n\n     ```shell\n     $ sudo apt-get install \\\n         apt-transport-https \\\n         ca-certificates \\\n         curl \\\n         software-properties-common\n     ```\n\n  2. 添加 Docker 官方的 GPG\n\n     `$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -`\n\n  3. 将 Docker 的源添加到 /etc/apt/sources.list\n\n     ```shell\n     $ sudo add-apt-repository \\\n       \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n       $(lsb_release -cs) \\\n       stable\"\n     ```\n\n  4. 安装Docker\n\n     ```shell\n     $ sudo apt-get update\n     $ sudo apt-get install docker-ce\n     ```\n\n  5. 运行httpd\n\n     ```shell\n     $ sudo docker run -d -p 80:80 httpd\n     ```\n\n  6. Docker适应非root用户\n\n     ```shell\n     $ sudo groupadd docker\n     $ sudo gpasswd -a ${USER} docker\n     $ sudo service docker restart\n     ```\n\n  **NOTE**\n\n  安装、使用Docker时注意权限是否足够\n\n---\n\n本文主要内容整理自[每天5分钟玩转Docker容器技术](https://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw)\n","source":"_posts/容器生态系统.md","raw":"---\ntitle: 容器生态系统\ndate: 2017-12-08 22:02:16\ntags: 容器\ncategories: 容器\n---\n\n## 容器核心技术\n\n### 容器规范\n\nOpen Container Initiative（OCI），制定开放的容器规范\n\n两个规范：runtime spec 和 image format spec\n\n### 容器runtime&管理工具\n\n容器的运行环境，容器只有在 runtime 中才能运行，主流容器：\n\n| runtime | 管理工具          | 备注                                       |\n| ------- | ------------- | ---------------------------------------- |\n| lxc     | lxd           | Linux 上老牌的容器 runtime；Docker 最初的 runtime  |\n| runc    | docker engine | Docker 开发的容器 runtime；符合 oci 规范；现在 Docker 的默认 runtime |\n| rkt     | rkt cli       | CoreOS 开发的容器 runtime，符合 oci 规范，能够运行 Docker 的容器 |\n\n### Registry&&容器OS\n\n- Registry：Docker Registry、[Docker Hub]([https://hub.docker.com]())、[Quay.io](https://quay.io/)\n- 容器OS：CoreOS、atomic、ubuntu core\n\n## 容器平台技术\n\n### 容器编排引擎\n\n高效的管理（容器管理、调度、集群定义和服务发现等）容器集群\n\n- docker swarm ： Docker 开发的容器编排引擎\n- kubernetes ： Google 领导开发的开源容器编排引擎，同时支持 Docker 和 CoreOS 容器\n- mesos 是一个通用的集群资源调度平台，mesos 与 marathon 一起提供容器编排引擎功能\n\n### 容器管理平台&&基于容器的PaaS\n\n容器管理平台：支持多种编排引擎，抽象了编排引擎的底层实现细节\n\n- Rancher\n- ContainerShip\n\n基于容器的PaaS：Deis、Flynn 和 Dokku\n\n## 容器支持技术\n\n- 容器网络：docker network、flannel、weave 和 calico\n- 服务发现：etcd、consul 和 zookeeper\n- 监控：docker ps/top/stats、stats API、sysdig、cAdvisor/Heapster 和 Weave Scope\n- 数据管理：Flocker\n- 日志管理：docker logs、logspout\n- 安全性：OpenSCAP\n\n\n## 运行容器——Hello World\n\n- 环境：\n\n  1. 管理工具：Docker Engine\n  2. runtime：runc\n  3. 操作系统：Ubuntu 16.04\n\n- 安装&运行：\n\n  1. 安装包，允许 `apt` 命令 HTTPS 访问 Docker 源\n\n     ```shell\n     $ sudo apt-get install \\\n         apt-transport-https \\\n         ca-certificates \\\n         curl \\\n         software-properties-common\n     ```\n\n  2. 添加 Docker 官方的 GPG\n\n     `$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -`\n\n  3. 将 Docker 的源添加到 /etc/apt/sources.list\n\n     ```shell\n     $ sudo add-apt-repository \\\n       \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n       $(lsb_release -cs) \\\n       stable\"\n     ```\n\n  4. 安装Docker\n\n     ```shell\n     $ sudo apt-get update\n     $ sudo apt-get install docker-ce\n     ```\n\n  5. 运行httpd\n\n     ```shell\n     $ sudo docker run -d -p 80:80 httpd\n     ```\n\n  6. Docker适应非root用户\n\n     ```shell\n     $ sudo groupadd docker\n     $ sudo gpasswd -a ${USER} docker\n     $ sudo service docker restart\n     ```\n\n  **NOTE**\n\n  安装、使用Docker时注意权限是否足够\n\n---\n\n本文主要内容整理自[每天5分钟玩转Docker容器技术](https://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw)\n","slug":"容器生态系统","published":1,"updated":"2017-12-08T14:06:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2sf004jd82equqb8dew","content":"<h2 id=\"容器核心技术\"><a href=\"#容器核心技术\" class=\"headerlink\" title=\"容器核心技术\"></a>容器核心技术</h2><h3 id=\"容器规范\"><a href=\"#容器规范\" class=\"headerlink\" title=\"容器规范\"></a>容器规范</h3><p>Open Container Initiative（OCI），制定开放的容器规范</p>\n<p>两个规范：runtime spec 和 image format spec</p>\n<h3 id=\"容器runtime-amp-管理工具\"><a href=\"#容器runtime-amp-管理工具\" class=\"headerlink\" title=\"容器runtime&amp;管理工具\"></a>容器runtime&amp;管理工具</h3><p>容器的运行环境，容器只有在 runtime 中才能运行，主流容器：</p>\n<table>\n<thead>\n<tr>\n<th>runtime</th>\n<th>管理工具</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>lxc</td>\n<td>lxd</td>\n<td>Linux 上老牌的容器 runtime；Docker 最初的 runtime</td>\n</tr>\n<tr>\n<td>runc</td>\n<td>docker engine</td>\n<td>Docker 开发的容器 runtime；符合 oci 规范；现在 Docker 的默认 runtime</td>\n</tr>\n<tr>\n<td>rkt</td>\n<td>rkt cli</td>\n<td>CoreOS 开发的容器 runtime，符合 oci 规范，能够运行 Docker 的容器</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Registry-amp-amp-容器OS\"><a href=\"#Registry-amp-amp-容器OS\" class=\"headerlink\" title=\"Registry&amp;&amp;容器OS\"></a>Registry&amp;&amp;容器OS</h3><ul>\n<li>Registry：Docker Registry、<a href=\"[https://hub.docker.com](\">Docker Hub</a>)、<a href=\"https://quay.io/\" target=\"_blank\" rel=\"external\">Quay.io</a></li>\n<li>容器OS：CoreOS、atomic、ubuntu core</li>\n</ul>\n<h2 id=\"容器平台技术\"><a href=\"#容器平台技术\" class=\"headerlink\" title=\"容器平台技术\"></a>容器平台技术</h2><h3 id=\"容器编排引擎\"><a href=\"#容器编排引擎\" class=\"headerlink\" title=\"容器编排引擎\"></a>容器编排引擎</h3><p>高效的管理（容器管理、调度、集群定义和服务发现等）容器集群</p>\n<ul>\n<li>docker swarm ： Docker 开发的容器编排引擎</li>\n<li>kubernetes ： Google 领导开发的开源容器编排引擎，同时支持 Docker 和 CoreOS 容器</li>\n<li>mesos 是一个通用的集群资源调度平台，mesos 与 marathon 一起提供容器编排引擎功能</li>\n</ul>\n<h3 id=\"容器管理平台-amp-amp-基于容器的PaaS\"><a href=\"#容器管理平台-amp-amp-基于容器的PaaS\" class=\"headerlink\" title=\"容器管理平台&amp;&amp;基于容器的PaaS\"></a>容器管理平台&amp;&amp;基于容器的PaaS</h3><p>容器管理平台：支持多种编排引擎，抽象了编排引擎的底层实现细节</p>\n<ul>\n<li>Rancher</li>\n<li>ContainerShip</li>\n</ul>\n<p>基于容器的PaaS：Deis、Flynn 和 Dokku</p>\n<h2 id=\"容器支持技术\"><a href=\"#容器支持技术\" class=\"headerlink\" title=\"容器支持技术\"></a>容器支持技术</h2><ul>\n<li>容器网络：docker network、flannel、weave 和 calico</li>\n<li>服务发现：etcd、consul 和 zookeeper</li>\n<li>监控：docker ps/top/stats、stats API、sysdig、cAdvisor/Heapster 和 Weave Scope</li>\n<li>数据管理：Flocker</li>\n<li>日志管理：docker logs、logspout</li>\n<li>安全性：OpenSCAP</li>\n</ul>\n<h2 id=\"运行容器——Hello-World\"><a href=\"#运行容器——Hello-World\" class=\"headerlink\" title=\"运行容器——Hello World\"></a>运行容器——Hello World</h2><ul>\n<li><p>环境：</p>\n<ol>\n<li>管理工具：Docker Engine</li>\n<li>runtime：runc</li>\n<li>操作系统：Ubuntu 16.04</li>\n</ol>\n</li>\n<li><p>安装&amp;运行：</p>\n<ol>\n<li><p>安装包，允许 <code>apt</code> 命令 HTTPS 访问 Docker 源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo apt-get install \\</div><div class=\"line\">    apt-transport-https \\</div><div class=\"line\">    ca-certificates \\</div><div class=\"line\">    curl \\</div><div class=\"line\">    software-properties-common</div></pre></td></tr></table></figure>\n</li>\n<li><p>添加 Docker 官方的 GPG</p>\n<p><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></p>\n</li>\n<li><p>将 Docker 的源添加到 /etc/apt/sources.list</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo add-apt-repository \\</div><div class=\"line\">  &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\</div><div class=\"line\">  $(lsb_release -cs) \\</div><div class=\"line\">  stable&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装Docker</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo apt-get update</div><div class=\"line\">$ sudo apt-get install docker-ce</div></pre></td></tr></table></figure>\n</li>\n<li><p>运行httpd</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo docker run -d -p 80:80 httpd</div></pre></td></tr></table></figure>\n</li>\n<li><p>Docker适应非root用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo groupadd docker</div><div class=\"line\">$ sudo gpasswd -a $&#123;USER&#125; docker</div><div class=\"line\">$ sudo service docker restart</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>NOTE</strong></p>\n<p>安装、使用Docker时注意权限是否足够</p>\n</li>\n</ul>\n<hr>\n<p>本文主要内容整理自<a href=\"https://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw\" target=\"_blank\" rel=\"external\">每天5分钟玩转Docker容器技术</a></p>\n","excerpt":"","more":"<h2 id=\"容器核心技术\"><a href=\"#容器核心技术\" class=\"headerlink\" title=\"容器核心技术\"></a>容器核心技术</h2><h3 id=\"容器规范\"><a href=\"#容器规范\" class=\"headerlink\" title=\"容器规范\"></a>容器规范</h3><p>Open Container Initiative（OCI），制定开放的容器规范</p>\n<p>两个规范：runtime spec 和 image format spec</p>\n<h3 id=\"容器runtime-amp-管理工具\"><a href=\"#容器runtime-amp-管理工具\" class=\"headerlink\" title=\"容器runtime&amp;管理工具\"></a>容器runtime&amp;管理工具</h3><p>容器的运行环境，容器只有在 runtime 中才能运行，主流容器：</p>\n<table>\n<thead>\n<tr>\n<th>runtime</th>\n<th>管理工具</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>lxc</td>\n<td>lxd</td>\n<td>Linux 上老牌的容器 runtime；Docker 最初的 runtime</td>\n</tr>\n<tr>\n<td>runc</td>\n<td>docker engine</td>\n<td>Docker 开发的容器 runtime；符合 oci 规范；现在 Docker 的默认 runtime</td>\n</tr>\n<tr>\n<td>rkt</td>\n<td>rkt cli</td>\n<td>CoreOS 开发的容器 runtime，符合 oci 规范，能够运行 Docker 的容器</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Registry-amp-amp-容器OS\"><a href=\"#Registry-amp-amp-容器OS\" class=\"headerlink\" title=\"Registry&amp;&amp;容器OS\"></a>Registry&amp;&amp;容器OS</h3><ul>\n<li>Registry：Docker Registry、<a href=\"[https://hub.docker.com](\">Docker Hub</a>)、<a href=\"https://quay.io/\">Quay.io</a></li>\n<li>容器OS：CoreOS、atomic、ubuntu core</li>\n</ul>\n<h2 id=\"容器平台技术\"><a href=\"#容器平台技术\" class=\"headerlink\" title=\"容器平台技术\"></a>容器平台技术</h2><h3 id=\"容器编排引擎\"><a href=\"#容器编排引擎\" class=\"headerlink\" title=\"容器编排引擎\"></a>容器编排引擎</h3><p>高效的管理（容器管理、调度、集群定义和服务发现等）容器集群</p>\n<ul>\n<li>docker swarm ： Docker 开发的容器编排引擎</li>\n<li>kubernetes ： Google 领导开发的开源容器编排引擎，同时支持 Docker 和 CoreOS 容器</li>\n<li>mesos 是一个通用的集群资源调度平台，mesos 与 marathon 一起提供容器编排引擎功能</li>\n</ul>\n<h3 id=\"容器管理平台-amp-amp-基于容器的PaaS\"><a href=\"#容器管理平台-amp-amp-基于容器的PaaS\" class=\"headerlink\" title=\"容器管理平台&amp;&amp;基于容器的PaaS\"></a>容器管理平台&amp;&amp;基于容器的PaaS</h3><p>容器管理平台：支持多种编排引擎，抽象了编排引擎的底层实现细节</p>\n<ul>\n<li>Rancher</li>\n<li>ContainerShip</li>\n</ul>\n<p>基于容器的PaaS：Deis、Flynn 和 Dokku</p>\n<h2 id=\"容器支持技术\"><a href=\"#容器支持技术\" class=\"headerlink\" title=\"容器支持技术\"></a>容器支持技术</h2><ul>\n<li>容器网络：docker network、flannel、weave 和 calico</li>\n<li>服务发现：etcd、consul 和 zookeeper</li>\n<li>监控：docker ps/top/stats、stats API、sysdig、cAdvisor/Heapster 和 Weave Scope</li>\n<li>数据管理：Flocker</li>\n<li>日志管理：docker logs、logspout</li>\n<li>安全性：OpenSCAP</li>\n</ul>\n<h2 id=\"运行容器——Hello-World\"><a href=\"#运行容器——Hello-World\" class=\"headerlink\" title=\"运行容器——Hello World\"></a>运行容器——Hello World</h2><ul>\n<li><p>环境：</p>\n<ol>\n<li>管理工具：Docker Engine</li>\n<li>runtime：runc</li>\n<li>操作系统：Ubuntu 16.04</li>\n</ol>\n</li>\n<li><p>安装&amp;运行：</p>\n<ol>\n<li><p>安装包，允许 <code>apt</code> 命令 HTTPS 访问 Docker 源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo apt-get install \\</div><div class=\"line\">    apt-transport-https \\</div><div class=\"line\">    ca-certificates \\</div><div class=\"line\">    curl \\</div><div class=\"line\">    software-properties-common</div></pre></td></tr></table></figure>\n</li>\n<li><p>添加 Docker 官方的 GPG</p>\n<p><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></p>\n</li>\n<li><p>将 Docker 的源添加到 /etc/apt/sources.list</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo add-apt-repository \\</div><div class=\"line\">  &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\</div><div class=\"line\">  $(lsb_release -cs) \\</div><div class=\"line\">  stable&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装Docker</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo apt-get update</div><div class=\"line\">$ sudo apt-get install docker-ce</div></pre></td></tr></table></figure>\n</li>\n<li><p>运行httpd</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo docker run -d -p 80:80 httpd</div></pre></td></tr></table></figure>\n</li>\n<li><p>Docker适应非root用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo groupadd docker</div><div class=\"line\">$ sudo gpasswd -a $&#123;USER&#125; docker</div><div class=\"line\">$ sudo service docker restart</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>NOTE</strong></p>\n<p>安装、使用Docker时注意权限是否足够</p>\n</li>\n</ul>\n<hr>\n<p>本文主要内容整理自<a href=\"https://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw\">每天5分钟玩转Docker容器技术</a></p>\n"},{"title":"单例背后的技术细节","date":"2017-12-08T13:40:46.000Z","_content":"\n单例是最简单的设计模式，这基本上是大家的共识。然而单例也是最经常被问及的基础面试题，各个语言下单例的实现通常都是以私有构造方法的方式实现，一个优雅的单例往往涉及线程，序列化等内容。 这里以 Java 实现单例，并总结一下各种单例的实现方式的特点。\n\n## 单例的各种写法\n\n### 饿汉单例\n\n```java\npublic class HungrySingleton {\n    private static HungrySingleton instance = new HungrySingleton();\n  \n    private HungrySingleton(){}\n  \n    public static HungrySingleton getInstance() {\n        return instance;\n    }\n}\n```\n\n- 优点：简单、线程安全\n- 缺点：无法延迟创建，无法防御反射、序列化重复创建\n\n### 简单懒汉单例\n\n```java\npublic class LazySingletonSimple {\n    private static LazySingletonSimple instance;\n\n    private LazySingletonSimple(){}\n\n    public static LazySingletonSimple getInstance() {\n        if (instance == null) {\n            instance = new LazySingletonSimple();\n        }\n        return instance;\n    }\n}\n```\n\n- 优点：简单，延迟创建\n- 缺点：线程不安全，无法防御反射、序列化重复创建\n\n### 内部类懒汉单例\n\n```java\npublic class LazySingletonStatic {\n    private static class SingletonHolder{\n        private static final LazySingletonStatic INSTANCE = new LazySingletonStatic();\n    }\n//    可以使用静态初始化块的方式实现饿汉单例\n//    private LazySingletonSimple instance;\n//    static {\n//        instance = new LazySingletonSimple();\n//    }\n\n    private LazySingletonStatic(){}\n\n    public static LazySingletonStatic getInstance(){\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n\n- 优点：延迟创建，线程安全\n- 缺点：较复杂，无法防御反射、序列化重复创建\n\n### 加锁懒汉单例\n\n```java\npublic class LazySingletonSafe {\n    private static LazySingletonSafe instance;\n    private LazySingletonSafe(){}\n\n    public static synchronized LazySingletonSafe getInstance(){\n        if (instance == null){\n            instance = new LazySingletonSafe();\n        }\n        return instance;\n    }\n}\n```\n\n- 优点：延迟创建，线程安全\n- 缺点：性能差，无法防御反射、序列化重复创建\n\n### 双锁懒汉单例\n\n```java\npublic class DoubleCheckLockSingleton {\n    // 指令重排可能影响执行指令的执行顺序\n    // volatile 声明的变量会禁止指令重排\n    // 只在 JDK5 之后生效\n    private volatile static DoubleCheckLockSingleton instance;\n    private DoubleCheckLockSingleton(){}\n\n    public static DoubleCheckLockSingleton getInstance(){\n        if(instance == null){\n            synchronized (DoubleCheckLockSingleton.class){\n                if(instance == null){\n                    instance = new DoubleCheckLockSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n- 优点：延迟创建，线程安全\n- 缺点：无法防御反射、序列化重复创建\n\n### 改进加锁懒汉单例\n\n```java\npublic class DefReflectAndSerialSingleton implements Serializable {\n    private static DefReflectAndSerialSingleton instance;\n\n    /**\n     * 防止反射创建多个单例\n     */\n    private DefReflectAndSerialSingleton(){\n        if (instance != null) {\n            throw new RuntimeException();\n        }\n    }\n\n    /**\n     * 防止序列化创建多个单例\n     * @return\n     * @throws ObjectStreamException\n     */\n    private Object readResolve() throws ObjectStreamException {\n        return instance;\n    }\n\n    public static synchronized DefReflectAndSerialSingleton getInstance(){\n        if (instance == null){\n            instance = new DefReflectAndSerialSingleton();\n        }\n        return instance;\n    }\n}\n```\n\n- 优点：延迟创建，线程安全，可以防御反射、序列化重复创建\n- 缺点：复杂，性能差\n\n### 枚举单例\n\n```java\npublic enum EnumSingleton {\n    INSTANCE;\n    public void functionInEnum(){\n        System.out.println(\"function in enum\");\n    }\n}\n```\n\n- 优点：延迟创建，线程安全，可以防御反射、序列化重复创建\n- 缺点：用的人太少\n\n## 单例背后的技术细节\n\n### 饿汉单例 & 简单懒汉单例\n\n最简单的写法，直接私有化构造器，区别在初始化单例的时机。这是初学者最容易掌握的单例写法，并没有什么太多值得说的。在一般的场景下使用也并没有太大问题，但如果考虑线程安全，序列化，反射场景时，这两种写法都不可取。\n\n### 内部类懒汉单例\n\n使用内部类机制形成懒加载，其过程涉及到了类加载机制\n\n#### 类加载\n\n类加载、使用的完整过程：\n\n加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载\n\n对内部类懒汉单例来说，初始化阶段影响了单例对象实例化的时间，这里具体看一下初始化阶段\n\n#### 初始化\n\n初始化阶段有两个东西比较重要：\n\n1. 初始化条件\n2. 初始化过程\n\n##### 初始化条件\n\n类初始化的条件在 JVM 规范中有明确要求：\n\n1. 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化\n2. 使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化\n3. 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化\n4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类\n5. 当使用jdk1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic ,  REF_putStatic ,  REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化\n\n在上面代码中的场景，只有 SingletonHolder.INSTANCE; 代码执行时才会初始化 SingletonHolder 类\n\n##### 初始化过程\n\n初始化阶段真正开始执行代码中定义的 Java 程序代码，初始化阶段会执行类构造器  <clinit>() 方法。\n\n<clinit>() 方法是 Java 编译器生成的，内容是收集代码中所有类变量的赋值语句和静态语句块中的语句合并而成，顺序由源文件中出现顺序决定。\n\n在上面的场景中，只有类变量赋值的语句：private static final LazySingletonStatic INSTANCE = new LazySingletonStatic();\n\n##### 线程安全\n\n单线程环境下初始化大致的过程清楚后，还需要说明一下 Java 中初始化一个类或接口是是加锁的同步操作，而这个操作是自动，可以确保当多个线程同时加载一个类时的线程安全。\n\n#### 懒汉 or 饿汉\n\n内部类懒汉单例中通过调用实例时调用内部类的静态属性达到延迟初始化目的。如果使用静态代码块的方式则可以在类初始化阶段完成实例变量的初始化实现饿汉单例，如上面的注释代码所示。\n\n但需要注意生成的 <clinit>() 方法内代码的顺序，一个错误的初始化：\n\n```java\npublic class Single {\n\n    private static final Single single = new Single();\n\n    private static Map<String, String> cache;\n\n    static {\n        cache = new HashMap<>();\n        cache.put(\"0\", \"0\");\n    }\n\n    private Single() {\n        if (null == cache) {\n            cache = new HashMap<>();\n        }\n        cache.put(\"1\", \"1\");\n        cache.put(\"2\", \"2\");\n    }\n\n    public static Single getSingle() {\n        return single;\n    }\n}\n```\n\n根据  <clinit>() 对语句的收集，会先执行 new Single()，然后执行静态代码块，所以 Single() 构造的内容将丢失。\n\n### 加锁懒汉单例\n\n前面的单例都是线程不安全的。以下的操作不满足原子性，当多个线程访问时会出现竞争：\n\n```java\npublic static Singleton getInstance() {\n  if (instance == null) {\n    instance = new Singleton();\n  }\n  return instance;\n}\n```\n\n要避免这种竞争的产生最简单的方式是使用 Java 提供的内置锁（synchronized）机制来保护同步代码块。当一个线程进入加锁的同步代码块之前会获得锁，直到离开同步代码块时释放锁，当一个线程持有锁时会，其他线程将无法获得锁而被阻塞。\n\n内置锁可以完全避免竞争的产生，但同时产生了严重的性能问题，所有线程访问 getInstance 方法都必须是顺序进行的，而getInstance 的核心逻辑是对第一次访问生效的，其余每次都判断是没有意义的。\n\n### 双锁懒汉单例\n\n双锁懒汉单例也是常见的一种单例写法，其主要改进是确保线程安全的同时避免了每次调用 getInstance 方法时都要加锁，锁操作在大多数场景下都是不必要的，竞争只发生在初始情况下（instance 为 null）时，而之后大部分时间的操作加锁就显得没意义了。双锁可以很好的区分这两种场景：\n\n- 初始情况下（instance 为 null），多个线程同时访问都满足 instance == null，但进一步会在加锁的位置阻塞，以顺序执行\n\n\n- 单例实例产生后，后面的线程再访问时将不满足 instance ==  null 的条件，直接返回实例，从而避免加锁的开销\n\n这种做法确实很好的做到加锁同时兼顾了性能，但最大的问题在于人们常常忘记 volatile 关键字，因为原子性和指令重排造成多线程下不安全的操作。\n\n#### 原子操作\n\n前面已经提到 if 代码块不满足原子性，这里看更局部的地方：instance = new DoubleCheckLockSingleton(); \n\n尽管只是一条语句但它也不是原子操作，在执行过程中会以三条指令执行，伪代码：\n\n```\nmemory = allocate();  // 1. 分配对象的内存空间\nctorInstance(memory);  // 2. 初始化对象\ninstance = memory;  // 3. 设置 instance 指向刚分配的内存地址\n```\n\n#### 指令重排\n\n非原子的操作本身并不影响程序的执行，我们甚至感受不到这是一个非原子的操作。但为了执行效率，指令可以发生重新排序，而指令重排让程序的执行充满了不确定性。上面的三条指令有可能会以下顺序执行：\n\n```\nmemory = allocate();  // 1. 分配对象的内存空间\ninstance = memory;  // 3. 设置 instance 指向刚分配的内存地址\nctorInstance(memory);  // 2. 初始化对象\n```\n\n同样我们对此毫无感受，在单线程下程序的正确性也没有收到影响。然而多线程环境下问题将变得很诡异，比如下面的场景：\n\n| 时间   | 线程A                   | 线程B                                  |\n| ---- | --------------------- | ------------------------------------ |\n| t1   | A1:分配对象的内存空间          |                                      |\n| t2   | A3:设置 instance 执行内存空间 |                                      |\n| t3   |                       | B1:判断 instance 是否 null               |\n| t4   |                       | B2:instance 不为 null，访问 instance 引用对象 |\n| t5   | A2:初始化对象              |                                      |\n| t6   | A4:访问 instance 引用对象   |                                      |\n\n在 t3, t4 时刻，线程B 居然访问到了一个没有完全初始化的对象。\n\n#### volatile\n\n将实例变量用 volatile 修饰后就可以解决这个问题。在 volatile 背后，JVM 实际做了两件事：\n\n1. 每次读取/写入变量都访问线程共享的存储数据，而不是线程私有区域缓存的数据\n2. 禁止指令重排优化\n\n这样上面演示的可能的重排操作将被避免，在多线程的环境下线程也将不会访问到未完全初始化的对象\n\n### 改进加锁懒汉单例\n\n单例属于创建型的设计模式，所以先看看 Java 中创建对象的几种方式：\n\n1. 使用 new 关键字，最常见的方式\n2. 反射创建，更具体有两种方式：Class.newInstance 和 Contructor,newInstance\n3. clone 对象，需要实现 Cloneable 接口，并实现 clone 方法\n4. 反序列化：需要实现 Serializable 接口\n\n对于每种创建方式的禁用方式也很简单：\n\n1. 私有构造禁止外部创建\n2. 构造方法添加判断逻辑，如果已将判断抛出异常\n3. 直接在 clone 方法抛出异常\n4. 构造方法添加判断逻辑，定制 readResolve 方法\n\n### 枚举\n\n枚举这个东西一直用起来，怪怪的。《Effective Java》里建议的单例实现方式也是使用枚举，但基本没见过有人这么用。具体的使用没什么太多好说的，这里总结一下枚举的相关特性吧。\n\n首先枚举是 Java 的句法糖，枚举最终会被转换为普通类。例如下面定义的枚举：\n\n```java\npublic enum Color  {  \n  RED,BLUE,BLACK,YELLOW,GREEN  // 最后没有分号，也没有逗号\n}   \n```\n\n会被转换成：\n\n```java\npublic final class Color extends  java.lang.Enum{   \n  public static final Color RED;   \n  public static final Color BLUE;   \n  public static final Color BLACK;   \n  public static final Color YELLOW;   \n  public static final Color GREEN;   \n  static {};   \n  public static Color[] values();   \n  public static Color valueOf(java.lang.String);   \n} \n```\n\n可以看到枚举继承了 Enum，因此枚举获得了如下方法：\n\n- ordinal：返回枚举值在枚举类种的顺序\n\n  `Color.RED.ordinal();  // 返回结果：0`\n\n- name：枚举类型名称\n\n- compareTo：比较象与指定对象的顺序\n\n  `Color.RED.compareTo(Color.BLUE);  // 返回结果 -1`\n\n- values：静态方法，获得全部枚举值的数组\n\n  ```java\n  Color[] colors=Color.values();\n  for(Color c:colors){\n    System.out.print(c+\",\"); \n  }\n  //返回结果：RED,BLUE,BLACK YELLOW,GREEN,\n  ```\n\n- toString：获得枚举常量的名称\n\n  ```java\n  Color c=Color.RED;\n  System.out.println(c);//返回结果: RED\n  ```\n\n- valueOf：静态方法，获得带指定名称的指定枚举类型的枚举常量\n\n  ```java\n  Color.valueOf(\"BLUE\");  // 返回结果: Color.BLUE\n  ```\n\n- equals：比较两个枚举对象的引用\n\n\n","source":"_posts/单例背后的技术细节.md","raw":"---\ntitle: 单例背后的技术细节\ndate: 2017-12-08 21:40:46\ntags: \n  - 设计模式\n  - Java\ncategories: 设计模式\n---\n\n单例是最简单的设计模式，这基本上是大家的共识。然而单例也是最经常被问及的基础面试题，各个语言下单例的实现通常都是以私有构造方法的方式实现，一个优雅的单例往往涉及线程，序列化等内容。 这里以 Java 实现单例，并总结一下各种单例的实现方式的特点。\n\n## 单例的各种写法\n\n### 饿汉单例\n\n```java\npublic class HungrySingleton {\n    private static HungrySingleton instance = new HungrySingleton();\n  \n    private HungrySingleton(){}\n  \n    public static HungrySingleton getInstance() {\n        return instance;\n    }\n}\n```\n\n- 优点：简单、线程安全\n- 缺点：无法延迟创建，无法防御反射、序列化重复创建\n\n### 简单懒汉单例\n\n```java\npublic class LazySingletonSimple {\n    private static LazySingletonSimple instance;\n\n    private LazySingletonSimple(){}\n\n    public static LazySingletonSimple getInstance() {\n        if (instance == null) {\n            instance = new LazySingletonSimple();\n        }\n        return instance;\n    }\n}\n```\n\n- 优点：简单，延迟创建\n- 缺点：线程不安全，无法防御反射、序列化重复创建\n\n### 内部类懒汉单例\n\n```java\npublic class LazySingletonStatic {\n    private static class SingletonHolder{\n        private static final LazySingletonStatic INSTANCE = new LazySingletonStatic();\n    }\n//    可以使用静态初始化块的方式实现饿汉单例\n//    private LazySingletonSimple instance;\n//    static {\n//        instance = new LazySingletonSimple();\n//    }\n\n    private LazySingletonStatic(){}\n\n    public static LazySingletonStatic getInstance(){\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n\n- 优点：延迟创建，线程安全\n- 缺点：较复杂，无法防御反射、序列化重复创建\n\n### 加锁懒汉单例\n\n```java\npublic class LazySingletonSafe {\n    private static LazySingletonSafe instance;\n    private LazySingletonSafe(){}\n\n    public static synchronized LazySingletonSafe getInstance(){\n        if (instance == null){\n            instance = new LazySingletonSafe();\n        }\n        return instance;\n    }\n}\n```\n\n- 优点：延迟创建，线程安全\n- 缺点：性能差，无法防御反射、序列化重复创建\n\n### 双锁懒汉单例\n\n```java\npublic class DoubleCheckLockSingleton {\n    // 指令重排可能影响执行指令的执行顺序\n    // volatile 声明的变量会禁止指令重排\n    // 只在 JDK5 之后生效\n    private volatile static DoubleCheckLockSingleton instance;\n    private DoubleCheckLockSingleton(){}\n\n    public static DoubleCheckLockSingleton getInstance(){\n        if(instance == null){\n            synchronized (DoubleCheckLockSingleton.class){\n                if(instance == null){\n                    instance = new DoubleCheckLockSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n- 优点：延迟创建，线程安全\n- 缺点：无法防御反射、序列化重复创建\n\n### 改进加锁懒汉单例\n\n```java\npublic class DefReflectAndSerialSingleton implements Serializable {\n    private static DefReflectAndSerialSingleton instance;\n\n    /**\n     * 防止反射创建多个单例\n     */\n    private DefReflectAndSerialSingleton(){\n        if (instance != null) {\n            throw new RuntimeException();\n        }\n    }\n\n    /**\n     * 防止序列化创建多个单例\n     * @return\n     * @throws ObjectStreamException\n     */\n    private Object readResolve() throws ObjectStreamException {\n        return instance;\n    }\n\n    public static synchronized DefReflectAndSerialSingleton getInstance(){\n        if (instance == null){\n            instance = new DefReflectAndSerialSingleton();\n        }\n        return instance;\n    }\n}\n```\n\n- 优点：延迟创建，线程安全，可以防御反射、序列化重复创建\n- 缺点：复杂，性能差\n\n### 枚举单例\n\n```java\npublic enum EnumSingleton {\n    INSTANCE;\n    public void functionInEnum(){\n        System.out.println(\"function in enum\");\n    }\n}\n```\n\n- 优点：延迟创建，线程安全，可以防御反射、序列化重复创建\n- 缺点：用的人太少\n\n## 单例背后的技术细节\n\n### 饿汉单例 & 简单懒汉单例\n\n最简单的写法，直接私有化构造器，区别在初始化单例的时机。这是初学者最容易掌握的单例写法，并没有什么太多值得说的。在一般的场景下使用也并没有太大问题，但如果考虑线程安全，序列化，反射场景时，这两种写法都不可取。\n\n### 内部类懒汉单例\n\n使用内部类机制形成懒加载，其过程涉及到了类加载机制\n\n#### 类加载\n\n类加载、使用的完整过程：\n\n加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载\n\n对内部类懒汉单例来说，初始化阶段影响了单例对象实例化的时间，这里具体看一下初始化阶段\n\n#### 初始化\n\n初始化阶段有两个东西比较重要：\n\n1. 初始化条件\n2. 初始化过程\n\n##### 初始化条件\n\n类初始化的条件在 JVM 规范中有明确要求：\n\n1. 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化\n2. 使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化\n3. 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化\n4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类\n5. 当使用jdk1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic ,  REF_putStatic ,  REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化\n\n在上面代码中的场景，只有 SingletonHolder.INSTANCE; 代码执行时才会初始化 SingletonHolder 类\n\n##### 初始化过程\n\n初始化阶段真正开始执行代码中定义的 Java 程序代码，初始化阶段会执行类构造器  <clinit>() 方法。\n\n<clinit>() 方法是 Java 编译器生成的，内容是收集代码中所有类变量的赋值语句和静态语句块中的语句合并而成，顺序由源文件中出现顺序决定。\n\n在上面的场景中，只有类变量赋值的语句：private static final LazySingletonStatic INSTANCE = new LazySingletonStatic();\n\n##### 线程安全\n\n单线程环境下初始化大致的过程清楚后，还需要说明一下 Java 中初始化一个类或接口是是加锁的同步操作，而这个操作是自动，可以确保当多个线程同时加载一个类时的线程安全。\n\n#### 懒汉 or 饿汉\n\n内部类懒汉单例中通过调用实例时调用内部类的静态属性达到延迟初始化目的。如果使用静态代码块的方式则可以在类初始化阶段完成实例变量的初始化实现饿汉单例，如上面的注释代码所示。\n\n但需要注意生成的 <clinit>() 方法内代码的顺序，一个错误的初始化：\n\n```java\npublic class Single {\n\n    private static final Single single = new Single();\n\n    private static Map<String, String> cache;\n\n    static {\n        cache = new HashMap<>();\n        cache.put(\"0\", \"0\");\n    }\n\n    private Single() {\n        if (null == cache) {\n            cache = new HashMap<>();\n        }\n        cache.put(\"1\", \"1\");\n        cache.put(\"2\", \"2\");\n    }\n\n    public static Single getSingle() {\n        return single;\n    }\n}\n```\n\n根据  <clinit>() 对语句的收集，会先执行 new Single()，然后执行静态代码块，所以 Single() 构造的内容将丢失。\n\n### 加锁懒汉单例\n\n前面的单例都是线程不安全的。以下的操作不满足原子性，当多个线程访问时会出现竞争：\n\n```java\npublic static Singleton getInstance() {\n  if (instance == null) {\n    instance = new Singleton();\n  }\n  return instance;\n}\n```\n\n要避免这种竞争的产生最简单的方式是使用 Java 提供的内置锁（synchronized）机制来保护同步代码块。当一个线程进入加锁的同步代码块之前会获得锁，直到离开同步代码块时释放锁，当一个线程持有锁时会，其他线程将无法获得锁而被阻塞。\n\n内置锁可以完全避免竞争的产生，但同时产生了严重的性能问题，所有线程访问 getInstance 方法都必须是顺序进行的，而getInstance 的核心逻辑是对第一次访问生效的，其余每次都判断是没有意义的。\n\n### 双锁懒汉单例\n\n双锁懒汉单例也是常见的一种单例写法，其主要改进是确保线程安全的同时避免了每次调用 getInstance 方法时都要加锁，锁操作在大多数场景下都是不必要的，竞争只发生在初始情况下（instance 为 null）时，而之后大部分时间的操作加锁就显得没意义了。双锁可以很好的区分这两种场景：\n\n- 初始情况下（instance 为 null），多个线程同时访问都满足 instance == null，但进一步会在加锁的位置阻塞，以顺序执行\n\n\n- 单例实例产生后，后面的线程再访问时将不满足 instance ==  null 的条件，直接返回实例，从而避免加锁的开销\n\n这种做法确实很好的做到加锁同时兼顾了性能，但最大的问题在于人们常常忘记 volatile 关键字，因为原子性和指令重排造成多线程下不安全的操作。\n\n#### 原子操作\n\n前面已经提到 if 代码块不满足原子性，这里看更局部的地方：instance = new DoubleCheckLockSingleton(); \n\n尽管只是一条语句但它也不是原子操作，在执行过程中会以三条指令执行，伪代码：\n\n```\nmemory = allocate();  // 1. 分配对象的内存空间\nctorInstance(memory);  // 2. 初始化对象\ninstance = memory;  // 3. 设置 instance 指向刚分配的内存地址\n```\n\n#### 指令重排\n\n非原子的操作本身并不影响程序的执行，我们甚至感受不到这是一个非原子的操作。但为了执行效率，指令可以发生重新排序，而指令重排让程序的执行充满了不确定性。上面的三条指令有可能会以下顺序执行：\n\n```\nmemory = allocate();  // 1. 分配对象的内存空间\ninstance = memory;  // 3. 设置 instance 指向刚分配的内存地址\nctorInstance(memory);  // 2. 初始化对象\n```\n\n同样我们对此毫无感受，在单线程下程序的正确性也没有收到影响。然而多线程环境下问题将变得很诡异，比如下面的场景：\n\n| 时间   | 线程A                   | 线程B                                  |\n| ---- | --------------------- | ------------------------------------ |\n| t1   | A1:分配对象的内存空间          |                                      |\n| t2   | A3:设置 instance 执行内存空间 |                                      |\n| t3   |                       | B1:判断 instance 是否 null               |\n| t4   |                       | B2:instance 不为 null，访问 instance 引用对象 |\n| t5   | A2:初始化对象              |                                      |\n| t6   | A4:访问 instance 引用对象   |                                      |\n\n在 t3, t4 时刻，线程B 居然访问到了一个没有完全初始化的对象。\n\n#### volatile\n\n将实例变量用 volatile 修饰后就可以解决这个问题。在 volatile 背后，JVM 实际做了两件事：\n\n1. 每次读取/写入变量都访问线程共享的存储数据，而不是线程私有区域缓存的数据\n2. 禁止指令重排优化\n\n这样上面演示的可能的重排操作将被避免，在多线程的环境下线程也将不会访问到未完全初始化的对象\n\n### 改进加锁懒汉单例\n\n单例属于创建型的设计模式，所以先看看 Java 中创建对象的几种方式：\n\n1. 使用 new 关键字，最常见的方式\n2. 反射创建，更具体有两种方式：Class.newInstance 和 Contructor,newInstance\n3. clone 对象，需要实现 Cloneable 接口，并实现 clone 方法\n4. 反序列化：需要实现 Serializable 接口\n\n对于每种创建方式的禁用方式也很简单：\n\n1. 私有构造禁止外部创建\n2. 构造方法添加判断逻辑，如果已将判断抛出异常\n3. 直接在 clone 方法抛出异常\n4. 构造方法添加判断逻辑，定制 readResolve 方法\n\n### 枚举\n\n枚举这个东西一直用起来，怪怪的。《Effective Java》里建议的单例实现方式也是使用枚举，但基本没见过有人这么用。具体的使用没什么太多好说的，这里总结一下枚举的相关特性吧。\n\n首先枚举是 Java 的句法糖，枚举最终会被转换为普通类。例如下面定义的枚举：\n\n```java\npublic enum Color  {  \n  RED,BLUE,BLACK,YELLOW,GREEN  // 最后没有分号，也没有逗号\n}   \n```\n\n会被转换成：\n\n```java\npublic final class Color extends  java.lang.Enum{   \n  public static final Color RED;   \n  public static final Color BLUE;   \n  public static final Color BLACK;   \n  public static final Color YELLOW;   \n  public static final Color GREEN;   \n  static {};   \n  public static Color[] values();   \n  public static Color valueOf(java.lang.String);   \n} \n```\n\n可以看到枚举继承了 Enum，因此枚举获得了如下方法：\n\n- ordinal：返回枚举值在枚举类种的顺序\n\n  `Color.RED.ordinal();  // 返回结果：0`\n\n- name：枚举类型名称\n\n- compareTo：比较象与指定对象的顺序\n\n  `Color.RED.compareTo(Color.BLUE);  // 返回结果 -1`\n\n- values：静态方法，获得全部枚举值的数组\n\n  ```java\n  Color[] colors=Color.values();\n  for(Color c:colors){\n    System.out.print(c+\",\"); \n  }\n  //返回结果：RED,BLUE,BLACK YELLOW,GREEN,\n  ```\n\n- toString：获得枚举常量的名称\n\n  ```java\n  Color c=Color.RED;\n  System.out.println(c);//返回结果: RED\n  ```\n\n- valueOf：静态方法，获得带指定名称的指定枚举类型的枚举常量\n\n  ```java\n  Color.valueOf(\"BLUE\");  // 返回结果: Color.BLUE\n  ```\n\n- equals：比较两个枚举对象的引用\n\n\n","slug":"单例背后的技术细节","published":1,"updated":"2017-12-08T13:43:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2si004ld82ex5ktc4y1","content":"<p>单例是最简单的设计模式，这基本上是大家的共识。然而单例也是最经常被问及的基础面试题，各个语言下单例的实现通常都是以私有构造方法的方式实现，一个优雅的单例往往涉及线程，序列化等内容。 这里以 Java 实现单例，并总结一下各种单例的实现方式的特点。</p>\n<h2 id=\"单例的各种写法\"><a href=\"#单例的各种写法\" class=\"headerlink\" title=\"单例的各种写法\"></a>单例的各种写法</h2><h3 id=\"饿汉单例\"><a href=\"#饿汉单例\" class=\"headerlink\" title=\"饿汉单例\"></a>饿汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HungrySingleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> HungrySingleton instance = <span class=\"keyword\">new</span> HungrySingleton();</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HungrySingleton</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HungrySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：简单、线程安全</li>\n<li>缺点：无法延迟创建，无法防御反射、序列化重复创建</li>\n</ul>\n<h3 id=\"简单懒汉单例\"><a href=\"#简单懒汉单例\" class=\"headerlink\" title=\"简单懒汉单例\"></a>简单懒汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingletonSimple</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingletonSimple instance;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LazySingletonSimple</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingletonSimple <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> LazySingletonSimple();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：简单，延迟创建</li>\n<li>缺点：线程不安全，无法防御反射、序列化重复创建</li>\n</ul>\n<h3 id=\"内部类懒汉单例\"><a href=\"#内部类懒汉单例\" class=\"headerlink\" title=\"内部类懒汉单例\"></a>内部类懒汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingletonStatic</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> LazySingletonStatic INSTANCE = <span class=\"keyword\">new</span> LazySingletonStatic();</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//    可以使用静态初始化块的方式实现饿汉单例</span></div><div class=\"line\"><span class=\"comment\">//    private LazySingletonSimple instance;</span></div><div class=\"line\"><span class=\"comment\">//    static &#123;</span></div><div class=\"line\"><span class=\"comment\">//        instance = new LazySingletonSimple();</span></div><div class=\"line\"><span class=\"comment\">//    &#125;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LazySingletonStatic</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingletonStatic <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：延迟创建，线程安全</li>\n<li>缺点：较复杂，无法防御反射、序列化重复创建</li>\n</ul>\n<h3 id=\"加锁懒汉单例\"><a href=\"#加锁懒汉单例\" class=\"headerlink\" title=\"加锁懒汉单例\"></a>加锁懒汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingletonSafe</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingletonSafe instance;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LazySingletonSafe</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> LazySingletonSafe <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> LazySingletonSafe();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：延迟创建，线程安全</li>\n<li>缺点：性能差，无法防御反射、序列化重复创建</li>\n</ul>\n<h3 id=\"双锁懒汉单例\"><a href=\"#双锁懒汉单例\" class=\"headerlink\" title=\"双锁懒汉单例\"></a>双锁懒汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoubleCheckLockSingleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 指令重排可能影响执行指令的执行顺序</span></div><div class=\"line\">    <span class=\"comment\">// volatile 声明的变量会禁止指令重排</span></div><div class=\"line\">    <span class=\"comment\">// 只在 JDK5 之后生效</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> DoubleCheckLockSingleton instance;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DoubleCheckLockSingleton</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DoubleCheckLockSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (DoubleCheckLockSingleton.class)&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">                    instance = <span class=\"keyword\">new</span> DoubleCheckLockSingleton();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：延迟创建，线程安全</li>\n<li>缺点：无法防御反射、序列化重复创建</li>\n</ul>\n<h3 id=\"改进加锁懒汉单例\"><a href=\"#改进加锁懒汉单例\" class=\"headerlink\" title=\"改进加锁懒汉单例\"></a>改进加锁懒汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefReflectAndSerialSingleton</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> DefReflectAndSerialSingleton instance;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 防止反射创建多个单例</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DefReflectAndSerialSingleton</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (instance != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 防止序列化创建多个单例</div><div class=\"line\">     * <span class=\"doctag\">@return</span></div><div class=\"line\">     * <span class=\"doctag\">@throws</span> ObjectStreamException</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ObjectStreamException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> DefReflectAndSerialSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> DefReflectAndSerialSingleton();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：延迟创建，线程安全，可以防御反射、序列化重复创建</li>\n<li>缺点：复杂，性能差</li>\n</ul>\n<h3 id=\"枚举单例\"><a href=\"#枚举单例\" class=\"headerlink\" title=\"枚举单例\"></a>枚举单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> EnumSingleton &#123;</div><div class=\"line\">    INSTANCE;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">functionInEnum</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"function in enum\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：延迟创建，线程安全，可以防御反射、序列化重复创建</li>\n<li>缺点：用的人太少</li>\n</ul>\n<h2 id=\"单例背后的技术细节\"><a href=\"#单例背后的技术细节\" class=\"headerlink\" title=\"单例背后的技术细节\"></a>单例背后的技术细节</h2><h3 id=\"饿汉单例-amp-简单懒汉单例\"><a href=\"#饿汉单例-amp-简单懒汉单例\" class=\"headerlink\" title=\"饿汉单例 &amp; 简单懒汉单例\"></a>饿汉单例 &amp; 简单懒汉单例</h3><p>最简单的写法，直接私有化构造器，区别在初始化单例的时机。这是初学者最容易掌握的单例写法，并没有什么太多值得说的。在一般的场景下使用也并没有太大问题，但如果考虑线程安全，序列化，反射场景时，这两种写法都不可取。</p>\n<h3 id=\"内部类懒汉单例-1\"><a href=\"#内部类懒汉单例-1\" class=\"headerlink\" title=\"内部类懒汉单例\"></a>内部类懒汉单例</h3><p>使用内部类机制形成懒加载，其过程涉及到了类加载机制</p>\n<h4 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h4><p>类加载、使用的完整过程：</p>\n<p>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p>\n<p>对内部类懒汉单例来说，初始化阶段影响了单例对象实例化的时间，这里具体看一下初始化阶段</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><p>初始化阶段有两个东西比较重要：</p>\n<ol>\n<li>初始化条件</li>\n<li>初始化过程</li>\n</ol>\n<h5 id=\"初始化条件\"><a href=\"#初始化条件\" class=\"headerlink\" title=\"初始化条件\"></a>初始化条件</h5><p>类初始化的条件在 JVM 规范中有明确要求：</p>\n<ol>\n<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化</li>\n<li>使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类</li>\n<li>当使用jdk1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic ,  REF_putStatic ,  REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>\n</ol>\n<p>在上面代码中的场景，只有 SingletonHolder.INSTANCE; 代码执行时才会初始化 SingletonHolder 类</p>\n<h5 id=\"初始化过程\"><a href=\"#初始化过程\" class=\"headerlink\" title=\"初始化过程\"></a>初始化过程</h5><p>初始化阶段真正开始执行代码中定义的 Java 程序代码，初始化阶段会执行类构造器  <clinit>() 方法。</clinit></p>\n<p><clinit>() 方法是 Java 编译器生成的，内容是收集代码中所有类变量的赋值语句和静态语句块中的语句合并而成，顺序由源文件中出现顺序决定。</clinit></p>\n<p>在上面的场景中，只有类变量赋值的语句：private static final LazySingletonStatic INSTANCE = new LazySingletonStatic();</p>\n<h5 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h5><p>单线程环境下初始化大致的过程清楚后，还需要说明一下 Java 中初始化一个类或接口是是加锁的同步操作，而这个操作是自动，可以确保当多个线程同时加载一个类时的线程安全。</p>\n<h4 id=\"懒汉-or-饿汉\"><a href=\"#懒汉-or-饿汉\" class=\"headerlink\" title=\"懒汉 or 饿汉\"></a>懒汉 or 饿汉</h4><p>内部类懒汉单例中通过调用实例时调用内部类的静态属性达到延迟初始化目的。如果使用静态代码块的方式则可以在类初始化阶段完成实例变量的初始化实现饿汉单例，如上面的注释代码所示。</p>\n<p>但需要注意生成的 <clinit>() 方法内代码的顺序，一个错误的初始化：</clinit></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Single single = <span class=\"keyword\">new</span> Single();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, String&gt; cache;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        cache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\">        cache.put(<span class=\"string\">\"0\"</span>, <span class=\"string\">\"0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Single</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == cache) &#123;</div><div class=\"line\">            cache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">        cache.put(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"1\"</span>);</div><div class=\"line\">        cache.put(<span class=\"string\">\"2\"</span>, <span class=\"string\">\"2\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Single <span class=\"title\">getSingle</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> single;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据  <clinit>() 对语句的收集，会先执行 new Single()，然后执行静态代码块，所以 Single() 构造的内容将丢失。</clinit></p>\n<h3 id=\"加锁懒汉单例-1\"><a href=\"#加锁懒汉单例-1\" class=\"headerlink\" title=\"加锁懒汉单例\"></a>加锁懒汉单例</h3><p>前面的单例都是线程不安全的。以下的操作不满足原子性，当多个线程访问时会出现竞争：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> instance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>要避免这种竞争的产生最简单的方式是使用 Java 提供的内置锁（synchronized）机制来保护同步代码块。当一个线程进入加锁的同步代码块之前会获得锁，直到离开同步代码块时释放锁，当一个线程持有锁时会，其他线程将无法获得锁而被阻塞。</p>\n<p>内置锁可以完全避免竞争的产生，但同时产生了严重的性能问题，所有线程访问 getInstance 方法都必须是顺序进行的，而getInstance 的核心逻辑是对第一次访问生效的，其余每次都判断是没有意义的。</p>\n<h3 id=\"双锁懒汉单例-1\"><a href=\"#双锁懒汉单例-1\" class=\"headerlink\" title=\"双锁懒汉单例\"></a>双锁懒汉单例</h3><p>双锁懒汉单例也是常见的一种单例写法，其主要改进是确保线程安全的同时避免了每次调用 getInstance 方法时都要加锁，锁操作在大多数场景下都是不必要的，竞争只发生在初始情况下（instance 为 null）时，而之后大部分时间的操作加锁就显得没意义了。双锁可以很好的区分这两种场景：</p>\n<ul>\n<li>初始情况下（instance 为 null），多个线程同时访问都满足 instance == null，但进一步会在加锁的位置阻塞，以顺序执行</li>\n</ul>\n<ul>\n<li>单例实例产生后，后面的线程再访问时将不满足 instance ==  null 的条件，直接返回实例，从而避免加锁的开销</li>\n</ul>\n<p>这种做法确实很好的做到加锁同时兼顾了性能，但最大的问题在于人们常常忘记 volatile 关键字，因为原子性和指令重排造成多线程下不安全的操作。</p>\n<h4 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h4><p>前面已经提到 if 代码块不满足原子性，这里看更局部的地方：instance = new DoubleCheckLockSingleton(); </p>\n<p>尽管只是一条语句但它也不是原子操作，在执行过程中会以三条指令执行，伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">memory = allocate();  // 1. 分配对象的内存空间</div><div class=\"line\">ctorInstance(memory);  // 2. 初始化对象</div><div class=\"line\">instance = memory;  // 3. 设置 instance 指向刚分配的内存地址</div></pre></td></tr></table></figure>\n<h4 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h4><p>非原子的操作本身并不影响程序的执行，我们甚至感受不到这是一个非原子的操作。但为了执行效率，指令可以发生重新排序，而指令重排让程序的执行充满了不确定性。上面的三条指令有可能会以下顺序执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">memory = allocate();  // 1. 分配对象的内存空间</div><div class=\"line\">instance = memory;  // 3. 设置 instance 指向刚分配的内存地址</div><div class=\"line\">ctorInstance(memory);  // 2. 初始化对象</div></pre></td></tr></table></figure>\n<p>同样我们对此毫无感受，在单线程下程序的正确性也没有收到影响。然而多线程环境下问题将变得很诡异，比如下面的场景：</p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>线程A</th>\n<th>线程B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>t1</td>\n<td>A1:分配对象的内存空间</td>\n<td></td>\n</tr>\n<tr>\n<td>t2</td>\n<td>A3:设置 instance 执行内存空间</td>\n<td></td>\n</tr>\n<tr>\n<td>t3</td>\n<td></td>\n<td>B1:判断 instance 是否 null</td>\n</tr>\n<tr>\n<td>t4</td>\n<td></td>\n<td>B2:instance 不为 null，访问 instance 引用对象</td>\n</tr>\n<tr>\n<td>t5</td>\n<td>A2:初始化对象</td>\n<td></td>\n</tr>\n<tr>\n<td>t6</td>\n<td>A4:访问 instance 引用对象</td>\n</tr>\n</tbody>\n</table>\n<p>在 t3, t4 时刻，线程B 居然访问到了一个没有完全初始化的对象。</p>\n<h4 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h4><p>将实例变量用 volatile 修饰后就可以解决这个问题。在 volatile 背后，JVM 实际做了两件事：</p>\n<ol>\n<li>每次读取/写入变量都访问线程共享的存储数据，而不是线程私有区域缓存的数据</li>\n<li>禁止指令重排优化</li>\n</ol>\n<p>这样上面演示的可能的重排操作将被避免，在多线程的环境下线程也将不会访问到未完全初始化的对象</p>\n<h3 id=\"改进加锁懒汉单例-1\"><a href=\"#改进加锁懒汉单例-1\" class=\"headerlink\" title=\"改进加锁懒汉单例\"></a>改进加锁懒汉单例</h3><p>单例属于创建型的设计模式，所以先看看 Java 中创建对象的几种方式：</p>\n<ol>\n<li>使用 new 关键字，最常见的方式</li>\n<li>反射创建，更具体有两种方式：Class.newInstance 和 Contructor,newInstance</li>\n<li>clone 对象，需要实现 Cloneable 接口，并实现 clone 方法</li>\n<li>反序列化：需要实现 Serializable 接口</li>\n</ol>\n<p>对于每种创建方式的禁用方式也很简单：</p>\n<ol>\n<li>私有构造禁止外部创建</li>\n<li>构造方法添加判断逻辑，如果已将判断抛出异常</li>\n<li>直接在 clone 方法抛出异常</li>\n<li>构造方法添加判断逻辑，定制 readResolve 方法</li>\n</ol>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>枚举这个东西一直用起来，怪怪的。《Effective Java》里建议的单例实现方式也是使用枚举，但基本没见过有人这么用。具体的使用没什么太多好说的，这里总结一下枚举的相关特性吧。</p>\n<p>首先枚举是 Java 的句法糖，枚举最终会被转换为普通类。例如下面定义的枚举：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color  &#123;  </div><div class=\"line\">  RED,BLUE,BLACK,YELLOW,GREEN  <span class=\"comment\">// 最后没有分号，也没有逗号</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>会被转换成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Color</span> <span class=\"keyword\">extends</span>  <span class=\"title\">java</span>.<span class=\"title\">lang</span>.<span class=\"title\">Enum</span></span>&#123;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Color RED;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Color BLUE;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Color BLACK;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Color YELLOW;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Color GREEN;   </div><div class=\"line\">  <span class=\"keyword\">static</span> &#123;&#125;;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Color[] values();   </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Color <span class=\"title\">valueOf</span><span class=\"params\">(java.lang.String)</span></span>;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到枚举继承了 Enum，因此枚举获得了如下方法：</p>\n<ul>\n<li><p>ordinal：返回枚举值在枚举类种的顺序</p>\n<p><code>Color.RED.ordinal();  // 返回结果：0</code></p>\n</li>\n<li><p>name：枚举类型名称</p>\n</li>\n<li><p>compareTo：比较象与指定对象的顺序</p>\n<p><code>Color.RED.compareTo(Color.BLUE);  // 返回结果 -1</code></p>\n</li>\n<li><p>values：静态方法，获得全部枚举值的数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Color[] colors=Color.values();</div><div class=\"line\"><span class=\"keyword\">for</span>(Color c:colors)&#123;</div><div class=\"line\">  System.out.print(c+<span class=\"string\">\",\"</span>); </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//返回结果：RED,BLUE,BLACK YELLOW,GREEN,</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>toString：获得枚举常量的名称</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Color c=Color.RED;</div><div class=\"line\">System.out.println(c);<span class=\"comment\">//返回结果: RED</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>valueOf：静态方法，获得带指定名称的指定枚举类型的枚举常量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Color.valueOf(<span class=\"string\">\"BLUE\"</span>);  <span class=\"comment\">// 返回结果: Color.BLUE</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>equals：比较两个枚举对象的引用</p>\n</li>\n</ul>\n","excerpt":"","more":"<p>单例是最简单的设计模式，这基本上是大家的共识。然而单例也是最经常被问及的基础面试题，各个语言下单例的实现通常都是以私有构造方法的方式实现，一个优雅的单例往往涉及线程，序列化等内容。 这里以 Java 实现单例，并总结一下各种单例的实现方式的特点。</p>\n<h2 id=\"单例的各种写法\"><a href=\"#单例的各种写法\" class=\"headerlink\" title=\"单例的各种写法\"></a>单例的各种写法</h2><h3 id=\"饿汉单例\"><a href=\"#饿汉单例\" class=\"headerlink\" title=\"饿汉单例\"></a>饿汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HungrySingleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> HungrySingleton instance = <span class=\"keyword\">new</span> HungrySingleton();</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HungrySingleton</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HungrySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：简单、线程安全</li>\n<li>缺点：无法延迟创建，无法防御反射、序列化重复创建</li>\n</ul>\n<h3 id=\"简单懒汉单例\"><a href=\"#简单懒汉单例\" class=\"headerlink\" title=\"简单懒汉单例\"></a>简单懒汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingletonSimple</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingletonSimple instance;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LazySingletonSimple</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingletonSimple <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> LazySingletonSimple();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：简单，延迟创建</li>\n<li>缺点：线程不安全，无法防御反射、序列化重复创建</li>\n</ul>\n<h3 id=\"内部类懒汉单例\"><a href=\"#内部类懒汉单例\" class=\"headerlink\" title=\"内部类懒汉单例\"></a>内部类懒汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingletonStatic</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> LazySingletonStatic INSTANCE = <span class=\"keyword\">new</span> LazySingletonStatic();</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//    可以使用静态初始化块的方式实现饿汉单例</span></div><div class=\"line\"><span class=\"comment\">//    private LazySingletonSimple instance;</span></div><div class=\"line\"><span class=\"comment\">//    static &#123;</span></div><div class=\"line\"><span class=\"comment\">//        instance = new LazySingletonSimple();</span></div><div class=\"line\"><span class=\"comment\">//    &#125;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LazySingletonStatic</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingletonStatic <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：延迟创建，线程安全</li>\n<li>缺点：较复杂，无法防御反射、序列化重复创建</li>\n</ul>\n<h3 id=\"加锁懒汉单例\"><a href=\"#加锁懒汉单例\" class=\"headerlink\" title=\"加锁懒汉单例\"></a>加锁懒汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingletonSafe</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingletonSafe instance;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LazySingletonSafe</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> LazySingletonSafe <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> LazySingletonSafe();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：延迟创建，线程安全</li>\n<li>缺点：性能差，无法防御反射、序列化重复创建</li>\n</ul>\n<h3 id=\"双锁懒汉单例\"><a href=\"#双锁懒汉单例\" class=\"headerlink\" title=\"双锁懒汉单例\"></a>双锁懒汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoubleCheckLockSingleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 指令重排可能影响执行指令的执行顺序</span></div><div class=\"line\">    <span class=\"comment\">// volatile 声明的变量会禁止指令重排</span></div><div class=\"line\">    <span class=\"comment\">// 只在 JDK5 之后生效</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> DoubleCheckLockSingleton instance;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DoubleCheckLockSingleton</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DoubleCheckLockSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (DoubleCheckLockSingleton.class)&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">                    instance = <span class=\"keyword\">new</span> DoubleCheckLockSingleton();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：延迟创建，线程安全</li>\n<li>缺点：无法防御反射、序列化重复创建</li>\n</ul>\n<h3 id=\"改进加锁懒汉单例\"><a href=\"#改进加锁懒汉单例\" class=\"headerlink\" title=\"改进加锁懒汉单例\"></a>改进加锁懒汉单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefReflectAndSerialSingleton</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> DefReflectAndSerialSingleton instance;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 防止反射创建多个单例</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DefReflectAndSerialSingleton</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (instance != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 防止序列化创建多个单例</div><div class=\"line\">     * <span class=\"doctag\">@return</span></div><div class=\"line\">     * <span class=\"doctag\">@throws</span> ObjectStreamException</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ObjectStreamException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> DefReflectAndSerialSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> DefReflectAndSerialSingleton();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：延迟创建，线程安全，可以防御反射、序列化重复创建</li>\n<li>缺点：复杂，性能差</li>\n</ul>\n<h3 id=\"枚举单例\"><a href=\"#枚举单例\" class=\"headerlink\" title=\"枚举单例\"></a>枚举单例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> EnumSingleton &#123;</div><div class=\"line\">    INSTANCE;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">functionInEnum</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"function in enum\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>优点：延迟创建，线程安全，可以防御反射、序列化重复创建</li>\n<li>缺点：用的人太少</li>\n</ul>\n<h2 id=\"单例背后的技术细节\"><a href=\"#单例背后的技术细节\" class=\"headerlink\" title=\"单例背后的技术细节\"></a>单例背后的技术细节</h2><h3 id=\"饿汉单例-amp-简单懒汉单例\"><a href=\"#饿汉单例-amp-简单懒汉单例\" class=\"headerlink\" title=\"饿汉单例 &amp; 简单懒汉单例\"></a>饿汉单例 &amp; 简单懒汉单例</h3><p>最简单的写法，直接私有化构造器，区别在初始化单例的时机。这是初学者最容易掌握的单例写法，并没有什么太多值得说的。在一般的场景下使用也并没有太大问题，但如果考虑线程安全，序列化，反射场景时，这两种写法都不可取。</p>\n<h3 id=\"内部类懒汉单例-1\"><a href=\"#内部类懒汉单例-1\" class=\"headerlink\" title=\"内部类懒汉单例\"></a>内部类懒汉单例</h3><p>使用内部类机制形成懒加载，其过程涉及到了类加载机制</p>\n<h4 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h4><p>类加载、使用的完整过程：</p>\n<p>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p>\n<p>对内部类懒汉单例来说，初始化阶段影响了单例对象实例化的时间，这里具体看一下初始化阶段</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><p>初始化阶段有两个东西比较重要：</p>\n<ol>\n<li>初始化条件</li>\n<li>初始化过程</li>\n</ol>\n<h5 id=\"初始化条件\"><a href=\"#初始化条件\" class=\"headerlink\" title=\"初始化条件\"></a>初始化条件</h5><p>类初始化的条件在 JVM 规范中有明确要求：</p>\n<ol>\n<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化</li>\n<li>使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类</li>\n<li>当使用jdk1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic ,  REF_putStatic ,  REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>\n</ol>\n<p>在上面代码中的场景，只有 SingletonHolder.INSTANCE; 代码执行时才会初始化 SingletonHolder 类</p>\n<h5 id=\"初始化过程\"><a href=\"#初始化过程\" class=\"headerlink\" title=\"初始化过程\"></a>初始化过程</h5><p>初始化阶段真正开始执行代码中定义的 Java 程序代码，初始化阶段会执行类构造器  <clinit>() 方法。</p>\n<p><clinit>() 方法是 Java 编译器生成的，内容是收集代码中所有类变量的赋值语句和静态语句块中的语句合并而成，顺序由源文件中出现顺序决定。</p>\n<p>在上面的场景中，只有类变量赋值的语句：private static final LazySingletonStatic INSTANCE = new LazySingletonStatic();</p>\n<h5 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h5><p>单线程环境下初始化大致的过程清楚后，还需要说明一下 Java 中初始化一个类或接口是是加锁的同步操作，而这个操作是自动，可以确保当多个线程同时加载一个类时的线程安全。</p>\n<h4 id=\"懒汉-or-饿汉\"><a href=\"#懒汉-or-饿汉\" class=\"headerlink\" title=\"懒汉 or 饿汉\"></a>懒汉 or 饿汉</h4><p>内部类懒汉单例中通过调用实例时调用内部类的静态属性达到延迟初始化目的。如果使用静态代码块的方式则可以在类初始化阶段完成实例变量的初始化实现饿汉单例，如上面的注释代码所示。</p>\n<p>但需要注意生成的 <clinit>() 方法内代码的顺序，一个错误的初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Single single = <span class=\"keyword\">new</span> Single();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, String&gt; cache;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        cache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\">        cache.put(<span class=\"string\">\"0\"</span>, <span class=\"string\">\"0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Single</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == cache) &#123;</div><div class=\"line\">            cache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">        cache.put(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"1\"</span>);</div><div class=\"line\">        cache.put(<span class=\"string\">\"2\"</span>, <span class=\"string\">\"2\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Single <span class=\"title\">getSingle</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> single;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据  <clinit>() 对语句的收集，会先执行 new Single()，然后执行静态代码块，所以 Single() 构造的内容将丢失。</p>\n<h3 id=\"加锁懒汉单例-1\"><a href=\"#加锁懒汉单例-1\" class=\"headerlink\" title=\"加锁懒汉单例\"></a>加锁懒汉单例</h3><p>前面的单例都是线程不安全的。以下的操作不满足原子性，当多个线程访问时会出现竞争：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> instance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>要避免这种竞争的产生最简单的方式是使用 Java 提供的内置锁（synchronized）机制来保护同步代码块。当一个线程进入加锁的同步代码块之前会获得锁，直到离开同步代码块时释放锁，当一个线程持有锁时会，其他线程将无法获得锁而被阻塞。</p>\n<p>内置锁可以完全避免竞争的产生，但同时产生了严重的性能问题，所有线程访问 getInstance 方法都必须是顺序进行的，而getInstance 的核心逻辑是对第一次访问生效的，其余每次都判断是没有意义的。</p>\n<h3 id=\"双锁懒汉单例-1\"><a href=\"#双锁懒汉单例-1\" class=\"headerlink\" title=\"双锁懒汉单例\"></a>双锁懒汉单例</h3><p>双锁懒汉单例也是常见的一种单例写法，其主要改进是确保线程安全的同时避免了每次调用 getInstance 方法时都要加锁，锁操作在大多数场景下都是不必要的，竞争只发生在初始情况下（instance 为 null）时，而之后大部分时间的操作加锁就显得没意义了。双锁可以很好的区分这两种场景：</p>\n<ul>\n<li>初始情况下（instance 为 null），多个线程同时访问都满足 instance == null，但进一步会在加锁的位置阻塞，以顺序执行</li>\n</ul>\n<ul>\n<li>单例实例产生后，后面的线程再访问时将不满足 instance ==  null 的条件，直接返回实例，从而避免加锁的开销</li>\n</ul>\n<p>这种做法确实很好的做到加锁同时兼顾了性能，但最大的问题在于人们常常忘记 volatile 关键字，因为原子性和指令重排造成多线程下不安全的操作。</p>\n<h4 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h4><p>前面已经提到 if 代码块不满足原子性，这里看更局部的地方：instance = new DoubleCheckLockSingleton(); </p>\n<p>尽管只是一条语句但它也不是原子操作，在执行过程中会以三条指令执行，伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">memory = allocate();  // 1. 分配对象的内存空间</div><div class=\"line\">ctorInstance(memory);  // 2. 初始化对象</div><div class=\"line\">instance = memory;  // 3. 设置 instance 指向刚分配的内存地址</div></pre></td></tr></table></figure>\n<h4 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h4><p>非原子的操作本身并不影响程序的执行，我们甚至感受不到这是一个非原子的操作。但为了执行效率，指令可以发生重新排序，而指令重排让程序的执行充满了不确定性。上面的三条指令有可能会以下顺序执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">memory = allocate();  // 1. 分配对象的内存空间</div><div class=\"line\">instance = memory;  // 3. 设置 instance 指向刚分配的内存地址</div><div class=\"line\">ctorInstance(memory);  // 2. 初始化对象</div></pre></td></tr></table></figure>\n<p>同样我们对此毫无感受，在单线程下程序的正确性也没有收到影响。然而多线程环境下问题将变得很诡异，比如下面的场景：</p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>线程A</th>\n<th>线程B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>t1</td>\n<td>A1:分配对象的内存空间</td>\n<td></td>\n</tr>\n<tr>\n<td>t2</td>\n<td>A3:设置 instance 执行内存空间</td>\n<td></td>\n</tr>\n<tr>\n<td>t3</td>\n<td></td>\n<td>B1:判断 instance 是否 null</td>\n</tr>\n<tr>\n<td>t4</td>\n<td></td>\n<td>B2:instance 不为 null，访问 instance 引用对象</td>\n</tr>\n<tr>\n<td>t5</td>\n<td>A2:初始化对象</td>\n<td></td>\n</tr>\n<tr>\n<td>t6</td>\n<td>A4:访问 instance 引用对象</td>\n</tr>\n</tbody>\n</table>\n<p>在 t3, t4 时刻，线程B 居然访问到了一个没有完全初始化的对象。</p>\n<h4 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h4><p>将实例变量用 volatile 修饰后就可以解决这个问题。在 volatile 背后，JVM 实际做了两件事：</p>\n<ol>\n<li>每次读取/写入变量都访问线程共享的存储数据，而不是线程私有区域缓存的数据</li>\n<li>禁止指令重排优化</li>\n</ol>\n<p>这样上面演示的可能的重排操作将被避免，在多线程的环境下线程也将不会访问到未完全初始化的对象</p>\n<h3 id=\"改进加锁懒汉单例-1\"><a href=\"#改进加锁懒汉单例-1\" class=\"headerlink\" title=\"改进加锁懒汉单例\"></a>改进加锁懒汉单例</h3><p>单例属于创建型的设计模式，所以先看看 Java 中创建对象的几种方式：</p>\n<ol>\n<li>使用 new 关键字，最常见的方式</li>\n<li>反射创建，更具体有两种方式：Class.newInstance 和 Contructor,newInstance</li>\n<li>clone 对象，需要实现 Cloneable 接口，并实现 clone 方法</li>\n<li>反序列化：需要实现 Serializable 接口</li>\n</ol>\n<p>对于每种创建方式的禁用方式也很简单：</p>\n<ol>\n<li>私有构造禁止外部创建</li>\n<li>构造方法添加判断逻辑，如果已将判断抛出异常</li>\n<li>直接在 clone 方法抛出异常</li>\n<li>构造方法添加判断逻辑，定制 readResolve 方法</li>\n</ol>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>枚举这个东西一直用起来，怪怪的。《Effective Java》里建议的单例实现方式也是使用枚举，但基本没见过有人这么用。具体的使用没什么太多好说的，这里总结一下枚举的相关特性吧。</p>\n<p>首先枚举是 Java 的句法糖，枚举最终会被转换为普通类。例如下面定义的枚举：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Color  &#123;  </div><div class=\"line\">  RED,BLUE,BLACK,YELLOW,GREEN  <span class=\"comment\">// 最后没有分号，也没有逗号</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>会被转换成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Color</span> <span class=\"keyword\">extends</span>  <span class=\"title\">java</span>.<span class=\"title\">lang</span>.<span class=\"title\">Enum</span></span>&#123;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Color RED;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Color BLUE;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Color BLACK;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Color YELLOW;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Color GREEN;   </div><div class=\"line\">  <span class=\"keyword\">static</span> &#123;&#125;;   </div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Color[] values();   </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Color <span class=\"title\">valueOf</span><span class=\"params\">(java.lang.String)</span></span>;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到枚举继承了 Enum，因此枚举获得了如下方法：</p>\n<ul>\n<li><p>ordinal：返回枚举值在枚举类种的顺序</p>\n<p><code>Color.RED.ordinal();  // 返回结果：0</code></p>\n</li>\n<li><p>name：枚举类型名称</p>\n</li>\n<li><p>compareTo：比较象与指定对象的顺序</p>\n<p><code>Color.RED.compareTo(Color.BLUE);  // 返回结果 -1</code></p>\n</li>\n<li><p>values：静态方法，获得全部枚举值的数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Color[] colors=Color.values();</div><div class=\"line\"><span class=\"keyword\">for</span>(Color c:colors)&#123;</div><div class=\"line\">  System.out.print(c+<span class=\"string\">\",\"</span>); </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//返回结果：RED,BLUE,BLACK YELLOW,GREEN,</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>toString：获得枚举常量的名称</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Color c=Color.RED;</div><div class=\"line\">System.out.println(c);<span class=\"comment\">//返回结果: RED</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>valueOf：静态方法，获得带指定名称的指定枚举类型的枚举常量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Color.valueOf(<span class=\"string\">\"BLUE\"</span>);  <span class=\"comment\">// 返回结果: Color.BLUE</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>equals：比较两个枚举对象的引用</p>\n</li>\n</ul>\n"},{"title":"对象回收与引用类型","date":"2017-03-22T14:16:45.000Z","_content":"\n## 引用分类\n\n- 强引用：日常使用的引用\n- 软引用：当内存空间不足时，不论是否引用都进行回收的引用\n- 弱引用：只要发生GC，就被回收的引用\n- 虚引用：“引用不到”的引用类型\n\n四个引用强度自上而下逐级递减，一个对象存在多个引用时以最强的引用类型为准；\n\n除了以上四个引用类型其实还有两个：FinalReference，Finalizer\n\n## 使用\n\n### SoftReference\n\n非常适合拿来做缓存，实现类似下面：\n\n```java\nReferenceQueue<Map<String, Object>> queue = new ReferenceQueue<>();\nMap<String, Object> map = new HashMap<>();\nSoftReference<Map<String, Object>> softReference = new SoftReference<>(map, queue);\nMap<String, Object> cache = softReference.get();\n\n// 使用cache\nif (cache == null) {\n  cache = new HashMap();\n}\n\n// 清理\nReference reference;\nwhile ((reference = queue.poll()) != null) {\n  clearn();\n}\n```\n\n### WeakReference\n\n通常只要发生GC，就会回收WeakReference引用的对象。\n\n当引用时常量是无法回收，还是可以通过弱引用获取，例如：\n\n```java\n@Test\npublic void weakReference() {\n  String string = new String(\"zhangh.tk\");\n  WeakReference<String> reference = new WeakReference<>(string);\n  assert reference.get() != null;\n  string = null;\n  runFinalization();\n  assert reference.get() == null;\n}\n\n@Test\npublic void weakReferenceWithFinal() {\n  String finalStr = \"zhangh.tk\";\n  WeakReference<String> reference = new WeakReference<>(finalStr);\n  assert reference.get() != null;\n  finalStr = null;\n  runFinalization();\n  assert reference.get() != null;\n}\n```\n\n典型的使用场景：\n\nThread实例中维护的ThreadLocalMap中key使用的是`WeakReference<ThreadLocal<?>>`。\n\n当不存在对ThreadLocal的强引用时，只有ThreadLocalMap对它存在弱引用，GC就可以回收ThreadLocal对象。否则只要Thread对象存在，那么始终保持对ThreadLocal的引用，就不能回收ThreadLocal，造成内存泄露。\n\n![ThreadLocal.png](https://ooo.0o0.ooo/2017/03/21/58d0b23d82ce2.png)\n\n与上面ThreadLocalMap用法类似，JDK提供了WeakHashMap。\n\n无论WeakHashMap还是ThreadLocalMap都存在当key被回收，value仍然存在的问题。\n\n两者解决此问题的思路也很类似，都是在类似size，add等方法时清理key为null的value避免内存泄露。\n\n```java\n@Test\npublic void weakHashMapOOM() {\n  List<WeakHashMap<byte[][], byte[][]>> list = new ArrayList<>();\n  for (int i = 0; i < Integer.MAX_VALUE; i++) {\n    WeakHashMap<byte[][], byte[][]> map = new WeakHashMap<>();\n    map.put(new byte[10000][1000], new byte[10000][1000]);\n    list.add(map);\n    runFinalization();\n    }\n}\n\n@Test\npublic void weakHashMapNotOOM() {\n  List<WeakHashMap<byte[][], byte[][]>> list = new ArrayList<>();\n  for (int i = 0; i < Integer.MAX_VALUE; i++) {\n    WeakHashMap<byte[][], byte[][]> map = new WeakHashMap<>();\n    map.put(new byte[10000][1000], new byte[10000][1000]);\n    list.add(map);\n    runFinalization();\n    map.size();\n  }\n}\n```\n\n### PhantomReference\n\n说它是引用不到的引用类型是因为使用PhantomReference无法获取到指向的对象，如果引用有强度那他的引用强度实在是太弱了。\n\n使用PhantomReference必须配合ReferenceQueue，关于ReferenceQueue后面再说。\n\n### FinalReference&Finalizer\n\n这两个类是父子关系，并且都是不公开的。若一个对象没有实现finalize方法，可以直接被回收，若实现了finalize方法由Finalizer处理。\n\n对象回收执行大致过程：\n\n1. 当对象不可达时，若未覆盖finalize方法直接回收，否则加入F-Queue队列\n2. FinalizerThread线程从F-Queue里面,不停的获取数据,然后调用相应的finalize方法\n3. finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”\n\n关于对象复活：finalize方法只能被JVM调用一次，也就是最多两条命，不存在不停复活的情况。\n\n对象从创建到被回收状态转换：\n\n![Finalizer.png](https://ooo.0o0.ooo/2017/03/21/58d0d5c346f6f.png)\n\n对象复活示例：\n\n```java\nclass Reclaimable {\n  static Reclaimable staticVar;\n  \n  @Override\n  protected void finalize() throws Throwable {\n    staticVar = this;\n  }\n}\n\n@Test\npublic void reclaimed() {\n  Reclaimable reclaimable = new Reclaimable();\n  reclaimable = null;\n  runFinalization();\n  assert Reclaimable.staticVar != null;\n  Reclaimable.staticVar = null;\n  runFinalization();\n  assert Reclaimable.staticVar == null;\n}\n```\n\n### 引用队列\n\n引用队列是垃圾收集器向应用程序返回关于对象生命周期的信息的一种方式。当一个引用对象被回收后可以选择加入引用队列，做最后的清理工作。\n\n例如上文提到的WeakHashMap就是用引用队列收集失效引用，根据引用队列数据清除Entry和值对象。\n\n再例如，因为不能从PhantomReference获得引用的对象，但是可以从引用队列中获得对象被回收的通知。\n\n可以使用引用队列和PhantomReference观察对象的复活：\n\n```java\n@Test\npublic void phantomQueueWithUnReclaimed() {\n  class A{}\n  ReferenceQueue<A> queue = new ReferenceQueue<>();\n  PhantomReference<A> reference = new PhantomReference<>(new A(), queue);\n  assert reference.get() == null;\n  assert queue.poll() == null;\n  runFinalization();\n  assert reference.get() == null;\n  assert queue.poll() != null;\n}\n\n@Test\npublic void phantomQueueWithReclaimed() {\n  ReferenceQueue<Reclaimable> queue = new ReferenceQueue<>();\n  PhantomReference<Reclaimable> reference = new PhantomReference<>(new Reclaimable(), queue);\n  assert reference.get() == null;\n  assert queue.poll() == null;\n  runFinalization();\n  assert reference.get() == null;\n  assert queue.poll() == null;\n  Reclaimable.staticVar = null;\n  runFinalization();\n  assert queue.poll() != null;\n}\n```\n","source":"_posts/对象回收与引用类型.md","raw":"---\ntitle: 对象回收与引用类型\ndate: 2017-03-22 22:16:45\ntags:\n  - Java\ncategories: Java\n---\n\n## 引用分类\n\n- 强引用：日常使用的引用\n- 软引用：当内存空间不足时，不论是否引用都进行回收的引用\n- 弱引用：只要发生GC，就被回收的引用\n- 虚引用：“引用不到”的引用类型\n\n四个引用强度自上而下逐级递减，一个对象存在多个引用时以最强的引用类型为准；\n\n除了以上四个引用类型其实还有两个：FinalReference，Finalizer\n\n## 使用\n\n### SoftReference\n\n非常适合拿来做缓存，实现类似下面：\n\n```java\nReferenceQueue<Map<String, Object>> queue = new ReferenceQueue<>();\nMap<String, Object> map = new HashMap<>();\nSoftReference<Map<String, Object>> softReference = new SoftReference<>(map, queue);\nMap<String, Object> cache = softReference.get();\n\n// 使用cache\nif (cache == null) {\n  cache = new HashMap();\n}\n\n// 清理\nReference reference;\nwhile ((reference = queue.poll()) != null) {\n  clearn();\n}\n```\n\n### WeakReference\n\n通常只要发生GC，就会回收WeakReference引用的对象。\n\n当引用时常量是无法回收，还是可以通过弱引用获取，例如：\n\n```java\n@Test\npublic void weakReference() {\n  String string = new String(\"zhangh.tk\");\n  WeakReference<String> reference = new WeakReference<>(string);\n  assert reference.get() != null;\n  string = null;\n  runFinalization();\n  assert reference.get() == null;\n}\n\n@Test\npublic void weakReferenceWithFinal() {\n  String finalStr = \"zhangh.tk\";\n  WeakReference<String> reference = new WeakReference<>(finalStr);\n  assert reference.get() != null;\n  finalStr = null;\n  runFinalization();\n  assert reference.get() != null;\n}\n```\n\n典型的使用场景：\n\nThread实例中维护的ThreadLocalMap中key使用的是`WeakReference<ThreadLocal<?>>`。\n\n当不存在对ThreadLocal的强引用时，只有ThreadLocalMap对它存在弱引用，GC就可以回收ThreadLocal对象。否则只要Thread对象存在，那么始终保持对ThreadLocal的引用，就不能回收ThreadLocal，造成内存泄露。\n\n![ThreadLocal.png](https://ooo.0o0.ooo/2017/03/21/58d0b23d82ce2.png)\n\n与上面ThreadLocalMap用法类似，JDK提供了WeakHashMap。\n\n无论WeakHashMap还是ThreadLocalMap都存在当key被回收，value仍然存在的问题。\n\n两者解决此问题的思路也很类似，都是在类似size，add等方法时清理key为null的value避免内存泄露。\n\n```java\n@Test\npublic void weakHashMapOOM() {\n  List<WeakHashMap<byte[][], byte[][]>> list = new ArrayList<>();\n  for (int i = 0; i < Integer.MAX_VALUE; i++) {\n    WeakHashMap<byte[][], byte[][]> map = new WeakHashMap<>();\n    map.put(new byte[10000][1000], new byte[10000][1000]);\n    list.add(map);\n    runFinalization();\n    }\n}\n\n@Test\npublic void weakHashMapNotOOM() {\n  List<WeakHashMap<byte[][], byte[][]>> list = new ArrayList<>();\n  for (int i = 0; i < Integer.MAX_VALUE; i++) {\n    WeakHashMap<byte[][], byte[][]> map = new WeakHashMap<>();\n    map.put(new byte[10000][1000], new byte[10000][1000]);\n    list.add(map);\n    runFinalization();\n    map.size();\n  }\n}\n```\n\n### PhantomReference\n\n说它是引用不到的引用类型是因为使用PhantomReference无法获取到指向的对象，如果引用有强度那他的引用强度实在是太弱了。\n\n使用PhantomReference必须配合ReferenceQueue，关于ReferenceQueue后面再说。\n\n### FinalReference&Finalizer\n\n这两个类是父子关系，并且都是不公开的。若一个对象没有实现finalize方法，可以直接被回收，若实现了finalize方法由Finalizer处理。\n\n对象回收执行大致过程：\n\n1. 当对象不可达时，若未覆盖finalize方法直接回收，否则加入F-Queue队列\n2. FinalizerThread线程从F-Queue里面,不停的获取数据,然后调用相应的finalize方法\n3. finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”\n\n关于对象复活：finalize方法只能被JVM调用一次，也就是最多两条命，不存在不停复活的情况。\n\n对象从创建到被回收状态转换：\n\n![Finalizer.png](https://ooo.0o0.ooo/2017/03/21/58d0d5c346f6f.png)\n\n对象复活示例：\n\n```java\nclass Reclaimable {\n  static Reclaimable staticVar;\n  \n  @Override\n  protected void finalize() throws Throwable {\n    staticVar = this;\n  }\n}\n\n@Test\npublic void reclaimed() {\n  Reclaimable reclaimable = new Reclaimable();\n  reclaimable = null;\n  runFinalization();\n  assert Reclaimable.staticVar != null;\n  Reclaimable.staticVar = null;\n  runFinalization();\n  assert Reclaimable.staticVar == null;\n}\n```\n\n### 引用队列\n\n引用队列是垃圾收集器向应用程序返回关于对象生命周期的信息的一种方式。当一个引用对象被回收后可以选择加入引用队列，做最后的清理工作。\n\n例如上文提到的WeakHashMap就是用引用队列收集失效引用，根据引用队列数据清除Entry和值对象。\n\n再例如，因为不能从PhantomReference获得引用的对象，但是可以从引用队列中获得对象被回收的通知。\n\n可以使用引用队列和PhantomReference观察对象的复活：\n\n```java\n@Test\npublic void phantomQueueWithUnReclaimed() {\n  class A{}\n  ReferenceQueue<A> queue = new ReferenceQueue<>();\n  PhantomReference<A> reference = new PhantomReference<>(new A(), queue);\n  assert reference.get() == null;\n  assert queue.poll() == null;\n  runFinalization();\n  assert reference.get() == null;\n  assert queue.poll() != null;\n}\n\n@Test\npublic void phantomQueueWithReclaimed() {\n  ReferenceQueue<Reclaimable> queue = new ReferenceQueue<>();\n  PhantomReference<Reclaimable> reference = new PhantomReference<>(new Reclaimable(), queue);\n  assert reference.get() == null;\n  assert queue.poll() == null;\n  runFinalization();\n  assert reference.get() == null;\n  assert queue.poll() == null;\n  Reclaimable.staticVar = null;\n  runFinalization();\n  assert queue.poll() != null;\n}\n```\n","slug":"对象回收与引用类型","published":1,"updated":"2017-03-22T14:19:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2sl004qd82e2yd9ezhq","content":"<h2 id=\"引用分类\"><a href=\"#引用分类\" class=\"headerlink\" title=\"引用分类\"></a>引用分类</h2><ul>\n<li>强引用：日常使用的引用</li>\n<li>软引用：当内存空间不足时，不论是否引用都进行回收的引用</li>\n<li>弱引用：只要发生GC，就被回收的引用</li>\n<li>虚引用：“引用不到”的引用类型</li>\n</ul>\n<p>四个引用强度自上而下逐级递减，一个对象存在多个引用时以最强的引用类型为准；</p>\n<p>除了以上四个引用类型其实还有两个：FinalReference，Finalizer</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"SoftReference\"><a href=\"#SoftReference\" class=\"headerlink\" title=\"SoftReference\"></a>SoftReference</h3><p>非常适合拿来做缓存，实现类似下面：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReferenceQueue&lt;Map&lt;String, Object&gt;&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</div><div class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\">SoftReference&lt;Map&lt;String, Object&gt;&gt; softReference = <span class=\"keyword\">new</span> SoftReference&lt;&gt;(map, queue);</div><div class=\"line\">Map&lt;String, Object&gt; cache = softReference.get();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用cache</span></div><div class=\"line\"><span class=\"keyword\">if</span> (cache == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">  cache = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 清理</span></div><div class=\"line\">Reference reference;</div><div class=\"line\"><span class=\"keyword\">while</span> ((reference = queue.poll()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">  clearn();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"WeakReference\"><a href=\"#WeakReference\" class=\"headerlink\" title=\"WeakReference\"></a>WeakReference</h3><p>通常只要发生GC，就会回收WeakReference引用的对象。</p>\n<p>当引用时常量是无法回收，还是可以通过弱引用获取，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">weakReference</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  String string = <span class=\"keyword\">new</span> String(<span class=\"string\">\"zhangh.tk\"</span>);</div><div class=\"line\">  WeakReference&lt;String&gt; reference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(string);</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() != <span class=\"keyword\">null</span>;</div><div class=\"line\">  string = <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() == <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">weakReferenceWithFinal</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  String finalStr = <span class=\"string\">\"zhangh.tk\"</span>;</div><div class=\"line\">  WeakReference&lt;String&gt; reference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(finalStr);</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() != <span class=\"keyword\">null</span>;</div><div class=\"line\">  finalStr = <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() != <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>典型的使用场景：</p>\n<p>Thread实例中维护的ThreadLocalMap中key使用的是<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>。</p>\n<p>当不存在对ThreadLocal的强引用时，只有ThreadLocalMap对它存在弱引用，GC就可以回收ThreadLocal对象。否则只要Thread对象存在，那么始终保持对ThreadLocal的引用，就不能回收ThreadLocal，造成内存泄露。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/21/58d0b23d82ce2.png\" alt=\"ThreadLocal.png\"></p>\n<p>与上面ThreadLocalMap用法类似，JDK提供了WeakHashMap。</p>\n<p>无论WeakHashMap还是ThreadLocalMap都存在当key被回收，value仍然存在的问题。</p>\n<p>两者解决此问题的思路也很类似，都是在类似size，add等方法时清理key为null的value避免内存泄露。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">weakHashMapOOM</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  List&lt;WeakHashMap&lt;<span class=\"keyword\">byte</span>[][], <span class=\"keyword\">byte</span>[][]&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class=\"line\">    WeakHashMap&lt;<span class=\"keyword\">byte</span>[][], <span class=\"keyword\">byte</span>[][]&gt; map = <span class=\"keyword\">new</span> WeakHashMap&lt;&gt;();</div><div class=\"line\">    map.put(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>][<span class=\"number\">1000</span>], <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>][<span class=\"number\">1000</span>]);</div><div class=\"line\">    list.add(map);</div><div class=\"line\">    runFinalization();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">weakHashMapNotOOM</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  List&lt;WeakHashMap&lt;<span class=\"keyword\">byte</span>[][], <span class=\"keyword\">byte</span>[][]&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class=\"line\">    WeakHashMap&lt;<span class=\"keyword\">byte</span>[][], <span class=\"keyword\">byte</span>[][]&gt; map = <span class=\"keyword\">new</span> WeakHashMap&lt;&gt;();</div><div class=\"line\">    map.put(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>][<span class=\"number\">1000</span>], <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>][<span class=\"number\">1000</span>]);</div><div class=\"line\">    list.add(map);</div><div class=\"line\">    runFinalization();</div><div class=\"line\">    map.size();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"PhantomReference\"><a href=\"#PhantomReference\" class=\"headerlink\" title=\"PhantomReference\"></a>PhantomReference</h3><p>说它是引用不到的引用类型是因为使用PhantomReference无法获取到指向的对象，如果引用有强度那他的引用强度实在是太弱了。</p>\n<p>使用PhantomReference必须配合ReferenceQueue，关于ReferenceQueue后面再说。</p>\n<h3 id=\"FinalReference-amp-Finalizer\"><a href=\"#FinalReference-amp-Finalizer\" class=\"headerlink\" title=\"FinalReference&amp;Finalizer\"></a>FinalReference&amp;Finalizer</h3><p>这两个类是父子关系，并且都是不公开的。若一个对象没有实现finalize方法，可以直接被回收，若实现了finalize方法由Finalizer处理。</p>\n<p>对象回收执行大致过程：</p>\n<ol>\n<li>当对象不可达时，若未覆盖finalize方法直接回收，否则加入F-Queue队列</li>\n<li>FinalizerThread线程从F-Queue里面,不停的获取数据,然后调用相应的finalize方法</li>\n<li>finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”</li>\n</ol>\n<p>关于对象复活：finalize方法只能被JVM调用一次，也就是最多两条命，不存在不停复活的情况。</p>\n<p>对象从创建到被回收状态转换：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/21/58d0d5c346f6f.png\" alt=\"Finalizer.png\"></p>\n<p>对象复活示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Reclaimable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> Reclaimable staticVar;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</div><div class=\"line\">    staticVar = <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reclaimed</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  Reclaimable reclaimable = <span class=\"keyword\">new</span> Reclaimable();</div><div class=\"line\">  reclaimable = <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> Reclaimable.staticVar != <span class=\"keyword\">null</span>;</div><div class=\"line\">  Reclaimable.staticVar = <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> Reclaimable.staticVar == <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"引用队列\"><a href=\"#引用队列\" class=\"headerlink\" title=\"引用队列\"></a>引用队列</h3><p>引用队列是垃圾收集器向应用程序返回关于对象生命周期的信息的一种方式。当一个引用对象被回收后可以选择加入引用队列，做最后的清理工作。</p>\n<p>例如上文提到的WeakHashMap就是用引用队列收集失效引用，根据引用队列数据清除Entry和值对象。</p>\n<p>再例如，因为不能从PhantomReference获得引用的对象，但是可以从引用队列中获得对象被回收的通知。</p>\n<p>可以使用引用队列和PhantomReference观察对象的复活：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">phantomQueueWithUnReclaimed</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;&#125;</div><div class=\"line\">  ReferenceQueue&lt;A&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</div><div class=\"line\">  PhantomReference&lt;A&gt; reference = <span class=\"keyword\">new</span> PhantomReference&lt;&gt;(<span class=\"keyword\">new</span> A(), queue);</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">assert</span> queue.poll() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">assert</span> queue.poll() != <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">phantomQueueWithReclaimed</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  ReferenceQueue&lt;Reclaimable&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</div><div class=\"line\">  PhantomReference&lt;Reclaimable&gt; reference = <span class=\"keyword\">new</span> PhantomReference&lt;&gt;(<span class=\"keyword\">new</span> Reclaimable(), queue);</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">assert</span> queue.poll() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">assert</span> queue.poll() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  Reclaimable.staticVar = <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> queue.poll() != <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"引用分类\"><a href=\"#引用分类\" class=\"headerlink\" title=\"引用分类\"></a>引用分类</h2><ul>\n<li>强引用：日常使用的引用</li>\n<li>软引用：当内存空间不足时，不论是否引用都进行回收的引用</li>\n<li>弱引用：只要发生GC，就被回收的引用</li>\n<li>虚引用：“引用不到”的引用类型</li>\n</ul>\n<p>四个引用强度自上而下逐级递减，一个对象存在多个引用时以最强的引用类型为准；</p>\n<p>除了以上四个引用类型其实还有两个：FinalReference，Finalizer</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"SoftReference\"><a href=\"#SoftReference\" class=\"headerlink\" title=\"SoftReference\"></a>SoftReference</h3><p>非常适合拿来做缓存，实现类似下面：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReferenceQueue&lt;Map&lt;String, Object&gt;&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</div><div class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\">SoftReference&lt;Map&lt;String, Object&gt;&gt; softReference = <span class=\"keyword\">new</span> SoftReference&lt;&gt;(map, queue);</div><div class=\"line\">Map&lt;String, Object&gt; cache = softReference.get();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用cache</span></div><div class=\"line\"><span class=\"keyword\">if</span> (cache == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">  cache = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 清理</span></div><div class=\"line\">Reference reference;</div><div class=\"line\"><span class=\"keyword\">while</span> ((reference = queue.poll()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">  clearn();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"WeakReference\"><a href=\"#WeakReference\" class=\"headerlink\" title=\"WeakReference\"></a>WeakReference</h3><p>通常只要发生GC，就会回收WeakReference引用的对象。</p>\n<p>当引用时常量是无法回收，还是可以通过弱引用获取，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">weakReference</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  String string = <span class=\"keyword\">new</span> String(<span class=\"string\">\"zhangh.tk\"</span>);</div><div class=\"line\">  WeakReference&lt;String&gt; reference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(string);</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() != <span class=\"keyword\">null</span>;</div><div class=\"line\">  string = <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() == <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">weakReferenceWithFinal</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  String finalStr = <span class=\"string\">\"zhangh.tk\"</span>;</div><div class=\"line\">  WeakReference&lt;String&gt; reference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(finalStr);</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() != <span class=\"keyword\">null</span>;</div><div class=\"line\">  finalStr = <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() != <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>典型的使用场景：</p>\n<p>Thread实例中维护的ThreadLocalMap中key使用的是<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>。</p>\n<p>当不存在对ThreadLocal的强引用时，只有ThreadLocalMap对它存在弱引用，GC就可以回收ThreadLocal对象。否则只要Thread对象存在，那么始终保持对ThreadLocal的引用，就不能回收ThreadLocal，造成内存泄露。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/21/58d0b23d82ce2.png\" alt=\"ThreadLocal.png\"></p>\n<p>与上面ThreadLocalMap用法类似，JDK提供了WeakHashMap。</p>\n<p>无论WeakHashMap还是ThreadLocalMap都存在当key被回收，value仍然存在的问题。</p>\n<p>两者解决此问题的思路也很类似，都是在类似size，add等方法时清理key为null的value避免内存泄露。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">weakHashMapOOM</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  List&lt;WeakHashMap&lt;<span class=\"keyword\">byte</span>[][], <span class=\"keyword\">byte</span>[][]&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class=\"line\">    WeakHashMap&lt;<span class=\"keyword\">byte</span>[][], <span class=\"keyword\">byte</span>[][]&gt; map = <span class=\"keyword\">new</span> WeakHashMap&lt;&gt;();</div><div class=\"line\">    map.put(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>][<span class=\"number\">1000</span>], <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>][<span class=\"number\">1000</span>]);</div><div class=\"line\">    list.add(map);</div><div class=\"line\">    runFinalization();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">weakHashMapNotOOM</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  List&lt;WeakHashMap&lt;<span class=\"keyword\">byte</span>[][], <span class=\"keyword\">byte</span>[][]&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class=\"line\">    WeakHashMap&lt;<span class=\"keyword\">byte</span>[][], <span class=\"keyword\">byte</span>[][]&gt; map = <span class=\"keyword\">new</span> WeakHashMap&lt;&gt;();</div><div class=\"line\">    map.put(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>][<span class=\"number\">1000</span>], <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>][<span class=\"number\">1000</span>]);</div><div class=\"line\">    list.add(map);</div><div class=\"line\">    runFinalization();</div><div class=\"line\">    map.size();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"PhantomReference\"><a href=\"#PhantomReference\" class=\"headerlink\" title=\"PhantomReference\"></a>PhantomReference</h3><p>说它是引用不到的引用类型是因为使用PhantomReference无法获取到指向的对象，如果引用有强度那他的引用强度实在是太弱了。</p>\n<p>使用PhantomReference必须配合ReferenceQueue，关于ReferenceQueue后面再说。</p>\n<h3 id=\"FinalReference-amp-Finalizer\"><a href=\"#FinalReference-amp-Finalizer\" class=\"headerlink\" title=\"FinalReference&amp;Finalizer\"></a>FinalReference&amp;Finalizer</h3><p>这两个类是父子关系，并且都是不公开的。若一个对象没有实现finalize方法，可以直接被回收，若实现了finalize方法由Finalizer处理。</p>\n<p>对象回收执行大致过程：</p>\n<ol>\n<li>当对象不可达时，若未覆盖finalize方法直接回收，否则加入F-Queue队列</li>\n<li>FinalizerThread线程从F-Queue里面,不停的获取数据,然后调用相应的finalize方法</li>\n<li>finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”</li>\n</ol>\n<p>关于对象复活：finalize方法只能被JVM调用一次，也就是最多两条命，不存在不停复活的情况。</p>\n<p>对象从创建到被回收状态转换：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/21/58d0d5c346f6f.png\" alt=\"Finalizer.png\"></p>\n<p>对象复活示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Reclaimable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> Reclaimable staticVar;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</div><div class=\"line\">    staticVar = <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reclaimed</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  Reclaimable reclaimable = <span class=\"keyword\">new</span> Reclaimable();</div><div class=\"line\">  reclaimable = <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> Reclaimable.staticVar != <span class=\"keyword\">null</span>;</div><div class=\"line\">  Reclaimable.staticVar = <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> Reclaimable.staticVar == <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"引用队列\"><a href=\"#引用队列\" class=\"headerlink\" title=\"引用队列\"></a>引用队列</h3><p>引用队列是垃圾收集器向应用程序返回关于对象生命周期的信息的一种方式。当一个引用对象被回收后可以选择加入引用队列，做最后的清理工作。</p>\n<p>例如上文提到的WeakHashMap就是用引用队列收集失效引用，根据引用队列数据清除Entry和值对象。</p>\n<p>再例如，因为不能从PhantomReference获得引用的对象，但是可以从引用队列中获得对象被回收的通知。</p>\n<p>可以使用引用队列和PhantomReference观察对象的复活：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">phantomQueueWithUnReclaimed</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;&#125;</div><div class=\"line\">  ReferenceQueue&lt;A&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</div><div class=\"line\">  PhantomReference&lt;A&gt; reference = <span class=\"keyword\">new</span> PhantomReference&lt;&gt;(<span class=\"keyword\">new</span> A(), queue);</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">assert</span> queue.poll() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">assert</span> queue.poll() != <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">phantomQueueWithReclaimed</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  ReferenceQueue&lt;Reclaimable&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</div><div class=\"line\">  PhantomReference&lt;Reclaimable&gt; reference = <span class=\"keyword\">new</span> PhantomReference&lt;&gt;(<span class=\"keyword\">new</span> Reclaimable(), queue);</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">assert</span> queue.poll() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> reference.get() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">assert</span> queue.poll() == <span class=\"keyword\">null</span>;</div><div class=\"line\">  Reclaimable.staticVar = <span class=\"keyword\">null</span>;</div><div class=\"line\">  runFinalization();</div><div class=\"line\">  <span class=\"keyword\">assert</span> queue.poll() != <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"类加载器在Tomcat中的应用","date":"2017-03-13T14:22:36.000Z","_content":"\n## 类加载器\n\n关于类加载器的文章有很多了，概括起来有如下几点：\n\n- 双亲委派模型\n  - 自底向下检查类是否已加载\n  - 自顶向下尝试加载类\n- 上下文类加载器：解决顶层类加载器无法加载底层类加载器加载的类（这句话好绕口）\n- 其他容易忽视的细节问题：\n  - 一个类的加载器可能不止一个\n    - 不同类加载器加载同一个类\n    - 同一个类加载器不同实例加载同一个类\n  - 完成一次加载过程的类加载器也可能不止一个\n    - 初始加载器：启动类的加载过程\n    - 定义加载器：真正完成类的加载工作\n  - 系统或扩展路径下的class文件会优先被系统类加载器或扩展类加载器加载\n  - loadClass方法抛出的是ClassNotFoundException\n  - defineClass方法抛出的是NoClassDefFoundError\n  - 在不指定父类加载器的情况下，默认采用系统类加载器\n\n## Tomcat\n\n在Tomcat中对类加载器的要求稍微复杂一些：\n\n- 不同web app下不同的类要做到隔离，不能互相干扰\n- 不同web app下相同的类要可以共享，避免重复加载\n\n以上两个功能根据两个类加载就可以实现：\n\n- WebappClassLoader\n- CommonClassLoader\n\nTomcat类加载器与Java自带类加载器组成的关系结构：\n\n![Tomcat类加载器架构.png](https://ooo.0o0.ooo/2017/03/13/58c6ae1596e2d.png)\n\n### WebappLoader\n\n默认的WebappClassLoader主要由以下特点：\n- 加载/WebApp/WEB-INF/*下的内容\n\n- 每个web app对应一个WebappLoader\n\n  确保不同web app的类由不同的WebappLoader实例加载\n\n- 不遵循双亲委派\n\n  优先使用WebappClassLoader自己加载，而不是委托给父类加载确保隔离\n\n- 避免Servlet API，java.， javax.相关类加载\n\n### CommonClassLoader\n- 加载/common/*下的内容\n\n- 统一加载容器和各个web app都需要的类\n\n- 在容器启动阶段就将CommonClassLoader设置为上下文类加载器\n\n- 所有WebappLoader的parent都是CommonClassLoader\n\n### 联系\n- CommonClassLoader能加载的类都能够被CatalinaClassLoader和WebappClassLoader使用；\n\n- 各个WebappClassLoader实例之间互相隔离\n\n- JasperLoader加载范围仅限JSP文件编译出的那个Class，方便丢弃实现热替换\n","source":"_posts/类加载器在Tomcat中的应用.md","raw":"---\ntitle: 类加载器在Tomcat中的应用\ndate: 2017-03-13 22:22:36\ntags:\n  - Java\n  - JVM\ncategories: Java\n---\n\n## 类加载器\n\n关于类加载器的文章有很多了，概括起来有如下几点：\n\n- 双亲委派模型\n  - 自底向下检查类是否已加载\n  - 自顶向下尝试加载类\n- 上下文类加载器：解决顶层类加载器无法加载底层类加载器加载的类（这句话好绕口）\n- 其他容易忽视的细节问题：\n  - 一个类的加载器可能不止一个\n    - 不同类加载器加载同一个类\n    - 同一个类加载器不同实例加载同一个类\n  - 完成一次加载过程的类加载器也可能不止一个\n    - 初始加载器：启动类的加载过程\n    - 定义加载器：真正完成类的加载工作\n  - 系统或扩展路径下的class文件会优先被系统类加载器或扩展类加载器加载\n  - loadClass方法抛出的是ClassNotFoundException\n  - defineClass方法抛出的是NoClassDefFoundError\n  - 在不指定父类加载器的情况下，默认采用系统类加载器\n\n## Tomcat\n\n在Tomcat中对类加载器的要求稍微复杂一些：\n\n- 不同web app下不同的类要做到隔离，不能互相干扰\n- 不同web app下相同的类要可以共享，避免重复加载\n\n以上两个功能根据两个类加载就可以实现：\n\n- WebappClassLoader\n- CommonClassLoader\n\nTomcat类加载器与Java自带类加载器组成的关系结构：\n\n![Tomcat类加载器架构.png](https://ooo.0o0.ooo/2017/03/13/58c6ae1596e2d.png)\n\n### WebappLoader\n\n默认的WebappClassLoader主要由以下特点：\n- 加载/WebApp/WEB-INF/*下的内容\n\n- 每个web app对应一个WebappLoader\n\n  确保不同web app的类由不同的WebappLoader实例加载\n\n- 不遵循双亲委派\n\n  优先使用WebappClassLoader自己加载，而不是委托给父类加载确保隔离\n\n- 避免Servlet API，java.， javax.相关类加载\n\n### CommonClassLoader\n- 加载/common/*下的内容\n\n- 统一加载容器和各个web app都需要的类\n\n- 在容器启动阶段就将CommonClassLoader设置为上下文类加载器\n\n- 所有WebappLoader的parent都是CommonClassLoader\n\n### 联系\n- CommonClassLoader能加载的类都能够被CatalinaClassLoader和WebappClassLoader使用；\n\n- 各个WebappClassLoader实例之间互相隔离\n\n- JasperLoader加载范围仅限JSP文件编译出的那个Class，方便丢弃实现热替换\n","slug":"类加载器在Tomcat中的应用","published":1,"updated":"2017-03-13T14:37:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2so004td82e3q8hfm91","content":"<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p>关于类加载器的文章有很多了，概括起来有如下几点：</p>\n<ul>\n<li>双亲委派模型<ul>\n<li>自底向下检查类是否已加载</li>\n<li>自顶向下尝试加载类</li>\n</ul>\n</li>\n<li>上下文类加载器：解决顶层类加载器无法加载底层类加载器加载的类（这句话好绕口）</li>\n<li>其他容易忽视的细节问题：<ul>\n<li>一个类的加载器可能不止一个<ul>\n<li>不同类加载器加载同一个类</li>\n<li>同一个类加载器不同实例加载同一个类</li>\n</ul>\n</li>\n<li>完成一次加载过程的类加载器也可能不止一个<ul>\n<li>初始加载器：启动类的加载过程</li>\n<li>定义加载器：真正完成类的加载工作</li>\n</ul>\n</li>\n<li>系统或扩展路径下的class文件会优先被系统类加载器或扩展类加载器加载</li>\n<li>loadClass方法抛出的是ClassNotFoundException</li>\n<li>defineClass方法抛出的是NoClassDefFoundError</li>\n<li>在不指定父类加载器的情况下，默认采用系统类加载器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h2><p>在Tomcat中对类加载器的要求稍微复杂一些：</p>\n<ul>\n<li>不同web app下不同的类要做到隔离，不能互相干扰</li>\n<li>不同web app下相同的类要可以共享，避免重复加载</li>\n</ul>\n<p>以上两个功能根据两个类加载就可以实现：</p>\n<ul>\n<li>WebappClassLoader</li>\n<li>CommonClassLoader</li>\n</ul>\n<p>Tomcat类加载器与Java自带类加载器组成的关系结构：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/13/58c6ae1596e2d.png\" alt=\"Tomcat类加载器架构.png\"></p>\n<h3 id=\"WebappLoader\"><a href=\"#WebappLoader\" class=\"headerlink\" title=\"WebappLoader\"></a>WebappLoader</h3><p>默认的WebappClassLoader主要由以下特点：</p>\n<ul>\n<li><p>加载/WebApp/WEB-INF/*下的内容</p>\n</li>\n<li><p>每个web app对应一个WebappLoader</p>\n<p>确保不同web app的类由不同的WebappLoader实例加载</p>\n</li>\n<li><p>不遵循双亲委派</p>\n<p>优先使用WebappClassLoader自己加载，而不是委托给父类加载确保隔离</p>\n</li>\n<li><p>避免Servlet API，java.， javax.相关类加载</p>\n</li>\n</ul>\n<h3 id=\"CommonClassLoader\"><a href=\"#CommonClassLoader\" class=\"headerlink\" title=\"CommonClassLoader\"></a>CommonClassLoader</h3><ul>\n<li><p>加载/common/*下的内容</p>\n</li>\n<li><p>统一加载容器和各个web app都需要的类</p>\n</li>\n<li><p>在容器启动阶段就将CommonClassLoader设置为上下文类加载器</p>\n</li>\n<li><p>所有WebappLoader的parent都是CommonClassLoader</p>\n</li>\n</ul>\n<h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><ul>\n<li><p>CommonClassLoader能加载的类都能够被CatalinaClassLoader和WebappClassLoader使用；</p>\n</li>\n<li><p>各个WebappClassLoader实例之间互相隔离</p>\n</li>\n<li><p>JasperLoader加载范围仅限JSP文件编译出的那个Class，方便丢弃实现热替换</p>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p>关于类加载器的文章有很多了，概括起来有如下几点：</p>\n<ul>\n<li>双亲委派模型<ul>\n<li>自底向下检查类是否已加载</li>\n<li>自顶向下尝试加载类</li>\n</ul>\n</li>\n<li>上下文类加载器：解决顶层类加载器无法加载底层类加载器加载的类（这句话好绕口）</li>\n<li>其他容易忽视的细节问题：<ul>\n<li>一个类的加载器可能不止一个<ul>\n<li>不同类加载器加载同一个类</li>\n<li>同一个类加载器不同实例加载同一个类</li>\n</ul>\n</li>\n<li>完成一次加载过程的类加载器也可能不止一个<ul>\n<li>初始加载器：启动类的加载过程</li>\n<li>定义加载器：真正完成类的加载工作</li>\n</ul>\n</li>\n<li>系统或扩展路径下的class文件会优先被系统类加载器或扩展类加载器加载</li>\n<li>loadClass方法抛出的是ClassNotFoundException</li>\n<li>defineClass方法抛出的是NoClassDefFoundError</li>\n<li>在不指定父类加载器的情况下，默认采用系统类加载器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h2><p>在Tomcat中对类加载器的要求稍微复杂一些：</p>\n<ul>\n<li>不同web app下不同的类要做到隔离，不能互相干扰</li>\n<li>不同web app下相同的类要可以共享，避免重复加载</li>\n</ul>\n<p>以上两个功能根据两个类加载就可以实现：</p>\n<ul>\n<li>WebappClassLoader</li>\n<li>CommonClassLoader</li>\n</ul>\n<p>Tomcat类加载器与Java自带类加载器组成的关系结构：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/13/58c6ae1596e2d.png\" alt=\"Tomcat类加载器架构.png\"></p>\n<h3 id=\"WebappLoader\"><a href=\"#WebappLoader\" class=\"headerlink\" title=\"WebappLoader\"></a>WebappLoader</h3><p>默认的WebappClassLoader主要由以下特点：</p>\n<ul>\n<li><p>加载/WebApp/WEB-INF/*下的内容</p>\n</li>\n<li><p>每个web app对应一个WebappLoader</p>\n<p>确保不同web app的类由不同的WebappLoader实例加载</p>\n</li>\n<li><p>不遵循双亲委派</p>\n<p>优先使用WebappClassLoader自己加载，而不是委托给父类加载确保隔离</p>\n</li>\n<li><p>避免Servlet API，java.， javax.相关类加载</p>\n</li>\n</ul>\n<h3 id=\"CommonClassLoader\"><a href=\"#CommonClassLoader\" class=\"headerlink\" title=\"CommonClassLoader\"></a>CommonClassLoader</h3><ul>\n<li><p>加载/common/*下的内容</p>\n</li>\n<li><p>统一加载容器和各个web app都需要的类</p>\n</li>\n<li><p>在容器启动阶段就将CommonClassLoader设置为上下文类加载器</p>\n</li>\n<li><p>所有WebappLoader的parent都是CommonClassLoader</p>\n</li>\n</ul>\n<h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><ul>\n<li><p>CommonClassLoader能加载的类都能够被CatalinaClassLoader和WebappClassLoader使用；</p>\n</li>\n<li><p>各个WebappClassLoader实例之间互相隔离</p>\n</li>\n<li><p>JasperLoader加载范围仅限JSP文件编译出的那个Class，方便丢弃实现热替换</p>\n</li>\n</ul>\n"},{"title":"聊聊JDK动态代理","date":"2017-05-12T16:51:29.000Z","_content":"\n提起代理多少有点老生常谈的意思了，无论是语言层面，模式层面，框架层面乃至系统架构，代理都算是比较高频的话题了。\n之前的文章有提到 Spring AOP 的实现是基于 JDK 的动态代理和 CgLib 实现的。今天聊聊 JDK 中的动态代理实现。\n\n## JDK 的描述\n\n提起JDK动态代理，有两个类是怎么都绕不过去的：\n\n`InvocationHandler` 和 `Proxy` 分别是实现 JDK 动态代理的门面。\n`Proxy` 比较好理解，主要就是生成代理对象实例的，但 `InvocationHandler` 这个参数就有点意思了。\n`InvocationHandler` 这个接口在 JDK 中的描述就是 invocation handler。\n\nJDK 中对 `InvocationHandler` 的详细描述：\n> InvocationHandler is the interface implemented by the invocation handler of a proxy instance.\n> Each proxy instance has an associated invocation handler. \n> When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.\n\n每一个代理都有一个被关联的invocation handler。当一个方法在代理对象上被调用，方法的调用被编码，由代理的 invocation handler 的 `invoke` 方法调用。\n\n## 嵌套静态代理\n\n先放结论：**实际上 JDK 的动态代理是由嵌套静态代理实现的。**\n\n具体来说：我们根据业务抽象出 `Subject` 接口，并提供 `RealSubject` 作为实现，除此还需要提供一个 `InvocationHandler` 的实现 `SubjectInvocationHandler`。\n把上面几个类组装一下，JDK 就可以根据以上信息默默的帮我们生成了代理类 `$Proxy`。\n\n在代理生成前在程序中可以设置输出代理类的 class 文件：\n`System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");`\n先看看生成代理的源码，最终生成的代理类文件反编译后类似下面这样：\n\n```java\npublic final class $Proxy0 extends Proxy implements Subject {\n    private static Method m1;\n    private static Method m3;\n    private static Method m2;\n    private static Method m4;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final void sayHello(String var1) throws  {\n        try {\n            super.h.invoke(this, m3, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final void sayBye(String var1) throws  {\n        try {\n            super.h.invoke(this, m4, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[]{Class.forName(\"java.lang.Object\")});\n            m3 = Class.forName(\"tk.zhangh.pattern.structure.proxy.Subject\").getMethod(\"sayHello\", new Class[]{Class.forName(\"java.lang.String\")});\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\n            m4 = Class.forName(\"tk.zhangh.pattern.structure.proxy.Subject\").getMethod(\"sayBye\", new Class[]{Class.forName(\"java.lang.String\")});\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n```\n\n `SubjectInvocationHandler` 是连接 `RealSubject` 和 `$Proxy` 的关键，扮演了既当爹又当妈的角色。\n\n对于 `RealSubject`，`SubjectInvocationHandler` 是代理类；\n\n对于 `$Proxy`, `SubjectInvocationHandler` 又是委托类。\n\n当我们调用 `$Proxy` 的方法时，`$Proxy` 将调用转发给委托类 `SubjectInvocationHandler`, `SubjectInvocationHandler`作为代理类又将调用转发给 `RealSubject`。\n\n`SubjectInvocationHandler` 不光是角色重要，还承担承上启下的任务，对`$Proxy`的调用，都是委托给了继承自`Proxy` 的`SubjectInvocationHandler`  的 `invoke` 方法处理。\n\n而`SubjectInvocationHandler`的 `invoke` 方法完全由开发者编写，方法怎么调用，是否选择代理，都是在 `invoke` 方法实现的。所以 JDK 在对 invocation handler 的描述中用到了 dispatched，但是把调度逻辑方法 `invoke` 方法我实在不觉得是个优雅的做法。\n\n\n\n有关动态代理实现详细的源码介绍可以参看[这里](http://www.cnblogs.com/MOBIN/p/5597215.html)，作者给出了比较详细的注释说明。\n","source":"_posts/聊聊JDK动态代理.md","raw":"---\ntitle: 聊聊JDK动态代理\ndate: 2017-05-13 00:51:29\ntags:\n - Java\ncategories: Java\n---\n\n提起代理多少有点老生常谈的意思了，无论是语言层面，模式层面，框架层面乃至系统架构，代理都算是比较高频的话题了。\n之前的文章有提到 Spring AOP 的实现是基于 JDK 的动态代理和 CgLib 实现的。今天聊聊 JDK 中的动态代理实现。\n\n## JDK 的描述\n\n提起JDK动态代理，有两个类是怎么都绕不过去的：\n\n`InvocationHandler` 和 `Proxy` 分别是实现 JDK 动态代理的门面。\n`Proxy` 比较好理解，主要就是生成代理对象实例的，但 `InvocationHandler` 这个参数就有点意思了。\n`InvocationHandler` 这个接口在 JDK 中的描述就是 invocation handler。\n\nJDK 中对 `InvocationHandler` 的详细描述：\n> InvocationHandler is the interface implemented by the invocation handler of a proxy instance.\n> Each proxy instance has an associated invocation handler. \n> When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.\n\n每一个代理都有一个被关联的invocation handler。当一个方法在代理对象上被调用，方法的调用被编码，由代理的 invocation handler 的 `invoke` 方法调用。\n\n## 嵌套静态代理\n\n先放结论：**实际上 JDK 的动态代理是由嵌套静态代理实现的。**\n\n具体来说：我们根据业务抽象出 `Subject` 接口，并提供 `RealSubject` 作为实现，除此还需要提供一个 `InvocationHandler` 的实现 `SubjectInvocationHandler`。\n把上面几个类组装一下，JDK 就可以根据以上信息默默的帮我们生成了代理类 `$Proxy`。\n\n在代理生成前在程序中可以设置输出代理类的 class 文件：\n`System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");`\n先看看生成代理的源码，最终生成的代理类文件反编译后类似下面这样：\n\n```java\npublic final class $Proxy0 extends Proxy implements Subject {\n    private static Method m1;\n    private static Method m3;\n    private static Method m2;\n    private static Method m4;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final void sayHello(String var1) throws  {\n        try {\n            super.h.invoke(this, m3, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final void sayBye(String var1) throws  {\n        try {\n            super.h.invoke(this, m4, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[]{Class.forName(\"java.lang.Object\")});\n            m3 = Class.forName(\"tk.zhangh.pattern.structure.proxy.Subject\").getMethod(\"sayHello\", new Class[]{Class.forName(\"java.lang.String\")});\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\n            m4 = Class.forName(\"tk.zhangh.pattern.structure.proxy.Subject\").getMethod(\"sayBye\", new Class[]{Class.forName(\"java.lang.String\")});\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n```\n\n `SubjectInvocationHandler` 是连接 `RealSubject` 和 `$Proxy` 的关键，扮演了既当爹又当妈的角色。\n\n对于 `RealSubject`，`SubjectInvocationHandler` 是代理类；\n\n对于 `$Proxy`, `SubjectInvocationHandler` 又是委托类。\n\n当我们调用 `$Proxy` 的方法时，`$Proxy` 将调用转发给委托类 `SubjectInvocationHandler`, `SubjectInvocationHandler`作为代理类又将调用转发给 `RealSubject`。\n\n`SubjectInvocationHandler` 不光是角色重要，还承担承上启下的任务，对`$Proxy`的调用，都是委托给了继承自`Proxy` 的`SubjectInvocationHandler`  的 `invoke` 方法处理。\n\n而`SubjectInvocationHandler`的 `invoke` 方法完全由开发者编写，方法怎么调用，是否选择代理，都是在 `invoke` 方法实现的。所以 JDK 在对 invocation handler 的描述中用到了 dispatched，但是把调度逻辑方法 `invoke` 方法我实在不觉得是个优雅的做法。\n\n\n\n有关动态代理实现详细的源码介绍可以参看[这里](http://www.cnblogs.com/MOBIN/p/5597215.html)，作者给出了比较详细的注释说明。\n","slug":"聊聊JDK动态代理","published":1,"updated":"2017-05-12T17:00:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2sr004xd82ept2un5ss","content":"<p>提起代理多少有点老生常谈的意思了，无论是语言层面，模式层面，框架层面乃至系统架构，代理都算是比较高频的话题了。<br>之前的文章有提到 Spring AOP 的实现是基于 JDK 的动态代理和 CgLib 实现的。今天聊聊 JDK 中的动态代理实现。</p>\n<h2 id=\"JDK-的描述\"><a href=\"#JDK-的描述\" class=\"headerlink\" title=\"JDK 的描述\"></a>JDK 的描述</h2><p>提起JDK动态代理，有两个类是怎么都绕不过去的：</p>\n<p><code>InvocationHandler</code> 和 <code>Proxy</code> 分别是实现 JDK 动态代理的门面。<br><code>Proxy</code> 比较好理解，主要就是生成代理对象实例的，但 <code>InvocationHandler</code> 这个参数就有点意思了。<br><code>InvocationHandler</code> 这个接口在 JDK 中的描述就是 invocation handler。</p>\n<p>JDK 中对 <code>InvocationHandler</code> 的详细描述：</p>\n<blockquote>\n<p>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.<br>Each proxy instance has an associated invocation handler.<br>When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.</p>\n</blockquote>\n<p>每一个代理都有一个被关联的invocation handler。当一个方法在代理对象上被调用，方法的调用被编码，由代理的 invocation handler 的 <code>invoke</code> 方法调用。</p>\n<h2 id=\"嵌套静态代理\"><a href=\"#嵌套静态代理\" class=\"headerlink\" title=\"嵌套静态代理\"></a>嵌套静态代理</h2><p>先放结论：<strong>实际上 JDK 的动态代理是由嵌套静态代理实现的。</strong></p>\n<p>具体来说：我们根据业务抽象出 <code>Subject</code> 接口，并提供 <code>RealSubject</code> 作为实现，除此还需要提供一个 <code>InvocationHandler</code> 的实现 <code>SubjectInvocationHandler</code>。<br>把上面几个类组装一下，JDK 就可以根据以上信息默默的帮我们生成了代理类 <code>$Proxy</code>。</p>\n<p>在代理生成前在程序中可以设置输出代理类的 class 文件：<br><code>System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code><br>先看看生成代理的源码，最终生成的代理类文件反编译后类似下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Proxy0</span> <span class=\"keyword\">extends</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m1;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m3;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m2;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m4;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m0;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> $Proxy0(InvocationHandler var1) <span class=\"keyword\">throws</span>  &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(var1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object var1)</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ((Boolean)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m1, <span class=\"keyword\">new</span> Object[]&#123;var1&#125;)).booleanValue();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var3;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var4) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var4);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(String var1)</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m3, <span class=\"keyword\">new</span> Object[]&#123;var1&#125;);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var3;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var4) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var4);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> (String)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m2, (Object[])<span class=\"keyword\">null</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var2;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var3);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">sayBye</span><span class=\"params\">(String var1)</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m4, <span class=\"keyword\">new</span> Object[]&#123;var1&#125;);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var3;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var4) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var4);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ((Integer)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m0, (Object[])<span class=\"keyword\">null</span>)).intValue();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var2;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var3);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            m1 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"equals\"</span>, <span class=\"keyword\">new</span> Class[]&#123;Class.forName(<span class=\"string\">\"java.lang.Object\"</span>)&#125;);</div><div class=\"line\">            m3 = Class.forName(<span class=\"string\">\"tk.zhangh.pattern.structure.proxy.Subject\"</span>).getMethod(<span class=\"string\">\"sayHello\"</span>, <span class=\"keyword\">new</span> Class[]&#123;Class.forName(<span class=\"string\">\"java.lang.String\"</span>)&#125;);</div><div class=\"line\">            m2 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"toString\"</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>]);</div><div class=\"line\">            m4 = Class.forName(<span class=\"string\">\"tk.zhangh.pattern.structure.proxy.Subject\"</span>).getMethod(<span class=\"string\">\"sayBye\"</span>, <span class=\"keyword\">new</span> Class[]&#123;Class.forName(<span class=\"string\">\"java.lang.String\"</span>)&#125;);</div><div class=\"line\">            m0 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"hashCode\"</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>]);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException var2) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchMethodError(var2.getMessage());</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoClassDefFoundError(var3.getMessage());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <code>SubjectInvocationHandler</code> 是连接 <code>RealSubject</code> 和 <code>$Proxy</code> 的关键，扮演了既当爹又当妈的角色。</p>\n<p>对于 <code>RealSubject</code>，<code>SubjectInvocationHandler</code> 是代理类；</p>\n<p>对于 <code>$Proxy</code>, <code>SubjectInvocationHandler</code> 又是委托类。</p>\n<p>当我们调用 <code>$Proxy</code> 的方法时，<code>$Proxy</code> 将调用转发给委托类 <code>SubjectInvocationHandler</code>, <code>SubjectInvocationHandler</code>作为代理类又将调用转发给 <code>RealSubject</code>。</p>\n<p><code>SubjectInvocationHandler</code> 不光是角色重要，还承担承上启下的任务，对<code>$Proxy</code>的调用，都是委托给了继承自<code>Proxy</code> 的<code>SubjectInvocationHandler</code>  的 <code>invoke</code> 方法处理。</p>\n<p>而<code>SubjectInvocationHandler</code>的 <code>invoke</code> 方法完全由开发者编写，方法怎么调用，是否选择代理，都是在 <code>invoke</code> 方法实现的。所以 JDK 在对 invocation handler 的描述中用到了 dispatched，但是把调度逻辑方法 <code>invoke</code> 方法我实在不觉得是个优雅的做法。</p>\n<p>有关动态代理实现详细的源码介绍可以参看<a href=\"http://www.cnblogs.com/MOBIN/p/5597215.html\" target=\"_blank\" rel=\"external\">这里</a>，作者给出了比较详细的注释说明。</p>\n","excerpt":"","more":"<p>提起代理多少有点老生常谈的意思了，无论是语言层面，模式层面，框架层面乃至系统架构，代理都算是比较高频的话题了。<br>之前的文章有提到 Spring AOP 的实现是基于 JDK 的动态代理和 CgLib 实现的。今天聊聊 JDK 中的动态代理实现。</p>\n<h2 id=\"JDK-的描述\"><a href=\"#JDK-的描述\" class=\"headerlink\" title=\"JDK 的描述\"></a>JDK 的描述</h2><p>提起JDK动态代理，有两个类是怎么都绕不过去的：</p>\n<p><code>InvocationHandler</code> 和 <code>Proxy</code> 分别是实现 JDK 动态代理的门面。<br><code>Proxy</code> 比较好理解，主要就是生成代理对象实例的，但 <code>InvocationHandler</code> 这个参数就有点意思了。<br><code>InvocationHandler</code> 这个接口在 JDK 中的描述就是 invocation handler。</p>\n<p>JDK 中对 <code>InvocationHandler</code> 的详细描述：</p>\n<blockquote>\n<p>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.<br>Each proxy instance has an associated invocation handler.<br>When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.</p>\n</blockquote>\n<p>每一个代理都有一个被关联的invocation handler。当一个方法在代理对象上被调用，方法的调用被编码，由代理的 invocation handler 的 <code>invoke</code> 方法调用。</p>\n<h2 id=\"嵌套静态代理\"><a href=\"#嵌套静态代理\" class=\"headerlink\" title=\"嵌套静态代理\"></a>嵌套静态代理</h2><p>先放结论：<strong>实际上 JDK 的动态代理是由嵌套静态代理实现的。</strong></p>\n<p>具体来说：我们根据业务抽象出 <code>Subject</code> 接口，并提供 <code>RealSubject</code> 作为实现，除此还需要提供一个 <code>InvocationHandler</code> 的实现 <code>SubjectInvocationHandler</code>。<br>把上面几个类组装一下，JDK 就可以根据以上信息默默的帮我们生成了代理类 <code>$Proxy</code>。</p>\n<p>在代理生成前在程序中可以设置输出代理类的 class 文件：<br><code>System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code><br>先看看生成代理的源码，最终生成的代理类文件反编译后类似下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Proxy0</span> <span class=\"keyword\">extends</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m1;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m3;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m2;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m4;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m0;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> $Proxy0(InvocationHandler var1) <span class=\"keyword\">throws</span>  &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(var1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object var1)</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ((Boolean)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m1, <span class=\"keyword\">new</span> Object[]&#123;var1&#125;)).booleanValue();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var3;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var4) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var4);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(String var1)</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m3, <span class=\"keyword\">new</span> Object[]&#123;var1&#125;);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var3;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var4) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var4);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> (String)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m2, (Object[])<span class=\"keyword\">null</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var2;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var3);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">sayBye</span><span class=\"params\">(String var1)</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m4, <span class=\"keyword\">new</span> Object[]&#123;var1&#125;);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var3;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var4) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var4);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ((Integer)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m0, (Object[])<span class=\"keyword\">null</span>)).intValue();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var2;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var3);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            m1 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"equals\"</span>, <span class=\"keyword\">new</span> Class[]&#123;Class.forName(<span class=\"string\">\"java.lang.Object\"</span>)&#125;);</div><div class=\"line\">            m3 = Class.forName(<span class=\"string\">\"tk.zhangh.pattern.structure.proxy.Subject\"</span>).getMethod(<span class=\"string\">\"sayHello\"</span>, <span class=\"keyword\">new</span> Class[]&#123;Class.forName(<span class=\"string\">\"java.lang.String\"</span>)&#125;);</div><div class=\"line\">            m2 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"toString\"</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>]);</div><div class=\"line\">            m4 = Class.forName(<span class=\"string\">\"tk.zhangh.pattern.structure.proxy.Subject\"</span>).getMethod(<span class=\"string\">\"sayBye\"</span>, <span class=\"keyword\">new</span> Class[]&#123;Class.forName(<span class=\"string\">\"java.lang.String\"</span>)&#125;);</div><div class=\"line\">            m0 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"hashCode\"</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>]);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException var2) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchMethodError(var2.getMessage());</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoClassDefFoundError(var3.getMessage());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <code>SubjectInvocationHandler</code> 是连接 <code>RealSubject</code> 和 <code>$Proxy</code> 的关键，扮演了既当爹又当妈的角色。</p>\n<p>对于 <code>RealSubject</code>，<code>SubjectInvocationHandler</code> 是代理类；</p>\n<p>对于 <code>$Proxy</code>, <code>SubjectInvocationHandler</code> 又是委托类。</p>\n<p>当我们调用 <code>$Proxy</code> 的方法时，<code>$Proxy</code> 将调用转发给委托类 <code>SubjectInvocationHandler</code>, <code>SubjectInvocationHandler</code>作为代理类又将调用转发给 <code>RealSubject</code>。</p>\n<p><code>SubjectInvocationHandler</code> 不光是角色重要，还承担承上启下的任务，对<code>$Proxy</code>的调用，都是委托给了继承自<code>Proxy</code> 的<code>SubjectInvocationHandler</code>  的 <code>invoke</code> 方法处理。</p>\n<p>而<code>SubjectInvocationHandler</code>的 <code>invoke</code> 方法完全由开发者编写，方法怎么调用，是否选择代理，都是在 <code>invoke</code> 方法实现的。所以 JDK 在对 invocation handler 的描述中用到了 dispatched，但是把调度逻辑方法 <code>invoke</code> 方法我实在不觉得是个优雅的做法。</p>\n<p>有关动态代理实现详细的源码介绍可以参看<a href=\"http://www.cnblogs.com/MOBIN/p/5597215.html\">这里</a>，作者给出了比较详细的注释说明。</p>\n"},{"title":"浅谈测试驱动开发","date":"2017-02-05T13:58:28.000Z","_content":"\n近两日参加了名为“软件测试质量体系最佳实践”的分享，其中着重介绍了质量体系的建设，测试的经验以及方法，就我个人最大的收获更多的是关于TDD的思考，在此简单记录。\n\n# Bug的影响\n\n不成熟的团队中一个常见情况：\n\n频繁被突发问题打断，响应式的处理，目标达成率低，可以称这样的团队为响应式的团队。\n\n为什么频繁的响应Bug会严重消耗团队资源？\n\n1. 完整的Bug处理的过程时间长\n2. 一个Bug导致多个Bug的产生\n3. 人员缺乏动力\n\n# 预防Bug\n\n然而解决Bug并不能算作突出的贡献，针对Bug的预防工作要优于Bug解决。从被动的救火到主动的预防问题发生，减少突发问题。\n\n一个团队的重要指标，是有效代码的产出，而不是代码的产出。\n\n有效代码，如同字面意思，有效的，可复用的，没有大量Bug，可以赚钱的代码。\n\n如何保证代码有效？测试！\n\n# 测试\n\n手工测试无法做到连续提供测试服务，存在间断，代码修改后测试报告随即失效。为了解决测试的间断问题，必须引入自动化测试。\n\n开发工作中耗时最多的是在调试，如果能减少问题的出现，避免反复调试，可以节省大量的时间、精力。\n\n因此，测试并不会让团队的工作量出现明显增加，最终开发与测试的人数趋于接近。\n\n测试短期可以帮助我们找Bug，长期可以帮助我们建设质量体系。\n\n# 质量体系\n\n系统的健康状况，项目的完成情况应当从质量体系中直观，实时的获取，而不是通过大量的会议，讨论得出。\n\n数据的三个来源\n\n- 用例库\n\n  积累的测试用例\n\n  要求能复用（良好的测试框架）\n\n  能够与其它平台，系统方便集成（一个test case对应多个test Run）\n\n- 缺陷库\n\n  Bug的完整生命周期记录\n\n- 结果库\n\n  每次自动化测试的结果\n\n  最小的单位不是test case，而是test run\n\n质量体系，不仅用于预防问题，长远看还需要提供数据支持，需要辅助决策，辅助管理。\n\n# 团队\n\n当一个团队可以很好的预防问题的发生时，可以称这样的团队为建设型的团队。\n\n传统的瀑布模型中开发完成开始测试是导致项目进度缓慢的一个重要原因。\n\n如何让开发与测试并行？测试始终伴随开发，甚至优先于开发。\n\n开发，测试并行的三个重要保障：需求文档，开发文档，测试文档\n\n# TDD\n\n**文档评审**\n\n从执行过程上来看，当需求文档出来后，开发和测试需要同时整理对应文档，然后进入评审环节。\n\n需求作为开发，测试的输入项，要求需求文档不能出现偏差。\n\n从制度上可以做出一些规范化，例如：\n\n- 需求文档、开发文档、测试文档作为三个关键文档，任何一个都一定不能或缺\n- 三个关键文档都要有评审，三次的评审都要求产品、开发、测试负责的人员到场确认\n- 文档可以驳回，但确认后的文档不可更改\n- 任何一个文档出现滞后，都要记录，分析问题\n\n文档内容要细致，需求文档作为开发文档和测试文档输入，尤其重要。\n\n各个文档的基本标准：\n\n- 需求文档：明确各步骤输入输出\n- 测试文档：明确各个测试点，需要进行什么测试，是否要求自动化等信息，设计（复用）测试框架\n- 开发文档：提供设计架构，需要细致到开发阶段填充代码就可以了\n\n一个优秀文档的重要标准：评审打回次数。\n\n**开发，测试并行**\n\n三个文档评审结束后，开发和测试同时开始工作。\n\n\n\n# 其它\n\n**关于需求分析**\n\n需求分析需要专业的人专门处理，需求分析的过程如同医生看病：\n\n医生不能问病人想吃什么药，想怎么治疗，而是需要找到病人病因\n\n产品不能表面的询问用户想要什么，而是要发现用户的真实需求\n\n需求分析过程展开：\n\n1. 获取\n\n   得到最原始的需求，这些需求可能是凌乱的，甚至是矛盾的，不能直接用来开发\n\n2. 分析\n\n   剔除原始需求中的噪音，获取真实的需求，这个阶段产品应该基本确认需求\n\n3. 细化\n\n   产出原型，与美术，设计确认沟通，明确每步的输入输出\n\n4. 固化\n\n   与用户确认，得到最终版本的需求文档\n\n**关于团队成员能力**\n\n1. 不能迁就最低能力人员，要推动团队成长，进步\n2. 开发与测试要互相促进，测试需要考虑开发设计的文档是否可以进行测试，有哪些改进，开发需要考虑代码的覆盖\n3. 通过模板让人员能力可流动，可转化。总结高质量方法，模板，流程给团队复用，提高整体质量\n\n**关于测试**\n\n- Bug分级\n- 不要首先搞UI测试\n- 尽量使用真实数据，边界数据\n- 避免对其它模块，代码的依赖\n- 发布时不一定就能做到所有测试都通过\n- 测试要可复用，粒度，范围要注意\n","source":"_posts/浅谈测试驱动开发.md","raw":"---\ntitle: 浅谈测试驱动开发\ndate: 2017-02-05 21:58:28\ntags:\n  - 设计模式\ncategories: 设计模式\n---\n\n近两日参加了名为“软件测试质量体系最佳实践”的分享，其中着重介绍了质量体系的建设，测试的经验以及方法，就我个人最大的收获更多的是关于TDD的思考，在此简单记录。\n\n# Bug的影响\n\n不成熟的团队中一个常见情况：\n\n频繁被突发问题打断，响应式的处理，目标达成率低，可以称这样的团队为响应式的团队。\n\n为什么频繁的响应Bug会严重消耗团队资源？\n\n1. 完整的Bug处理的过程时间长\n2. 一个Bug导致多个Bug的产生\n3. 人员缺乏动力\n\n# 预防Bug\n\n然而解决Bug并不能算作突出的贡献，针对Bug的预防工作要优于Bug解决。从被动的救火到主动的预防问题发生，减少突发问题。\n\n一个团队的重要指标，是有效代码的产出，而不是代码的产出。\n\n有效代码，如同字面意思，有效的，可复用的，没有大量Bug，可以赚钱的代码。\n\n如何保证代码有效？测试！\n\n# 测试\n\n手工测试无法做到连续提供测试服务，存在间断，代码修改后测试报告随即失效。为了解决测试的间断问题，必须引入自动化测试。\n\n开发工作中耗时最多的是在调试，如果能减少问题的出现，避免反复调试，可以节省大量的时间、精力。\n\n因此，测试并不会让团队的工作量出现明显增加，最终开发与测试的人数趋于接近。\n\n测试短期可以帮助我们找Bug，长期可以帮助我们建设质量体系。\n\n# 质量体系\n\n系统的健康状况，项目的完成情况应当从质量体系中直观，实时的获取，而不是通过大量的会议，讨论得出。\n\n数据的三个来源\n\n- 用例库\n\n  积累的测试用例\n\n  要求能复用（良好的测试框架）\n\n  能够与其它平台，系统方便集成（一个test case对应多个test Run）\n\n- 缺陷库\n\n  Bug的完整生命周期记录\n\n- 结果库\n\n  每次自动化测试的结果\n\n  最小的单位不是test case，而是test run\n\n质量体系，不仅用于预防问题，长远看还需要提供数据支持，需要辅助决策，辅助管理。\n\n# 团队\n\n当一个团队可以很好的预防问题的发生时，可以称这样的团队为建设型的团队。\n\n传统的瀑布模型中开发完成开始测试是导致项目进度缓慢的一个重要原因。\n\n如何让开发与测试并行？测试始终伴随开发，甚至优先于开发。\n\n开发，测试并行的三个重要保障：需求文档，开发文档，测试文档\n\n# TDD\n\n**文档评审**\n\n从执行过程上来看，当需求文档出来后，开发和测试需要同时整理对应文档，然后进入评审环节。\n\n需求作为开发，测试的输入项，要求需求文档不能出现偏差。\n\n从制度上可以做出一些规范化，例如：\n\n- 需求文档、开发文档、测试文档作为三个关键文档，任何一个都一定不能或缺\n- 三个关键文档都要有评审，三次的评审都要求产品、开发、测试负责的人员到场确认\n- 文档可以驳回，但确认后的文档不可更改\n- 任何一个文档出现滞后，都要记录，分析问题\n\n文档内容要细致，需求文档作为开发文档和测试文档输入，尤其重要。\n\n各个文档的基本标准：\n\n- 需求文档：明确各步骤输入输出\n- 测试文档：明确各个测试点，需要进行什么测试，是否要求自动化等信息，设计（复用）测试框架\n- 开发文档：提供设计架构，需要细致到开发阶段填充代码就可以了\n\n一个优秀文档的重要标准：评审打回次数。\n\n**开发，测试并行**\n\n三个文档评审结束后，开发和测试同时开始工作。\n\n\n\n# 其它\n\n**关于需求分析**\n\n需求分析需要专业的人专门处理，需求分析的过程如同医生看病：\n\n医生不能问病人想吃什么药，想怎么治疗，而是需要找到病人病因\n\n产品不能表面的询问用户想要什么，而是要发现用户的真实需求\n\n需求分析过程展开：\n\n1. 获取\n\n   得到最原始的需求，这些需求可能是凌乱的，甚至是矛盾的，不能直接用来开发\n\n2. 分析\n\n   剔除原始需求中的噪音，获取真实的需求，这个阶段产品应该基本确认需求\n\n3. 细化\n\n   产出原型，与美术，设计确认沟通，明确每步的输入输出\n\n4. 固化\n\n   与用户确认，得到最终版本的需求文档\n\n**关于团队成员能力**\n\n1. 不能迁就最低能力人员，要推动团队成长，进步\n2. 开发与测试要互相促进，测试需要考虑开发设计的文档是否可以进行测试，有哪些改进，开发需要考虑代码的覆盖\n3. 通过模板让人员能力可流动，可转化。总结高质量方法，模板，流程给团队复用，提高整体质量\n\n**关于测试**\n\n- Bug分级\n- 不要首先搞UI测试\n- 尽量使用真实数据，边界数据\n- 避免对其它模块，代码的依赖\n- 发布时不一定就能做到所有测试都通过\n- 测试要可复用，粒度，范围要注意\n","slug":"浅谈测试驱动开发","published":1,"updated":"2017-02-05T14:13:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2su0051d82ew5g0zhwj","content":"<p>近两日参加了名为“软件测试质量体系最佳实践”的分享，其中着重介绍了质量体系的建设，测试的经验以及方法，就我个人最大的收获更多的是关于TDD的思考，在此简单记录。</p>\n<h1 id=\"Bug的影响\"><a href=\"#Bug的影响\" class=\"headerlink\" title=\"Bug的影响\"></a>Bug的影响</h1><p>不成熟的团队中一个常见情况：</p>\n<p>频繁被突发问题打断，响应式的处理，目标达成率低，可以称这样的团队为响应式的团队。</p>\n<p>为什么频繁的响应Bug会严重消耗团队资源？</p>\n<ol>\n<li>完整的Bug处理的过程时间长</li>\n<li>一个Bug导致多个Bug的产生</li>\n<li>人员缺乏动力</li>\n</ol>\n<h1 id=\"预防Bug\"><a href=\"#预防Bug\" class=\"headerlink\" title=\"预防Bug\"></a>预防Bug</h1><p>然而解决Bug并不能算作突出的贡献，针对Bug的预防工作要优于Bug解决。从被动的救火到主动的预防问题发生，减少突发问题。</p>\n<p>一个团队的重要指标，是有效代码的产出，而不是代码的产出。</p>\n<p>有效代码，如同字面意思，有效的，可复用的，没有大量Bug，可以赚钱的代码。</p>\n<p>如何保证代码有效？测试！</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p>手工测试无法做到连续提供测试服务，存在间断，代码修改后测试报告随即失效。为了解决测试的间断问题，必须引入自动化测试。</p>\n<p>开发工作中耗时最多的是在调试，如果能减少问题的出现，避免反复调试，可以节省大量的时间、精力。</p>\n<p>因此，测试并不会让团队的工作量出现明显增加，最终开发与测试的人数趋于接近。</p>\n<p>测试短期可以帮助我们找Bug，长期可以帮助我们建设质量体系。</p>\n<h1 id=\"质量体系\"><a href=\"#质量体系\" class=\"headerlink\" title=\"质量体系\"></a>质量体系</h1><p>系统的健康状况，项目的完成情况应当从质量体系中直观，实时的获取，而不是通过大量的会议，讨论得出。</p>\n<p>数据的三个来源</p>\n<ul>\n<li><p>用例库</p>\n<p>积累的测试用例</p>\n<p>要求能复用（良好的测试框架）</p>\n<p>能够与其它平台，系统方便集成（一个test case对应多个test Run）</p>\n</li>\n<li><p>缺陷库</p>\n<p>Bug的完整生命周期记录</p>\n</li>\n<li><p>结果库</p>\n<p>每次自动化测试的结果</p>\n<p>最小的单位不是test case，而是test run</p>\n</li>\n</ul>\n<p>质量体系，不仅用于预防问题，长远看还需要提供数据支持，需要辅助决策，辅助管理。</p>\n<h1 id=\"团队\"><a href=\"#团队\" class=\"headerlink\" title=\"团队\"></a>团队</h1><p>当一个团队可以很好的预防问题的发生时，可以称这样的团队为建设型的团队。</p>\n<p>传统的瀑布模型中开发完成开始测试是导致项目进度缓慢的一个重要原因。</p>\n<p>如何让开发与测试并行？测试始终伴随开发，甚至优先于开发。</p>\n<p>开发，测试并行的三个重要保障：需求文档，开发文档，测试文档</p>\n<h1 id=\"TDD\"><a href=\"#TDD\" class=\"headerlink\" title=\"TDD\"></a>TDD</h1><p><strong>文档评审</strong></p>\n<p>从执行过程上来看，当需求文档出来后，开发和测试需要同时整理对应文档，然后进入评审环节。</p>\n<p>需求作为开发，测试的输入项，要求需求文档不能出现偏差。</p>\n<p>从制度上可以做出一些规范化，例如：</p>\n<ul>\n<li>需求文档、开发文档、测试文档作为三个关键文档，任何一个都一定不能或缺</li>\n<li>三个关键文档都要有评审，三次的评审都要求产品、开发、测试负责的人员到场确认</li>\n<li>文档可以驳回，但确认后的文档不可更改</li>\n<li>任何一个文档出现滞后，都要记录，分析问题</li>\n</ul>\n<p>文档内容要细致，需求文档作为开发文档和测试文档输入，尤其重要。</p>\n<p>各个文档的基本标准：</p>\n<ul>\n<li>需求文档：明确各步骤输入输出</li>\n<li>测试文档：明确各个测试点，需要进行什么测试，是否要求自动化等信息，设计（复用）测试框架</li>\n<li>开发文档：提供设计架构，需要细致到开发阶段填充代码就可以了</li>\n</ul>\n<p>一个优秀文档的重要标准：评审打回次数。</p>\n<p><strong>开发，测试并行</strong></p>\n<p>三个文档评审结束后，开发和测试同时开始工作。</p>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><p><strong>关于需求分析</strong></p>\n<p>需求分析需要专业的人专门处理，需求分析的过程如同医生看病：</p>\n<p>医生不能问病人想吃什么药，想怎么治疗，而是需要找到病人病因</p>\n<p>产品不能表面的询问用户想要什么，而是要发现用户的真实需求</p>\n<p>需求分析过程展开：</p>\n<ol>\n<li><p>获取</p>\n<p>得到最原始的需求，这些需求可能是凌乱的，甚至是矛盾的，不能直接用来开发</p>\n</li>\n<li><p>分析</p>\n<p>剔除原始需求中的噪音，获取真实的需求，这个阶段产品应该基本确认需求</p>\n</li>\n<li><p>细化</p>\n<p>产出原型，与美术，设计确认沟通，明确每步的输入输出</p>\n</li>\n<li><p>固化</p>\n<p>与用户确认，得到最终版本的需求文档</p>\n</li>\n</ol>\n<p><strong>关于团队成员能力</strong></p>\n<ol>\n<li>不能迁就最低能力人员，要推动团队成长，进步</li>\n<li>开发与测试要互相促进，测试需要考虑开发设计的文档是否可以进行测试，有哪些改进，开发需要考虑代码的覆盖</li>\n<li>通过模板让人员能力可流动，可转化。总结高质量方法，模板，流程给团队复用，提高整体质量</li>\n</ol>\n<p><strong>关于测试</strong></p>\n<ul>\n<li>Bug分级</li>\n<li>不要首先搞UI测试</li>\n<li>尽量使用真实数据，边界数据</li>\n<li>避免对其它模块，代码的依赖</li>\n<li>发布时不一定就能做到所有测试都通过</li>\n<li>测试要可复用，粒度，范围要注意</li>\n</ul>\n","excerpt":"","more":"<p>近两日参加了名为“软件测试质量体系最佳实践”的分享，其中着重介绍了质量体系的建设，测试的经验以及方法，就我个人最大的收获更多的是关于TDD的思考，在此简单记录。</p>\n<h1 id=\"Bug的影响\"><a href=\"#Bug的影响\" class=\"headerlink\" title=\"Bug的影响\"></a>Bug的影响</h1><p>不成熟的团队中一个常见情况：</p>\n<p>频繁被突发问题打断，响应式的处理，目标达成率低，可以称这样的团队为响应式的团队。</p>\n<p>为什么频繁的响应Bug会严重消耗团队资源？</p>\n<ol>\n<li>完整的Bug处理的过程时间长</li>\n<li>一个Bug导致多个Bug的产生</li>\n<li>人员缺乏动力</li>\n</ol>\n<h1 id=\"预防Bug\"><a href=\"#预防Bug\" class=\"headerlink\" title=\"预防Bug\"></a>预防Bug</h1><p>然而解决Bug并不能算作突出的贡献，针对Bug的预防工作要优于Bug解决。从被动的救火到主动的预防问题发生，减少突发问题。</p>\n<p>一个团队的重要指标，是有效代码的产出，而不是代码的产出。</p>\n<p>有效代码，如同字面意思，有效的，可复用的，没有大量Bug，可以赚钱的代码。</p>\n<p>如何保证代码有效？测试！</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p>手工测试无法做到连续提供测试服务，存在间断，代码修改后测试报告随即失效。为了解决测试的间断问题，必须引入自动化测试。</p>\n<p>开发工作中耗时最多的是在调试，如果能减少问题的出现，避免反复调试，可以节省大量的时间、精力。</p>\n<p>因此，测试并不会让团队的工作量出现明显增加，最终开发与测试的人数趋于接近。</p>\n<p>测试短期可以帮助我们找Bug，长期可以帮助我们建设质量体系。</p>\n<h1 id=\"质量体系\"><a href=\"#质量体系\" class=\"headerlink\" title=\"质量体系\"></a>质量体系</h1><p>系统的健康状况，项目的完成情况应当从质量体系中直观，实时的获取，而不是通过大量的会议，讨论得出。</p>\n<p>数据的三个来源</p>\n<ul>\n<li><p>用例库</p>\n<p>积累的测试用例</p>\n<p>要求能复用（良好的测试框架）</p>\n<p>能够与其它平台，系统方便集成（一个test case对应多个test Run）</p>\n</li>\n<li><p>缺陷库</p>\n<p>Bug的完整生命周期记录</p>\n</li>\n<li><p>结果库</p>\n<p>每次自动化测试的结果</p>\n<p>最小的单位不是test case，而是test run</p>\n</li>\n</ul>\n<p>质量体系，不仅用于预防问题，长远看还需要提供数据支持，需要辅助决策，辅助管理。</p>\n<h1 id=\"团队\"><a href=\"#团队\" class=\"headerlink\" title=\"团队\"></a>团队</h1><p>当一个团队可以很好的预防问题的发生时，可以称这样的团队为建设型的团队。</p>\n<p>传统的瀑布模型中开发完成开始测试是导致项目进度缓慢的一个重要原因。</p>\n<p>如何让开发与测试并行？测试始终伴随开发，甚至优先于开发。</p>\n<p>开发，测试并行的三个重要保障：需求文档，开发文档，测试文档</p>\n<h1 id=\"TDD\"><a href=\"#TDD\" class=\"headerlink\" title=\"TDD\"></a>TDD</h1><p><strong>文档评审</strong></p>\n<p>从执行过程上来看，当需求文档出来后，开发和测试需要同时整理对应文档，然后进入评审环节。</p>\n<p>需求作为开发，测试的输入项，要求需求文档不能出现偏差。</p>\n<p>从制度上可以做出一些规范化，例如：</p>\n<ul>\n<li>需求文档、开发文档、测试文档作为三个关键文档，任何一个都一定不能或缺</li>\n<li>三个关键文档都要有评审，三次的评审都要求产品、开发、测试负责的人员到场确认</li>\n<li>文档可以驳回，但确认后的文档不可更改</li>\n<li>任何一个文档出现滞后，都要记录，分析问题</li>\n</ul>\n<p>文档内容要细致，需求文档作为开发文档和测试文档输入，尤其重要。</p>\n<p>各个文档的基本标准：</p>\n<ul>\n<li>需求文档：明确各步骤输入输出</li>\n<li>测试文档：明确各个测试点，需要进行什么测试，是否要求自动化等信息，设计（复用）测试框架</li>\n<li>开发文档：提供设计架构，需要细致到开发阶段填充代码就可以了</li>\n</ul>\n<p>一个优秀文档的重要标准：评审打回次数。</p>\n<p><strong>开发，测试并行</strong></p>\n<p>三个文档评审结束后，开发和测试同时开始工作。</p>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><p><strong>关于需求分析</strong></p>\n<p>需求分析需要专业的人专门处理，需求分析的过程如同医生看病：</p>\n<p>医生不能问病人想吃什么药，想怎么治疗，而是需要找到病人病因</p>\n<p>产品不能表面的询问用户想要什么，而是要发现用户的真实需求</p>\n<p>需求分析过程展开：</p>\n<ol>\n<li><p>获取</p>\n<p>得到最原始的需求，这些需求可能是凌乱的，甚至是矛盾的，不能直接用来开发</p>\n</li>\n<li><p>分析</p>\n<p>剔除原始需求中的噪音，获取真实的需求，这个阶段产品应该基本确认需求</p>\n</li>\n<li><p>细化</p>\n<p>产出原型，与美术，设计确认沟通，明确每步的输入输出</p>\n</li>\n<li><p>固化</p>\n<p>与用户确认，得到最终版本的需求文档</p>\n</li>\n</ol>\n<p><strong>关于团队成员能力</strong></p>\n<ol>\n<li>不能迁就最低能力人员，要推动团队成长，进步</li>\n<li>开发与测试要互相促进，测试需要考虑开发设计的文档是否可以进行测试，有哪些改进，开发需要考虑代码的覆盖</li>\n<li>通过模板让人员能力可流动，可转化。总结高质量方法，模板，流程给团队复用，提高整体质量</li>\n</ol>\n<p><strong>关于测试</strong></p>\n<ul>\n<li>Bug分级</li>\n<li>不要首先搞UI测试</li>\n<li>尽量使用真实数据，边界数据</li>\n<li>避免对其它模块，代码的依赖</li>\n<li>发布时不一定就能做到所有测试都通过</li>\n<li>测试要可复用，粒度，范围要注意</li>\n</ul>\n"},{"title":"自下而上的开发实践","date":"2016-10-22T11:23:25.000Z","_content":"\n## 两种开发思路\n\n**自上而下**：设计先行，根据设计开发\n\n**自下而上**：开发先行，给予开发重构\n\n## 关注点分离\n\n类似于文章段落的划分，代码拆分的简单过程可以概括为：\n\n- 分行\n  - 方法真实逻辑与业务支撑逻辑的划分\n  - 基于模块层次的划分，而不是语句行数的划分\n- 注释\n  - 良好命名要胜过写大量的注释\n- 抽象提取方法\n  - 合理封装\n  - 参数内联\n  - 方法名、可访问性\n- 删除不必要的分行与注释\n\n## 共性与可变性分析\n\n软件工程的两个敌人：\n\n* 共性：开发成本、维护成本 \n* 可变性：维护成本\n\n共性的复用两种模式：\n\n- 继承\n  - 强耦合关系，父类的修改影响所有子类\n  - 单继承限制\n  - 多态\n  - 差异式编程\n  - 钩子方法\n- 组合\n  - 优先使用\n  - 依赖注入\n  - 优先组合接口而非实现\n    - 控制翻转\n\n## 接口\n\ncontext+role+collaborator\n\n好处：类型确定，但实现可变、不确定\n\n类与接口的关系类似于人与角色的关系：\n\n- 人可以有多个角色，类可以有多个接口\n- 人的某一个角色的确定是由环境决定的，类某一接口的确定是由上下文环境决定的\n\n接口设计应当遵循的原则：**接口隔离原则（SIP）**\n\n接口应该是干净的，单一的，细粒度的，而不是混合过多的方法，职责单一\n\n## 扩展式设计的一般过程：\n\n1. 分离职责各司其职：关注点分离\n   - 向上分离：继承\n   - 向外分离：组合\n2. 统一接口：\n   - 提炼接口，提供多态\n   - 面向接口编程\n3. 引用接口预留空白\n   - 依赖注入\n\n以一个事务为例子展示扩展式设计的一般过程：\n\n首先，有一个Service，在方法中业务逻辑与JDBC事务粘合在一起：\n\n\n```java\npublic class OrderService {\n    private DatabasePool dbPool;\n\n    public void subscribTrainings(List<Training> trainings, \n                                  Customer customer) throws SQLException {\n        // 初始化方法\n      \tConnection c = null;\n        PreparedStatement ps = null;\n        Statement s = null;\n        ResultSet rs = null;\n        boolean transactionState = false;\n      \n        try {\n          \t// 开启事务 \n            s = c.createStatement();\n            transactionState = c.getAutoCommit();\n            c.setAutoCommit(false);\n          \n          \t// 业务操作\n            for (Training training : trainings) {\n                addTrainingItem(customer, training);\n            }\n            addOrder(customer, trainings);\n            \n          \t// 提交事务\n          \tc.commit();\n        } catch (SQLException sqlx) {\n          \t// 回滚\n            c.rollback();\n          \n            throw sqlx;\n        } finally {\n          \t// 关闭操作\n            try {\n                c.setAutoCommit(transactionState);\n                dbPool.release(c);\n                if (s != null) s.close();\n                if (ps != null) ps.close();\n                if (rs != null) rs.close();\n            } catch (SQLException ignored) {\n            }\n        }\n    }\n\n    private void addOrder(Customer customer, List<Training> trainings) {\n\t\n    }\n\n    private void addTrainingItem(Customer customer, Training training) {\n\n    }\n}\n```\n\n第一步在原始代码上分段并添加注释后代码如上所示。对每段代码提取方法，向上抽象：\n\n```java\npublic class TransactionScope {\n    private DatabasePool dbPool;\n    private Connection connection;\n    private PreparedStatement preparedStatement;\n    private Statement statement;\n    private ResultSet resultSet;\n    private boolean transactionState;\n\n    public void using() throws SQLException {\n        setup();\n        try {\n            beginTransaction();\n            // 留白一个具体的业务的实现:\n            //      1. (模板方法)继承->钩子方法\n            //      2. (委派)传递一个方法(方法接口)\n            commitTransaction();\n        } catch (SQLException sqlx) {\n            rollbackTransaction();\n            throw sqlx;\n        } finally {\n            teardown();\n        }\n    }\n\n    private void rollbackTransaction() throws SQLException {\n        connection.rollback();\n    }\n\n    private void setup() {\n        connection = null;\n        preparedStatement = null;\n        statement = null;\n        resultSet = null;\n        transactionState = false;\n    }\n\n    private void teardown() {\n        try {\n            connection.setAutoCommit(transactionState);\n            dbPool.release(connection);\n            if (statement != null) statement.close();\n            if (preparedStatement != null) preparedStatement.close();\n            if (resultSet != null) resultSet.close();\n        } catch (SQLException ignored) {\n        }\n    }\n\n    private void commitTransaction() throws SQLException {\n        connection.commit();\n    }\n\n    private void beginTransaction() throws SQLException {\n        statement = connection.createStatement();\n        transactionState = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n    }\n}\n\npublic interface Command {\n    void execute();\n}\n\n```\n现在提炼出了一个本地事务的基本控制模板，实现了事务控制与业务逻辑控制基本分离。\n\n继续提炼事务控制类的接口，用于横向扩展继承使用：\n\n```java\npublic interface TransactionScope {\n    void using(Command command) throws SQLException;\n}\n\npublic class LocalTransactionScope implements TransactionScope {\n  \t@Override\n    public void using(Command action) throws SQLException {\n        setup();\n        try {\n            beginTransaction();\n            action.execute();  // 具体的业务逻辑\n            commitTransaction();\n        } catch (SQLException sqlx) {\n            rollbackTransaction();\n            throw sqlx;\n        } finally {\n            teardown();\n        }\n    }\n}\n\npublic class DistructedTransactionScope implements TransactionScope {\n    @Override\n    public void using(Command command) throws SQLException {\n      \n    }\n}\n```\n调用方通过接口留白，实现依赖注入：\n\n```java\npublic class OrderService {\n    private TransactionScope transactionScope;\n\n    public void setTransactionScope(TransactionScope transactionScope) {\n        this.transactionScope = transactionScope;\n    }\n\n    public void subscribTrainings(List<Training> trainings, \n                                  Customer customer) throws SQLException {\n        transactionScope.using(() -> {\n                for (Training training : trainings) {\n                    addTrainingItem(customer, training);\n                }\n                addOrder(customer, trainings);\n        });\n    }\n}\n```\n","source":"_posts/自下而上的开发实践.md","raw":"---\ntitle: 自下而上的开发实践\ndate: 2016-10-22 19:23:25\ntags:\n  - 设计模式\n  - Java\ncategories: 设计模式\n---\n\n## 两种开发思路\n\n**自上而下**：设计先行，根据设计开发\n\n**自下而上**：开发先行，给予开发重构\n\n## 关注点分离\n\n类似于文章段落的划分，代码拆分的简单过程可以概括为：\n\n- 分行\n  - 方法真实逻辑与业务支撑逻辑的划分\n  - 基于模块层次的划分，而不是语句行数的划分\n- 注释\n  - 良好命名要胜过写大量的注释\n- 抽象提取方法\n  - 合理封装\n  - 参数内联\n  - 方法名、可访问性\n- 删除不必要的分行与注释\n\n## 共性与可变性分析\n\n软件工程的两个敌人：\n\n* 共性：开发成本、维护成本 \n* 可变性：维护成本\n\n共性的复用两种模式：\n\n- 继承\n  - 强耦合关系，父类的修改影响所有子类\n  - 单继承限制\n  - 多态\n  - 差异式编程\n  - 钩子方法\n- 组合\n  - 优先使用\n  - 依赖注入\n  - 优先组合接口而非实现\n    - 控制翻转\n\n## 接口\n\ncontext+role+collaborator\n\n好处：类型确定，但实现可变、不确定\n\n类与接口的关系类似于人与角色的关系：\n\n- 人可以有多个角色，类可以有多个接口\n- 人的某一个角色的确定是由环境决定的，类某一接口的确定是由上下文环境决定的\n\n接口设计应当遵循的原则：**接口隔离原则（SIP）**\n\n接口应该是干净的，单一的，细粒度的，而不是混合过多的方法，职责单一\n\n## 扩展式设计的一般过程：\n\n1. 分离职责各司其职：关注点分离\n   - 向上分离：继承\n   - 向外分离：组合\n2. 统一接口：\n   - 提炼接口，提供多态\n   - 面向接口编程\n3. 引用接口预留空白\n   - 依赖注入\n\n以一个事务为例子展示扩展式设计的一般过程：\n\n首先，有一个Service，在方法中业务逻辑与JDBC事务粘合在一起：\n\n\n```java\npublic class OrderService {\n    private DatabasePool dbPool;\n\n    public void subscribTrainings(List<Training> trainings, \n                                  Customer customer) throws SQLException {\n        // 初始化方法\n      \tConnection c = null;\n        PreparedStatement ps = null;\n        Statement s = null;\n        ResultSet rs = null;\n        boolean transactionState = false;\n      \n        try {\n          \t// 开启事务 \n            s = c.createStatement();\n            transactionState = c.getAutoCommit();\n            c.setAutoCommit(false);\n          \n          \t// 业务操作\n            for (Training training : trainings) {\n                addTrainingItem(customer, training);\n            }\n            addOrder(customer, trainings);\n            \n          \t// 提交事务\n          \tc.commit();\n        } catch (SQLException sqlx) {\n          \t// 回滚\n            c.rollback();\n          \n            throw sqlx;\n        } finally {\n          \t// 关闭操作\n            try {\n                c.setAutoCommit(transactionState);\n                dbPool.release(c);\n                if (s != null) s.close();\n                if (ps != null) ps.close();\n                if (rs != null) rs.close();\n            } catch (SQLException ignored) {\n            }\n        }\n    }\n\n    private void addOrder(Customer customer, List<Training> trainings) {\n\t\n    }\n\n    private void addTrainingItem(Customer customer, Training training) {\n\n    }\n}\n```\n\n第一步在原始代码上分段并添加注释后代码如上所示。对每段代码提取方法，向上抽象：\n\n```java\npublic class TransactionScope {\n    private DatabasePool dbPool;\n    private Connection connection;\n    private PreparedStatement preparedStatement;\n    private Statement statement;\n    private ResultSet resultSet;\n    private boolean transactionState;\n\n    public void using() throws SQLException {\n        setup();\n        try {\n            beginTransaction();\n            // 留白一个具体的业务的实现:\n            //      1. (模板方法)继承->钩子方法\n            //      2. (委派)传递一个方法(方法接口)\n            commitTransaction();\n        } catch (SQLException sqlx) {\n            rollbackTransaction();\n            throw sqlx;\n        } finally {\n            teardown();\n        }\n    }\n\n    private void rollbackTransaction() throws SQLException {\n        connection.rollback();\n    }\n\n    private void setup() {\n        connection = null;\n        preparedStatement = null;\n        statement = null;\n        resultSet = null;\n        transactionState = false;\n    }\n\n    private void teardown() {\n        try {\n            connection.setAutoCommit(transactionState);\n            dbPool.release(connection);\n            if (statement != null) statement.close();\n            if (preparedStatement != null) preparedStatement.close();\n            if (resultSet != null) resultSet.close();\n        } catch (SQLException ignored) {\n        }\n    }\n\n    private void commitTransaction() throws SQLException {\n        connection.commit();\n    }\n\n    private void beginTransaction() throws SQLException {\n        statement = connection.createStatement();\n        transactionState = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n    }\n}\n\npublic interface Command {\n    void execute();\n}\n\n```\n现在提炼出了一个本地事务的基本控制模板，实现了事务控制与业务逻辑控制基本分离。\n\n继续提炼事务控制类的接口，用于横向扩展继承使用：\n\n```java\npublic interface TransactionScope {\n    void using(Command command) throws SQLException;\n}\n\npublic class LocalTransactionScope implements TransactionScope {\n  \t@Override\n    public void using(Command action) throws SQLException {\n        setup();\n        try {\n            beginTransaction();\n            action.execute();  // 具体的业务逻辑\n            commitTransaction();\n        } catch (SQLException sqlx) {\n            rollbackTransaction();\n            throw sqlx;\n        } finally {\n            teardown();\n        }\n    }\n}\n\npublic class DistructedTransactionScope implements TransactionScope {\n    @Override\n    public void using(Command command) throws SQLException {\n      \n    }\n}\n```\n调用方通过接口留白，实现依赖注入：\n\n```java\npublic class OrderService {\n    private TransactionScope transactionScope;\n\n    public void setTransactionScope(TransactionScope transactionScope) {\n        this.transactionScope = transactionScope;\n    }\n\n    public void subscribTrainings(List<Training> trainings, \n                                  Customer customer) throws SQLException {\n        transactionScope.using(() -> {\n                for (Training training : trainings) {\n                    addTrainingItem(customer, training);\n                }\n                addOrder(customer, trainings);\n        });\n    }\n}\n```\n","slug":"自下而上的开发实践","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2sv0055d82enmreo5p6","content":"<h2 id=\"两种开发思路\"><a href=\"#两种开发思路\" class=\"headerlink\" title=\"两种开发思路\"></a>两种开发思路</h2><p><strong>自上而下</strong>：设计先行，根据设计开发</p>\n<p><strong>自下而上</strong>：开发先行，给予开发重构</p>\n<h2 id=\"关注点分离\"><a href=\"#关注点分离\" class=\"headerlink\" title=\"关注点分离\"></a>关注点分离</h2><p>类似于文章段落的划分，代码拆分的简单过程可以概括为：</p>\n<ul>\n<li>分行<ul>\n<li>方法真实逻辑与业务支撑逻辑的划分</li>\n<li>基于模块层次的划分，而不是语句行数的划分</li>\n</ul>\n</li>\n<li>注释<ul>\n<li>良好命名要胜过写大量的注释</li>\n</ul>\n</li>\n<li>抽象提取方法<ul>\n<li>合理封装</li>\n<li>参数内联</li>\n<li>方法名、可访问性</li>\n</ul>\n</li>\n<li>删除不必要的分行与注释</li>\n</ul>\n<h2 id=\"共性与可变性分析\"><a href=\"#共性与可变性分析\" class=\"headerlink\" title=\"共性与可变性分析\"></a>共性与可变性分析</h2><p>软件工程的两个敌人：</p>\n<ul>\n<li>共性：开发成本、维护成本 </li>\n<li>可变性：维护成本</li>\n</ul>\n<p>共性的复用两种模式：</p>\n<ul>\n<li>继承<ul>\n<li>强耦合关系，父类的修改影响所有子类</li>\n<li>单继承限制</li>\n<li>多态</li>\n<li>差异式编程</li>\n<li>钩子方法</li>\n</ul>\n</li>\n<li>组合<ul>\n<li>优先使用</li>\n<li>依赖注入</li>\n<li>优先组合接口而非实现<ul>\n<li>控制翻转</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>context+role+collaborator</p>\n<p>好处：类型确定，但实现可变、不确定</p>\n<p>类与接口的关系类似于人与角色的关系：</p>\n<ul>\n<li>人可以有多个角色，类可以有多个接口</li>\n<li>人的某一个角色的确定是由环境决定的，类某一接口的确定是由上下文环境决定的</li>\n</ul>\n<p>接口设计应当遵循的原则：<strong>接口隔离原则（SIP）</strong></p>\n<p>接口应该是干净的，单一的，细粒度的，而不是混合过多的方法，职责单一</p>\n<h2 id=\"扩展式设计的一般过程：\"><a href=\"#扩展式设计的一般过程：\" class=\"headerlink\" title=\"扩展式设计的一般过程：\"></a>扩展式设计的一般过程：</h2><ol>\n<li>分离职责各司其职：关注点分离<ul>\n<li>向上分离：继承</li>\n<li>向外分离：组合</li>\n</ul>\n</li>\n<li>统一接口：<ul>\n<li>提炼接口，提供多态</li>\n<li>面向接口编程</li>\n</ul>\n</li>\n<li>引用接口预留空白<ul>\n<li>依赖注入</li>\n</ul>\n</li>\n</ol>\n<p>以一个事务为例子展示扩展式设计的一般过程：</p>\n<p>首先，有一个Service，在方法中业务逻辑与JDBC事务粘合在一起：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> DatabasePool dbPool;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribTrainings</span><span class=\"params\">(List&lt;Training&gt; trainings, </span></span></div><div class=\"line\">                                  Customer customer) <span class=\"keyword\">throws</span> SQLException &#123;</div><div class=\"line\">        <span class=\"comment\">// 初始化方法</span></div><div class=\"line\">      \tConnection c = <span class=\"keyword\">null</span>;</div><div class=\"line\">        PreparedStatement ps = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Statement s = <span class=\"keyword\">null</span>;</div><div class=\"line\">        ResultSet rs = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> transactionState = <span class=\"keyword\">false</span>;</div><div class=\"line\">      </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 开启事务 </span></div><div class=\"line\">            s = c.createStatement();</div><div class=\"line\">            transactionState = c.getAutoCommit();</div><div class=\"line\">            c.setAutoCommit(<span class=\"keyword\">false</span>);</div><div class=\"line\">          </div><div class=\"line\">          \t<span class=\"comment\">// 业务操作</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (Training training : trainings) &#123;</div><div class=\"line\">                addTrainingItem(customer, training);</div><div class=\"line\">            &#125;</div><div class=\"line\">            addOrder(customer, trainings);</div><div class=\"line\">            </div><div class=\"line\">          \t<span class=\"comment\">// 提交事务</span></div><div class=\"line\">          \tc.commit();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 回滚</span></div><div class=\"line\">            c.rollback();</div><div class=\"line\">          </div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 关闭操作</span></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                c.setAutoCommit(transactionState);</div><div class=\"line\">                dbPool.release(c);</div><div class=\"line\">                <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>) s.close();</div><div class=\"line\">                <span class=\"keyword\">if</span> (ps != <span class=\"keyword\">null</span>) ps.close();</div><div class=\"line\">                <span class=\"keyword\">if</span> (rs != <span class=\"keyword\">null</span>) rs.close();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException ignored) &#123;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addOrder</span><span class=\"params\">(Customer customer, List&lt;Training&gt; trainings)</span> </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addTrainingItem</span><span class=\"params\">(Customer customer, Training training)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一步在原始代码上分段并添加注释后代码如上所示。对每段代码提取方法，向上抽象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> DatabasePool dbPool;</div><div class=\"line\">    <span class=\"keyword\">private</span> Connection connection;</div><div class=\"line\">    <span class=\"keyword\">private</span> PreparedStatement preparedStatement;</div><div class=\"line\">    <span class=\"keyword\">private</span> Statement statement;</div><div class=\"line\">    <span class=\"keyword\">private</span> ResultSet resultSet;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> transactionState;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        setup();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            beginTransaction();</div><div class=\"line\">            <span class=\"comment\">// 留白一个具体的业务的实现:</span></div><div class=\"line\">            <span class=\"comment\">//      1. (模板方法)继承-&gt;钩子方法</span></div><div class=\"line\">            <span class=\"comment\">//      2. (委派)传递一个方法(方法接口)</span></div><div class=\"line\">            commitTransaction();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">            rollbackTransaction();</div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            teardown();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rollbackTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        connection.rollback();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        connection = <span class=\"keyword\">null</span>;</div><div class=\"line\">        preparedStatement = <span class=\"keyword\">null</span>;</div><div class=\"line\">        statement = <span class=\"keyword\">null</span>;</div><div class=\"line\">        resultSet = <span class=\"keyword\">null</span>;</div><div class=\"line\">        transactionState = <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">teardown</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            connection.setAutoCommit(transactionState);</div><div class=\"line\">            dbPool.release(connection);</div><div class=\"line\">            <span class=\"keyword\">if</span> (statement != <span class=\"keyword\">null</span>) statement.close();</div><div class=\"line\">            <span class=\"keyword\">if</span> (preparedStatement != <span class=\"keyword\">null</span>) preparedStatement.close();</div><div class=\"line\">            <span class=\"keyword\">if</span> (resultSet != <span class=\"keyword\">null</span>) resultSet.close();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException ignored) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">commitTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        connection.commit();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">beginTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        statement = connection.createStatement();</div><div class=\"line\">        transactionState = connection.getAutoCommit();</div><div class=\"line\">        connection.setAutoCommit(<span class=\"keyword\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Command</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在提炼出了一个本地事务的基本控制模板，实现了事务控制与业务逻辑控制基本分离。</p>\n<p>继续提炼事务控制类的接口，用于横向扩展继承使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command command)</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalTransactionScope</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">  \t<span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command action)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        setup();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            beginTransaction();</div><div class=\"line\">            action.execute();  <span class=\"comment\">// 具体的业务逻辑</span></div><div class=\"line\">            commitTransaction();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">            rollbackTransaction();</div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            teardown();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DistructedTransactionScope</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command command)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">      </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用方通过接口留白，实现依赖注入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> TransactionScope transactionScope;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTransactionScope</span><span class=\"params\">(TransactionScope transactionScope)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.transactionScope = transactionScope;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribTrainings</span><span class=\"params\">(List&lt;Training&gt; trainings, </span></span></div><div class=\"line\">                                  Customer customer) <span class=\"keyword\">throws</span> SQLException &#123;</div><div class=\"line\">        transactionScope.using(() -&gt; &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (Training training : trainings) &#123;</div><div class=\"line\">                    addTrainingItem(customer, training);</div><div class=\"line\">                &#125;</div><div class=\"line\">                addOrder(customer, trainings);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"两种开发思路\"><a href=\"#两种开发思路\" class=\"headerlink\" title=\"两种开发思路\"></a>两种开发思路</h2><p><strong>自上而下</strong>：设计先行，根据设计开发</p>\n<p><strong>自下而上</strong>：开发先行，给予开发重构</p>\n<h2 id=\"关注点分离\"><a href=\"#关注点分离\" class=\"headerlink\" title=\"关注点分离\"></a>关注点分离</h2><p>类似于文章段落的划分，代码拆分的简单过程可以概括为：</p>\n<ul>\n<li>分行<ul>\n<li>方法真实逻辑与业务支撑逻辑的划分</li>\n<li>基于模块层次的划分，而不是语句行数的划分</li>\n</ul>\n</li>\n<li>注释<ul>\n<li>良好命名要胜过写大量的注释</li>\n</ul>\n</li>\n<li>抽象提取方法<ul>\n<li>合理封装</li>\n<li>参数内联</li>\n<li>方法名、可访问性</li>\n</ul>\n</li>\n<li>删除不必要的分行与注释</li>\n</ul>\n<h2 id=\"共性与可变性分析\"><a href=\"#共性与可变性分析\" class=\"headerlink\" title=\"共性与可变性分析\"></a>共性与可变性分析</h2><p>软件工程的两个敌人：</p>\n<ul>\n<li>共性：开发成本、维护成本 </li>\n<li>可变性：维护成本</li>\n</ul>\n<p>共性的复用两种模式：</p>\n<ul>\n<li>继承<ul>\n<li>强耦合关系，父类的修改影响所有子类</li>\n<li>单继承限制</li>\n<li>多态</li>\n<li>差异式编程</li>\n<li>钩子方法</li>\n</ul>\n</li>\n<li>组合<ul>\n<li>优先使用</li>\n<li>依赖注入</li>\n<li>优先组合接口而非实现<ul>\n<li>控制翻转</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>context+role+collaborator</p>\n<p>好处：类型确定，但实现可变、不确定</p>\n<p>类与接口的关系类似于人与角色的关系：</p>\n<ul>\n<li>人可以有多个角色，类可以有多个接口</li>\n<li>人的某一个角色的确定是由环境决定的，类某一接口的确定是由上下文环境决定的</li>\n</ul>\n<p>接口设计应当遵循的原则：<strong>接口隔离原则（SIP）</strong></p>\n<p>接口应该是干净的，单一的，细粒度的，而不是混合过多的方法，职责单一</p>\n<h2 id=\"扩展式设计的一般过程：\"><a href=\"#扩展式设计的一般过程：\" class=\"headerlink\" title=\"扩展式设计的一般过程：\"></a>扩展式设计的一般过程：</h2><ol>\n<li>分离职责各司其职：关注点分离<ul>\n<li>向上分离：继承</li>\n<li>向外分离：组合</li>\n</ul>\n</li>\n<li>统一接口：<ul>\n<li>提炼接口，提供多态</li>\n<li>面向接口编程</li>\n</ul>\n</li>\n<li>引用接口预留空白<ul>\n<li>依赖注入</li>\n</ul>\n</li>\n</ol>\n<p>以一个事务为例子展示扩展式设计的一般过程：</p>\n<p>首先，有一个Service，在方法中业务逻辑与JDBC事务粘合在一起：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> DatabasePool dbPool;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribTrainings</span><span class=\"params\">(List&lt;Training&gt; trainings, </div><div class=\"line\">                                  Customer customer)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 初始化方法</span></div><div class=\"line\">      \tConnection c = <span class=\"keyword\">null</span>;</div><div class=\"line\">        PreparedStatement ps = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Statement s = <span class=\"keyword\">null</span>;</div><div class=\"line\">        ResultSet rs = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> transactionState = <span class=\"keyword\">false</span>;</div><div class=\"line\">      </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 开启事务 </span></div><div class=\"line\">            s = c.createStatement();</div><div class=\"line\">            transactionState = c.getAutoCommit();</div><div class=\"line\">            c.setAutoCommit(<span class=\"keyword\">false</span>);</div><div class=\"line\">          </div><div class=\"line\">          \t<span class=\"comment\">// 业务操作</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (Training training : trainings) &#123;</div><div class=\"line\">                addTrainingItem(customer, training);</div><div class=\"line\">            &#125;</div><div class=\"line\">            addOrder(customer, trainings);</div><div class=\"line\">            </div><div class=\"line\">          \t<span class=\"comment\">// 提交事务</span></div><div class=\"line\">          \tc.commit();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 回滚</span></div><div class=\"line\">            c.rollback();</div><div class=\"line\">          </div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 关闭操作</span></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                c.setAutoCommit(transactionState);</div><div class=\"line\">                dbPool.release(c);</div><div class=\"line\">                <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>) s.close();</div><div class=\"line\">                <span class=\"keyword\">if</span> (ps != <span class=\"keyword\">null</span>) ps.close();</div><div class=\"line\">                <span class=\"keyword\">if</span> (rs != <span class=\"keyword\">null</span>) rs.close();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException ignored) &#123;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addOrder</span><span class=\"params\">(Customer customer, List&lt;Training&gt; trainings)</span> </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addTrainingItem</span><span class=\"params\">(Customer customer, Training training)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一步在原始代码上分段并添加注释后代码如上所示。对每段代码提取方法，向上抽象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> DatabasePool dbPool;</div><div class=\"line\">    <span class=\"keyword\">private</span> Connection connection;</div><div class=\"line\">    <span class=\"keyword\">private</span> PreparedStatement preparedStatement;</div><div class=\"line\">    <span class=\"keyword\">private</span> Statement statement;</div><div class=\"line\">    <span class=\"keyword\">private</span> ResultSet resultSet;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> transactionState;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        setup();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            beginTransaction();</div><div class=\"line\">            <span class=\"comment\">// 留白一个具体的业务的实现:</span></div><div class=\"line\">            <span class=\"comment\">//      1. (模板方法)继承-&gt;钩子方法</span></div><div class=\"line\">            <span class=\"comment\">//      2. (委派)传递一个方法(方法接口)</span></div><div class=\"line\">            commitTransaction();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">            rollbackTransaction();</div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            teardown();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rollbackTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        connection.rollback();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        connection = <span class=\"keyword\">null</span>;</div><div class=\"line\">        preparedStatement = <span class=\"keyword\">null</span>;</div><div class=\"line\">        statement = <span class=\"keyword\">null</span>;</div><div class=\"line\">        resultSet = <span class=\"keyword\">null</span>;</div><div class=\"line\">        transactionState = <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">teardown</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            connection.setAutoCommit(transactionState);</div><div class=\"line\">            dbPool.release(connection);</div><div class=\"line\">            <span class=\"keyword\">if</span> (statement != <span class=\"keyword\">null</span>) statement.close();</div><div class=\"line\">            <span class=\"keyword\">if</span> (preparedStatement != <span class=\"keyword\">null</span>) preparedStatement.close();</div><div class=\"line\">            <span class=\"keyword\">if</span> (resultSet != <span class=\"keyword\">null</span>) resultSet.close();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException ignored) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">commitTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        connection.commit();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">beginTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        statement = connection.createStatement();</div><div class=\"line\">        transactionState = connection.getAutoCommit();</div><div class=\"line\">        connection.setAutoCommit(<span class=\"keyword\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Command</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在提炼出了一个本地事务的基本控制模板，实现了事务控制与业务逻辑控制基本分离。</p>\n<p>继续提炼事务控制类的接口，用于横向扩展继承使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command command)</span> <span class=\"keyword\">throws</span> SQLException</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalTransactionScope</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">  \t<span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command action)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        setup();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            beginTransaction();</div><div class=\"line\">            action.execute();  <span class=\"comment\">// 具体的业务逻辑</span></div><div class=\"line\">            commitTransaction();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException sqlx) &#123;</div><div class=\"line\">            rollbackTransaction();</div><div class=\"line\">            <span class=\"keyword\">throw</span> sqlx;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            teardown();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DistructedTransactionScope</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionScope</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">using</span><span class=\"params\">(Command command)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">      </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用方通过接口留白，实现依赖注入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> TransactionScope transactionScope;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTransactionScope</span><span class=\"params\">(TransactionScope transactionScope)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.transactionScope = transactionScope;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribTrainings</span><span class=\"params\">(List&lt;Training&gt; trainings, </div><div class=\"line\">                                  Customer customer)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</div><div class=\"line\">        transactionScope.using(() -&gt; &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (Training training : trainings) &#123;</div><div class=\"line\">                    addTrainingItem(customer, training);</div><div class=\"line\">                &#125;</div><div class=\"line\">                addOrder(customer, trainings);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"迪米特法则——合理的封装","date":"2016-10-22T10:55:36.000Z","_content":"\n## 背景\n\n以服务员，客户，钱包为载体，模拟一个付款过程，阐述不恰当的封装行为。\n\n说明合理封装的一般过程以及不合理封装所表现的一般形式，介绍迪米特法则相关的基本内容，遵循迪米特法则对问题代码进行重构。\n\n## 看似没有问题的问题\n\n先看一个简单代码，分别描述钱包、客户、服务员：\n\n```java\npublic class Wallet {\n    private double value;\n     public double getTotalMoney() {\n        return value;\n    }\n    public void setTotalMoney(double newValue) {\n        value = newValue;\n    }\n    public void addMoney(double deposit) {\n        value += deposit;\n    }\n    public void subtractMoney(double debit) {\n        value -= debit;\n    }\n\t// 省略其它字段，方法\n}\n\npublic class Customer {\n    private Wallet myWallet;\n\t// 省略其它字段，方法\n}\n\npublic class Paperboy {\n  private Customer myCustomer;\n  public void pay(double payment) {\n    Wallet theWallet = myCustomer.getWallet();\n    if (theWallet.getTotalMoney() > payment) {\n        theWallet.subtractMoney(payment);\n    } else {\n        //money not enough\n    }\n  }\n}\n```\n一眼看过去，没毛病。几个基本的简单类在Paperboy的pay方法中实现了简单的业务逻辑，但翻译成“人类语言”就有点问题了：\n\n业务的第一步造作：通过客户获取其钱包。\n\n等等这样真的好吗?现实生活中仿佛讲不通啊，程序设计中其实违反了迪米特法则。\n\n听到迪米特法则那一瞬间，我想到的是各种设计模式概念，尴尬的是就是想不起迪米特到底是个啥!\n\n## 迪米特法则\n\n迪米特法则（最小知识法则，强调专注性）：\n\n任何一个对象或者方法，它应该只能调用下列对象：\n\n- 该对象本身和对象的属性\n- 作为参数传进方法的对象\n- 在方法内创建的对象\n\n这下好像清晰多了，其实再通俗一点上面的代码就是违反了**封装**的原则。\n\n**合理的封装分为两步**：\n\n1. **分辨职责**\n   1. 依据：数据与行为应该封装在一起（信息专家模式）\n   2. 过程：职责操作哪些数据，数据在哪个（些）类，进而确定职责在哪个类\n2. 判别哪些是实现细节，哪些是可以**公开的接口**，以保证对**细节的合理隐藏**\n\n**不良封装造成的结果**：Feature Envy（依恋情结）\n\n**不良封装可能的代码样式**：\n\n```java\nobj1.obj1_fun().obj2_fun();\n```\n类似链式的方法调用，但方法返回的是不同对象，这时候的代码很有可能是不良封装，违反迪米特法则了。\n\n## 问题的解决\n\n上面代码良好的封装示例：\n\n```java\npublic class Customer {\n    private Wallet myWallet;\n\n    public void pay(float payment) {\n        Wallet theWallet = myWallet;\n        if (theWallet.getTotalMoney() > payment) {\n            theWallet.subtractMoney(payment);\n        } else {\n            //money not enough\n        }\n    }\n}\n\npublic class Paperboy {\n    private Customer myCustomer;\n\n    public void pay(float payment) {\n        myCustomer.pay(payment);\n    }\n\n}\n```\n","source":"_posts/迪米特法则——合理的封装.md","raw":"---\ntitle: 迪米特法则——合理的封装\ndate: 2016-10-22 18:55:36\ntags: \n  - Java\n  - 设计模式\ncategories: 设计模式\n---\n\n## 背景\n\n以服务员，客户，钱包为载体，模拟一个付款过程，阐述不恰当的封装行为。\n\n说明合理封装的一般过程以及不合理封装所表现的一般形式，介绍迪米特法则相关的基本内容，遵循迪米特法则对问题代码进行重构。\n\n## 看似没有问题的问题\n\n先看一个简单代码，分别描述钱包、客户、服务员：\n\n```java\npublic class Wallet {\n    private double value;\n     public double getTotalMoney() {\n        return value;\n    }\n    public void setTotalMoney(double newValue) {\n        value = newValue;\n    }\n    public void addMoney(double deposit) {\n        value += deposit;\n    }\n    public void subtractMoney(double debit) {\n        value -= debit;\n    }\n\t// 省略其它字段，方法\n}\n\npublic class Customer {\n    private Wallet myWallet;\n\t// 省略其它字段，方法\n}\n\npublic class Paperboy {\n  private Customer myCustomer;\n  public void pay(double payment) {\n    Wallet theWallet = myCustomer.getWallet();\n    if (theWallet.getTotalMoney() > payment) {\n        theWallet.subtractMoney(payment);\n    } else {\n        //money not enough\n    }\n  }\n}\n```\n一眼看过去，没毛病。几个基本的简单类在Paperboy的pay方法中实现了简单的业务逻辑，但翻译成“人类语言”就有点问题了：\n\n业务的第一步造作：通过客户获取其钱包。\n\n等等这样真的好吗?现实生活中仿佛讲不通啊，程序设计中其实违反了迪米特法则。\n\n听到迪米特法则那一瞬间，我想到的是各种设计模式概念，尴尬的是就是想不起迪米特到底是个啥!\n\n## 迪米特法则\n\n迪米特法则（最小知识法则，强调专注性）：\n\n任何一个对象或者方法，它应该只能调用下列对象：\n\n- 该对象本身和对象的属性\n- 作为参数传进方法的对象\n- 在方法内创建的对象\n\n这下好像清晰多了，其实再通俗一点上面的代码就是违反了**封装**的原则。\n\n**合理的封装分为两步**：\n\n1. **分辨职责**\n   1. 依据：数据与行为应该封装在一起（信息专家模式）\n   2. 过程：职责操作哪些数据，数据在哪个（些）类，进而确定职责在哪个类\n2. 判别哪些是实现细节，哪些是可以**公开的接口**，以保证对**细节的合理隐藏**\n\n**不良封装造成的结果**：Feature Envy（依恋情结）\n\n**不良封装可能的代码样式**：\n\n```java\nobj1.obj1_fun().obj2_fun();\n```\n类似链式的方法调用，但方法返回的是不同对象，这时候的代码很有可能是不良封装，违反迪米特法则了。\n\n## 问题的解决\n\n上面代码良好的封装示例：\n\n```java\npublic class Customer {\n    private Wallet myWallet;\n\n    public void pay(float payment) {\n        Wallet theWallet = myWallet;\n        if (theWallet.getTotalMoney() > payment) {\n            theWallet.subtractMoney(payment);\n        } else {\n            //money not enough\n        }\n    }\n}\n\npublic class Paperboy {\n    private Customer myCustomer;\n\n    public void pay(float payment) {\n        myCustomer.pay(payment);\n    }\n\n}\n```\n","slug":"迪米特法则——合理的封装","published":1,"updated":"2017-01-07T06:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2sz0059d82ep584u5vv","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>以服务员，客户，钱包为载体，模拟一个付款过程，阐述不恰当的封装行为。</p>\n<p>说明合理封装的一般过程以及不合理封装所表现的一般形式，介绍迪米特法则相关的基本内容，遵循迪米特法则对问题代码进行重构。</p>\n<h2 id=\"看似没有问题的问题\"><a href=\"#看似没有问题的问题\" class=\"headerlink\" title=\"看似没有问题的问题\"></a>看似没有问题的问题</h2><p>先看一个简单代码，分别描述钱包、客户、服务员：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wallet</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> value;</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTotalMoney</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTotalMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> newValue)</span> </span>&#123;</div><div class=\"line\">        value = newValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> deposit)</span> </span>&#123;</div><div class=\"line\">        value += deposit;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subtractMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> debit)</span> </span>&#123;</div><div class=\"line\">        value -= debit;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 省略其它字段，方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Wallet myWallet;</div><div class=\"line\">\t<span class=\"comment\">// 省略其它字段，方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Paperboy</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> Customer myCustomer;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">double</span> payment)</span> </span>&#123;</div><div class=\"line\">    Wallet theWallet = myCustomer.getWallet();</div><div class=\"line\">    <span class=\"keyword\">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</div><div class=\"line\">        theWallet.subtractMoney(payment);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//money not enough</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一眼看过去，没毛病。几个基本的简单类在Paperboy的pay方法中实现了简单的业务逻辑，但翻译成“人类语言”就有点问题了：</p>\n<p>业务的第一步造作：通过客户获取其钱包。</p>\n<p>等等这样真的好吗?现实生活中仿佛讲不通啊，程序设计中其实违反了迪米特法则。</p>\n<p>听到迪米特法则那一瞬间，我想到的是各种设计模式概念，尴尬的是就是想不起迪米特到底是个啥!</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>迪米特法则（最小知识法则，强调专注性）：</p>\n<p>任何一个对象或者方法，它应该只能调用下列对象：</p>\n<ul>\n<li>该对象本身和对象的属性</li>\n<li>作为参数传进方法的对象</li>\n<li>在方法内创建的对象</li>\n</ul>\n<p>这下好像清晰多了，其实再通俗一点上面的代码就是违反了<strong>封装</strong>的原则。</p>\n<p><strong>合理的封装分为两步</strong>：</p>\n<ol>\n<li><strong>分辨职责</strong><ol>\n<li>依据：数据与行为应该封装在一起（信息专家模式）</li>\n<li>过程：职责操作哪些数据，数据在哪个（些）类，进而确定职责在哪个类</li>\n</ol>\n</li>\n<li>判别哪些是实现细节，哪些是可以<strong>公开的接口</strong>，以保证对<strong>细节的合理隐藏</strong></li>\n</ol>\n<p><strong>不良封装造成的结果</strong>：Feature Envy（依恋情结）</p>\n<p><strong>不良封装可能的代码样式</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj1.obj1_fun().obj2_fun();</div></pre></td></tr></table></figure>\n<p>类似链式的方法调用，但方法返回的是不同对象，这时候的代码很有可能是不良封装，违反迪米特法则了。</p>\n<h2 id=\"问题的解决\"><a href=\"#问题的解决\" class=\"headerlink\" title=\"问题的解决\"></a>问题的解决</h2><p>上面代码良好的封装示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Wallet myWallet;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">float</span> payment)</span> </span>&#123;</div><div class=\"line\">        Wallet theWallet = myWallet;</div><div class=\"line\">        <span class=\"keyword\">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</div><div class=\"line\">            theWallet.subtractMoney(payment);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//money not enough</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Paperboy</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Customer myCustomer;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">float</span> payment)</span> </span>&#123;</div><div class=\"line\">        myCustomer.pay(payment);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>以服务员，客户，钱包为载体，模拟一个付款过程，阐述不恰当的封装行为。</p>\n<p>说明合理封装的一般过程以及不合理封装所表现的一般形式，介绍迪米特法则相关的基本内容，遵循迪米特法则对问题代码进行重构。</p>\n<h2 id=\"看似没有问题的问题\"><a href=\"#看似没有问题的问题\" class=\"headerlink\" title=\"看似没有问题的问题\"></a>看似没有问题的问题</h2><p>先看一个简单代码，分别描述钱包、客户、服务员：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wallet</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> value;</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTotalMoney</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTotalMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> newValue)</span> </span>&#123;</div><div class=\"line\">        value = newValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> deposit)</span> </span>&#123;</div><div class=\"line\">        value += deposit;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subtractMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> debit)</span> </span>&#123;</div><div class=\"line\">        value -= debit;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 省略其它字段，方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Wallet myWallet;</div><div class=\"line\">\t<span class=\"comment\">// 省略其它字段，方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Paperboy</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> Customer myCustomer;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">double</span> payment)</span> </span>&#123;</div><div class=\"line\">    Wallet theWallet = myCustomer.getWallet();</div><div class=\"line\">    <span class=\"keyword\">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</div><div class=\"line\">        theWallet.subtractMoney(payment);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//money not enough</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一眼看过去，没毛病。几个基本的简单类在Paperboy的pay方法中实现了简单的业务逻辑，但翻译成“人类语言”就有点问题了：</p>\n<p>业务的第一步造作：通过客户获取其钱包。</p>\n<p>等等这样真的好吗?现实生活中仿佛讲不通啊，程序设计中其实违反了迪米特法则。</p>\n<p>听到迪米特法则那一瞬间，我想到的是各种设计模式概念，尴尬的是就是想不起迪米特到底是个啥!</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>迪米特法则（最小知识法则，强调专注性）：</p>\n<p>任何一个对象或者方法，它应该只能调用下列对象：</p>\n<ul>\n<li>该对象本身和对象的属性</li>\n<li>作为参数传进方法的对象</li>\n<li>在方法内创建的对象</li>\n</ul>\n<p>这下好像清晰多了，其实再通俗一点上面的代码就是违反了<strong>封装</strong>的原则。</p>\n<p><strong>合理的封装分为两步</strong>：</p>\n<ol>\n<li><strong>分辨职责</strong><ol>\n<li>依据：数据与行为应该封装在一起（信息专家模式）</li>\n<li>过程：职责操作哪些数据，数据在哪个（些）类，进而确定职责在哪个类</li>\n</ol>\n</li>\n<li>判别哪些是实现细节，哪些是可以<strong>公开的接口</strong>，以保证对<strong>细节的合理隐藏</strong></li>\n</ol>\n<p><strong>不良封装造成的结果</strong>：Feature Envy（依恋情结）</p>\n<p><strong>不良封装可能的代码样式</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj1.obj1_fun().obj2_fun();</div></pre></td></tr></table></figure>\n<p>类似链式的方法调用，但方法返回的是不同对象，这时候的代码很有可能是不良封装，违反迪米特法则了。</p>\n<h2 id=\"问题的解决\"><a href=\"#问题的解决\" class=\"headerlink\" title=\"问题的解决\"></a>问题的解决</h2><p>上面代码良好的封装示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Wallet myWallet;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">float</span> payment)</span> </span>&#123;</div><div class=\"line\">        Wallet theWallet = myWallet;</div><div class=\"line\">        <span class=\"keyword\">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</div><div class=\"line\">            theWallet.subtractMoney(payment);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//money not enough</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Paperboy</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Customer myCustomer;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">float</span> payment)</span> </span>&#123;</div><div class=\"line\">        myCustomer.pay(payment);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"责任链模式","date":"2017-01-15T18:35:47.000Z","_content":"\n> 当你想要让一个以上的对象有机会能够处理某个请求的时候,就是用责任链模式(Chain of Responsibility Pattern).\n>\n> ——《Head First 设计模式》\n\n所属类别:行为型模式。\n\n典型使用场景：一个事件或请求需要多步判断/处理\n\n针对这样的场景直接编码会造成哪些问题？\n1. 多步的判断、处理集中在一起，违反单一职责\n2. 事件的处理依赖具体的过程，而不是行为或接口，违反依赖倒置\n3. 维护期需要新的处理过程时，必须修改原有代码，违反开闭原则\n\n首先，可以对具体在一起的业务代码代码进行了拆分，使业务逻辑的处理分散到多个模块；\n\n其次，为了统一整个请求处理逻辑，抽象接口，整个请求的处理过程对外只需要暴露入口。\n\n实现以上过程的UML类图如下：\n\n![责任链模式.png](https://ooo.0o0.ooo/2017/01/04/586ceaf92cc2c.png)\n\n责任链模式处理请求的一般过程：\n\n![责任链模式处理流程 (1).png](https://ooo.0o0.ooo/2017/01/04/586cef1ec3144.png)\n\n责任链模式的优点：\n\n1. 对客户端来说并不能感知到责任链的存在（迪米特法则）；\n2. 整个责任链的配置过程可以使用配置方式组装，后续处理节点的调整可以修改配置（开闭原则）；\n3. 请求发送者与处理者的解耦\n4. 简化了请求处理过程（单一职责）\n\n典型的责任链模式使用场景：JavaEE Servlet Filter\n\n","source":"_posts/责任链模式.md","raw":"---\ntitle: 责任链模式\ndate: 2017-01-16 02:35:47\ntags:\n - 设计模式\n - Java\ncategory: 设计模式\n---\n\n> 当你想要让一个以上的对象有机会能够处理某个请求的时候,就是用责任链模式(Chain of Responsibility Pattern).\n>\n> ——《Head First 设计模式》\n\n所属类别:行为型模式。\n\n典型使用场景：一个事件或请求需要多步判断/处理\n\n针对这样的场景直接编码会造成哪些问题？\n1. 多步的判断、处理集中在一起，违反单一职责\n2. 事件的处理依赖具体的过程，而不是行为或接口，违反依赖倒置\n3. 维护期需要新的处理过程时，必须修改原有代码，违反开闭原则\n\n首先，可以对具体在一起的业务代码代码进行了拆分，使业务逻辑的处理分散到多个模块；\n\n其次，为了统一整个请求处理逻辑，抽象接口，整个请求的处理过程对外只需要暴露入口。\n\n实现以上过程的UML类图如下：\n\n![责任链模式.png](https://ooo.0o0.ooo/2017/01/04/586ceaf92cc2c.png)\n\n责任链模式处理请求的一般过程：\n\n![责任链模式处理流程 (1).png](https://ooo.0o0.ooo/2017/01/04/586cef1ec3144.png)\n\n责任链模式的优点：\n\n1. 对客户端来说并不能感知到责任链的存在（迪米特法则）；\n2. 整个责任链的配置过程可以使用配置方式组装，后续处理节点的调整可以修改配置（开闭原则）；\n3. 请求发送者与处理者的解耦\n4. 简化了请求处理过程（单一职责）\n\n典型的责任链模式使用场景：JavaEE Servlet Filter\n\n","slug":"责任链模式","published":1,"updated":"2017-01-15T18:37:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjaxzl2t2005dd82eg3gxpn4q","content":"<blockquote>\n<p>当你想要让一个以上的对象有机会能够处理某个请求的时候,就是用责任链模式(Chain of Responsibility Pattern).</p>\n<p>——《Head First 设计模式》</p>\n</blockquote>\n<p>所属类别:行为型模式。</p>\n<p>典型使用场景：一个事件或请求需要多步判断/处理</p>\n<p>针对这样的场景直接编码会造成哪些问题？</p>\n<ol>\n<li>多步的判断、处理集中在一起，违反单一职责</li>\n<li>事件的处理依赖具体的过程，而不是行为或接口，违反依赖倒置</li>\n<li>维护期需要新的处理过程时，必须修改原有代码，违反开闭原则</li>\n</ol>\n<p>首先，可以对具体在一起的业务代码代码进行了拆分，使业务逻辑的处理分散到多个模块；</p>\n<p>其次，为了统一整个请求处理逻辑，抽象接口，整个请求的处理过程对外只需要暴露入口。</p>\n<p>实现以上过程的UML类图如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/04/586ceaf92cc2c.png\" alt=\"责任链模式.png\"></p>\n<p>责任链模式处理请求的一般过程：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/04/586cef1ec3144.png\" alt=\"责任链模式处理流程 (1).png\"></p>\n<p>责任链模式的优点：</p>\n<ol>\n<li>对客户端来说并不能感知到责任链的存在（迪米特法则）；</li>\n<li>整个责任链的配置过程可以使用配置方式组装，后续处理节点的调整可以修改配置（开闭原则）；</li>\n<li>请求发送者与处理者的解耦</li>\n<li>简化了请求处理过程（单一职责）</li>\n</ol>\n<p>典型的责任链模式使用场景：JavaEE Servlet Filter</p>\n","excerpt":"","more":"<blockquote>\n<p>当你想要让一个以上的对象有机会能够处理某个请求的时候,就是用责任链模式(Chain of Responsibility Pattern).</p>\n<p>——《Head First 设计模式》</p>\n</blockquote>\n<p>所属类别:行为型模式。</p>\n<p>典型使用场景：一个事件或请求需要多步判断/处理</p>\n<p>针对这样的场景直接编码会造成哪些问题？</p>\n<ol>\n<li>多步的判断、处理集中在一起，违反单一职责</li>\n<li>事件的处理依赖具体的过程，而不是行为或接口，违反依赖倒置</li>\n<li>维护期需要新的处理过程时，必须修改原有代码，违反开闭原则</li>\n</ol>\n<p>首先，可以对具体在一起的业务代码代码进行了拆分，使业务逻辑的处理分散到多个模块；</p>\n<p>其次，为了统一整个请求处理逻辑，抽象接口，整个请求的处理过程对外只需要暴露入口。</p>\n<p>实现以上过程的UML类图如下：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/04/586ceaf92cc2c.png\" alt=\"责任链模式.png\"></p>\n<p>责任链模式处理请求的一般过程：</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/01/04/586cef1ec3144.png\" alt=\"责任链模式处理流程 (1).png\"></p>\n<p>责任链模式的优点：</p>\n<ol>\n<li>对客户端来说并不能感知到责任链的存在（迪米特法则）；</li>\n<li>整个责任链的配置过程可以使用配置方式组装，后续处理节点的调整可以修改配置（开闭原则）；</li>\n<li>请求发送者与处理者的解耦</li>\n<li>简化了请求处理过程（单一职责）</li>\n</ol>\n<p>典型的责任链模式使用场景：JavaEE Servlet Filter</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjaxzl2o90000d82eucrbnpf5","category_id":"cjaxzl2oq0005d82elvechmhw","_id":"cjaxzl2p4000hd82euoj2w51y"},{"post_id":"cjaxzl2oh0002d82epkykm5oq","category_id":"cjaxzl2p0000cd82egqwo8hmp","_id":"cjaxzl2pe000pd82ewotcvlbm"},{"post_id":"cjaxzl2or0006d82e2nvgx6jb","category_id":"cjaxzl2p7000ld82e7826zupe","_id":"cjaxzl2pm000zd82esjojwvm8"},{"post_id":"cjaxzl2ph000td82e6ha278m0","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2pp0014d82ex9n0h17v"},{"post_id":"cjaxzl2ov0008d82ek8y4dijm","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2pr0017d82ebwlislk3"},{"post_id":"cjaxzl2pn0012d82e1xjqrg0d","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2pt001bd82ekpbu4xr2"},{"post_id":"cjaxzl2oy000bd82ez9ccysie","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2pv001dd82e5b1gi6v4"},{"post_id":"cjaxzl2pp0015d82e96clprif","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2px001id82eutqkj4nm"},{"post_id":"cjaxzl2p2000fd82ehhut72jc","category_id":"cjaxzl2pr0018d82e1kgv9z3j","_id":"cjaxzl2py001ld82e8j1aj0ft"},{"post_id":"cjaxzl2p4000id82ewpn1xrcb","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2q3001qd82e43g4o4sg"},{"post_id":"cjaxzl2p9000md82e0o2w7ybk","category_id":"cjaxzl2pr0018d82e1kgv9z3j","_id":"cjaxzl2qc001wd82ef6dnxk6v"},{"post_id":"cjaxzl2pd000od82epd518p2e","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2qi0023d82elg16uh6j"},{"post_id":"cjaxzl2qc001yd82et1vz5d3u","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2qk0028d82efdk82utc"},{"post_id":"cjaxzl2pk000wd82eswhuy6sr","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2qo002dd82ef4nt523s"},{"post_id":"cjaxzl2ps0019d82e108qjefg","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2qu002id82e025wv2ag"},{"post_id":"cjaxzl2qr002gd82epuxmi7iu","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2qv002nd82ecpxn42qe"},{"post_id":"cjaxzl2pt001cd82ex81xuujq","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2r1002sd82ebhq041zu"},{"post_id":"cjaxzl2qt002hd82e63kikgmh","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2r3002ud82e2z2iqjq7"},{"post_id":"cjaxzl2pv001fd82ehxsitxog","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2r8002yd82ejsam5sjn"},{"post_id":"cjaxzl2r1002td82e9gf8nwa1","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2rb0031d82eubzg7zoz"},{"post_id":"cjaxzl2px001jd82epd1hlul8","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2re0036d82ewqv7bd7f"},{"post_id":"cjaxzl2r3002vd82ek1r4ao13","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2rf0039d82e9h2stitp"},{"post_id":"cjaxzl2r90030d82eijwsipvj","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2ri003ed82eb7cr8ew2"},{"post_id":"cjaxzl2pz001nd82ef6cqi5lp","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2rj003hd82eld31me1n"},{"post_id":"cjaxzl2rc0033d82exdtw77y5","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2rk003md82evndcogvk"},{"post_id":"cjaxzl2q0001pd82eet6sz7vw","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2ro003pd82e13tl04fb"},{"post_id":"cjaxzl2ri003gd82enb1hhv7k","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2rp003td82euq5oafuk"},{"post_id":"cjaxzl2q3001rd82ewehp0b7g","category_id":"cjaxzl2qd001zd82eqiicv14y","_id":"cjaxzl2rs003xd82enb5oeg1o"},{"post_id":"cjaxzl2q7001vd82e4m5zgbgw","category_id":"cjaxzl2rk003kd82en6z4y726","_id":"cjaxzl2ru0041d82e3bql2ndf"},{"post_id":"cjaxzl2qg0022d82e7ss7z2kb","category_id":"cjaxzl2rk003kd82en6z4y726","_id":"cjaxzl2s70047d82etirv2j28"},{"post_id":"cjaxzl2ru0044d82e8drks4um","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2sb004cd82erjln9thu"},{"post_id":"cjaxzl2qi0025d82egvjps2ee","category_id":"cjaxzl2ru0040d82eei99mcqs","_id":"cjaxzl2se004fd82efqblse6x"},{"post_id":"cjaxzl2qk002ad82eel2obgdp","category_id":"cjaxzl2ru0040d82eei99mcqs","_id":"cjaxzl2sk004md82eyasxt0nw"},{"post_id":"cjaxzl2sf004jd82equqb8dew","category_id":"cjaxzl2p0000cd82egqwo8hmp","_id":"cjaxzl2so004rd82e6c42h55z"},{"post_id":"cjaxzl2qn002cd82ex9f74av8","category_id":"cjaxzl2ru0040d82eei99mcqs","_id":"cjaxzl2sq004ud82e0zj3t9kn"},{"post_id":"cjaxzl2sl004qd82e2yd9ezhq","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2st004zd82ew9o8hfn5"},{"post_id":"cjaxzl2so004td82e3q8hfm91","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2sv0052d82ew1rehv4v"},{"post_id":"cjaxzl2qv002md82e2mwfozzw","category_id":"cjaxzl2sk004nd82e0b0vkops","_id":"cjaxzl2sy0057d82eo9ftxnuo"},{"post_id":"cjaxzl2sr004xd82ept2un5ss","category_id":"cjaxzl2pg000sd82e6us0l4m6","_id":"cjaxzl2t1005ad82eh61iiiki"},{"post_id":"cjaxzl2qw002pd82eenk4ocs5","category_id":"cjaxzl2ru0040d82eei99mcqs","_id":"cjaxzl2t5005fd82ekxc9lcss"},{"post_id":"cjaxzl2re0038d82ekv1o59hj","category_id":"cjaxzl2sx0056d82eq1u7990u","_id":"cjaxzl2t6005jd82e37bjauw3"},{"post_id":"cjaxzl2rg003bd82ezpp9wqgh","category_id":"cjaxzl2t4005ed82e3adqayw0","_id":"cjaxzl2t8005od82eucutbq82"},{"post_id":"cjaxzl2rj003jd82e1yb0nzjb","category_id":"cjaxzl2t4005ed82e3adqayw0","_id":"cjaxzl2t9005td82etaesgs2m"},{"post_id":"cjaxzl2rm003od82e3d2iasyp","category_id":"cjaxzl2t8005pd82eb6ld9afp","_id":"cjaxzl2ta005yd82enhf4kc60"},{"post_id":"cjaxzl2ro003rd82eu428ew15","category_id":"cjaxzl2sx0056d82eq1u7990u","_id":"cjaxzl2tb0063d82ensygy3bh"},{"post_id":"cjaxzl2rp003wd82euczj48go","category_id":"cjaxzl2t4005ed82e3adqayw0","_id":"cjaxzl2te0068d82efu3clqxp"},{"post_id":"cjaxzl2rs003zd82edxmnxwji","category_id":"cjaxzl2tb0064d82epyvzmnp8","_id":"cjaxzl2tf006dd82e1tuyrax0"},{"post_id":"cjaxzl2rw0046d82ennbnalmr","category_id":"cjaxzl2t8005pd82eb6ld9afp","_id":"cjaxzl2tf006id82etdy0s2dv"},{"post_id":"cjaxzl2s8004bd82eylsw548g","category_id":"cjaxzl2tb0064d82epyvzmnp8","_id":"cjaxzl2ti006nd82e0e7yurxa"},{"post_id":"cjaxzl2sc004ed82e15g8gz7x","category_id":"cjaxzl2tb0064d82epyvzmnp8","_id":"cjaxzl2tk006sd82e0xlxzeja"},{"post_id":"cjaxzl2si004ld82ex5ktc4y1","category_id":"cjaxzl2tb0064d82epyvzmnp8","_id":"cjaxzl2tm006xd82e0ut2lq8z"},{"post_id":"cjaxzl2su0051d82ew5g0zhwj","category_id":"cjaxzl2tb0064d82epyvzmnp8","_id":"cjaxzl2tn0072d82ey1i52emi"},{"post_id":"cjaxzl2sv0055d82enmreo5p6","category_id":"cjaxzl2tb0064d82epyvzmnp8","_id":"cjaxzl2to0077d82eju9hhk3t"},{"post_id":"cjaxzl2sz0059d82ep584u5vv","category_id":"cjaxzl2tb0064d82epyvzmnp8","_id":"cjaxzl2tp007bd82e2t05azcw"},{"post_id":"cjaxzl2t2005dd82eg3gxpn4q","category_id":"cjaxzl2tb0064d82epyvzmnp8","_id":"cjaxzl2tq007ed82e4fslff6o"}],"PostTag":[{"post_id":"cjaxzl2o90000d82eucrbnpf5","tag_id":"cjaxzl2ol0004d82evyz8aw69","_id":"cjaxzl2p1000ed82eenidm42t"},{"post_id":"cjaxzl2or0006d82e2nvgx6jb","tag_id":"cjaxzl2oy000ad82eeqo4uuaq","_id":"cjaxzl2pj000ud82eajs3kwsn"},{"post_id":"cjaxzl2or0006d82e2nvgx6jb","tag_id":"cjaxzl2p6000jd82et7xv0bg2","_id":"cjaxzl2pl000xd82es1x81kho"},{"post_id":"cjaxzl2ov0008d82ek8y4dijm","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2pp0013d82ea022vgss"},{"post_id":"cjaxzl2pp0015d82e96clprif","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2pt001ad82en9xf2co7"},{"post_id":"cjaxzl2oy000bd82ez9ccysie","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2px001hd82ev1s58r47"},{"post_id":"cjaxzl2oy000bd82ez9ccysie","tag_id":"cjaxzl2pr0016d82eewtk14gm","_id":"cjaxzl2py001kd82e6d73nf40"},{"post_id":"cjaxzl2p2000fd82ehhut72jc","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2q6001ud82eozx2y9hq"},{"post_id":"cjaxzl2p2000fd82ehhut72jc","tag_id":"cjaxzl2py001md82e0d3wmgw2","_id":"cjaxzl2qc001xd82ehymin7gn"},{"post_id":"cjaxzl2q7001vd82e4m5zgbgw","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2qg0021d82e34kc1x4d"},{"post_id":"cjaxzl2qc001yd82et1vz5d3u","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2qi0024d82e5npewsl0"},{"post_id":"cjaxzl2p4000id82ewpn1xrcb","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2qk0029d82e7tojdbd3"},{"post_id":"cjaxzl2p4000id82ewpn1xrcb","tag_id":"cjaxzl2pr0016d82eewtk14gm","_id":"cjaxzl2qn002bd82e36tdbn46"},{"post_id":"cjaxzl2p9000md82e0o2w7ybk","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2qu002ld82eeufp7bh7"},{"post_id":"cjaxzl2p9000md82e0o2w7ybk","tag_id":"cjaxzl2py001md82e0d3wmgw2","_id":"cjaxzl2qv002od82em0wigxit"},{"post_id":"cjaxzl2pd000od82epd518p2e","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2r8002zd82e5eegaeuk"},{"post_id":"cjaxzl2pd000od82epd518p2e","tag_id":"cjaxzl2pr0016d82eewtk14gm","_id":"cjaxzl2rb0032d82eyz614zz3"},{"post_id":"cjaxzl2ph000td82e6ha278m0","tag_id":"cjaxzl2ol0004d82evyz8aw69","_id":"cjaxzl2re0037d82eqpw2nefj"},{"post_id":"cjaxzl2ph000td82e6ha278m0","tag_id":"cjaxzl2py001md82e0d3wmgw2","_id":"cjaxzl2rf003ad82efnszhlyk"},{"post_id":"cjaxzl2ph000td82e6ha278m0","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2ri003fd82euvsn6c6w"},{"post_id":"cjaxzl2pk000wd82eswhuy6sr","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2rj003id82estlc5st0"},{"post_id":"cjaxzl2pk000wd82eswhuy6sr","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2rl003nd82ege7a1luf"},{"post_id":"cjaxzl2ri003gd82enb1hhv7k","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2ro003qd82e34wu2633"},{"post_id":"cjaxzl2ri003gd82enb1hhv7k","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2rp003vd82er4zib90s"},{"post_id":"cjaxzl2pn0012d82e1xjqrg0d","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2rs003yd82e19b7iyd9"},{"post_id":"cjaxzl2pn0012d82e1xjqrg0d","tag_id":"cjaxzl2rh003dd82ekxbgq86i","_id":"cjaxzl2ru0043d82ej4ofb0ab"},{"post_id":"cjaxzl2pn0012d82e1xjqrg0d","tag_id":"cjaxzl2rk003ld82ex9g5aukz","_id":"cjaxzl2rw0045d82e4qgc9emv"},{"post_id":"cjaxzl2ps0019d82e108qjefg","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2s7004ad82ex66xxvw4"},{"post_id":"cjaxzl2ps0019d82e108qjefg","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2sb004dd82etqq70gz1"},{"post_id":"cjaxzl2ru0044d82e8drks4um","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2sf004id82eoexvi55t"},{"post_id":"cjaxzl2pt001cd82ex81xuujq","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2si004kd82e3so7makt"},{"post_id":"cjaxzl2pt001cd82ex81xuujq","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2sl004pd82e7c7v7t5r"},{"post_id":"cjaxzl2pv001fd82ehxsitxog","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2so004sd82e2ltnben6"},{"post_id":"cjaxzl2pv001fd82ehxsitxog","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2sr004wd82e16njzepx"},{"post_id":"cjaxzl2px001jd82epd1hlul8","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2st0050d82e91msth5r"},{"post_id":"cjaxzl2px001jd82epd1hlul8","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2sv0054d82eblvr2mfr"},{"post_id":"cjaxzl2sl004qd82e2yd9ezhq","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2sy0058d82eti9pqh6r"},{"post_id":"cjaxzl2so004td82e3q8hfm91","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2t1005cd82euy6c2hnm"},{"post_id":"cjaxzl2so004td82e3q8hfm91","tag_id":"cjaxzl2py001md82e0d3wmgw2","_id":"cjaxzl2t5005gd82e25j2atxm"},{"post_id":"cjaxzl2pz001nd82ef6cqi5lp","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2t6005id82e0wfkol73"},{"post_id":"cjaxzl2pz001nd82ef6cqi5lp","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2t7005ld82evgy2aab1"},{"post_id":"cjaxzl2sr004xd82ept2un5ss","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2t7005md82e9kd5xtex"},{"post_id":"cjaxzl2q0001pd82eet6sz7vw","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2t8005qd82eakkx54v5"},{"post_id":"cjaxzl2q0001pd82eet6sz7vw","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2t8005rd82e0lji35qu"},{"post_id":"cjaxzl2q3001rd82ewehp0b7g","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2t9005vd82elwt2q0gg"},{"post_id":"cjaxzl2q3001rd82ewehp0b7g","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2t9005wd82egmpioc81"},{"post_id":"cjaxzl2qg0022d82e7ss7z2kb","tag_id":"cjaxzl2rk003ld82ex9g5aukz","_id":"cjaxzl2ta0060d82ei5vdwyhe"},{"post_id":"cjaxzl2qi0025d82egvjps2ee","tag_id":"cjaxzl2t6005hd82eicresaj8","_id":"cjaxzl2tb0061d82et18q228k"},{"post_id":"cjaxzl2qk002ad82eel2obgdp","tag_id":"cjaxzl2t6005hd82eicresaj8","_id":"cjaxzl2tc0065d82ehycdam7p"},{"post_id":"cjaxzl2qn002cd82ex9f74av8","tag_id":"cjaxzl2t6005hd82eicresaj8","_id":"cjaxzl2td0066d82e319nfqs1"},{"post_id":"cjaxzl2qr002gd82epuxmi7iu","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2te0069d82e0v2n19en"},{"post_id":"cjaxzl2qr002gd82epuxmi7iu","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2te006bd82e0b1evi92"},{"post_id":"cjaxzl2qt002hd82e63kikgmh","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2tf006ed82eq95wm4fj"},{"post_id":"cjaxzl2qt002hd82e63kikgmh","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2tf006gd82er9we7v16"},{"post_id":"cjaxzl2qv002md82e2mwfozzw","tag_id":"cjaxzl2td0067d82ett45hddt","_id":"cjaxzl2tg006jd82ene6ezzj1"},{"post_id":"cjaxzl2qv002md82e2mwfozzw","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2tg006ld82exl0m6gnw"},{"post_id":"cjaxzl2qw002pd82eenk4ocs5","tag_id":"cjaxzl2t6005hd82eicresaj8","_id":"cjaxzl2ti006od82ejovjt7te"},{"post_id":"cjaxzl2r1002td82e9gf8nwa1","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2tj006qd82ed8di0gpz"},{"post_id":"cjaxzl2r1002td82e9gf8nwa1","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2tk006td82ewxetiifc"},{"post_id":"cjaxzl2r3002vd82ek1r4ao13","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2tl006vd82e98qbpevj"},{"post_id":"cjaxzl2r3002vd82ek1r4ao13","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2tm006yd82ef6b7gsvy"},{"post_id":"cjaxzl2r90030d82eijwsipvj","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2tm0070d82etvkba7a8"},{"post_id":"cjaxzl2r90030d82eijwsipvj","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2tn0073d82em37zhkjh"},{"post_id":"cjaxzl2rc0033d82exdtw77y5","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2tn0075d82ejwy8c5km"},{"post_id":"cjaxzl2rc0033d82exdtw77y5","tag_id":"cjaxzl2rd0034d82eg36bm5hd","_id":"cjaxzl2tp0078d82eksh1h4jw"},{"post_id":"cjaxzl2re0038d82ekv1o59hj","tag_id":"cjaxzl2tm0071d82ekb7gir1m","_id":"cjaxzl2tp007ad82evmoixtaw"},{"post_id":"cjaxzl2rg003bd82ezpp9wqgh","tag_id":"cjaxzl2tn0076d82eflh9zinr","_id":"cjaxzl2tq007dd82e5532ej18"},{"post_id":"cjaxzl2rj003jd82e1yb0nzjb","tag_id":"cjaxzl2tn0076d82eflh9zinr","_id":"cjaxzl2tr007gd82elyqqtcam"},{"post_id":"cjaxzl2ro003rd82eu428ew15","tag_id":"cjaxzl2tm0071d82ekb7gir1m","_id":"cjaxzl2ts007id82el41tzifv"},{"post_id":"cjaxzl2rp003wd82euczj48go","tag_id":"cjaxzl2tn0076d82eflh9zinr","_id":"cjaxzl2ts007kd82e8delv39e"},{"post_id":"cjaxzl2rs003zd82edxmnxwji","tag_id":"cjaxzl2ts007jd82ezznvgspi","_id":"cjaxzl2tt007md82eulogx563"},{"post_id":"cjaxzl2rs003zd82edxmnxwji","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2tt007nd82e6lk7a981"},{"post_id":"cjaxzl2s8004bd82eylsw548g","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2tt007pd82ehrkm34fa"},{"post_id":"cjaxzl2s8004bd82eylsw548g","tag_id":"cjaxzl2ts007jd82ezznvgspi","_id":"cjaxzl2tt007qd82em6h7wla6"},{"post_id":"cjaxzl2s8004bd82eylsw548g","tag_id":"cjaxzl2rk003ld82ex9g5aukz","_id":"cjaxzl2tu007sd82e0u4ba9pz"},{"post_id":"cjaxzl2sc004ed82e15g8gz7x","tag_id":"cjaxzl2ts007jd82ezznvgspi","_id":"cjaxzl2tu007td82e83l7zhlx"},{"post_id":"cjaxzl2sc004ed82e15g8gz7x","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2tu007vd82e2hl2mtvv"},{"post_id":"cjaxzl2sf004jd82equqb8dew","tag_id":"cjaxzl2tt007rd82e0jlkatm9","_id":"cjaxzl2tu007wd82evyf3f3ku"},{"post_id":"cjaxzl2si004ld82ex5ktc4y1","tag_id":"cjaxzl2ts007jd82ezznvgspi","_id":"cjaxzl2tv007yd82er82b26r6"},{"post_id":"cjaxzl2si004ld82ex5ktc4y1","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2tv007zd82esn8ckctr"},{"post_id":"cjaxzl2su0051d82ew5g0zhwj","tag_id":"cjaxzl2ts007jd82ezznvgspi","_id":"cjaxzl2u80081d82eeif3osf2"},{"post_id":"cjaxzl2sv0055d82enmreo5p6","tag_id":"cjaxzl2ts007jd82ezznvgspi","_id":"cjaxzl2u90083d82el7qjxkgj"},{"post_id":"cjaxzl2sv0055d82enmreo5p6","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2u90084d82eusokmo3n"},{"post_id":"cjaxzl2sz0059d82ep584u5vv","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2u90086d82em7bgj1lu"},{"post_id":"cjaxzl2sz0059d82ep584u5vv","tag_id":"cjaxzl2ts007jd82ezznvgspi","_id":"cjaxzl2u90087d82ejijn1cox"},{"post_id":"cjaxzl2t2005dd82eg3gxpn4q","tag_id":"cjaxzl2ts007jd82ezznvgspi","_id":"cjaxzl2ua0088d82en73pmpnq"},{"post_id":"cjaxzl2t2005dd82eg3gxpn4q","tag_id":"cjaxzl2pg000rd82eakj710qw","_id":"cjaxzl2ub0089d82em8bkzmar"}],"Tag":[{"name":"daily","_id":"cjaxzl2ol0004d82evyz8aw69"},{"name":"HTML","_id":"cjaxzl2oy000ad82eeqo4uuaq"},{"name":"CSS","_id":"cjaxzl2p6000jd82et7xv0bg2"},{"name":"Java","_id":"cjaxzl2pg000rd82eakj710qw"},{"name":"并发","_id":"cjaxzl2pr0016d82eewtk14gm"},{"name":"JVM","_id":"cjaxzl2py001md82e0d3wmgw2"},{"name":"Spring","_id":"cjaxzl2rd0034d82eg36bm5hd"},{"name":"读书笔记","_id":"cjaxzl2rh003dd82ekxbgq86i"},{"name":"Functional","_id":"cjaxzl2rk003ld82ex9g5aukz"},{"name":"MQ","_id":"cjaxzl2t6005hd82eicresaj8"},{"name":"Netty","_id":"cjaxzl2td0067d82ett45hddt"},{"name":"翻译","_id":"cjaxzl2tm0071d82ekb7gir1m"},{"name":"网络","_id":"cjaxzl2tn0076d82eflh9zinr"},{"name":"设计模式","_id":"cjaxzl2ts007jd82ezznvgspi"},{"name":"容器","_id":"cjaxzl2tt007rd82e0jlkatm9"}]}}